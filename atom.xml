<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jonchan1013.github.io</id>
    <title>CY的学习博客</title>
    <updated>2020-06-15T18:24:34.682Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jonchan1013.github.io"/>
    <link rel="self" href="https://jonchan1013.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://jonchan1013.github.io/images/avatar.png</logo>
    <icon>https://jonchan1013.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, CY的学习博客</rights>
    <entry>
        <title type="html"><![CDATA[Mybatis]]></title>
        <id>https://jonchan1013.github.io/post/mybatis/</id>
        <link href="https://jonchan1013.github.io/post/mybatis/">
        </link>
        <updated>2020-06-15T18:19:24.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="1-简介">1、简介</h2>
<h3 id="11-什么是mybatis">1.1、什么是Mybatis</h3>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200616022004.png" alt="" loading="lazy"></figure>
<ul>
<li>MyBatis 是一款优秀的<strong>持久层框架</strong></li>
<li>它支持定制化 SQL、存储过程以及高级映射。</li>
<li>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</li>
<li>MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h2 id="1-简介">1、简介</h2>
<h3 id="11-什么是mybatis">1.1、什么是Mybatis</h3>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200616022004.png" alt="" loading="lazy"></figure>
<ul>
<li>MyBatis 是一款优秀的<strong>持久层框架</strong></li>
<li>它支持定制化 SQL、存储过程以及高级映射。</li>
<li>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</li>
<li>MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</li>
</ul>
<!-- more -->
<ul>
<li>MyBatis 本是<a href="https://baike.baidu.com/item/apache/6265">apache</a>的一个开源项目<a href="https://baike.baidu.com/item/iBatis">iBatis</a>, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。</li>
<li>2013年11月迁移到Github。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git]]></title>
        <id>https://jonchan1013.github.io/post/git/</id>
        <link href="https://jonchan1013.github.io/post/git/">
        </link>
        <updated>2020-06-15T18:15:09.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="1-git简介">1、Git简介</h2>
<h3 id="11-git概念">1.1 Git概念</h3>
<p>Git 是一个免费的、开源的分布式版本控制系统，可以快速高效地处理从小型到大型的<br>
项目。</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="1-git简介">1、Git简介</h2>
<h3 id="11-git概念">1.1 Git概念</h3>
<p>Git 是一个免费的、开源的分布式版本控制系统，可以快速高效地处理从小型到大型的<br>
项目。</p>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux]]></title>
        <id>https://jonchan1013.github.io/post/linux/</id>
        <link href="https://jonchan1013.github.io/post/linux/">
        </link>
        <updated>2020-06-15T09:31:03.000Z</updated>
        <summary type="html"><![CDATA[<p>👩‍💻目前在中大型互联网项目中，Linux操作系统已成为不可或缺的技术，是程序员必备技能。同时也为其他高级技术的使用提供了有效的保障。</p>
<h2 id="1-linux的简介">1、Linux的简介</h2>
<h3 id="11-定位">1.1 定位</h3>
<p>服务器操作系统</p>
]]></summary>
        <content type="html"><![CDATA[<p>👩‍💻目前在中大型互联网项目中，Linux操作系统已成为不可或缺的技术，是程序员必备技能。同时也为其他高级技术的使用提供了有效的保障。</p>
<h2 id="1-linux的简介">1、Linux的简介</h2>
<h3 id="11-定位">1.1 定位</h3>
<p>服务器操作系统</p>
<!-- more -->
<h3 id="12-历史">1.2 历史</h3>
<p>肯·汤姆森（Ken Thompson）在 MULTICS 操作系统上研发游戏“Space Travel”，</p>
<p>发现运行速度慢且成本比较高（每次 75 美元），找到丹尼斯·里奇（Dennis Ritchie）我们</p>
<p>能不能研发一个操作系统让这个游戏运行效率更高，成本更低。使用一台被人遗弃的计算机</p>
<p>上（连操作系统都没有）使用汇编语言仅仅一个月就开发了一个系统。发现使用汇编开发操</p>
<p>作系统满足不了要求。肯·汤姆森就和丹尼斯·里奇商量我们能不能研究一个语言来写系统内</p>
<p>核，后来就研究出了 B 语言。使用 B 语言写发现还是不行，最后就研发出了大名鼎鼎的 C</p>
<p>语言。使用 C 语言研发出了 Unix 操作系统。</p>
<p>很多开始仿照 Unix，市场上出现了很多类似操作系统，相互告侵权。</p>
<p>Liuns 带领了 Unix 原班人马开发出了 Liuns，后更名为 Liunx。</p>
<table>
<thead>
<tr>
<th>Linux 内核发明人</th>
<th>林纳斯·本纳第克特·托瓦兹（Linus Benedict Torvalds）</th>
</tr>
</thead>
<tbody>
<tr>
<td>内核特点</td>
<td>基于 Unix 实现。支持多用户、多进程、多线程和多 CPU</td>
</tr>
<tr>
<td>应用领域</td>
<td>智能设备、后台服务器、云计算、大数据等</td>
</tr>
<tr>
<td>Linux 家族</td>
<td>Ubuntu、Fedora、CentOS、RedHat、Android 等</td>
</tr>
</tbody>
</table>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615174439.png" alt="" loading="lazy"></figure>
<p>发展到目前，Liunx 不是一个具体的操作系统，而是一类操作系统的统称。具体版本称为发行版。</p>
<ul>
<li>Red Hat：目前被 IBM 收购了。收费版。目前全球最大的 Linux 供应商。</li>
<li><strong>Cent OS</strong>：Red Hat 推出的<strong>免费</strong>版。</li>
<li>Ubuntu：界面比较友好。</li>
</ul>
<h2 id="2-vmware-安装及使用">2、VMWare 安装及使用</h2>
<h3 id="21-vmware-简介">2.1  VMWare 简介</h3>
<p>​		VMWare 就是虚拟机软件。目前最新版本是 VMware Workstation Pro15。使用VMWare 就是使用软件来模拟一台真实的计算机。由于虚拟机安装在当前计算机中，所以虚拟机硬件配置上限就是当前计算机硬件配置。</p>
<h3 id="22-硬件要求">2.2 硬件要求</h3>
<p>​		虚拟机运行过程中比较耗费内存，为了应对后面的课程，建议同学们电脑内存至少 8G以上。如果可以最好是 16GB。当然了，即使 4G 内存也可以运行，只是那时电脑会非常非常的卡。</p>
<h3 id="23-安装步骤">2.3 安装步骤</h3>
<p>运行安装程序</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615174703.png" alt="" loading="lazy"></figure>
<p>按照提示进行安装，点击“下一步”</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615174914.png" alt="" loading="lazy"></figure>
<p>勾选“我接受许可协议中的条款”</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200616021318.png" alt="" loading="lazy"></figure>
<p>路径可以修改也可以不修改。但是路径尽量不要包含中文。示例中把路径修改了。</p>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615174849.png" alt="" loading="lazy"></figure>
<p>取消勾选后点击下一步</p>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615181534.png" alt="" loading="lazy"></figure>
<p>点击“下一步”。桌面和开始菜单是否创建快捷方式可以根据自己的习惯进行操作。</p>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615181655.png" alt="" loading="lazy"></figure>
<p>点击完成进行安装</p>
<figure data-type="image" tabindex="8"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615181728.png" alt="" loading="lazy"></figure>
<p>点击许可证输入许可信息</p>
<figure data-type="image" tabindex="9"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615181802.png" alt="" loading="lazy"></figure>
<p>点击“完成”完成安装</p>
<figure data-type="image" tabindex="10"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615181853.png" alt="" loading="lazy"></figure>
<h3 id="24-安装结果">2.4 安装结果</h3>
<p>VMWare 每次新建虚拟机就相当于产生一台电脑。</p>
<p>安装完成之后产生两个虚拟网卡。这是保证 Windows 是虚拟机中系统互通的。</p>
<figure data-type="image" tabindex="11"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615181941.png" alt="" loading="lazy"></figure>
<h3 id="25-卸载">2.5 卸载</h3>
<p>VMWare 使用 windows 的程序卸载可能无法卸载干净。要使用安装包的卸载功能进行卸载。</p>
<p>双击安装包<img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615182110.png" alt="" loading="lazy"></p>
<p>后点击下一步，会出现下面的界面，点击“删除按钮进行删除”</p>
<figure data-type="image" tabindex="12"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615182139.png" alt="" loading="lazy"></figure>
<h2 id="3-安装linux">3、安装Linux</h2>
<ol>
<li>新建虚拟机</li>
</ol>
<figure data-type="image" tabindex="13"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615182223.png" alt="" loading="lazy"></figure>
<ol start="2">
<li>选择安装模式</li>
</ol>
<figure data-type="image" tabindex="14"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615182303.png" alt="" loading="lazy"></figure>
<ol start="3">
<li>选择 Linux 镜像文件</li>
</ol>
<figure data-type="image" tabindex="15"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615182554.png" alt="" loading="lazy"></figure>
<ol start="4">
<li>输入用户名以及密码</li>
</ol>
<figure data-type="image" tabindex="16"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615182621.png" alt="" loading="lazy"></figure>
<ol start="5">
<li>
<p>指定虚拟系统安装位置</p>
<p>建立放到空间大的磁盘中，目录名称尽量不要含有中文。</p>
</li>
</ol>
<figure data-type="image" tabindex="17"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615182717.png" alt="" loading="lazy"></figure>
<ol start="6">
<li>
<p>指定磁盘容量</p>
<p>默认就可以</p>
<figure data-type="image" tabindex="18"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615182801.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>配置信息提示</p>
</li>
</ol>
<figure data-type="image" tabindex="19"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615182835.png" alt="" loading="lazy"></figure>
<ol start="8">
<li>开始安装</li>
</ol>
<figure data-type="image" tabindex="20"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615182901.png" alt="" loading="lazy"></figure>
<ol start="9">
<li>注意事项</li>
</ol>
<p>​		在安装时，VMWare 默认会去指定的虚拟机目录查找 Linux 的镜像文件，此时我们需要<br>
停止安装重新指定镜像文件位置。</p>
<figure data-type="image" tabindex="21"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615183355.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="22"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615183417.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="23"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615183608.png" alt="" loading="lazy"></figure>
<ol start="10">
<li>选择安装界面的语言</li>
</ol>
<figure data-type="image" tabindex="24"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615183637.png" alt="" loading="lazy"></figure>
<ol start="11">
<li>配置安装位置</li>
</ol>
<figure data-type="image" tabindex="25"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615183702.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="26"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615183721.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="27"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615183740.png" alt="" loading="lazy"></figure>
<ol start="12">
<li>设置 root 用户密码</li>
</ol>
<figure data-type="image" tabindex="28"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615183809.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="29"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615183826.png" alt="" loading="lazy"></figure>
<ol start="13">
<li>安装完毕后重启 Linux</li>
</ol>
<figure data-type="image" tabindex="30"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615183849.png" alt="" loading="lazy"></figure>
<ol start="14">
<li>配置 Linux</li>
</ol>
<figure data-type="image" tabindex="31"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615183910.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="32"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615183924.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="33"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615183942.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="34"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615183956.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="35"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615184010.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="36"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615184022.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="37"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615184142.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="38"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615184159.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="39"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615184213.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="40"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615184343.png" alt="" loading="lazy"></figure>
<h2 id="4-目录结构及路径">4、目录结构及路径</h2>
<h3 id="41-linux-系统目录结构">4.1  Linux 系统目录结构</h3>
<ol>
<li>/</li>
</ol>
<p>​		根目录.Unix 和 Linux 中,没有盘符. 一个硬盘,一个根.</p>
<ol start="2">
<li>
<p>/bin</p>
<p>系统的常用命令目录. 包括控制台命令, 系统可执行文件, 系统的核心二进制文件等</p>
</li>
<li>
<p>/etc</p>
<p>发布目录, 相当于 windows 系统中的 windows 目录, 保存系统中的所有核心内容.</p>
<p>要求控制权限高, 建议不要随便读写</p>
</li>
<li>
<p>/usr</p>
<p>用户目录, 相当于 windows 系统中的 program files 目录. 常用于安装系统所有用户共</p>
<p>用的软件,资源的</p>
</li>
<li>
<p>/root</p>
<p>root 根用户的用户目录. 相当于 windows 系统中的 C:/users/administrator 目录</p>
<p>称为用户主目录</p>
</li>
<li>
<p>/home</p>
<p>保存其他用户主目录的目录</p>
<p>如: Linux 系统中有 oldlu 用户. 那么一定有/home/oldlu 目录存在. 代表用户的主目录</p>
</li>
<li>
<p>/var</p>
<p>系统运行过程的数据目录</p>
</li>
</ol>
<h3 id="42-路径">4.2 路径</h3>
<ol>
<li>
<p>全路径</p>
<p>从 filesystem 根目录开始寻找文件。</p>
<p>写法： 以 / 开头。例如找 usr 下 local 中内容，路径： /usr/local</p>
</li>
<li>
<p>相对路径</p>
<p>从当前资源路径开始寻找，找到其他资源路径过程。</p>
<p>写法：一定不是以/开头。找当前资源的子目录直接写子目录名称，如果向上跳一级文</p>
<p>件夹写法 ： ../</p>
</li>
<li>
<p>特殊路径写法</p>
<p>/ 表示磁盘根</p>
<p>~ 表示/root ，root 文件夹的根目录</p>
</li>
</ol>
<h2 id="5-linux常用命令">5、Linux常用命令</h2>
<p>Linux 系统中的命令是严格区分大小写的。</p>
<h3 id="51-pwd">5.1 pwd</h3>
<p>​		print working directory - 输出当前工作目录, 光标所在位置的目录</p>
<h3 id="52-cd">5.2 cd</h3>
<p>​		change directory - 切换目录</p>
<p>​		特殊目录符号 : 当前目录 - ‘.’ , 父目录 - ‘..’</p>
<p><strong>使用方式:</strong></p>
<ol>
<li>
<p>切换固定位置</p>
<p>使用根目录作为定位标准, 绝对寻址</p>
<p>cd /xxx/yyy/zzz</p>
</li>
<li>
<p>切换相对位置</p>
<p>在当前目录位置开始相对寻址</p>
<p>cd xxx/yyy/zzz</p>
</li>
<li>
<p>进入主目录</p>
<p>直接进入用户主目录</p>
<p>cd</p>
<p>cd ~</p>
</li>
</ol>
<h3 id="53-ls">5.3 ls</h3>
<p>list - 列表目录中的内容.默认显示当前目录下的文件列表</p>
<p><strong>使用方式:</strong></p>
<ol>
<li>
<p>列表当前目录</p>
<p>ls</p>
</li>
<li>
<p>列表指定目录</p>
</li>
</ol>
<p>ls 目录位置(绝对路径|相对路径)</p>
<ol start="3">
<li>
<p>看全部内容</p>
<p>ls -a [目录]</p>
<p>list all - 查看所有, 包括隐藏文件. Linux 中隐藏文件都是以’. ’开头的文件</p>
</li>
<li>
<p>列表查看目录内容</p>
<p>ls -l [目录]</p>
<p>显示当前目录下的文件属性：大小、权限、日期、符号链接。</p>
<p>ll - 简化命令不代表全部 Linux 系统可用.</p>
<p>list list - 以列表的信息,显示指定目录中的内容. 列表代表的是文件的详情.</p>
</li>
</ol>
<figure data-type="image" tabindex="41"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200616011631.png" alt="" loading="lazy"></figure>
<table>
<thead>
<tr>
<th>类型</th>
<th>拥有者权限</th>
<th>同组权限</th>
<th>其他权限</th>
<th>类型</th>
<th>拥有者</th>
<th>所在组</th>
<th>容量</th>
<th>时间</th>
<th>文件名</th>
</tr>
</thead>
<tbody>
<tr>
<td>-</td>
<td>rw-</td>
<td>---</td>
<td>---</td>
<td>1</td>
<td>root</td>
<td>root</td>
<td>3326</td>
<td>Nov 8 01:23</td>
<td>anaconda-ks.cfg</td>
</tr>
<tr>
<td>d</td>
<td>rwx</td>
<td>r-x</td>
<td>r-x</td>
<td>2</td>
<td>rooy</td>
<td>root</td>
<td>4096</td>
<td>Nov 8 01:36</td>
<td>Desktop</td>
</tr>
</tbody>
</table>
<p>4.1 类型</p>
<pre><code class="language-html">- | 1 代表文件
d | 2 代表目录
</code></pre>
<p>4.2 权限</p>
<p>​		分为不同的角色: 文件的所有者, 就是创建文件的用户. 所在组, 和所有者同一个组的</p>
<p>其他用户. 其他用户, 和所有者不在一个组的用户</p>
<p>​		rwx: read write execut</p>
<p>​		‘-’ 代表没有对应权限.</p>
<p>4.3 容量</p>
<p>​		单位是字节. 所有的目录固定容量为 4096.</p>
<p>4.4 命令参数</p>
<p>所有以 - 开头的命令后缀信息, 都是命令参数. 多参数可以并行使用. 如: ls -al</p>
<h3 id="54-clear">5.4 clear</h3>
<p>​		clear - 清空屏幕</p>
<h3 id="55-touch">5.5 touch</h3>
<p>​		创建空白文件</p>
<p>​		在 Linux 系统中,文件不需要强制后缀名</p>
<p>​		如: 文本文件可以定义为, a | a.txt | a.text</p>
<ol>
<li>
<p>使用方式</p>
<p>touch 文件名</p>
<p>touch 目录/文件名</p>
</li>
</ol>
<h3 id="56-cat">5.6 cat</h3>
<p>​		查看文件的全部内容.</p>
<p>​		一次性显示文件中所有内容.</p>
<h3 id="57-more">5.7 more</h3>
<p>​		分屏显示文件内容, 显示后,使用空格显示下一屏, 回车显示下一行,q 退出分屏显示</p>
<p>ctrl+c,退出命令.</p>
<h3 id="58-head">5.8 head</h3>
<p>​		显示文件的前多少行, 默认显示前 10 行</p>
<p>​		head -number filename</p>
<p>​		查看文件中的前多少行</p>
<h3 id="59-tail">5.9 tail</h3>
<p>​		显示文件末尾多少行.默认显示末尾 10 行</p>
<p>​		tail -number filename</p>
<h3 id="510-mkdir">5.10 mkdir</h3>
<p>​		make directory - 创建目录</p>
<p><strong>使用方式：</strong></p>
<ol>
<li>
<p>相对创建一个子目录</p>
<p>mkdir directoryName</p>
</li>
<li>
<p>绝对创建一个目录</p>
<p>mkdir /directoryName</p>
</li>
<li>
<p>一次性创建多级目录</p>
<p>mkdir -p parentDirectoryName/childDirectoryName</p>
</li>
</ol>
<h3 id="511-cp">5.11 cp</h3>
<p>​		copy - 复制命令</p>
<p><strong>使用方式：</strong></p>
<p>​		cp source target</p>
<p>​		cp 源信息 目录信息</p>
<ol>
<li>复制文件</li>
</ol>
<p>​	cp fileName newFileName</p>
<p>​	cp directoryName/fileName directoryName/[newFileName]</p>
<p>​	cp /directoryName/fileName /directoryName/[newFileName]</p>
<ol start="2">
<li>
<p>复制目录</p>
<p>cp -r directoryName newDirectoryName</p>
</li>
</ol>
<h3 id="512-rm">5.12 rm</h3>
<p>​		remove - 删除</p>
<p><strong>使用方式:</strong></p>
<p>​	rm source</p>
<p>​	rm 要删除的资源</p>
<ol>
<li>
<p>删除文件需提示</p>
<p>​	rm fileName</p>
<p>​	rm directoryName/fileName</p>
<p>​	rm / directoryName/fileName</p>
<p>​	-f force 忽略不存在的文件，从不给出提示</p>
<p>​	-r recursive 指示 rm 将参数中列出的全部目录和子目录均递归地删除</p>
</li>
<li>
<p>删除文件不需提示</p>
<p>​	rm -f fileName</p>
<p>​	rm -f directoryName/fileName</p>
<p>​	rm -f /directoryName/fileName</p>
</li>
<li>
<p>删除目录需提示</p>
<p>​	rm -r directoryName</p>
</li>
<li>
<p>删除目录不需提示</p>
<p>​	rm -rf directoryName</p>
</li>
</ol>
<h3 id="513-mv">5.13 mv</h3>
<p>​		move - 移动或重命名. 相当于剪切和重命名</p>
<p><strong>使用方式：</strong></p>
<p>​		mv source target 移动</p>
<p>​		mv source newName 重命名</p>
<ol>
<li>
<p>移动文件到指定位置</p>
<p>​	mv fileName directoryName</p>
</li>
<li>
<p>为文件重命名</p>
</li>
</ol>
<p>​	mv fileName newFileName</p>
<h3 id="514-vi-vim">5.14 vi | vim</h3>
<p>​		编辑文件, vim 是增强命令. 不代表所有的 Linux 都支持</p>
<p>​		vim 增强在有高亮显示</p>
<p><strong>使用方式:</strong></p>
<p>​		vi fileName</p>
<p><strong>命令模式:</strong></p>
<p>​		是控制编辑的文件的状态的,如:保存,退出编辑等</p>
<ol>
<li>
<p>进入编辑模式:</p>
<p>​	a - append, 追加的方式进入编辑模式</p>
<p>​	i - insert, 插入的方式进入编辑模式</p>
<p>​	o - under line , 在光标所在位置之下,新增一行,进入编辑模式</p>
<p>​	O - pre line, 在光标所在位置之上,新增一行, 进入编辑模式</p>
</li>
<li>
<p>dd</p>
<p>​	dd - delete line 删除指定行, 默认 1 行</p>
</li>
<li>
<p>:w</p>
<p>​	write - 保存</p>
</li>
<li>
<p>:q</p>
<p>​	quit - 退出 vi 编辑器</p>
</li>
<li>
<p>:wq</p>
<p>​	保存并退出</p>
</li>
<li>
<p>:q!</p>
<p>​	强制退出不保存</p>
</li>
<li>
<p>:set nu</p>
<p>​	显示行号</p>
</li>
<li>
<p>/keywords</p>
<p>​	搜索关键字, keywords 是关键字的命名</p>
</li>
<li>
<p>G</p>
<p>​	光标跳转到文件尾</p>
</li>
<li>
<p>gg</p>
<p>​	光标跳转到文件头</p>
</li>
</ol>
<p><strong>编辑模式：</strong></p>
<p>​		是编辑文件内容的</p>
<p>​		进入命令模式 - esc</p>
<h3 id="515-reboot">5.15 reboot</h3>
<p>​		reboot 用来重启 Linux 系统和 Windows 系统中的 restart 一样。但是机器重启必须</p>
<p>要 root 用户才有权限。</p>
<h3 id="516-halt">5.16 halt</h3>
<p>​		halt 命令用来关闭正在运行的 Linux 操作系统。</p>
<h2 id="6-linux常用配置">6、Linux常用配置</h2>
<h3 id="61-设置系统时区">6.1 设置系统时区</h3>
<h4 id="611-安装系统时可设置时区">6.1.1 安装系统时可设置时区</h4>
<figure data-type="image" tabindex="42"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200616014040.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="43"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200616014053.png" alt="" loading="lazy"></figure>
<h3 id="62-通过-linux-命令设置时区">6.2 通过 Linux 命令设置时区</h3>
<h4 id="621-查看系统当前时间">6.2.1 查看系统当前时间</h4>
<p>date 命令</p>
<figure data-type="image" tabindex="44"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200616014153.png" alt="" loading="lazy"></figure>
<h4 id="622-修改时区">6.2.2 修改时区</h4>
<ol>
<li>
<p>获取当前时区配置</p>
<p>tzselect 命令<br>
选择 Asia 亚洲</p>
</li>
</ol>
<figure data-type="image" tabindex="45"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200616014241.png" alt="" loading="lazy"></figure>
<p>​	选择中国</p>
<figure data-type="image" tabindex="46"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200616014303.png" alt="" loading="lazy"></figure>
<p>​	选择北京时间</p>
<figure data-type="image" tabindex="47"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200616014323.png" alt="" loading="lazy"></figure>
<p>得到时区配置信息</p>
<figure data-type="image" tabindex="48"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200616014342.png" alt="" loading="lazy"></figure>
<ol start="2">
<li>
<p>修改 .bash_profile 文件设置时区</p>
<p>.bash_profile 文件在当前用户的目录下，时区一旦修改仅对当前用户生效。</p>
</li>
</ol>
<figure data-type="image" tabindex="49"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200616014420.png" alt="" loading="lazy"></figure>
<p>​		使用 vim 编辑 .bash_profile 文件</p>
<figure data-type="image" tabindex="50"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200616014439.png" alt="" loading="lazy"></figure>
<p>​		将获取到的时区配置信息添加到该文件中</p>
<figure data-type="image" tabindex="51"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200616014507.png" alt="" loading="lazy"></figure>
<p>​		注销当前登录用户，重新登录</p>
<h3 id="63-通过-linux-的操作界面设置时区">6.3 通过 Linux 的操作界面设置时区</h3>
<p>​		如果安装 Linux 时选择带有 GUI 的，那么可以通过 GUI 设置时区，该设置方式对所有用户生效。</p>
<figure data-type="image" tabindex="52"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200616014607.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="53"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200616015218.png" alt="" loading="lazy"></figure>
<h3 id="63-网络配置">6.3 网络配置</h3>
<h4 id="631-开启网络">6.3.1 开启网络</h4>
<p>​		CentOS8 中默认没有开始网络配置。需要手动开启。</p>
<p>​		启用 ens33 网络配置。默认只有 ens33</p>
<p>​		nmcli c up ens33</p>
<p>​		vim /etc/sysconfig/network-scripts/ifcfg-ens33</p>
<p>​		先点击键盘的 i 键，左下角出现--insert-- 才能开始进行编辑。</p>
<p>​		修改最后一行 ONBOOT=yes，表示开启此网卡设置启动。</p>
<figure data-type="image" tabindex="54"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200616015446.png" alt="" loading="lazy"></figure>
<p>​		点击键盘”ESC”退出编辑状态后，不考虑光标位置，直接输入:wq，然后回车。</p>
<p>通过下面命令查看 ip 地址</p>
<p>ifconfig 命令</p>
<h4 id="632-修改网段">6.3.2 修改网段</h4>
<p>​		VMware 菜单编辑 --&gt; 虚拟网络编辑器 --&gt; 右下角 “更改设置” --&gt; 选择“VMNet 8” -- &gt; 修改子网 IP 为自己希望的网段 --&gt; DHCP 设置中修改两处网段</p>
<figure data-type="image" tabindex="55"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200616015555.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="56"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200616015607.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="57"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200616015621.png" alt="" loading="lazy"></figure>
<h4 id="632-设置网络类型">6.3.2 设置网络类型</h4>
<p>​		在 VMWare 中默认使用 NAT 模式</p>
<p>​		NAT 模式：“Network Address Translation，网络地址转换”，允许一个整体机构以一个公用 IP 地址出现在 Internet 上。顾名思义，它是一种把内部私有网络地址（IP 地址）通过 NAT 转发成合法公有网络 IP 地址的技术。</p>
<p>​		优点：可以节省 IP 资源</p>
<p>​		缺点：由于网段不同，局域网内其他设备无法访问虚拟机中的操作系统</p>
<figure data-type="image" tabindex="58"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200616015726.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="59"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200616015753.png" alt="" loading="lazy"></figure>
<h3 id="64-快照与克隆">6.4 快照与克隆</h3>
<h4 id="641快照">6.4.1快照</h4>
<ol>
<li>
<p>创建快照</p>
<p>​	快照功能是在关机状态使用的。<br>
​	快照就是类似 windows 的还原点。还原系统。使用快照可以还原系统也可以克隆系统。</p>
</li>
</ol>
<figure data-type="image" tabindex="60"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200616015902.png" alt="" loading="lazy"></figure>
<ol start="2">
<li>删除快照</li>
</ol>
<figure data-type="image" tabindex="61"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200616015925.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="62"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200616015944.png" alt="" loading="lazy"></figure>
<h4 id="642-克隆功能">6.4.2 克隆功能</h4>
<p>​		要求：关闭状态</p>
<p>​		可以帮助快速生成一台虚拟机</p>
<figure data-type="image" tabindex="63"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200616020018.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="64"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200616020032.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="65"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200616020045.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="66"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200616020055.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="67"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200616020107.png" alt="" loading="lazy"></figure>
<h2 id="7-xshell-安装及使用">7、XShell 安装及使用</h2>
<p>​		一款 Windows 中使用的 Linux 客户端命令工具。</p>
<p>​		常见的 Linux 客户端工具：</p>
<p>​		XShell、FinallShell、SecureCRT 等</p>
<h3 id="71-安装-xshell">7.1 安装 Xshell</h3>
<p>​		Xshell 版本：6</p>
<h3 id="72-xshell-的使用">7.2 Xshell 的使用</h3>
<h4 id="721-创建连接">7.2.1 创建连接</h4>
<figure data-type="image" tabindex="68"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200616020310.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="69"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200616020350.png" alt="" loading="lazy"></figure>
<h4 id="722-使用-xsehll-连接-linux-系统">7.2.2  使用 Xsehll 连接 Linux 系统</h4>
<figure data-type="image" tabindex="70"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200616020512.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="71"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200616020551.png" alt="" loading="lazy"></figure>
<h2 id="8-linux-的文件上传与下载">8、Linux 的文件上传与下载</h2>
<h3 id="81-xftp-安装及使用">8.1 Xftp 安装及使用</h3>
<p>​		Xftp 和 Xshell 是同一个公司的产品。Xftp 是基于 FTP 协议的工具。可以方便的实现互联网中主机和主机之间的文件传输。</p>
<figure data-type="image" tabindex="72"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200616020701.png" alt="" loading="lazy"></figure>
<h2 id="9-linux-中文件的压缩与解压缩">9、Linux 中文件的压缩与解压缩</h2>
<h3 id="91-targz-格式">9.1 *.tar.gz 格式</h3>
<p>​		tar.gz 是 Linux 中的一种文件压缩格式，可是使用 tar 命令实现对文件的压缩与解压处理。</p>
<h4 id="911-tar-命令参数介绍">9.1.1  tar 命令参数介绍</h4>
<pre><code class="language-html">	-c: 创建压缩文件
	-C: 指定解压文件存放的位置
	-x：解压-t：查看内容
	-z：有 gzip 属性的
	-v：显示所有过程
	-f: 使用文件名字，切记，这个参数是最后一个参数，后面只能接文件名
</code></pre>
<h4 id="912-创建-targz-压缩文件">9.1.2 创建 tar.gz 压缩文件</h4>
<p>​		tar -czvf 压缩文件的名称.tar.gz 源文件或者目录名称</p>
<h4 id="913-解压-targz-文件">9.1.3 解压 tar.gz 文件</h4>
<p>​		tar -zxvf 解压文件名称</p>
<h3 id="92-zip-格式">9.2 *.zip 格式</h3>
<p>​		如果压缩文件格式为.zip 那么需要使用 unzip 命令解压.zip 压缩包。</p>
<h4 id="921-unzip-参数介绍">9.2.1 unzip 参数介绍</h4>
<pre><code class="language-java">-n：解压缩时不要覆盖原有的文件
-d&lt;目录&gt;：指定文件解压缩后所要存储的目录
-v：执行时显示详细的信息；
</code></pre>
<h4 id="922-解压-zip-文件">9.2.2 解压 zip 文件</h4>
<p>unzip 压缩文件.zip</p>
<p>unzip 压缩文件.zip -d 解压到指定目录</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode刷题]]></title>
        <id>https://jonchan1013.github.io/post/leetcode-shua-ti/</id>
        <link href="https://jonchan1013.github.io/post/leetcode-shua-ti/">
        </link>
        <updated>2020-06-13T03:54:48.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="70-爬楼梯">70、爬楼梯</h2>
<p>题目描述：假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="70-爬楼梯">70、爬楼梯</h2>
<p>题目描述：假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<!-- more -->
<p>**注意：**给定 <em>n</em> 是一个正整数。</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613121348.png" alt="" loading="lazy"></figure>
<p>方法1：记忆化递归：</p>
<pre><code class="language-java">class Solution {
    public int climbStairs(int n) {
        int memo[] = new int[n + 1]; //存储中间结果，避免重复计算
        return climbStairsMemo(n, memo);

    }

    public int climbStairsMemo(int n, int memo[]) {
        if (memo[n] &gt; 0) {
            return memo[n];
        }
        if (n == 1) {
            return memo[n] = 1;
        } else if (n == 2) {
            return memo[n] = 2;
        } else {
            return memo[n] = climbStairs(n - 1) + climbStairs(n - 2);
        }
    }
}
</code></pre>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<p>方法2：斐波那契数列</p>
<pre><code class="language-java">class Solution {
    public int climbStairs(int n) {
        if (n == 1) {
            return 1;
        }
        int first = 1;
        int second = 2;
        for (int i = 3; i &lt;= n; i++) {
            //滚动数组，优化空间复杂度,只记录两个状态
            int third = first + second;
            first = second;
            second = third;
        }
        return second;
    }
}
</code></pre>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Ajax]]></title>
        <id>https://jonchan1013.github.io/post/ajax/</id>
        <link href="https://jonchan1013.github.io/post/ajax/">
        </link>
        <updated>2020-06-12T10:34:35.000Z</updated>
        <summary type="html"><![CDATA[<p>✍️Ajax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式、快速动态应用的网页开发技术，无需重新加载整个网页的情况下，能够更新页面局部数据的技术。<br>
通过在后台与服务器进行少量数据交换，Ajax 可以使页面实现异步更新。这意味着可以在不重新加载整个页面的情况下，对页面的某部分进行更新。</p>
]]></summary>
        <content type="html"><![CDATA[<p>✍️Ajax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式、快速动态应用的网页开发技术，无需重新加载整个网页的情况下，能够更新页面局部数据的技术。<br>
通过在后台与服务器进行少量数据交换，Ajax 可以使页面实现异步更新。这意味着可以在不重新加载整个页面的情况下，对页面的某部分进行更新。</p>
<!-- more -->
<h2 id="1-ajax简介">1、Ajax简介</h2>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200612214538.png" alt="" loading="lazy"></figure>
<p>​		Ajax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式、快速动态应用的网页开发技术，无需重新加载整个网页的情况下，能够更新页面局部数据的技术。</p>
<p>​		通过在后台与服务器进行少量数据交换，Ajax 可以使页面实现异步更新。这意味着可以在不重新加载整个页面的情况下，对页面的某部分进行更新。</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200612214639.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200612214744.png" alt="" loading="lazy"></figure>
<h2 id="2-ajax的使用">2、Ajax的使用</h2>
<h3 id="21-xmlhttprequest-对象">2.1 XMLHttpRequest 对象</h3>
<p>​		XMLHttpRequest 是浏览器接口对象，该对象的 API 可被 JavaScript、VBScript 以及其它<br>
web 浏览器内嵌的脚本语言调用，通过 HTTP 协议在浏览器和 web 服务器之间收发 XML 或<br>
其它数据。XMLHttpRequest 可以与服务器实现异步交互，而无需让整个页面刷新，因此成<br>
为 Ajax 编程的核心对象。</p>
<h3 id="22-ajax-的使用步骤">2.2 Ajax 的使用步骤</h3>
<ol>
<li>
<p>创建 XMLHttpRequest 对象</p>
<pre><code class="language-javascript">var xhr = new XMLHttpRequest();
</code></pre>
</li>
<li>
<p>给定请求方式以及请求地址</p>
</li>
</ol>
<pre><code class="language-javascript">xhr.open(&quot;get&quot;,&quot;http://www.example.com&quot;);
</code></pre>
<ol start="3">
<li>发送请求</li>
</ol>
<pre><code class="language-javascript">xhr.send();
</code></pre>
<ol start="4">
<li>获取服务器端给客户端的响应数据</li>
</ol>
<pre><code class="language-javascript">xhr.onreadystatechange = function(){
//0:open()没有被调用
//1:open()正在被调用
//2:send()正在被调用
//3:服务端正在返回结果
//4:请求结束，并且服务端已经结束发送数据到客户端
if(xhr.readyState == 4 &amp;&amp; xhr.status == 200){
document.getElementById(&quot;span&quot;).innerHTML=xhr.responseText;
alert(xhr.responseText);
}
</code></pre>
<h3 id="23-ajax的运行原理">2.3 Ajax的运行原理</h3>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200612215857.png" alt="" loading="lazy"></figure>
<h3 id="24-示例代码">2.4 示例代码</h3>
<p>index.jsp：</p>
<pre><code class="language-js">&lt;%@ page contentType=&quot;text/html; charset=UTF-8&quot; language=&quot;java&quot;%&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;script&gt;
        function but() {
            var xhr = new XMLHttpRequest();
            xhr.open(&quot;get&quot;, &quot;ajax.do&quot;);
            xhr.send();
            xhr.onreadystatechange = function () {
                if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) {
                    alert(xhr.responseText);
                    //将数据插入到span标签中
                    document.getElementById(&quot;span&quot;).innerHTML=xhr.responseText;
                }
            }
        }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h2&gt;你好&lt;/h2&gt;
&lt;hr/&gt;
&lt;span id=&quot;span&quot;&gt;&lt;/span&gt;
&lt;input type=&quot;button&quot; value=&quot;ok&quot; onclick=&quot;but()&quot;/&gt;
&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<p>AjaxServlet:</p>
<pre><code class="language-java">@WebServlet(&quot;/ajax.do&quot;)
public class AjaxServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        PrintWriter pw=resp.getWriter();
        pw.println(&quot;hello,ajax!&quot;);
        pw.flush();
        pw.close();
    }
}
</code></pre>
<p>效果：</p>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200612234214.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200612234238.png" alt="" loading="lazy"></figure>
<h2 id="3-json详解">3、JSON详解</h2>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613002650.png" alt="" loading="lazy"></figure>
<h3 id="31-json简介">3.1 JSON简介</h3>
<p>​		JSON(JavaScript Object Notation) 是一种基于字符串的轻量级的数据交换格式。易于人阅读和编写，同时也易于机器解析和生成。JSON 是 JavaScript 数据类型的子集。</p>
<h3 id="32-为什么要使用-json">3.2 为什么要使用 JSON</h3>
<p>​		在 JSON 未出现之前在 Ajax 中对于数据传递方式，会使用 XML 作为主要数据格式来传输数据。直到 JSON 出现后逐渐放弃使用 XML 作为数据传输格式。JSON 比 XML 更小、更快，更易解析。</p>
<h3 id="33-json-格式的特征">3.3 JSON 格式的特征</h3>
<h4 id="331json-的语法规则">3.3.1JSON 的语法规则</h4>
<p>JSON 是按照特定的语法规则所生成的字符串结构。</p>
<ul>
<li>大括号表示 JSON 的字符串对象。{ }</li>
<li>属性和值用冒号分割。{&quot;属性&quot;:&quot;value&quot;}</li>
<li>属性和属性之间用逗号分割。{&quot;属性&quot;:&quot;value&quot;,&quot;属性&quot;:&quot;value&quot;,...}</li>
<li>中括号表示数组。[{&quot;属性&quot;:&quot;value&quot;...},{&quot;属性&quot;:&quot;value&quot;...}]</li>
</ul>
<p>JSON 字符串对象：<img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613002918.png" alt="" loading="lazy"></p>
<p>{&quot;userid&quot;:1,&quot;username&quot;:&quot;admin&quot;,&quot;sex&quot;:&quot;male&quot;}</p>
<p>数组：<img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613002948.png" alt="" loading="lazy"></p>
<p>[{&quot;userid&quot;:1,&quot;username&quot;:&quot;admin&quot;},{&quot;userid&quot;:2,&quot;username&quot;:&quot;oldlu&quot;}]</p>
<h4 id="332-josn-的-6-种数据类型">3.3.2 JOSN 的 6 种数据类型</h4>
<figure data-type="image" tabindex="8"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613003047.png" alt="" loading="lazy"></figure>
<ul>
<li>string：字符串，必须要用双引号引起来。</li>
<li>number：数值，与 JavaScript 的 number 一致，</li>
<li>object：JavaScript 的对象形式，{ key:value }表示方式，可嵌套。</li>
<li>array：数组，JavaScript 的 Array 表示方式[ value ]，可嵌套。</li>
<li>true/false：布尔类型，JavaScript 的 boolean 类型。</li>
<li>null：空值，JavaScript 的 null。</li>
</ul>
<h3 id="34-jackson的使用">3.4 Jackson的使用</h3>
<p>​		在 JDK 中并没有内置操作 JSON 格式数据的 API，因此使用处理 JSON 格式的数据需要借助第三方类库。<br>
几个常用的 JSON 解析类库：<br>
Gson: 谷歌开发的 JSON 库，功能十分全面。<br>
FastJson: 阿里巴巴开发的 JSON 库，性能十分优秀。<br>
Jackson: 社区十分活跃且更新速度很快。被称为“最好的 Json 解析器”</p>
<h4 id="341-jackson简介">3.4.1 Jackson简介</h4>
<p>Jackson 是一种解析 JSON 格式数据的 API，也是最流行，速度最快的 JSON API。在SpringMVC 中默认使用 Jackson API 处理 JSON 格式的数据。<br>
Jackson 下载地址：<br>
https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-annotations<br>
https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core<br>
https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind</p>
<h4 id="342-在响应中通过-json-格式传递数据">3.4.2 在响应中通过 JSON 格式传递数据</h4>
<p>在响应中使用 Jackson 处理 JSON 格式数据的步骤：</p>
<ul>
<li>添加 jackson-annotations.jar、jackson-core.jar、jackson-databind.jar</li>
<li>通过 jackson API 将 Java 对象转换 JSON 格式</li>
<li>修改响应头，响应类型为 application/json</li>
<li>将结果基于字符输出流推回客户端浏览器</li>
<li>在页面的中通过 JavaScript 的 JSON.parse()函数将 JSON 格式的数据转换为 JavaScript对象</li>
</ul>
<h5 id="3421-通过-json-格式在响应中传递单个对象">3.4.2.1 通过 JSON 格式在响应中传递单个对象</h5>
<p>需求：<br>
定义一个 User 类，包含 userid、username 属性。<br>
实例化一个 User 对象，通过 JSON 格式将 User 对象响应到客户端浏览器。<br>
将 User 对象中的数据插入到页面中。</p>
<p>User类:</p>
<pre><code class="language-java">public class User {
    private int userid;
    private String username;

    public int getUserid() {
        return userid;
    }

    public void setUserid(int userid) {
        this.userid = userid;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    @Override
    public String toString() {
        return &quot;User{&quot; +
                &quot;userid=&quot; + userid +
                &quot;, username='&quot; + username + '\'' +
                '}';
    }
}
</code></pre>
<p>SingleObjectServlet类：</p>
<pre><code class="language-java">@WebServlet(&quot;/single.do&quot;)
public class SingleObjectServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //创建User对象
        User user = new User();
        user.setUserid(10);
        user.setUsername(&quot;张三&quot;);


        //使用jackson的api将User对象转换成JSON格式的字符串对象
        ObjectMapper objectMapper = new ObjectMapper();
        //将USer对象转换为JSON格式的字符串对象
        String s = objectMapper.writeValueAsString(user);
        System.out.println(s);
        //设置响应类型为application/json
        resp.setContentType(&quot;application/json&quot;);

        PrintWriter pw = resp.getWriter();
        //将数据输出到前端
        pw.print(s);
        pw.flush();
        pw.close();

    }
}

</code></pre>
<p>singleDemo.jsp</p>
<pre><code class="language-jsp">&lt;%@ page contentType=&quot;text/html; charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;script&gt;
        function but(){
            var xhr = new XMLHttpRequest();
            xhr.open(&quot;get&quot;,&quot;single.do&quot;);
            xhr.send();
            xhr.onreadystatechange = function(){

                if(xhr.readyState == 4 &amp;&amp; xhr.status == 200){
                    alert(xhr.responseText);
                    //通过javaScript的内置对象JSON中的parse函数将JSON格式的字符串对转换成javascript对象
                    var obj = JSON.parse(xhr.responseText);
                    alert(obj.userid+&quot; &quot;+obj.username);
                    document.getElementById(&quot;span&quot;).innerHTML=obj.userid+&quot;&lt;br/&gt;&quot;+obj.username;
                }
            }
        }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h3&gt;JSON格式的单个对象响应&lt;/h3&gt;
&lt;hr/&gt;
&lt;span id=&quot;span&quot;&gt;&lt;/span&gt;
&lt;input type=&quot;button&quot; value=&quot;OK&quot; onclick=&quot;but()&quot;/&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h5 id="3422-通过-json-格式在响应中传递多个对象">3.4.2.2 通过 JSON 格式在响应中传递多个对象</h5>
<p>需求：<br>
定义一个 User 类，包含 userid、username 属性。<br>
实例化多个 User 对象，通过 JSON 格式将 User对象响应到客户端浏览器。<br>
将 User 对象中的数据插入到页面中。</p>
<p>MultipleObjectServlet类：</p>
<pre><code class="language-java">@WebServlet(&quot;/multiple.do&quot;)
public class MultipleObjectServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        User user1 = new User();
        user1.setUserid(1);
        user1.setUsername(&quot;张三&quot;);
        User user2 = new User();
        user2.setUserid(2);
        user2.setUsername(&quot;李四&quot;);

        //将多个对象放入list中
        List&lt;User&gt; list = new ArrayList&lt;&gt;();
        list.add(user1);
        list.add(user2);

        //通过jackson将List转换成JSON格式的字符串对象
        ObjectMapper objectMapper = new ObjectMapper();
        String s = objectMapper.writeValueAsString(list);
        System.out.println(s);
        resp.setContentType(&quot;application/json&quot;);

        PrintWriter pw = resp.getWriter();
        pw.print(s);
        pw.flush();
        pw.close();
    }
}
</code></pre>
<p>multipleDemo.jsp</p>
<pre><code class="language-jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;script&gt;
        function but() {
            var xhr = new XMLHttpRequest();
            xhr.open(&quot;get&quot;, &quot;multiple.do&quot;);
            xhr.send();
            xhr.onreadystatechange = function () {

                if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) {
                    alert(xhr.responseText);
                    //通过javaScript的内置对象JSON中的parse函数将JSON格式的字符串对转换成javascript对象
                    //此时obj是数组，里面存放的是JavaScript对象
                    var obj = JSON.parse(xhr.responseText);
                    var temp = &quot;&quot;;
                    for (var i = 0; i &lt; obj.length; i++) {
                        alert(obj[i].userid + &quot; &quot; + obj[i].username);
                        temp +=obj[i].userid + &quot;&lt;br/&gt;&quot; + obj[i].username
                    }

                    document.getElementById(&quot;span&quot;).innerHTML = temp;
                }
            }
        }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h3&gt;JSON格式的多个对象响应&lt;/h3&gt;
&lt;hr/&gt;
&lt;span id=&quot;span&quot;&gt;&lt;/span&gt;
&lt;input type=&quot;button&quot; value=&quot;OK&quot; onclick=&quot;but()&quot;/&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h5 id="3423-在-json-中通过-map-传递数据">3.4.2.3 在 JSON 中通过 Map 传递数据</h5>
<p>​		在 JSON 格式中可以直接使用 Map 作为传递数据的模型。因为 Map 结构本身就是 key与 value 的结构与 JSON 格式对象模型完全匹配，所以我们可以直接将一个 Map 对象转换为JSON 格式的字符串对象。这对于我们来说是一件非常方便的事情，如果我们返回的数据并没有对应的模型来存放数据，那么我们可以通过 Map 来解决。</p>
<p>MapModelServlet类：</p>
<pre><code class="language-java">@WebServlet(&quot;/map.do&quot;)
public class MapModelServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //一个map对象对应一个json
        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;userid&quot;,11);
        map.put(&quot;url&quot;,&quot;map.do&quot;);
        ObjectMapper objectMapper = new ObjectMapper();
        String s = objectMapper.writeValueAsString(map);
        resp.setContentType(&quot;application/json&quot;);

        PrintWriter pw = resp.getWriter();
        pw.print(s);
        pw.flush();
        pw.close();
    }
}
</code></pre>
<p>mapDemo.jsp</p>
<pre><code class="language-jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;script&gt;
        function but(){
            var xhr = new XMLHttpRequest();
            xhr.open(&quot;get&quot;,&quot;map.do&quot;);
            xhr.send();
            xhr.onreadystatechange = function(){

                if(xhr.readyState == 4 &amp;&amp; xhr.status == 200){
                    alert(xhr.responseText);
                    //通过javaScript的内置对象JSON中的parse函数将JSON格式的字符串对转换成javascript对象
                    var obj = JSON.parse(xhr.responseText);
                    alert(obj.userid+&quot; &quot;+obj.url);
                    document.getElementById(&quot;span&quot;).innerHTML=obj.userid+&quot;&lt;br/&gt;&quot;+obj.url;
                }
            }
        }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h3&gt;Map模型的使用&lt;/h3&gt;
&lt;hr/&gt;
&lt;span id=&quot;span&quot;&gt;&lt;/span&gt;
&lt;input type=&quot;button&quot; value=&quot;OK&quot; onclick=&quot;but()&quot;/&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h4 id="343-在请求中通过-json-格式传递数据">3.4.3 在请求中通过 JSON 格式传递数据</h4>
<p>我们除了可以在响应中通过 JSON 格式来传递数据以外，在请求中也可以使用 JSON 格式传递数据。如果在请求中使用 JSON 格式传递数据，那么提交方式需要使用 POST 方式，通过 JavaScript 中的 JSON.stringify()函数将 JavaScript 对象转换为 JSON 格式数据。通过 send方法将参数传递到 Servlet 中，在 Servlet 中通过字符输入流获取 JSON 格式数据。</p>
<p>在请求中使用 Jackson 处理 JSON 格式数据的步骤：</p>
<ol>
<li>添加 jackson-annotations.jar、jackson-core.jar、jackson-databind.jar</li>
<li>在页面的 JavaScript 中通过 JSON.stringify()函数将 JavaScript 对象转换为 JSON 格式的数据</li>
<li>将请求方式修改为 POST 方式</li>
<li>通过 send()函数将 JSON 格式的数据提交到服务端。</li>
<li>在 Servlet 中通过字符输入流读取请求体中 JSON 格式的数据</li>
<li>通过 jackson API 将获取到的 JSON 格式的数据转换为 Java 对象</li>
</ol>
<p>requestDemo.jsp</p>
<pre><code class="language-jsp">&lt;%@ page contentType=&quot;text/html; charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;script&gt;
        function but() {
            var id = document.getElementById(&quot;userid&quot;).value;
            var name = document.getElementById(&quot;username&quot;).value;
            var obj = {
                userid: id,
                username: name
            }
            var content = json.stringify(obj);
            alert(content);
            var xhr = new XMLHttpRequest();
            xhr.open(&quot;post&quot;, &quot;json.do&quot;);
            //这样在/json.do请求的时候会将我们转换完的json串传递到servlet
            xhr.send(content);
            xhr.onreadystatechange = function () {

                if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) {
                    alert(xhr.responseText);
                    //通过javaScript的内置对象JSON中的parse函数将JSON格式的字符串对转换成javascript对象
                    var obj = JSON.parse(xhr.responseText);
                    alert(obj.userid + &quot; &quot; + obj.username);
                    document.getElementById(&quot;span&quot;).innerHTML = obj.userid + &quot;&lt;br/&gt;&quot; + obj.username;
                }
            }
        }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h3&gt;在请求中通过json格式传递数据&lt;/h3&gt;
&lt;hr/&gt;
用户ID：&lt;input name=&quot;userid&quot; id=&quot;userid&quot;/&gt;&lt;br/&gt;
用户姓名：&lt;input name=&quot;username&quot; id=&quot;username&quot;/&gt;&lt;br/&gt;
&lt;span id=&quot;span&quot;&gt;&lt;/span&gt;
&lt;input type=&quot;button&quot; value=&quot;OK&quot; onclick=&quot;but()&quot;/&gt;
&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<p>RequestJsonServlet类：</p>
<pre><code class="language-java">@WebServlet(&quot;/json.do&quot;)
public class RequestJsonServlet extends HttpServlet {
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //通过字符输入流从请求体中获取提交的json格式的数据
        req.setCharacterEncoding(&quot;utf-8&quot;);
        String s = req.getReader().readLine();

        //使用jackson将json格式数据转换成java对象
        ObjectMapper objectMapper = new ObjectMapper();
        User user = objectMapper.readValue(s, User.class);
        System.out.println(user.getUserid()+&quot;&quot;+user.getUsername());

        PrintWriter pw = resp.getWriter();
        pw.print(&quot;OK&quot;);
        pw.flush();
        pw.close();
    }
}
</code></pre>
<h3 id="344-jackson-的常用注解">3.4.4 Jackson 的常用注解</h3>
<h5 id="3441jsonproperty">3.4.4.1@JsonProperty</h5>
<p>​		此注解用于属性上，作用是把该属性的名称序列化为另外一个名称，如把 username 属性序列化为 name，@JsonProperty(&quot;name&quot;)。</p>
<h5 id="3442-jsonignore">3.4.4.2 @JsonIgnore</h5>
<p>​		此注解用于属性或者方法上（一般都是定义在属性上），用来完全忽略被注解的字段和方法对应的属性，返回的 json 数据即不包含该属性。</p>
<h5 id="3443-jsonformat">3.4.4.3  @JsonFormat</h5>
<p>​		此注解用于属性或者方法上（一般都是定义在属性上），可以方便的把 Date 类型属性的值直接转化为我们想要的样式。如：@JsonFormat(pattern=&quot;yyyy-MM-dd hh:mm:ss&quot;)</p>
<h4 id="345-jackson-工具类的使用">3.4.5 Jackson 工具类的使用</h4>
<pre><code class="language-java">/**
* JSON 转换工具类
*/
public class JsonUtils {

// 定义 jackson 对象
private static final ObjectMapper MAPPER = new ObjectMapper();
/**
* 将对象转换成 json 字符串。
* &lt;p&gt;Title: pojoToJson&lt;/p&gt;
* &lt;p&gt;Description: &lt;/p&gt;
* @param data
* @return
*/
public static String objectToJson(Object data) {
try {
	String string = MAPPER.writeValueAsString(data);
	return string;
} catch (JsonProcessingException e) {
	e.printStackTrace();
}
	return null;
}

/**
* 将 json 结果集转化为对象
* @param jsonData json 数据
* @param beanType 对象中的 object 类型
* @return
*/
public static &lt;T&gt; T jsonToPojo(String jsonData, Class&lt;T&gt; beanType)
{
	try {
		T t = MAPPER.readValue(jsonData, beanType);
		return t;
		} catch (Exception e) {
		e.printStackTrace();
		}
		return null;
}
/**
* 将 json 数据转换成 pojo 对象 list
* &lt;p&gt;Title: jsonToList&lt;/p&gt;
* &lt;p&gt;Description: &lt;/p&gt;
* @param jsonData
* @param beanType
* @return
*/
public static &lt;T&gt;List&lt;T&gt; jsonToList(String jsonData, Class&lt;T&gt;
beanType) {
	JavaType javaType =MAPPER.getTypeFactory().constructParametricType(List.class,
beanType);
try {
	List&lt;T&gt; list = MAPPER.readValue(jsonData, javaType);
	return list;
	} catch (Exception e) {
	e.printStackTrace();
}
	return null;
	}
}
</code></pre>
<h2 id="4-jquery-的-ajax-使用">4、Jquery 的 Ajax 使用</h2>
<figure data-type="image" tabindex="9"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615094159.png" alt="" loading="lazy"></figure>
<p>​		在 JQuery 中提供了对 Ajax 的封装，让我们在使用 Ajax 技术时变得更加容易。在 JQuery中提供了很多的基于 Ajax 发送异步请求的方法，如：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">.</mi><mi>a</mi><mi>j</mi><mi>a</mi><mi>x</mi><mo>(</mo><mo>)</mo><mi mathvariant="normal">、</mi></mrow><annotation encoding="application/x-tex">.ajax()、</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">.</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mclose">)</span><span class="mord cjk_fallback">、</span></span></span></span>.get()、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">.</mi><mi>p</mi><mi>o</mi><mi>s</mi><mi>t</mi><mo>(</mo><mo>)</mo><mi mathvariant="normal">、</mi></mrow><annotation encoding="application/x-tex">.post()、</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">.</span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mclose">)</span><span class="mord cjk_fallback">、</span></span></span></span>.getJSON()。</p>
<h3 id="41-ajax的使用">4.1  $.ajax()的使用</h3>
<h4 id="411-语法结构">4.1.1 语法结构</h4>
<p>$.ajax({name:value,name:value......})</p>
<figure data-type="image" tabindex="10"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615094350.png" alt="" loading="lazy"></figure>
<p>jqueryAjaxDemo.jsp</p>
<pre><code class="language-jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;script src=&quot;js/jquery.js&quot;/&gt;
    &lt;script&gt;
        function but() {
            $.ajax({
                type:&quot;get&quot;,
                url:&quot;jqueryAjax.do&quot;,
                success:function (result) {
                    $(&quot;#span&quot;).html(result)
                }
            })
        }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;span id=&quot;span&quot;&gt;&lt;/span&gt;
&lt;input type=&quot;button&quot; value=&quot;ok&quot; onclick=&quot;but()&quot;/&gt;
&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<p>jqueryAjaxServlet类：</p>
<pre><code class="language-java">@WebServlet(&quot;/jqueryAjax.do&quot;)
public class jqueryAjaxServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        PrintWriter pw = resp.getWriter();
        //将数据输出到前端
        pw.print(&quot;hello,jqueryAjax&quot;);
        pw.flush();
        pw.close();
    }
}
</code></pre>
<h4 id="412-ajax在异步请求中提交数据">4.1.2 $.ajax()在异步请求中提交数据</h4>
<p>​		在$.ajax()方法中通过 data 属性来存放提交的数据，支持 JSON 格式的数据。</p>
<h5 id="4121-提交普通格式数据">4.1.2.1 提交普通格式数据</h5>
<p>​		在 data 属 性 中 我 们 可 以 通 过 两 种 方 式 来 指 定 需 要 提 交 的 数 据 。 一 种 是 通 过<br>
name=value&amp;name=value 的结构。另一种是通过 JavaScript 对象来指定提交数据。无论使用哪种方式在 Servlet 中都是通过 request.getParameter 方法根据 name 获取 value 的。</p>
<ol>
<li>
<p>通过标准格式指定提交数据</p>
<p>data:”name=value&amp;name=value.....”<br>
在 Servlet 中通过 request.getParameter 来获取提交的数据。</p>
</li>
<li>
<p>通过 JavaScript 对象指定提交数据</p>
<p>data:{<br>
userid:100,<br>
username:”oldlu”</p>
<p>}</p>
</li>
</ol>
<p>在 Servlet 中通过 request.getParameter 来获取提交的数据。</p>
<p>dataDemo.jsp</p>
<pre><code class="language-jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;script src=&quot;js/jquery.js&quot;/&gt;
    &lt;script&gt;
        function but() {
            var id = $(&quot;#userid&quot;).val;
            var name = $(&quot;#username&quot;).val;
            $.ajax({
                type:&quot;get&quot;,
                url:&quot;data.do&quot;,
                //通过标准格式
               /* data:&quot;id=&quot;+id+&quot;&amp;name=&quot;+name,*/
                //通过JavaScript对象
                data:{
                    id:id,
                    name:name
                },
                success:function (result) {
                    $(&quot;#span&quot;).html(result)
                }
            })
        }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
用户ID：&lt;input type=&quot;text&quot; id=&quot;userid&quot;&gt;
用户名：&lt;input type=&quot;text&quot; id=&quot;username&quot;&gt;
&lt;span id=&quot;span&quot;&gt;&lt;/span&gt;
&lt;input type=&quot;button&quot; value=&quot;ok&quot; onclick=&quot;but()&quot;/&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>DataServlet类：</p>
<pre><code class="language-java">@WebServlet(&quot;/data.do&quot;)
public class DataServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        String id = req.getParameter(&quot;id&quot;);
        String name = req.getParameter(&quot;name&quot;);

        PrintWriter pw = resp.getWriter();
        pw.print(id+&quot; &quot;+name);
        pw.flush();
        pw.close();
    }
}
</code></pre>
<h5 id="4122-提交-json-格式数据">4.1.2.2 提交 JSON 格式数据</h5>
<p>在$.ajax()中提交 JSON 格式的数据需要使用 post 方式提交，通过 JSON.stringify()函数将JavaScript 对象转换成 JSON 格式的字符串。在 Servlet 中通过字符输入获取提交的 JSON 格式的数据。</p>
<p>​		data:JSON.stringify({name:value,name:value......})<br>
在 Servlet 中通过 req.getReader().readLine()来获取提交的数据。</p>
<p>jsonDataDemo.jsp</p>
<pre><code class="language-jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;script src=&quot;js/jquery.js&quot;/&gt;
    &lt;script&gt;
        function but() {
            var id = $(&quot;#userid&quot;).val;
            var name = $(&quot;#username&quot;).val;
            $.ajax({
                type:&quot;post&quot;,
                url:&quot;jsonData.do&quot;,
                //将JavaScript 对象转换成 JSON 格式的字符串
                data:JSON.stringify({
                    id:id,
                    name:name
                }),
                success:function (result) {
                    $(&quot;#span&quot;).html(result)
                }
            })
        }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
用户ID：&lt;input type=&quot;text&quot; id=&quot;userid&quot;&gt;
用户名：&lt;input type=&quot;text&quot; id=&quot;username&quot;&gt;
&lt;span id=&quot;span&quot;&gt;&lt;/span&gt;
&lt;input type=&quot;button&quot; value=&quot;ok&quot; onclick=&quot;but()&quot;/&gt;
&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<p>JsonDataServlet类：</p>
<pre><code class="language-java">@WebServlet(&quot;/jsonData.do&quot;)
public class JsonDataServlet extends HttpServlet {
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        String s= req.getReader().readLine();
        PrintWriter pw = resp.getWriter();
        pw.print(s);
        pw.flush();
        pw.close();
    }
}

</code></pre>
<h5 id="4123-ajax处理响应中的-json-格式数据">4.1.2.3 $.ajax()处理响应中的 JSON 格式数据</h5>
<p>$.ajax()方法会根据 dataType 属性中的值自动对响应的数据做类型处理。如果响应的是一个 JSON 格式的数据，那么 dataType 的值为“JSON”,在回调函数中我们得到的直接就是JSON 字符串转换完的 JavaScript 对象。不需要在使用 JSON.parse()做格式的转换处理。</p>
<p>jsonConvertDemo.jsp</p>
<pre><code class="language-jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;script src=&quot;js/jquery.js&quot;/&gt;
    &lt;script&gt;
        function but() {
            var id = $(&quot;#userid&quot;).val;
            var name = $(&quot;#username&quot;).val;
            $.ajax({
                type:&quot;post&quot;,
                url:&quot;jsonConvert.do&quot;,
                //将json格式的字符串转换为JavaScript对象
                datatype:&quot;json&quot;,
                //将JavaScript 对象转换成 JSON 格式的字符串
                data:JSON.stringify({
                    id:id,
                    name:name
                }),
                success:function (result) {
                    alert(result.id+&quot; &quot;+result.name);
                    $(&quot;#span&quot;).html(result.id+&quot; &quot;+result.name);
                }
            })
        }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
用户ID：&lt;input type=&quot;text&quot; id=&quot;userid&quot;&gt;
用户名：&lt;input type=&quot;text&quot; id=&quot;username&quot;&gt;
&lt;span id=&quot;span&quot;&gt;&lt;/span&gt;
&lt;input type=&quot;button&quot; value=&quot;ok&quot; onclick=&quot;but()&quot;/&gt;
&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<p>JsonConvertServletl类：</p>
<pre><code class="language-java">@WebServlet(&quot;/jsonConvert.do&quot;)
public class JsonConvertServlet extends HttpServlet {
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        resp.setContentType(&quot;application/json&quot;);
        String s = req.getReader().readLine();
        PrintWriter pw = resp.getWriter();
        pw.print(s);
        pw.flush();
        pw.close();
    }
}
</code></pre>
<h3 id="42-get的使用">4.2 $.get()的使用</h3>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">.</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo>(</mo><mo>)</mo><mi mathvariant="normal">方</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">是</mi></mrow><annotation encoding="application/x-tex">.get()方法是</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mclose">)</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">是</span></span></span></span>.ajax()方法基于 get 方式发送异步请求的简化版。</p>
<h4 id="421-语法结构">4.2.1 语法结构</h4>
<pre><code class="language-jsp">$.get(url,function(result)) //function相当于回调函数
$.get(url,data,function(result))
</code></pre>
<h4 id="422-通过标准格式指定提交数据">4.2.2 通过标准格式指定提交数据</h4>
<p>$.get(url,”name=value&amp;name=value”,function(result))</p>
<h4 id="423-通过-javascript-对象指定提交数据">4.2.3 通过 JavaScript 对象指定提交数据</h4>
<p>$.get(url,{userid:1,username:”oldlu”,......},function(result))</p>
<p>getDemo.jsp</p>
<pre><code class="language-jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;script src=&quot;js/jquery.js&quot;/&gt;
    &lt;script&gt;
        function but() {
            var id = $(&quot;#userid&quot;).val;
            var name = $(&quot;#username&quot;).val;
            /*$.get(&quot;data.do&quot;,&quot;id=&quot;+id+&quot;&amp;name=&quot;+name,function (result) {
                $(&quot;#span&quot;).html(result)
            })*/
            $.get(&quot;data.do&quot;,{id:id,name:name},function (result) {
                $(&quot;#span&quot;).html(result);
            })
        }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
用户ID：&lt;input type=&quot;text&quot; id=&quot;userid&quot;&gt;
用户名：&lt;input type=&quot;text&quot; id=&quot;username&quot;&gt;
&lt;span id=&quot;span&quot;&gt;&lt;/span&gt;
&lt;input type=&quot;button&quot; value=&quot;ok&quot; onclick=&quot;but()&quot;/&gt;
&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<p>DataServletle类：</p>
<pre><code class="language-java">@WebServlet(&quot;/data.do&quot;)
public class DataServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        String id = req.getParameter(&quot;id&quot;);
        String name = req.getParameter(&quot;name&quot;);

        PrintWriter pw = resp.getWriter();
        pw.print(id+&quot; &quot;+name);
        pw.flush();
        pw.close();
    }
}
</code></pre>
<h3 id="43-post的使用">4.3 $.post()的使用</h3>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">.</mi><mi>p</mi><mi>o</mi><mi>s</mi><mi>t</mi><mo>(</mo><mo>)</mo><mi mathvariant="normal">方</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">是</mi></mrow><annotation encoding="application/x-tex">.post()方法是</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">.</span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mclose">)</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">是</span></span></span></span>.ajax()方法基于 post 方式发送异步请求的简化版。</p>
<h4 id="431-语法结构">4.3.1 语法结构</h4>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">.</mi><mi>p</mi><mi>o</mi><mi>s</mi><mi>t</mi><mo>(</mo><mi>u</mi><mi>r</mi><mi>l</mi><mo separator="true">,</mo><mi>f</mi><mi>u</mi><mi>n</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo>(</mo><mi>r</mi><mi>e</mi><mi>s</mi><mi>u</mi><mi>l</mi><mi>t</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">.post(url,function(result))
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">.</span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>.post(url,data,function(result))</p>
<h4 id="432-通过标准格式指定提交数据">4.3.2 通过标准格式指定提交数据</h4>
<p>$.post(url,”name=value&amp;name=value”,function(result))</p>
<h4 id="433-通过-javascript-对象指定提交数据">4.3.3 通过 JavaScript 对象指定提交数据</h4>
<p>$.post(url,userid:1,username:”oldlu”,......},function(result))</p>
<h3 id="44-getjson的使用">4.4 $.getJSON()的使用</h3>
<p>​		<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">.</mi><mi>g</mi><mi>e</mi><mi>t</mi><mi>J</mi><mi>S</mi><mi>O</mi><mi>N</mi><mo>(</mo><mo>)</mo><mi mathvariant="normal">方</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">是</mi></mrow><annotation encoding="application/x-tex">.getJSON()方法是</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mclose">)</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">是</span></span></span></span>.ajax()方法基于 get 方式发送异步请求，并将响应结果中 JSON 格式的字符串对象自动转换为 JavaScript 对象。在使用该方法时要求返回的数据必须是 JSON 格式类型。$.getJSON()方法和 resp.setContentType(“application/json”)是一起使用的。</p>
<h4 id="441-语法结构">4.4.1 语法结构</h4>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">.</mi><mi>g</mi><mi>e</mi><mi>t</mi><mi>J</mi><mi>S</mi><mi>O</mi><mi>N</mi><mo>(</mo><mi>u</mi><mi>r</mi><mi>l</mi><mo separator="true">,</mo><mi>f</mi><mi>u</mi><mi>n</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo>(</mo><mi>r</mi><mi>e</mi><mi>s</mi><mi>u</mi><mi>l</mi><mi>t</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">.getJSON(url,function(result))
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>.getJSON(url,data,function(result))</p>
<h4 id="442-通过标准格式指定提交数据">4.4.2 通过标准格式指定提交数据</h4>
<p>$.getJSON(url,”name=value&amp;name=value”,function(result))<br>
要求返回的数据格式必须是 JSON 格式。</p>
<h4 id="443-通过-javascript-对象指定提交数据">4.4.3 通过 JavaScript 对象指定提交数据</h4>
<p>$.getJSON(url{userid:1,username:”oldlu”,......},function(result))<br>
要求返回的数据格式必须是 JSON 格式。</p>
<p>getJsonDemo.jsp</p>
<pre><code class="language-jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;script src=&quot;js/jquery.js&quot;/&gt;
    &lt;script&gt;
        function but() {
            var id = $(&quot;#userid&quot;).val;
            var name = $(&quot;#username&quot;).val;
            $.getJSON(&quot;getJson.do&quot;,{id:id,name:name},function (result) {
                $(&quot;#span&quot;).html(result.userid+&quot; &quot;+result.username);
            })
        }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
用户ID：&lt;input type=&quot;text&quot; id=&quot;userid&quot;&gt;
用户名：&lt;input type=&quot;text&quot; id=&quot;username&quot;&gt;
&lt;span id=&quot;span&quot;&gt;&lt;/span&gt;
&lt;input type=&quot;button&quot; value=&quot;ok&quot; onclick=&quot;but()&quot;/&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>GetJsonServlet类：</p>
<pre><code class="language-java">@WebServlet(&quot;/getJson.do&quot;)
public class GetJsonServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        String id = req.getParameter(&quot;id&quot;);
        String name = req.getParameter(&quot;name&quot;);

        HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;userid&quot;,id);
        map.put(&quot;username&quot;,name);
        String s= JsonUtils.objectToJson(map);
        resp.setContentType(&quot;application/json&quot;);

        PrintWriter pw = resp.getWriter();
        pw.print(s);
        pw.flush();
        pw.close();
    }
}
</code></pre>
<h3 id="45-serialize方法的使用">4.5 serialize()方法的使用</h3>
<p>将 form 表单中的数据自动拼接成 name=value&amp;name=value 结构。</p>
<h4 id="451-语法结构">4.5.1 语法结构</h4>
<p>var param = $(“form”).serialize();<br>
param 的值为：name=value&amp;name=value</p>
<pre><code class="language-jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;script src=&quot;js/jquery.js&quot;/&gt;
    &lt;script&gt;
        function but() {
            var param = $(&quot;form&quot;).serialize();
            alert(param);
            $.ajax({
                type: &quot;get&quot;,
                url: &quot;data.do&quot;,
                //通过标准格式
                data:param,
                success: function (result) {
                    $(&quot;#span&quot;).html(result)
                }
            })
        }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form&gt;
    用户ID：&lt;input type=&quot;text&quot; id=&quot;userid&quot;&gt;
    用户名：&lt;input type=&quot;text&quot; id=&quot;username&quot;&gt;
&lt;/form&gt;

&lt;span id=&quot;span&quot;&gt;&lt;/span&gt;
&lt;input type=&quot;button&quot; value=&quot;ok&quot; onclick=&quot;but()&quot;/&gt;
&lt;/body&gt;

</code></pre>
<h2 id="5-ajax实战案例">5、Ajax实战案例</h2>
<p>需求:<br>
创建 User 类，包含 uesrid、username、usersex、userbirth 属性。</p>
<p>​		在用户管理页面中通过 Ajax 技术完成对用户数据载入、添加用户、更新用户、删除用户操作。</p>
<h3 id="51-搭建环境">5.1 搭建环境</h3>
<h4 id="511-创建user类">5.1.1 创建User类</h4>
<pre><code class="language-java">public class User {
    private int userid;
    private String username;
    private String usersex;
    @JsonFormat(pattern = &quot;yyyy-MM-dd&quot;)
    private Date userbirth;

    public int getUserid() {
        return userid;
    }

    public void setUserid(int userid) {
        this.userid = userid;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getUsersex() {
        return usersex;
    }

    public void setUsersex(String usersex) {
        this.usersex = usersex;
    }

    public Date getUserbirth() {
        return userbirth;
    }

    public void setUserbirth(Date userbirth) {
        this.userbirth = userbirth;
    }
}
</code></pre>
<h4 id="512-在页面中创建表格">5.1.2 在页面中创建表格</h4>
<pre><code class="language-jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;用户管理&lt;/title&gt;
    &lt;script src=&quot;js/jquery.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;table align=&quot;center&quot; width=&quot;60%&quot; border=&quot;1&quot;&gt;
    &lt;tr&gt;
        &lt;td&gt;ID：&lt;/td&gt;
        &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;userid&quot; id=&quot;userid&quot;/&gt;&lt;/td&gt;
        &lt;td&gt;姓名：&lt;/td&gt;
        &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot;/&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;性别：&lt;/td&gt;
        &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;usersex&quot; id=&quot;usersex&quot;/&gt;&lt;/td&gt;
        &lt;td&gt;生日：&lt;/td&gt;
        &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;userbirth&quot;
                   id=&quot;userbirth&quot;/&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr align=&quot;center&quot;&gt;
        &lt;td colspan=&quot;4&quot;&gt;
            &lt;input type=&quot;button&quot; value=&quot;添加用户&quot; id=&quot;add&quot; /&gt;
            &lt;input type=&quot;button&quot; value=&quot;更新用户&quot; id=&quot;update&quot;/&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
&lt;hr/&gt;
&lt;table align=&quot;center&quot; width=&quot;60%&quot; bgcolor=&quot;&quot; border=&quot;1&quot;
       id=&quot;myTable&quot;&gt;
    &lt;thead&gt;
    &lt;tr align=&quot;center&quot;&gt;
        &lt;td&gt;ID&lt;/td&gt;
        &lt;td&gt;姓名&lt;/td&gt;
        &lt;td&gt;性别&lt;/td&gt;
        &lt;td&gt;生日&lt;/td&gt;
        &lt;td&gt;操作&lt;/td&gt;
    &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody id=&quot;tBody&quot;&gt;&lt;/tbody&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<figure data-type="image" tabindex="11"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615120307.png" alt="" loading="lazy"></figure>
<h3 id="52-加载用户数据">5.2 加载用户数据</h3>
<h4 id="521-通过ajax完成页面数据初始化">5.2.1 通过Ajax完成页面数据初始化</h4>
<pre><code class="language-jsp">&lt;script&gt;
        $(function () {
            //获取页面初始化数据
            getData();
        });

        //获取页面初始化数据
        function getData() {
            $.getJSON(&quot;user.do&quot;, {flag: &quot;getData&quot;}, function (result) {
                init(result);
            });
        }

        //遍历数据生成数据
        function init(obj) {
            var str = &quot;&quot;;
            $.each(obj, function () {
                str += &quot;&lt;tr align='center'&gt;&lt;td id = '&quot; + this.userid + &quot;' &gt; &quot; + this.userid + &quot;&lt;/td&gt;&lt;td&gt;&quot; + this.username + &quot;&lt;/td&gt;&lt;td&gt;&quot; + this.usersex + &quot;&lt;/td&gt;&lt;td&gt;&quot; + this.userbirth + &quot;&lt;/td&gt;&lt;td&gt;&lt;a href='#' onclick='preUpdateUser()'&gt;选择更新&amp;nbsp;&amp;nbsp;&lt;/a&gt;&lt;a href='#' onclick='deleteUser(&quot; + this.userid + &quot;)'&gt;删除&lt;/a&gt;&lt;/td &gt; &lt; /tr&gt;&quot;
            });
            $(&quot;#tBody&quot;).prepend(str);
        }
    &lt;/script&gt;
</code></pre>
<h4 id="522-创建-servlet-处理页面数据初始化请求">5.2.2 创建 Servlet 处理页面数据初始化请求</h4>
<pre><code class="language-java">@WebServlet(&quot;/user.do&quot;)
public class UserServlet extends HttpServlet {
    //生成模拟数据初始化
    @Override
    public void init() throws ServletException {
        User user = new User();
        user.setUserid(1);
        user.setUsername(&quot;Oldlu&quot;);
        user.setUsersex(&quot;male&quot;);
        user.setUserbirth(new Date());
        User user2 = new User();
        user2.setUserid(2);
        user2.setUsername(&quot;Kevin&quot;);
        user2.setUsersex(&quot;male&quot;);
        user2.setUserbirth(new Date());
        List&lt;User&gt; list = new ArrayList&lt;&gt;();
        list.add(user);
        list.add(user2);
        ServletContext servletContext = this.getServletContext();
        servletContext.setAttribute(&quot;list&quot;, list);

    }

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        this.doPost(req, resp);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        String flag = req.getParameter(&quot;flag&quot;);
        if (&quot;getData&quot;.equals(flag)) {
            this.getData(req, resp);
        }
    }

    //获取页面初始化数据
    private void getData(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        List&lt;User&gt; list = (List&lt;User&gt;) this.getServletContext().getAttribute(&quot;list&quot;);
        String s = JsonUtils.objectToJson(list);
        resp.setContentType(&quot;application/json&quot;);
        PrintWriter pw = resp.getWriter();
        pw.print(s);
        pw.flush();
        pw.close();
    }
}

</code></pre>
<figure data-type="image" tabindex="12"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615144207.png" alt="" loading="lazy"></figure>
<h3 id="53-添加用户操作">5.3 添加用户操作</h3>
<h4 id="531-通过-ajax-完成添加用户">5.3.1 通过 Ajax 完成添加用户</h4>
<pre><code class="language-jsp">&lt;script&gt;
        $(function () {
            //获取页面初始化数据
            getData();
            //添加按钮绑定点击事件
            $(&quot;#add&quot;).click(function () {
                addorupdateUser(&quot;addUser&quot;);
            });
        });

        //获取页面初始化数据
        function getData() {
            $.getJSON(&quot;user.do&quot;, {flag: &quot;getData&quot;}, function (result) {
                init(result);
            });
        }

        //遍历数据生成数据
        function init(obj) {
            var str = &quot;&quot;;
            $.each(obj, function () {
                str += &quot;&lt;tr align='center'&gt;&lt;td id = '&quot; + this.userid + &quot;' &gt; &quot; + this.userid + &quot;&lt;/td&gt;&lt;td&gt;&quot; + this.username + &quot;&lt;/td&gt;&lt;td&gt;&quot; + this.usersex + &quot;&lt;/td&gt;&lt;td&gt;&quot; + this.userbirth + &quot;&lt;/td&gt;&lt;td&gt;&lt;a href='#' onclick='preUpdateUser()'&gt;选择更新&amp;nbsp;&amp;nbsp;&lt;/a&gt;&lt;a href='#' onclick='deleteUser(&quot; + this.userid + &quot;)'&gt;删除&lt;/a&gt;&lt;/td &gt; &lt; /tr&gt;&quot;
            });
            $(&quot;#tBody&quot;).prepend(str);
        }

        //用户添加或者更新
        function addorupdateUser(flag) {
            var userid = $(&quot;#userid&quot;).val();
            var username = $(&quot;#username&quot;).val();
            var usersex = $(&quot;#usersex&quot;).val();
            var userbirth = $(&quot;#userbirth&quot;).val();
            var data = {
                userid: userid,
                username: username,
                usersex: usersex,
                userbirth: userbirth,
                flag: flag
            }
            //刷新页面
            location.reload();
            $.get(&quot;user.do&quot;, data, function (result) {
                alert(result);
            });
        }
    &lt;/script&gt;
</code></pre>
<h4 id="532-在-servlet-中处理添加用户请求">5.3.2 在 Servlet 中处理添加用户请求</h4>
<pre><code class="language-java">/**
 * 用户管理 Servlet
 */
@WebServlet(&quot;/user.do&quot;)
public class UserServlet extends HttpServlet {
    //生成模拟数据初始化
    @Override
    public void init() throws ServletException {
        User user = new User();
        user.setUserid(1);
        user.setUsername(&quot;Oldlu&quot;);
        user.setUsersex(&quot;male&quot;);
        user.setUserbirth(new Date());
        User user2 = new User();
        user2.setUserid(2);
        user2.setUsername(&quot;Kevin&quot;);
        user2.setUsersex(&quot;male&quot;);
        user2.setUserbirth(new Date());
        List&lt;User&gt; list = new ArrayList&lt;&gt;();
        list.add(user);
        list.add(user2);
        ServletContext servletContext = this.getServletContext();
        servletContext.setAttribute(&quot;list&quot;, list);

    }

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        this.doPost(req, resp);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        String flag = req.getParameter(&quot;flag&quot;);
        if (&quot;getData&quot;.equals(flag)) {
            this.getData(req, resp);
        }else if(&quot;addUser&quot;.equals(flag)){
            try {
                this.addUser(req, resp);
            } catch (ParseException e) {
                e.printStackTrace();
            }
        }
    }

    //获取页面初始化数据
    private void getData(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        List&lt;User&gt; list = (List&lt;User&gt;) this.getServletContext().getAttribute(&quot;list&quot;);
        String s = JsonUtils.objectToJson(list);
        resp.setContentType(&quot;application/json&quot;);
        PrintWriter pw = resp.getWriter();
        pw.print(s);
        pw.flush();
        pw.close();
    }

    //处理添加用户请求
    private void addUser(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException, ParseException {
        User user = createUser(req);
        //从ServletContext中取出list
        ServletContext servletContext = this.getServletContext();
        //getAttribute返回的是一个object对象
        List&lt;User&gt; list = (List&lt;User&gt;) servletContext.getAttribute(&quot;list&quot;);
        list.add(user);
        resp.setContentType(&quot;text/plain;charset=utf-8&quot;);
        PrintWriter pw = resp.getWriter();
        pw.print(&quot;添加成功&quot;);
        pw.flush();
        pw.close();
    }

    //获取请求数据
    private User createUser(HttpServletRequest req) throws ParseException {
        String userid = req.getParameter(&quot;userid&quot;);
        String username = req.getParameter(&quot;username&quot;);
        String usersex = req.getParameter(&quot;usersex&quot;);
        String userbirth = req.getParameter(&quot;userbirth&quot;);

        User user = new User();
        user.setUserid(Integer.parseInt(userid));
        user.setUsername(username);
        user.setUsersex(usersex);

        SimpleDateFormat sf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        Date parse = sf.parse(userbirth);
        user.setUserbirth(parse);

        return user;
    }
}
</code></pre>
<p>解决时区问题:</p>
<pre><code class="language-java">@JsonFormat(pattern = &quot;yyyy-MM-dd&quot;,timezone = &quot;GMT+8&quot;)
</code></pre>
<figure data-type="image" tabindex="13"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615153808.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="14"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615153820.png" alt="" loading="lazy"></figure>
<h3 id="54-更新用户操作">5.4 更新用户操作</h3>
<h4 id="541-通过-ajax-完成预更新用户选择">5.4.1 通过 Ajax 完成预更新用户选择</h4>
<p>实现选择更新数据回填文本框</p>
<pre><code class="language-jsp">&lt;script&gt;
        $(function () {
            //获取页面初始化数据
            getData();
            //添加按钮绑定点击事件
            $(&quot;#add&quot;).click(function () {
                addorupdateUser(&quot;addUser&quot;);
            });
        });

        //获取页面初始化数据
        function getData() {
            $.getJSON(&quot;user.do&quot;, {flag: &quot;getData&quot;}, function (result) {
                init(result);
            });
        }

        //遍历数据生成数据
        function init(obj) {
            var str = &quot;&quot;;
            $.each(obj, function () {
                str += &quot;&lt;tr align='center'&gt;&lt;td id = '&quot; + this.userid + &quot;' &gt; &quot; + this.userid + &quot;&lt;/td&gt;&lt;td&gt;&quot; + this.username + &quot;&lt;/td&gt;&lt;td&gt;&quot; + this.usersex + &quot;&lt;/td&gt;&lt;td&gt;&quot; + this.userbirth + &quot;&lt;/td&gt;&lt;td&gt;&lt;a href='#' onclick='preUpdateUser(&quot; + this.userid + &quot;)'&gt;选择更新&amp;nbsp;&amp;nbsp;&lt;/a&gt;&lt;a href='#' onclick='deleteUser(&quot; + this.userid + &quot;)'&gt;删除&lt;/a&gt;&lt;/td &gt; &lt; /tr&gt;&quot;
            });
            $(&quot;#tBody&quot;).prepend(str);
        }

        //用户添加或者更新
        function addorupdateUser(flag) {
            var userid = $(&quot;#userid&quot;).val();
            var username = $(&quot;#username&quot;).val();
            var usersex = $(&quot;#usersex&quot;).val();
            var userbirth = $(&quot;#userbirth&quot;).val();
            var data = {
                userid: userid,
                username: username,
                usersex: usersex,
                userbirth: userbirth,
                flag: flag
            }
            //刷新页面
            location.reload();
            $.get(&quot;user.do&quot;, data, function (result) {
                alert(result);
            });
        }

        //更新之前数据选择
        function preUpdateUser(userid) {
            var arr = new Array();
            //根据传进来的userid拼接
            $(&quot;#&quot;+userid).closest(&quot;tr&quot;).children().each(function (index, ele) {
                if (index &lt;= 3) {
                    arr[index] = ele.innerText;
                }
            })
            $(&quot;#userid&quot;).val(arr[0]);
            $(&quot;#username&quot;).val(arr[1]);
            $(&quot;#usersex&quot;).val(arr[2]);
            $(&quot;#userbirth&quot;).val(arr[3]);

            $(&quot;#userid&quot;).Attr(&quot;readonly&quot;);
        }
    &lt;/script&gt;
</code></pre>
<figure data-type="image" tabindex="15"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615160446.png" alt="" loading="lazy"></figure>
<h4 id="542-通过-ajax-完成更新用户">5.4.2 通过 Ajax 完成更新用户</h4>
<pre><code class="language-jsp">&lt;script&gt;
        $(function () {
            //获取页面初始化数据
            getData();
            //添加按钮绑定点击事件
            $(&quot;#add&quot;).click(function () {
                addorupdateUser(&quot;addUser&quot;);
            });
            //更新按钮绑定点击事件
            $(&quot;#update&quot;).click(function () {
                addorupdateUser(&quot;updateUser&quot;);
            })
        });

        //获取页面初始化数据
        function getData() {
            $.getJSON(&quot;user.do&quot;, {flag: &quot;getData&quot;}, function (result) {
                init(result);
            });
        }

        //遍历数据生成数据
        function init(obj) {
            var str = &quot;&quot;;
            $.each(obj, function () {
                str += &quot;&lt;tr align='center'&gt;&lt;td id = '&quot; + this.userid + &quot;' &gt; &quot; + this.userid + &quot;&lt;/td&gt;&lt;td&gt;&quot; + this.username + &quot;&lt;/td&gt;&lt;td&gt;&quot; + this.usersex + &quot;&lt;/td&gt;&lt;td&gt;&quot; + this.userbirth + &quot;&lt;/td&gt;&lt;td&gt;&lt;a href='#' onclick='preUpdateUser(&quot; + this.userid + &quot;)'&gt;选择更新&amp;nbsp;&amp;nbsp;&lt;/a&gt;&lt;a href='#' onclick='deleteUser(&quot; + this.userid + &quot;)'&gt;删除&lt;/a&gt;&lt;/td &gt; &lt; /tr&gt;&quot;
            });
            $(&quot;#tBody&quot;).prepend(str);
        }

        //用户添加或者更新
        function addorupdateUser(flag) {
            var userid = $(&quot;#userid&quot;).val();
            var username = $(&quot;#username&quot;).val();
            var usersex = $(&quot;#usersex&quot;).val();
            var userbirth = $(&quot;#userbirth&quot;).val();
            var data = {
                userid: userid,
                username: username,
                usersex: usersex,
                userbirth: userbirth,
                flag: flag
            }
            //刷新页面
            location.reload();
            $.get(&quot;user.do&quot;, data, function (result) {
                alert(result);
            });
        }

        //更新之前数据选择
        function preUpdateUser(userid) {
            var arr = new Array();
            $(&quot;#&quot;+userid).closest(&quot;tr&quot;).children().each(function (index, ele) {
                if (index &lt;= 3) {
                    arr[index] = ele.innerText;
                }
            })
            $(&quot;#userid&quot;).val(arr[0]);
            $(&quot;#username&quot;).val(arr[1]);
            $(&quot;#usersex&quot;).val(arr[2]);
            $(&quot;#userbirth&quot;).val(arr[3]);

            $(&quot;#userid&quot;).Attr(&quot;readonly&quot;);
        }
    &lt;/script&gt;
</code></pre>
<h4 id="543-在-servlet-中处理更新用户请求">5.4.3 在 Servlet 中处理更新用户请求</h4>
<pre><code class="language-java">/** 用户管理 Servlet 
 *
 * */
@WebServlet(&quot;/user.do&quot;)
public class UserServlet extends HttpServlet {
  // 生成模拟数据初始化
  @Override
  public void init() throws ServletException {
    User user = new User();
    user.setUserid(1);
    user.setUsername(&quot;Oldlu&quot;);
    user.setUsersex(&quot;male&quot;);
    user.setUserbirth(new Date());
    User user2 = new User();
    user2.setUserid(2);
    user2.setUsername(&quot;Kevin&quot;);
    user2.setUsersex(&quot;male&quot;);
    user2.setUserbirth(new Date());
    List&lt;User&gt; list = new ArrayList&lt;&gt;();
    list.add(user);
    list.add(user2);
    ServletContext servletContext = this.getServletContext();
    servletContext.setAttribute(&quot;list&quot;, list);
  }

  @Override
  protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    this.doPost(req, resp);
  }

  @Override
  protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    String flag = req.getParameter(&quot;flag&quot;);
    if (&quot;getData&quot;.equals(flag)) {
      this.getData(req, resp);
    } else if (&quot;addUser&quot;.equals(flag)) {
      try {
        this.addUser(req, resp);
      } catch (ParseException e) {
        e.printStackTrace();
      }
    } else if (&quot;updateUser&quot;.equals(flag)) {
      try {
        this.updateUser(req, resp);
      } catch (ParseException e) {
        e.printStackTrace();
      }
    }
  }

  // 获取页面初始化数据
  private void getData(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    List&lt;User&gt; list = (List&lt;User&gt;) this.getServletContext().getAttribute(&quot;list&quot;);
    String s = JsonUtils.objectToJson(list);
    resp.setContentType(&quot;application/json&quot;);
    PrintWriter pw = resp.getWriter();
    pw.print(s);
    pw.flush();
    pw.close();
  }

  // 处理添加用户请求
  private void addUser(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException, ParseException {
    User user = createUser(req);
    // 从ServletContext中取出list
    ServletContext servletContext = this.getServletContext();
    // getAttribute返回的是一个object对象
    List&lt;User&gt; list = (List&lt;User&gt;) servletContext.getAttribute(&quot;list&quot;);
    list.add(user);
    resp.setContentType(&quot;text/plain;charset=utf-8&quot;);
    PrintWriter pw = resp.getWriter();
    pw.print(&quot;添加成功&quot;);
    pw.flush();
    pw.close();
  }

  // 处理更新用户请求
  private void updateUser(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException, ParseException {
    User user = this.createUser(req);
    ServletContext servletContext = this.getServletContext();
    List&lt;User&gt; list = (List&lt;User&gt;) servletContext.getAttribute(&quot;list&quot;);

    //避免在迭代中更改集合的长度
      User u=null;
      for (User temp :list ) {
          if(temp.getUserid() == user.getUserid()){
              u = temp;
              break;
          }
      }
      if(u != null){
          list.remove(u);
      }
      list.add(user);
      resp.setContentType(&quot;text/plain;charset=utf-8&quot;);
      PrintWriter pw = resp.getWriter();
      pw.print(&quot;更新成功&quot;);
      pw.flush();
      pw.close();
  }

  // 获取请求数据
  private User createUser(HttpServletRequest req) throws ParseException {
    String userid = req.getParameter(&quot;userid&quot;);
    String username = req.getParameter(&quot;username&quot;);
    String usersex = req.getParameter(&quot;usersex&quot;);
    String userbirth = req.getParameter(&quot;userbirth&quot;);

    User user = new User();
    user.setUserid(Integer.parseInt(userid));
    user.setUsername(username);
    user.setUsersex(usersex);

    SimpleDateFormat sf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
    Date parse = sf.parse(userbirth);
    user.setUserbirth(parse);

    return user;
  }
}
</code></pre>
<figure data-type="image" tabindex="16"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615163605.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="17"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615163622.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="18"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615163635.png" alt="" loading="lazy"></figure>
<h3 id="55删除用户操作">5.5删除用户操作</h3>
<h4 id="551-通过-ajax-完成删除用户">5.5.1 通过 Ajax 完成删除用户</h4>
<pre><code class="language-jsp">&lt;script&gt;
        $(function () {
            //获取页面初始化数据
            getData();
            //添加按钮绑定点击事件
            $(&quot;#add&quot;).click(function () {
                addorupdateUser(&quot;addUser&quot;);
            });
            //更新按钮绑定点击事件
            $(&quot;#update&quot;).click(function () {
                addorupdateUser(&quot;updateUser&quot;);
            })
        });

        //获取页面初始化数据
        function getData() {
            $.getJSON(&quot;user.do&quot;, {flag: &quot;getData&quot;}, function (result) {
                init(result);
            });
        }

        //遍历数据生成数据
        function init(obj) {
            var str = &quot;&quot;;
            $.each(obj, function () {
                str += &quot;&lt;tr align='center'&gt;&lt;td id = '&quot; + this.userid + &quot;' &gt; &quot; + this.userid + &quot;&lt;/td&gt;&lt;td&gt;&quot; + this.username + &quot;&lt;/td&gt;&lt;td&gt;&quot; + this.usersex + &quot;&lt;/td&gt;&lt;td&gt;&quot; + this.userbirth + &quot;&lt;/td&gt;&lt;td&gt;&lt;a href='#' onclick='preUpdateUser(&quot; + this.userid + &quot;)'&gt;选择更新&amp;nbsp;&amp;nbsp;&lt;/a&gt;&lt;a href='#' onclick='deleteUser(&quot; + this.userid + &quot;)'&gt;删除&lt;/a&gt;&lt;/td &gt; &lt; /tr&gt;&quot;
            });
            $(&quot;#tBody&quot;).prepend(str);
        }

        //用户添加或者更新
        function addorupdateUser(flag) {
            var userid = $(&quot;#userid&quot;).val();
            var username = $(&quot;#username&quot;).val();
            var usersex = $(&quot;#usersex&quot;).val();
            var userbirth = $(&quot;#userbirth&quot;).val();
            var data = {
                userid: userid,
                username: username,
                usersex: usersex,
                userbirth: userbirth,
                flag: flag
            }
            //刷新页面
            location.reload();
            $.get(&quot;user.do&quot;, data, function (result) {
                alert(result);
            });
        }

        //更新之前数据选择
        function preUpdateUser(userid) {
            var arr = new Array();
            $(&quot;#&quot; + userid).closest(&quot;tr&quot;).children().each(function (index, ele) {
                if (index &lt;= 3) {
                    arr[index] = ele.innerText;
                }
            })
            $(&quot;#userid&quot;).val(arr[0]);
            $(&quot;#username&quot;).val(arr[1]);
            $(&quot;#usersex&quot;).val(arr[2]);
            $(&quot;#userbirth&quot;).val(arr[3]);

            $(&quot;#userid&quot;).Attr(&quot;readonly&quot;);
        }

        //删除用户
        function deleteUser(userid) {
            $(&quot;#&quot; + userid).closest(&quot;tr&quot;).remove();
            $.get(&quot;user.do&quot;, {userid: userid}, function (result) {
                alert(result);
            })
        }
    &lt;/script&gt;
</code></pre>
<h4 id="552-在-servlet-处理删除用户请求">5.5.2 在 Servlet 处理删除用户请求</h4>
<pre><code class="language-java">/** 用户管理 Servlet
 *
 * */
@WebServlet(&quot;/user.do&quot;)
public class UserServlet extends HttpServlet {
  // 生成模拟数据初始化
  @Override
  public void init() throws ServletException {
    User user = new User();
    user.setUserid(1);
    user.setUsername(&quot;Oldlu&quot;);
    user.setUsersex(&quot;male&quot;);
    user.setUserbirth(new Date());
    User user2 = new User();
    user2.setUserid(2);
    user2.setUsername(&quot;Kevin&quot;);
    user2.setUsersex(&quot;male&quot;);
    user2.setUserbirth(new Date());
    List&lt;User&gt; list = new ArrayList&lt;&gt;();
    list.add(user);
    list.add(user2);
    ServletContext servletContext = this.getServletContext();
    servletContext.setAttribute(&quot;list&quot;, list);
  }

  @Override
  protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    this.doPost(req, resp);
  }

  @Override
  protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    String flag = req.getParameter(&quot;flag&quot;);
    if (&quot;getData&quot;.equals(flag)) {
      this.getData(req, resp);
    } else if (&quot;addUser&quot;.equals(flag)) {
      try {
        this.addUser(req, resp);
      } catch (ParseException e) {
         e.printStackTrace();
      }
    } else if (&quot;updateUser&quot;.equals(flag)) {
      try {
        this.updateUser(req, resp);
      } catch (ParseException e) {
        e.printStackTrace();
      }
    }else{
        try {
            this.deleteUser(req,resp);
        } catch (ParseException e) {
            e.printStackTrace();
        }
    }
  }

  // 获取页面初始化数据
  private void getData(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    List&lt;User&gt; list = (List&lt;User&gt;) this.getServletContext().getAttribute(&quot;list&quot;);
    String s = JsonUtils.objectToJson(list);
    resp.setContentType(&quot;application/json&quot;);
    PrintWriter pw = resp.getWriter();
    pw.print(s);
    pw.flush();
    pw.close();
  }

  // 处理添加用户请求
  private void addUser(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException, ParseException {
    User user = createUser(req);
    // 从ServletContext中取出list
    ServletContext servletContext = this.getServletContext();
    // getAttribute返回的是一个object对象
    List&lt;User&gt; list = (List&lt;User&gt;) servletContext.getAttribute(&quot;list&quot;);
    list.add(user);
    resp.setContentType(&quot;text/plain;charset=utf-8&quot;);
    PrintWriter pw = resp.getWriter();
    pw.print(&quot;添加成功&quot;);
    pw.flush();
    pw.close();
  }

  // 处理更新用户请求
  private void updateUser(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException, ParseException {
    User user = this.createUser(req);
    ServletContext servletContext = this.getServletContext();
    List&lt;User&gt; list = (List&lt;User&gt;) servletContext.getAttribute(&quot;list&quot;);

    //避免在迭代中更改集合的长度
      User u = null;
      for (User temp :list ) {
          if(temp.getUserid() == user.getUserid()){
              u = temp;
              break;
          }
      }
      if(u != null){
          list.remove(u);
      }
      list.add(user);
      resp.setContentType(&quot;text/plain;charset=utf-8&quot;);
      PrintWriter pw = resp.getWriter();
      pw.print(&quot;更新成功&quot;);
      pw.flush();
      pw.close();
  }

  //处理删除用户数据
    private void deleteUser(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException, ParseException {
        String userid = req.getParameter(&quot;userid&quot;);
        ServletContext servletContext = this.getServletContext();
        List&lt;User&gt; list = (List&lt;User&gt;) servletContext.getAttribute(&quot;list&quot;);
        User user = null;
        for (User temp : list) {
            if((temp.getUserid()+&quot;&quot;).equals(userid)){
                user = temp;
                break;
            }
        }
        if(user != null){
            list.remove(user);
        }
        resp.setContentType(&quot;text/plain;charset=utf-8&quot;);
        PrintWriter pw = resp.getWriter();
        pw.print(&quot;删除成功&quot;);
        pw.flush();
        pw.close();
    }

  // 获取请求数据
  private User createUser(HttpServletRequest req) throws ParseException {
    String userid = req.getParameter(&quot;userid&quot;);
    String username = req.getParameter(&quot;username&quot;);
    String usersex = req.getParameter(&quot;usersex&quot;);
    String userbirth = req.getParameter(&quot;userbirth&quot;);

    User user = new User();
    user.setUserid(Integer.parseInt(userid));
    user.setUsername(username);
    user.setUsersex(usersex);

    SimpleDateFormat sf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
    Date parse = sf.parse(userbirth);
    user.setUserbirth(parse);

    return user;
  }
}

</code></pre>
<figure data-type="image" tabindex="19"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615170710.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="20"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615170722.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[jQuery]]></title>
        <id>https://jonchan1013.github.io/post/jquery/</id>
        <link href="https://jonchan1013.github.io/post/jquery/">
        </link>
        <updated>2020-06-11T01:32:04.000Z</updated>
        <summary type="html"><![CDATA[<p>✍️ jQuery 是一个 JavaScript 库。 jQuery 极大地简化了 JavaScript 编程......</p>
]]></summary>
        <content type="html"><![CDATA[<p>✍️ jQuery 是一个 JavaScript 库。 jQuery 极大地简化了 JavaScript 编程......</p>
<!-- more -->
<h2 id="1-jquery的概述">1、jQuery的概述</h2>
<h3 id="11-为什么要用jquery">1.1 为什么要用jquery</h3>
<ul>
<li>选择器功能弱</li>
<li>DOM操作繁琐之极</li>
<li>浏览器兼容性不好</li>
<li>动画效果弱</li>
</ul>
<h3 id="12-什么是-jquery概念">1.2 什么是 jQuery(概念)</h3>
<p>​	jQuery （javaScriptQuery）JavaScript 代码库</p>
<p>js.js:</p>
<pre><code class="language-js">function $(id){
    var dom = document.getElementById(id);
    return dom;
}
</code></pre>
<p>jq的含义.html:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;utf-8&quot;&gt;
		&lt;title&gt;&lt;/title&gt;
		
		&lt;!--[1]引入js文件--&gt;
		
		&lt;script src=&quot;js/js.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
		
		&lt;script&gt;
			
			//js获得元素对象的方式
			var  div =document.getElementById(&quot;div1&quot;);
			
			//JQ获得元素的方式
			var  div2=$(&quot;div1&quot;);
			
		&lt;/script&gt;	
		
	&lt;/head&gt;
	&lt;body&gt;
		
		&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;
		
	&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="13-目前-jquery-有三个大版本">1.3 目前 jQuery 有三个大版本：</h3>
<ul>
<li>
<p>1.x：兼容ie678,使用最为广泛的，官方只做BUG维护，功能不再新增。因此一般项目来说，使用1.x版本就可以了，最终版本：1.12.4 (2016年5月20日)</p>
</li>
<li>
<p>2.x：不兼容ie678，很少有人使用，官方只做BUG维护，功<br>
能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x，最终版本：2.2.4 (2016年5月20日)</p>
</li>
<li>
<p>3.x：不兼容 ie678，只支持最新的浏览器。除非特殊要求一般不会使用 3.x 版本的，很多老的 jQuery 插件不支持这个版本。目前该版本是官方主要更新维护的版本。最新版本：3.4.1</p>
</li>
</ul>
<h2 id="2-jquery-中的含义">2、jQuery 中$的含义</h2>
<p>引入jQuery：</p>
<script src="js/jquery-1.9.1.js" type="text/javascript" charset="utf-8"></script>
<p>js的方式实现隔行变色的效果：</p>
<pre><code class="language-html">window.onload=function(){	  	 	
		  	 	//获得所有的tr对象  	 	
  	 	var  tr =document.getElementsByTagName(&quot;tr&quot;);
		  	 	
	 	 	for(var i =0;i&lt;tr.length;i++){ 		
  	 		 if(i%2==0){
  	 		 	tr[i].style.backgroundColor=&quot;red&quot;;	  	 		 	
		  		 }else { 	 		 	
		  		 	tr[i].style.backgroundColor=&quot;green&quot;;
	 	 		 }		  	 				  	 		
  	 	} 	 	
  	 }
</code></pre>
<p>jQuery实现隔行变色的效果：</p>
<pre><code class="language-javascript">$(function(){	
	 	  $(&quot;tr:odd&quot;).css(&quot;background-color&quot;,&quot;red&quot;);
 })
</code></pre>
<h3 id="21-作用-1function">2.1 作用 1：$(function)</h3>
<ul>
<li>相当于 window.onload=function(){}</li>
<li>功能比window.onload更强大
<ol>
<li>window onload一个页面只能写一个,但是可以写多个$() 而不冲突</li>
<li>window onload要等整个页面加载完后再执行（包括图片、超链接、音视频等），但是$的执行时间要早</li>
</ol>
</li>
<li>3.完整形式是$(document).ready(…….);</li>
</ul>
<h3 id="22-作用-2selector">2.2. 作用 2：$(selector)</h3>
<ul>
<li>选择器<br>
jQuery具有强大的选择器功能</li>
</ul>
<h2 id="3-基本选择器一">3、基本选择器（一）</h2>
<h3 id="31-对象之间的转换">3.1 对象之间的转换</h3>
<ul>
<li>DOM对象：直接使用JavaScript获取的节点对象
<ul>
<li>className  innerHTML  value</li>
</ul>
</li>
<li>jQuery对象：使用jQuery选择器获取的节点对象，它能够使用jQuery中的方法
<ul>
<li>addClass()  html()  val()</li>
</ul>
</li>
<li>DOM对象和jQuery对象分别拥有一套独立的方法，不能混用</li>
<li>DOM对象转换成jQuery对象
<ul>
<li>$(DOM对象)</li>
</ul>
</li>
<li>jQuery对象转换成DOM对象
<ul>
<li>jQuery对象[index]</li>
<li>jQuery对象.get(index)</li>
</ul>
</li>
</ul>
<h3 id="32-基本选择器">3.2 基本选择器</h3>
<ul>
<li>标签选择器 $(“a”)</li>
<li>ID选择器 $(“#id”)    $(“p#id”)</li>
<li>类选择器 $(“.class”)    $(“h2.class”)    通配选择器 $(&quot;*&quot;)</li>
</ul>
<pre><code class="language-html">&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;utf-8&quot;&gt;
		&lt;title&gt;&lt;/title&gt;
		
		&lt;script src=&quot;js/jquery-1.9.1.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
		
		&lt;script type=&quot;text/javascript&quot;&gt;
			   $(function(){		   	
			   	//js获得元素对象
			    var  zh =document.getElementById(&quot;zh&quot;);
			    //Element
			    // JS----JQ对象
			    var  zhh=$(zh);
			    alert(zh);
			    
			    //JQ获得元素的对象  *ID选择器
			    var  zh1=$(&quot;#zh&quot;);
			    //Object---[Element1,Element2,Element3]
			    //JQ----JS对象
			    alert(zh1[0]);
			    
			    //*元素选择器
			    var inp =$(&quot;input&quot;);
			    
			    alert(inp.length);

                //*类选择器
                
                var inp2=$(&quot;.inp&quot;);
                //jq先转成js再获取内容
              alert(inp2[0].value);
                //  jq获得内容操作
			    alert(inp2.eq(0).val());

                //通用选择器
                
                $(&quot;*&quot;).css(&quot;background-color&quot;,&quot;greenyellow&quot;);
                
			    //分组选择器
			   })
		
		&lt;/script&gt;
	
	&lt;/head&gt;
	&lt;body&gt;	
		&lt;p&gt;		
			账号: &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;zh&quot; value=&quot;123&quot; /&gt;		
		&lt;/p&gt;		
		&lt;p&gt;
			密码: &lt;input type=&quot;password&quot; name=&quot;&quot; id=&quot;pwd&quot; value=&quot;12366&quot;  class=&quot;inp&quot;/&gt;			
		&lt;/p&gt;
		&lt;p&gt;
			 确认密码： &lt;input type=&quot;password&quot; name=&quot;&quot; id=&quot;pwd2&quot; value=&quot;123&quot; class=&quot;inp&quot;/&gt;		
		&lt;/p&gt;	
	&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<h2 id="4-层级选择器">4、层级选择器</h2>
<ul>
<li>并集选择器$(&quot;elem1,elem2,elem3&quot;)</li>
<li>后代选择器$(ul li)</li>
<li>父子选择器 $(ul&gt;li)</li>
<li>后面第一个兄弟元素 prev + next
<ul>
<li>后面所有的兄弟元素 prev ~ next</li>
</ul>
</li>
</ul>
<pre><code class="language-html">&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;utf-8&quot;&gt;
		&lt;title&gt;&lt;/title&gt;
		&lt;style&gt;			
			div{				
				height: 200px;				
				border:  3px solid  red;				
			}
		&lt;/style&gt;
		
		&lt;script src=&quot;js/jquery-1.9.1.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
		
		&lt;script type=&quot;text/javascript&quot;&gt;
			
			   $(function(){
			   	
			   	   //  div下面包含的所有span标签
			   	   $(&quot;div span&quot;).css(&quot;background-color&quot;,&quot;red&quot;);
			   	  // div下面的直系子元素
			   	   $(&quot;div&gt;span&quot;).css(&quot;background-color&quot;,&quot;green&quot;);

                  //  紧接着的span标签
                 $(&quot;#sp1 + span&quot;).css(&quot;background-color&quot;,&quot;red&quot;);
                    
                    //获得指定元素后面同级的span标签
                   $(&quot;#sp1~span&quot;).css(&quot;background-color&quot;,&quot;aqua&quot;); 
			   	
			   })		
		&lt;/script&gt;		
	&lt;/head&gt;
	&lt;body&gt;		
	   &lt;div&gt;	   	 
	   	 &lt;span id=&quot;sp1&quot;&gt;你好&lt;/span&gt;
	   	 
	   	 &lt;span&gt;你好&lt;/span&gt;&lt;br /&gt;
	   	 
	   	 &lt;span&gt;你好&lt;/span&gt;&lt;br /&gt;
	   	 
	   	 &lt;p&gt;
	   	 	&lt;span&gt;你好&lt;/span&gt;&lt;br /&gt;
	   	 
	   	    &lt;span&gt;你好&lt;/span&gt;&lt;br /&gt;
	   	 
	   	    &lt;span&gt;你好&lt;/span&gt;&lt;br /&gt;
	   	 		   	 	
	   	 &lt;/p&gt;	   	
	   &lt;/div&gt;		
	&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<h2 id="5-基本选择器二">5、基本选择器（二)</h2>
<pre><code class="language-html">&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;utf-8&quot;&gt;
		&lt;title&gt;&lt;/title&gt;
		&lt;style&gt;
			div{
				
				height: 200px;
				
				border:  3px solid red;
				
			}
		&lt;/style&gt;
		&lt;script src=&quot;js/jquery-1.9.1.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
		
		&lt;script type=&quot;text/javascript&quot;&gt;
			
			  $(function(){
			  	    //只是第一行变颜色
			  	   $(&quot;ul li:first&quot;).css(&quot;background-color&quot;,&quot;red&quot;);
			  	   $(&quot;ul li&quot;).first().css(&quot;background-color&quot;,&quot;red&quot;);
			  	   
			  	   //最后一行变颜色
			  	   $(&quot;ul li:last&quot;).css(&quot;background-color&quot;,&quot;green&quot;);
			  	   $(&quot;ul li&quot;).last().css(&quot;background-color&quot;,&quot;green&quot;);
                   //获得索引是奇数对象  索引从0开始
             	  $(&quot;ul li:odd&quot;).css(&quot;background-color&quot;,&quot;green&quot;);
					//获得索引是偶数对象  索引从0开始
                  $(&quot;ul li:even&quot;).css(&quot;background-color&quot;,&quot;green&quot;);
			  	   //获得索引下标位3的对象
			   	  $(&quot;ul li:eq(3)&quot;).css(&quot;background-color&quot;,&quot;green&quot;);
                    //获得大于指定索引下标的对象
                  $(&quot;ul li:gt(3)&quot;).css(&quot;background-color&quot;,&quot;green&quot;);
			  	    //获得小于指定索引下标的对象
			  	   $(&quot;ul li:lt(3)&quot;).css(&quot;background-color&quot;,&quot;green&quot;);

                   /**********子选择器*************************/
                  
                  
             	 $(&quot;ul li:nth-child(1)&quot;).css(&quot;background-color&quot;,&quot;green&quot;);
                    
                 $(&quot;ul li:first-child&quot;).css(&quot;background-color&quot;,&quot;darkred&quot;);
                    
                 $(&quot;ul li:last-child&quot;).css(&quot;background-color&quot;,&quot;darkred&quot;);  
                  
                 $(&quot;ul li:only-child&quot;).css(&quot;background-color&quot;,&quot;#00A40C&quot;);
			  })		
		&lt;/script&gt;
				
	&lt;/head&gt;
	&lt;body&gt;		
		&lt;div&gt;		
			&lt;ul&gt;
				&lt;li&gt;List  Item1&lt;/li&gt;
				&lt;li&gt;List  Item2&lt;/li&gt;
				&lt;li&gt;List  Item3&lt;/li&gt;
				&lt;li&gt;List  Item4&lt;/li&gt;
			&lt;/ul&gt;	
            
			&lt;ul&gt;
				&lt;li&gt;List  Item1&lt;/li&gt;
			&lt;/ul&gt;						
		&lt;/div&gt;	
	&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<h2 id="6-属性选择器">6、属性选择器</h2>
<pre><code class="language-html">&lt;script type=&quot;text/javascript&quot;&gt;
			
			$(function(){
				//type属性等于text
				$(&quot;input[type=text]&quot;).css(&quot;background-color&quot;,&quot;#00A40C&quot;);
				// name属性用z开头的
				$(&quot;input[name^=z]&quot;).css(&quot;background-color&quot;,&quot;#FF0000&quot;);
				// name属性同d结尾的
				$(&quot;input[name$=d]&quot;).css(&quot;background-color&quot;,&quot;green&quot;);
				//name属性中包含p 的元素
				$(&quot;input[name*=p]&quot;).css(&quot;background-color&quot;,&quot;green&quot;);
               
               //复合属性选择器，需要同时满足多个条件时使用
                $(&quot;input[type=text][name^=z]&quot;).css(&quot;background-color&quot;,&quot;deeppink&quot;); 
			})
			
			
		&lt;/script&gt;
</code></pre>
<h2 id="7-表单选择器">7、表单选择器</h2>
<pre><code class="language-html">&lt;script type=&quot;text/javascript&quot;&gt;
			
			$(function(){
				
				// √ 获得form表单中的所有的表单项
				var inp= $(&quot;:input&quot;) 
				//获得标签名称是input 的所有的标签对象
				var  inp2=$(&quot;input&quot;);
				alert(inp.length+&quot;----&quot;+inp2.length);
				
				$(&quot;input[type=text]&quot;)
				//  √ input标签 type属性等于text所对应的对象
				$(&quot;:text&quot;).css(&quot;background-color&quot;,&quot;green&quot;);
				
				$(&quot;:password&quot;).css(&quot;background-color&quot;,&quot;red&quot;);
				
				
				/********表单属性选择器*****************/
				
				//获得input标签中含有disabled属性的对象
				var but=  $(&quot;input:disabled&quot;);	
				
				alert(but.val());
				//√  获得含有checked属性的对象
				var  ch =$(&quot;input:checked&quot;);
				
			})
</code></pre>
<h2 id="8-操作元素对象的样式">8、 操作元素对象的样式</h2>
<pre><code class="language-html">&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;utf-8&quot;&gt;
		&lt;title&gt;&lt;/title&gt;
		
		&lt;style&gt;
			
			#div1{
				
				width: 200px;
				
				height: 200px;
				
				border: 2px solid  green;
				
			}			
		&lt;/style&gt;		
		&lt;script src=&quot;js/jquery-1.9.1.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
		
		&lt;script type=&quot;text/javascript&quot;&gt;
			
			$(function(){
				
				
				$(&quot;#bu1&quot;).click(function(){
					
					//获得div对象
					
					var  div =$(&quot;#div1&quot;);
					
					//获得css样式
					
					var wid=div.css(&quot;width&quot;);
					
					var hi=div.css(&quot;height&quot;);
					
					console.log(wid+&quot;----&quot;+hi);
					
					//操作元素对象的css
					
					div.css(&quot;width&quot;,&quot;400px&quot;);
					
					div.css(&quot;height&quot;,&quot;500px&quot;);
					
					div.css(&quot;background-color&quot;,&quot;red&quot;);
					
					div.css(&quot;backgroundColor&quot;,&quot;red&quot;);
					
				  //以上内容的综合---{key1:value1,key2:value2}---json数据格式
					
					div.css({'width':'300px','height':'300px','background-color':'red'});
				})
				
				
			})
			
		&lt;/script&gt;
		
	&lt;/head&gt;
	&lt;body&gt;		
		&lt;input type=&quot;button&quot; value=&quot;样式的添加&quot; id=&quot;bu1&quot;&gt;		
		&lt;hr /&gt;	
		&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;	
	&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<p>如果当页面中的css样式比较多的时候可以通过添加类的方式添加样式，方法如下：两种：</p>
<pre><code class="language-html">&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;utf-8&quot;&gt;
		&lt;title&gt;&lt;/title&gt;
		&lt;style&gt;
			#div1{
				
				width: 300px;
				
				height: 300px;
				
				border:  3px solid red;
				
			}
			
			.div{
				
				width: 500px;
				
				height: 500px;
				
				
				background-image: url(img/1.jpg);
				
				background-repeat: no-repeat;
				
				background-position: center;
				
				background-color: greenyellow;
				
			}
			
		&lt;/style&gt;
		
		&lt;script src=&quot;js/jquery-1.9.1.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
		
		&lt;script type=&quot;text/javascript&quot;&gt;
			
			  $(function(){
			  	 
			  	$(&quot;#bu1&quot;).click(function(){
			  		
			  		//获得div对象 --通过添加类的方式添加css样式
			  		$(&quot;#div1&quot;).attr(&quot;class&quot;,&quot;div&quot;);
			  		
			  		$(&quot;#div1&quot;).addClass(&quot;div&quot;);
			  	})			  				  	
			  })
						
		&lt;/script&gt;				
	&lt;/head&gt;
	&lt;body&gt;
		
		&lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;bu1&quot; value=&quot;元素样式操作&quot; /&gt;		
		&lt;hr /&gt;		
		&lt;div id=&quot;div1&quot;&gt;			
		&lt;/div&gt;
	&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<h2 id="9-操作元素对象的属性">9、操作元素对象的属性</h2>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;utf-8&quot;&gt;
		&lt;title&gt;&lt;/title&gt;
		&lt;script src=&quot;js/jquery-1.9.1.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
		
		&lt;script type=&quot;text/javascript&quot;&gt;
			
			 $(function(){
			 	
			 	 $(&quot;#bu1&quot;).click(function(){
			 	 	
			 	  //获得元素对象
			 	  var tex=$(&quot;#inp1&quot;);
			 	 //获得元素对象的属性	
			 	  var te=tex.attr(&quot;type&quot;);
			 	 	
			 	  var cl =tex.attr(&quot;class&quot;);
			 	 //获得元素固有的属性值
			 	 var  val =tex.attr(&quot;value&quot;);
			 	 
			 	 console.log(te+&quot;------&quot;+cl+&quot;-----&quot;+val);
			 	 //获得文本框实时输入的值
			 	 var  val2=tex.val();
			 	  alert(val2);
			 	 
			 	 /*********操作元素对象的属性******************/
                  
                  tex.attr(&quot;type&quot;,&quot;button&quot;);
                  
                  tex.attr(&quot;value&quot;,&quot;测试按钮&quot;);
			 	 
			 	 //支持json数据格式
			 	  tex.attr({&quot;type&quot;:&quot;button&quot;,&quot;value&quot;:&quot;测试按钮&quot;});
			 	  
			 	  var ch= $(&quot;#fav&quot;).attr(&quot;checked&quot;);//返回的是checked
                  var  flag=$(&quot;#fav&quot;).prop(&quot;checked&quot;);//返回值是true或false

                  var  flag=$(&quot;#fav&quot;).prop(&quot;checked&quot;,true);
			 	 
			 	 })			 	
			 	
			 })
		&lt;/script&gt;
		
	&lt;/head&gt;
	&lt;body&gt;
		
		&lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;bu1&quot; value=&quot;元素属性的获得&quot; /&gt;
		&lt;hr /&gt;
		&lt;form&gt;
			
			
			账号：&lt;input type=&quot;text&quot; class=&quot;inp&quot; id=&quot;inp1&quot; value=&quot;sxt&quot; /&gt; &lt;br /&gt;
			
			
			密码：&lt;input type=&quot;password&quot; class=&quot;pwd&quot; id=&quot;pwd1&quot; value=&quot;sxt&quot; /&gt;&lt;br /&gt;
			
			
			爱好： 抽烟：&lt;input type=&quot;checkbox&quot; /&gt;
			         
			       喝酒：&lt;input type=&quot;checkbox&quot; /&gt;
			
			       烫头：&lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot; id=&quot;fav&quot; /&gt;
		
		&lt;/form&gt;
		
	&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<h2 id="10-操作元素对象的内容和值">10、操作元素对象的内容和值</h2>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;utf-8&quot;&gt;
		&lt;title&gt;&lt;/title&gt;
      &lt;script src=&quot;js/jquery-1.9.1.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
      
      &lt;script type=&quot;text/javascript&quot;&gt;
      	
      	$(function(){
      		
      		$(&quot;#bu1&quot;).click(function(){
      			
      			 //获得div元素对象
      			 var div =$(&quot;#div1&quot;);
      			 
      			 
      			 //获得元素的内容 含有HTML的标签的
      			 var  ht=div.html();
      			 
      			 console.log(ht);
      			 //只是获得文本内容， 不含有HTML标签
      			 var te =div.text();
      			 
      			 console.log(te);
      			//获得文本框的值
      			
      			var val=$(&quot;#inp1&quot;).val();
      			
      			console.log(val);
      			
      			
      			/********操作元素对象的内容和值****************/
      			
      			//会识别这里的b标签，覆盖之前的内容
      			div.html(&quot;&lt;b&gt;我们都爱笑&lt;/b&gt;&quot;);
				
				//不会识别这里的b标签，覆盖之前的内容
      			div.text(&lt;b&gt;我们都爱笑&lt;/b&gt;&quot;);
      			
				//累加，不覆盖
      			div.text(div.text()+&quot;&lt;b&gt;我们都爱笑&lt;/b&gt;&quot;);
      			
      			
      			$(&quot;#inp1&quot;).val(&quot;123&quot;);
      			
      		})
	
      	})
      	
      	
      &lt;/script&gt;
	
	&lt;/head&gt;
	&lt;body&gt;
		
		&lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;bu1&quot; value=&quot;操作元素的内容&quot; /&gt;
		&lt;hr /&gt;
		
		&lt;div id=&quot;div1&quot;&gt;
			
			&lt;span&gt;你好&lt;/span&gt;
			
		&lt;/div&gt;
	
		&lt;input type=&quot;text&quot; name=&quot;inp1&quot;  id=&quot;inp1&quot; value=&quot;&quot; /&gt;
		
	&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<h2 id="11-操作元素对象的节点">11、操作元素对象的节点</h2>
<pre><code class="language-html">&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;utf-8&quot;&gt;
		&lt;title&gt;&lt;/title&gt;
		&lt;style&gt;	
			#div1{
				height: 300px;
				
				border: 3px solid  red;
			}
			p{
				border: 2px solid  green;
				
			}
		&lt;/style&gt;
		
		&lt;script src=&quot;js/jquery-1.9.1.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
		
		&lt;script type=&quot;text/javascript&quot;&gt;
			$(function(){
				//创建了新的元素
				var  p=$(&quot;&lt;p&gt; &lt;b&gt;List  Item0&lt;/b&gt; &lt;/p&gt;&quot;)
				//增加子元素   ---现有元素之后
				$(&quot;#div1&quot;).append(p);
                 //把p元素增加到  div里面 
                p.appendTo(&quot;#div1&quot;);
               //添加内部的子元素  ---现有元素之前
                $(&quot;#div1&quot;).prepend(p);
               
                p.prependTo(&quot;#div1&quot;);
               //平级的添加元素---现有元素之前
                p.insertBefore(&quot;#div1&quot;);
               
                $(&quot;#div1&quot;).before(p);
                
                //平级的添加元素---现有元素之后
                p.insertAfter(&quot;#div1&quot;);
                
                $(&quot;#div1&quot;).after(p);

            /***********替换指定的节点******************/
            
            $(&quot;div p:nth-child(1)&quot;).replaceWith(p);
            
            p.replaceAll(&quot;div p:nth-child(5)&quot;);
             
             /**********删除指定的节点元素***************************/
             //删除指定的元素
            $(&quot;#div1&quot;).remove();
	        //删除指定下标为3的子元素
	         $(&quot;div p:nth-child(3)&quot;).remove();
	         
	         
	         //清空内容,div1里面的内容全清空
	         $(&quot;#div1&quot;).empty();
	         
	         $(&quot;div p:nth-child(2)&quot;).empty();
	         
			})
			
		&lt;/script&gt;
		
	&lt;/head&gt;
	&lt;body&gt;
		
		&lt;div id=&quot;div1&quot;&gt;
			
			&lt;p&gt;List Item1&lt;/p&gt;
			
			&lt;p&gt;List Item2&lt;/p&gt;
			
			&lt;p&gt;List Item3&lt;/p&gt;
			
			&lt;p&gt;List Item4&lt;/p&gt;
			
			&lt;p&gt;List Item5&lt;/p&gt;	
		&lt;/div&gt;
		
	&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<pre><code class="language-html">&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;utf-8&quot;&gt;
		&lt;title&gt;&lt;/title&gt;
		&lt;script src=&quot;js/jquery-1.9.1.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
		
		&lt;script type=&quot;text/javascript&quot;&gt;
			
			 function insertNode(){
			 	
			 	//创建节点对象
			 	var  p =$('&lt;p&gt;'+
				'照片:&lt;input type=&quot;file&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;&quot; /&gt;'+
				'&lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;删除&quot; onclick=&quot;removeNode(this)&quot; /&gt;'+
			    '&lt;/p&gt;');
			 	
			 	$(&quot;#last&quot;).before(p);
			 	
			 }
			 function removeNode(obj){
			 	
			 	$(obj).parent().remove();
			 }
						
		&lt;/script&gt;
				
	&lt;/head&gt;
	&lt;body&gt;
		
		&lt;form&gt;
			
			&lt;p&gt;
				
				用户名:&lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;&quot; /&gt;
				
			&lt;/p&gt;
			
			&lt;p&gt;
				照片:&lt;input type=&quot;file&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;&quot; /&gt;
				
				&lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;添加&quot; onclick=&quot;insertNode()&quot; /&gt;
			&lt;/p&gt;
			
			&lt;p id=&quot;last&quot;&gt;
				&lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;提交&quot; /&gt;
				
				&lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;清空&quot; /&gt;
			&lt;/p&gt;
			
		&lt;/form&gt;	
	&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<h2 id="12-事件处理">12、事件处理</h2>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;utf-8&quot;&gt;
		&lt;title&gt;&lt;/title&gt;
		&lt;script src=&quot;http://apps.bdimg.com/libs/jquery/1.7.0/jquery.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
		
		&lt;script type=&quot;text/javascript&quot;&gt;
			/*页面加载完执行的操作*/
//			$(function(){})
			
//			jQuery(function(){})
			
//			$(document).ready(function(){})
			
			$(function(){
				/*******事件的基础绑定*************/
				$(&quot;#bu1&quot;).click(function(){
				
				alert(&quot;单击事件&quot;);
				
			  })
			  
			 $(&quot;#bu1&quot;).dblclick(function(){
			  	
			  	alert(&quot;双击事件&quot;);
			  })
			 
			  /*******bind事件绑定**************/
			  $(&quot;#bu2&quot;).bind('click',function(){
			  	
			  	alert(&quot;单击事件绑定&quot;);
			  	
			  })*/
			  //内容还支持json数据格式
			  $(&quot;#bu2&quot;).bind({
			  	 'click':function(){},
			  	 'dblclick':function(){},
			  	 'blur':function(){}
			  	})
			  
			  /*********one一次事件绑定*************/
			  
				$(&quot;#bu3&quot;).one('click',function(){
					
					alert(&quot;一次事件绑定&quot;);
				})			
				
				/*********trigger事件操作****************/
				
				$(&quot;#bu4&quot;).click(function(){
						
					$(&quot;#bu1&quot;).trigger('dblclick');
					
					$(&quot;#bu3&quot;).trigger('click');
					
				})
				
				/********事件的解绑***********/
				
				$(&quot;#bu5&quot;).click(function(){
					
					//事件的解绑
					//解绑指定对象上的所有事件
					$(&quot;#bu1&quot;).unbind();
					//解绑指定的事件
					$(&quot;#bu1&quot;).unbind(&quot;dblclick&quot;);
					
				})
				
				$(&quot;.bu6&quot;).click(function(){
					
					alert(&quot;单击事件的绑定&quot;);
					
				})
				
				$(&quot;.bu6&quot;).live('click',function(){
					
					alert(&quot;单击事件绑定&quot;);
					
				})
				
				
				$(&quot;body&quot;).append('&lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; class=&quot;bu6&quot; value=&quot;事件操作2&quot; /&gt;');
				
			})
		
		&lt;/script&gt;
	
	&lt;/head&gt;
	&lt;body&gt;
	
		&lt;input type=&quot;button&quot; name=&quot;bu1&quot; id=&quot;bu1&quot; value=&quot;事件绑定&quot; /&gt;
		
		&lt;input type=&quot;button&quot; name=&quot;bu2&quot; id=&quot;bu2&quot; value=&quot;bind事件绑定&quot; /&gt;
		
		&lt;input type=&quot;button&quot; name=&quot;bu3&quot; id=&quot;bu3&quot; value=&quot;one事件绑定&quot; /&gt;
		
		&lt;input type=&quot;button&quot; name=&quot;bu4&quot; id=&quot;bu4&quot; value=&quot;tigger事件学习&quot; /&gt;
		
		&lt;input type=&quot;button&quot; name=&quot;bu5&quot; id=&quot;bu5&quot; value=&quot;事件解绑&quot; /&gt;
	
		&lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; class=&quot;bu6&quot; value=&quot;事件操作&quot; /&gt;
	
	&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<h2 id="13-动画功能">13、动画功能</h2>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;utf-8&quot;&gt;
		&lt;title&gt;&lt;/title&gt;
		&lt;style&gt;
			#div1{		
				height: 300px;
				background-color: green;
			}
			
			#div2{
				
				height: 300px;
				
				background-color: yellow;
		}
		&lt;/style&gt;
		
		&lt;script src=&quot;js/jquery-1.9.1.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
		
		&lt;script type=&quot;text/javascript&quot;&gt;
			
			  $(function(){
			  	  $(&quot;#bu1&quot;).click(function(){
			  	  	
			  	  	  //获得div对象
			  	  	  var  div1 =$(&quot;#div1&quot;);
			  	  	  
			  	  	  //3s隐藏动画
			  	  	  div1.hide(3000);
			  	  	  
			  	  	  div1.show(3000);
                      //隐藏的显示 ---显示的隐藏
                      $(&quot;div&quot;).toggle(3000);
                     //滑动上
                   div1.slideUp(3000);
                     //滑动下
                   div1.slideDown(3000);
                     //滑动上--滑动下    滑动下---滑动上
                   $(&quot;div&quot;).slideToggle(3000);
                   
                     //淡出
                     div1.fadeOut(3000);
                     //淡入
                     div1.fadeIn(3000);
			  	  	
			  	  })
	  	
			  })
			
		&lt;/script&gt;
		
	&lt;/head&gt;
	&lt;body&gt;
		
		&lt;input type=&quot;button&quot; id=&quot;bu1&quot; value='动画触发'&gt;
		
		&lt;hr /&gt;
		
		&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;
		
		&lt;div id=&quot;div2&quot;&gt;&lt;/div&gt;	
	&lt;/body&gt;
&lt;/html&gt;

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaWeb]]></title>
        <id>https://jonchan1013.github.io/post/javaweb/</id>
        <link href="https://jonchan1013.github.io/post/javaweb/">
        </link>
        <updated>2019-09-14T17:34:28.000Z</updated>
        <summary type="html"><![CDATA[<p>✍️JAVAEE的核心内容：Servlet和JSP、Tomcat服务器等。此外Maven的配置、Servlet的原理、Cookie和Session、JSP、监听器和过滤器、JDBC......</p>
]]></summary>
        <content type="html"><![CDATA[<p>✍️JAVAEE的核心内容：Servlet和JSP、Tomcat服务器等。此外Maven的配置、Servlet的原理、Cookie和Session、JSP、监听器和过滤器、JDBC......</p>
<!-- more -->
<h2 id="1-基本概念">1、基本概念</h2>
<h3 id="11-前言">1.1、前言</h3>
<p>web开发：</p>
<ul>
<li>web，网页的意思  ， www.baidu.com</li>
<li>静态web
<ul>
<li>html，css</li>
<li>提供给所有人看的数据始终不会发生变化！</li>
</ul>
</li>
<li>动态web
<ul>
<li>淘宝，几乎是所有的网站；</li>
<li>提供给所有人看的数据始终会发生变化，每个人在不同的时间，不同的地点看到的信息各不相同！</li>
<li>技术栈：Servlet/JSP，ASP，PHP</li>
</ul>
</li>
</ul>
<p>在Java中，动态web资源开发的技术统称为JavaWeb；</p>
<h3 id="12-web应用程序">1.2、web应用程序</h3>
<p>web应用程序：可以提供浏览器访问的程序；</p>
<ul>
<li>a.html、b.html......多个web资源，这些web资源可以被外界访问，对外界提供服务；</li>
<li>你们能访问到的任何一个页面或者资源，都存在于这个世界的某一个角落的计算机上。</li>
<li>URL</li>
<li>这个统一的web资源会被放在同一个文件夹下，web应用程序--&gt;Tomcat：服务器</li>
<li>一个web应用由多部分组成 （静态web，动态web）
<ul>
<li>html，css，js</li>
<li>jsp，servlet</li>
<li>Java程序</li>
<li>jar包</li>
<li>配置文件 （Properties）</li>
</ul>
</li>
</ul>
<p>web应用程序编写完毕后，若想提供给外界访问：需要一个服务器来统一管理；</p>
<h3 id="13-静态web">1.3、静态web</h3>
<ul>
<li>*.htm, *.html,这些都是网页的后缀，如果服务器上一直存在这些东西，我们就可以直接进行读取。通络；</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613005453.png" alt="" loading="lazy"></figure>
<ul>
<li>静态web存在的缺点
<ul>
<li>Web页面无法动态更新，所有用户看到都是同一个页面
<ul>
<li>轮播图，点击特效：伪动态</li>
<li>JavaScript [实际开发中，它用的最多]</li>
<li>VBScript</li>
</ul>
</li>
<li>它无法和数据库交互（数据无法持久化，用户无法交互）</li>
</ul>
</li>
</ul>
<h3 id="14-动态web">1.4、动态web</h3>
<p>页面会动态展示： “Web的页面展示的效果因人而异”；</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613005517.png" alt="" loading="lazy"></figure>
<p>缺点：</p>
<ul>
<li>加入服务器的动态web资源出现了错误，我们需要重新编写我们的<strong>后台程序</strong>,重新发布；
<ul>
<li>停机维护</li>
</ul>
</li>
</ul>
<p>优点：</p>
<ul>
<li>Web页面可以动态更新，所有用户看到都不是同一个页面</li>
<li>它可以与数据库交互 （数据持久化：注册，商品信息，用户信息........）</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613005534.png" alt="" loading="lazy"></figure>
<p>新手村：--魔鬼训练（分析原理，看源码）--&gt; PK场</p>
<h2 id="2-web服务器">2、web服务器</h2>
<h3 id="21-技术讲解">2.1、技术讲解</h3>
<p><strong>ASP:</strong></p>
<ul>
<li>
<p>微软：国内最早流行的就是ASP；</p>
</li>
<li>
<p>在HTML中嵌入了VB的脚本，  ASP + COM；</p>
</li>
<li>
<p>在ASP开发中，基本一个页面都有几千行的业务代码，页面极其换乱</p>
</li>
<li>
<p>维护成本高！</p>
</li>
<li>
<p>C#</p>
</li>
<li>
<p>IIS</p>
<pre><code class="language-html">&lt;h1&gt;
    &lt;h1&gt;&lt;h1&gt;
        &lt;h1&gt;
            &lt;h1&gt;
                &lt;h1&gt;
        &lt;h1&gt;
            &lt;%
            System.out.println(&quot;hello&quot;)
            %&gt;
            &lt;h1&gt;
                &lt;h1&gt;
   &lt;h1&gt;&lt;h1&gt;
&lt;h1&gt;
</code></pre>
</li>
</ul>
<p><strong>php：</strong></p>
<ul>
<li>PHP开发速度很快，功能很强大，跨平台，代码很简单 （70% , WP）</li>
<li>无法承载大访问量的情况（局限性）</li>
</ul>
<p>**JSP/Servlet : **</p>
<p>B/S：浏览和服务器</p>
<p>C/S:  客户端和服务器</p>
<ul>
<li>sun公司主推的B/S架构</li>
<li>基于Java语言的 (所有的大公司，或者一些开源的组件，都是用Java写的)</li>
<li>可以承载三高问题带来的影响；</li>
<li>语法像ASP ， ASP--&gt;JSP , 加强市场强度；</li>
</ul>
<p>.....</p>
<h3 id="22-web服务器">2.2、web服务器</h3>
<p>服务器是一种被动的操作，用来处理用户的一些请求和给用户一些响应信息；</p>
<p><strong>IIS</strong></p>
<p>微软的； ASP...,Windows中自带的</p>
<p><strong>Tomcat</strong></p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613005712.png" alt="" loading="lazy"></figure>
<p>面向百度编程；</p>
<p>Tomcat是Apache 软件基金会（Apache Software Foundation）的Jakarta 项目中的一个核心项目，最新的Servlet 和JSP 规范总是能在Tomcat 中得到体现，因为Tomcat 技术先进、性能稳定，而且<strong>免费</strong>，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。</p>
<p>Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用<a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8">服务器</a>，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。对于一个Java初学web的人来说，它是最佳的选择</p>
<p>Tomcat 实际上运行JSP 页面和Servlet。Tomcat最新版本为<strong>9.0。</strong></p>
<p>....</p>
<p><strong>工作3-5年之后，可以尝试手写Tomcat服务器；</strong></p>
<p>下载tomcat：</p>
<ol>
<li>安装 or  解压</li>
<li>了解配置文件及目录结构</li>
<li>这个东西的作用</li>
</ol>
<h2 id="3-tomcat">3、Tomcat</h2>
<h3 id="31-安装tomcat">3.1、 安装tomcat</h3>
<p>tomcat官网：http://tomcat.apache.org/</p>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613005728.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613005741.png" alt="" loading="lazy"></figure>
<h3 id="32-tomcat启动和配置">3.2、Tomcat启动和配置</h3>
<p>文件夹作用：</p>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613005759.png" alt="" loading="lazy"></figure>
<p><strong>启动。关闭Tomcat</strong></p>
<figure data-type="image" tabindex="8"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613005814.png" alt="" loading="lazy"></figure>
<p>访问测试：http://localhost:8080/</p>
<p>可能遇到的问题：</p>
<ol>
<li>Java环境变量没有配置</li>
<li>闪退问题：需要配置兼容性</li>
<li>乱码问题：配置文件中设置</li>
</ol>
<h3 id="33-配置">3.3、配置</h3>
<figure data-type="image" tabindex="9"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613005836.png" alt="" loading="lazy"></figure>
<p>可以配置启动的端口号</p>
<ul>
<li>tomcat的默认端口号为：8080</li>
<li>mysql：3306</li>
<li>http：80</li>
<li>https：443</li>
</ul>
<pre><code class="language-xml">&lt;Connector port=&quot;8081&quot; protocol=&quot;HTTP/1.1&quot;
           connectionTimeout=&quot;20000&quot;
           redirectPort=&quot;8443&quot; /&gt;
</code></pre>
<p>可以配置主机的名称</p>
<ul>
<li>默认的主机名为：localhost-&gt;127.0.0.1</li>
<li>默认网站应用存放的位置为：webapps</li>
</ul>
<pre><code class="language-xml">  &lt;Host name=&quot;www.cy.com&quot;  appBase=&quot;webapps&quot;
        unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;
</code></pre>
<h4 id="高难度面试题">高难度面试题：</h4>
<p>请你谈谈网站是如何进行访问的！</p>
<ol>
<li>
<p>输入一个域名；回车</p>
</li>
<li>
<p>检查本机的 C:\Windows\System32\drivers\etc\hosts配置文件下有没有这个域名映射；</p>
<ol>
<li>
<p>有：直接返回对应的ip地址，这个地址中，有我们需要访问的web程序，可以直接访问</p>
<pre><code class="language-java">127.0.0.1       www.qinjiang.com
</code></pre>
</li>
<li>
<p>没有：去DNS服务器找，找到的话就返回，找不到就返回找不到；</p>
</li>
</ol>
<figure data-type="image" tabindex="10"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613005939.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>可以配置一下环境变量（可选性）</p>
</li>
</ol>
<h3 id="34-发布一个web网站">3.4、发布一个web网站</h3>
<p>不会就先模仿</p>
<ul>
<li>将自己写的网站，放到服务器(Tomcat)中指定的web应用的文件夹（webapps）下，就可以访问了</li>
</ul>
<p>网站应该有的结构</p>
<pre><code class="language-java">--webapps ：Tomcat服务器的web目录
	-ROOT
	-kuangstudy ：网站的目录名
		- WEB-INF
			-classes : java程序
			-lib：web应用所依赖的jar包
			-web.xml ：网站配置文件
		- index.html 默认的首页
		- static 
            -css
            	-style.css
            -js
            -img
         -.....
</code></pre>
<p>HTTP协议 ： 面试</p>
<p>Maven：构建工具</p>
<ul>
<li>Maven安装包</li>
</ul>
<p>Servlet 入门</p>
<ul>
<li>HelloWorld！</li>
<li>Servlet配置</li>
<li>原理</li>
</ul>
<h2 id="4-http">4、Http</h2>
<h3 id="41-什么是http">4.1、什么是HTTP</h3>
<p>HTTP（超文本传输协议）是一个简单的请求-响应协议，它通常运行在TCP之上。</p>
<ul>
<li>文本：html，字符串，~ ….</li>
<li>超文本：图片，音乐，视频，定位，地图…….</li>
<li>80</li>
</ul>
<p>Https：安全的</p>
<ul>
<li>443</li>
</ul>
<h3 id="42-两个时代">4.2、两个时代</h3>
<ul>
<li>
<p>http1.0</p>
<ul>
<li>HTTP/1.0：客户端可以与web服务器连接后，只能获得一个web资源，断开连接</li>
</ul>
</li>
<li>
<p>http2.0</p>
<ul>
<li>HTTP/1.1：客户端可以与web服务器连接后，可以获得多个web资源。‘</li>
</ul>
</li>
</ul>
<h3 id="43-http请求">4.3、Http请求</h3>
<ul>
<li>客户端---发请求（Request）---服务器</li>
</ul>
<p>百度：</p>
<pre><code class="language-java">Request URL:https://www.baidu.com/   请求地址
Request Method:GET    get方法/post方法
Status Code:200 OK    状态码：200
Remote（远程） Address:14.215.177.39:443
</code></pre>
<pre><code class="language-java">Accept:text/html  
Accept-Encoding:gzip, deflate, br
Accept-Language:zh-CN,zh;q=0.9    语言
Cache-Control:max-age=0
Connection:keep-alive
</code></pre>
<h4 id="1-请求行">1、请求行</h4>
<ul>
<li>请求行中的请求方式：GET</li>
<li>请求方式：<strong>Get，Post</strong>，HEAD,DELETE,PUT,TRACT…
<ul>
<li>get：请求能够携带的参数比较少，大小有限制，会在浏览器的URL地址栏显示数据内容，不安全，但高效</li>
<li>post：请求能够携带的参数没有限制，大小没有限制，不会在浏览器的URL地址栏显示数据内容，安全，但不高效。</li>
</ul>
</li>
</ul>
<h4 id="2-消息头">2、消息头</h4>
<pre><code class="language-java">Accept：告诉浏览器，它所支持的数据类型
Accept-Encoding：支持哪种编码格式  GBK   UTF-8   GB2312  ISO8859-1
Accept-Language：告诉浏览器，它的语言环境
Cache-Control：缓存控制
Connection：告诉浏览器，请求完成是断开还是保持连接
HOST：主机..../.
</code></pre>
<h3 id="44-http响应">4.4、Http响应</h3>
<ul>
<li>服务器---响应-----客户端</li>
</ul>
<p>百度：</p>
<pre><code class="language-java">Cache-Control:private    缓存控制
Connection:Keep-Alive    连接
Content-Encoding:gzip    编码
Content-Type:text/html   类型
</code></pre>
<h4 id="1响应体">1.响应体</h4>
<pre><code class="language-java">Accept：告诉浏览器，它所支持的数据类型
Accept-Encoding：支持哪种编码格式  GBK   UTF-8   GB2312  ISO8859-1
Accept-Language：告诉浏览器，它的语言环境
Cache-Control：缓存控制
Connection：告诉浏览器，请求完成是断开还是保持连接
HOST：主机..../.
Refresh：告诉客户端，多久刷新一次；
Location：让网页重新定位；
</code></pre>
<h4 id="2-响应状态码">2、响应状态码</h4>
<p>200：请求响应成功  200</p>
<p>3xx：请求重定向</p>
<ul>
<li>重定向：你重新到我给你新位置去；</li>
</ul>
<p>4xx：找不到资源   404</p>
<ul>
<li>资源不存在；</li>
</ul>
<p>5xx：服务器代码错误   500       502:网关错误</p>
<p><strong>常见面试题：</strong></p>
<p>当你的浏览器中地址栏输入地址并回车的一瞬间到页面能够展示回来，经历了什么？</p>
<h2 id="5-maven">5、Maven</h2>
<p><strong>我为什么要学习这个技术？</strong></p>
<ol>
<li>
<p>在Javaweb开发中，需要使用大量的jar包，我们手动去导入；</p>
</li>
<li>
<p>如何能够让一个东西自动帮我导入和配置这个jar包。</p>
<p>由此，Maven诞生了！</p>
</li>
</ol>
<h3 id="51-maven项目架构管理工具">5.1 Maven项目架构管理工具</h3>
<p>我们目前用来就是方便导入jar包的！</p>
<p>Maven的核心思想：<strong>约定大于配置</strong></p>
<ul>
<li>有约束，不要去违反。</li>
</ul>
<p>Maven会规定好你该如何去编写我们的Java代码，必须要按照这个规范来；</p>
<h3 id="52-下载安装maven">5.2 下载安装Maven</h3>
<p>官网;https://maven.apache.org/</p>
<figure data-type="image" tabindex="11"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613010043.png" alt="" loading="lazy"></figure>
<p>下载完成后，解压即可；</p>
<h3 id="53-配置环境变量">5.3 配置环境变量</h3>
<p>在我们的系统环境变量中</p>
<p>配置如下配置：</p>
<ul>
<li>M2_HOME     maven目录下的bin目录</li>
<li>MAVEN_HOME      maven的目录</li>
<li>在系统的path中配置  %MAVEN_HOME%\bin</li>
</ul>
<figure data-type="image" tabindex="12"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613010116.png" alt="" loading="lazy"></figure>
<p>测试Maven是否安装成功，保证必须配置完毕！</p>
<h3 id="54-阿里云镜像">5.4 阿里云镜像</h3>
<figure data-type="image" tabindex="13"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613010134.png" alt="" loading="lazy"></figure>
<ul>
<li>镜像：mirrors
<ul>
<li>作用：加速我们的下载</li>
</ul>
</li>
<li>国内建议使用阿里云的镜像</li>
</ul>
<pre><code class="language-xml">&lt;mirror&gt;
    &lt;id&gt;nexus-aliyun&lt;/id&gt;  
    &lt;mirrorOf&gt;*,!jeecg,!jeecg-snapshots&lt;/mirrorOf&gt;  
    &lt;name&gt;Nexus aliyun&lt;/name&gt;  
    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; 
&lt;/mirror&gt;
</code></pre>
<h3 id="55-本地仓库">5.5 本地仓库</h3>
<p>在本地的仓库，远程仓库；</p>
<p>**建立一个本地仓库：**localRepository</p>
<pre><code class="language-xml">&lt;localRepository&gt;D:\Environment\apache-maven-3.6.2\maven-repo&lt;/localRepository&gt;
</code></pre>
<h3 id="56-在idea中使用maven">5.6、在IDEA中使用Maven</h3>
<ol>
<li>
<p>启动IDEA</p>
</li>
<li>
<p>创建一个MavenWeb项目</p>
<figure data-type="image" tabindex="14"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613010155.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="15"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613010224.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="16"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613010243.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="17"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613010308.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="18"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613010344.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>等待项目初始化完毕</p>
<figure data-type="image" tabindex="19"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613010438.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="20"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613010525.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>观察maven仓库中多了什么东西？</p>
</li>
<li>
<p>IDEA中的Maven设置</p>
<p>注意：IDEA项目创建成功后，看一眼Maven的配置</p>
<figure data-type="image" tabindex="21"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613010556.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="22"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613010613.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>到这里，Maven在IDEA中的配置和使用就OK了!</p>
</li>
</ol>
<h3 id="57-创建一个普通的maven项目">5.7、创建一个普通的Maven项目</h3>
<figure data-type="image" tabindex="23"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613010651.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="24"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613010711.png" alt="" loading="lazy"></figure>
<p>这个只有在Web应用下才会有！</p>
<figure data-type="image" tabindex="25"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613010738.png" alt="" loading="lazy"></figure>
<h3 id="58-标记文件夹功能">5.8  标记文件夹功能</h3>
<figure data-type="image" tabindex="26"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613010816.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="27"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613010846.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="28"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613010926.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="29"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613010954.png" alt="" loading="lazy"></figure>
<h3 id="59-在-idea中配置tomcat">5.9 在 IDEA中配置Tomcat</h3>
<figure data-type="image" tabindex="30"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613011016.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="31"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613011032.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="32"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613011049.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="33"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613011103.png" alt="" loading="lazy"></figure>
<p>解决警告问题</p>
<p>必须要的配置：<strong>为什么会有这个问题：我们访问一个网站，需要指定一个文件夹名字；</strong></p>
<figure data-type="image" tabindex="34"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613011122.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="35"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613011156.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="36"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613011214.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="37"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613011230.png" alt="" loading="lazy"></figure>
<h3 id="510-pom文件">5.10 pom文件</h3>
<p>pom.xml 是Maven的核心配置文件</p>
<figure data-type="image" tabindex="38"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613011251.png" alt="" loading="lazy"></figure>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;!--Maven版本和头文件--&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

  &lt;!--这里就是我们刚才配置的GAV--&gt;
  &lt;groupId&gt;com.kuang&lt;/groupId&gt;
  &lt;artifactId&gt;javaweb-01-maven&lt;/artifactId&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;!--Package：项目的打包方式
  jar：java应用
  war：JavaWeb应用
  --&gt;
  &lt;packaging&gt;war&lt;/packaging&gt;


  &lt;!--配置--&gt;
  &lt;properties&gt;
    &lt;!--项目的默认构建编码--&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;!--编码版本--&gt;
    &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
    &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
  &lt;/properties&gt;

  &lt;!--项目依赖--&gt;
  &lt;dependencies&gt;
    &lt;!--具体依赖的jar包配置文件--&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;4.11&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;

  &lt;!--项目构建用的东西--&gt;
  &lt;build&gt;
    &lt;finalName&gt;javaweb-01-maven&lt;/finalName&gt;
    &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;
      &lt;plugins&gt;
        &lt;plugin&gt;
          &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;
          &lt;version&gt;3.1.0&lt;/version&gt;
        &lt;/plugin&gt;
        &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt;
        &lt;plugin&gt;
          &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;
          &lt;version&gt;3.0.2&lt;/version&gt;
        &lt;/plugin&gt;
        &lt;plugin&gt;
          &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
          &lt;version&gt;3.8.0&lt;/version&gt;
        &lt;/plugin&gt;
        &lt;plugin&gt;
          &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
          &lt;version&gt;2.22.1&lt;/version&gt;
        &lt;/plugin&gt;
        &lt;plugin&gt;
          &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;
          &lt;version&gt;3.2.2&lt;/version&gt;
        &lt;/plugin&gt;
        &lt;plugin&gt;
          &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt;
          &lt;version&gt;2.5.2&lt;/version&gt;
        &lt;/plugin&gt;
        &lt;plugin&gt;
          &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt;
          &lt;version&gt;2.8.2&lt;/version&gt;
        &lt;/plugin&gt;
      &lt;/plugins&gt;
    &lt;/pluginManagement&gt;
  &lt;/build&gt;
&lt;/project&gt;

</code></pre>
<figure data-type="image" tabindex="39"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613011335.png" alt="" loading="lazy"></figure>
<p>maven由于他的约定大于配置，我们之后可以能遇到我们写的配置文件，无法被导出或者生效的问题，解决方案：</p>
<pre><code class="language-xml">&lt;!--在build中配置resources，来防止我们资源导出失败的问题--&gt;
&lt;build&gt;
    &lt;resources&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/resources&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.properties&lt;/include&gt;
                &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
            &lt;filtering&gt;true&lt;/filtering&gt;
        &lt;/resource&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/java&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.properties&lt;/include&gt;
                &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
            &lt;filtering&gt;true&lt;/filtering&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
&lt;/build&gt;
</code></pre>
<h3 id="512-idea操作">5.12 IDEA操作</h3>
<figure data-type="image" tabindex="40"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613011355.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="41"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613011409.png" alt="" loading="lazy"></figure>
<h3 id="513-解决遇到的问题">5.13 解决遇到的问题</h3>
<ol>
<li>
<p>Maven 3.6.2</p>
<p>解决方法：降级为3.6.1</p>
<figure data-type="image" tabindex="42"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613011426.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>Tomcat闪退</p>
</li>
<li>
<p>IDEA中每次都要重复配置Maven<br>
在IDEA中的全局默认配置中去配置</p>
<figure data-type="image" tabindex="43"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613011443.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="44"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613011501.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>Maven项目中Tomcat无法配置</p>
</li>
<li>
<p>maven默认web项目中的web.xml版本问题</p>
<figure data-type="image" tabindex="45"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613011524.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>替换为webapp4.0版本和tomcat一致</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee
                      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;
         metadata-complete=&quot;true&quot;&gt;



&lt;/web-app&gt;
</code></pre>
</li>
<li>
<p>Maven仓库的使用</p>
<p>地址：https://mvnrepository.com/</p>
<figure data-type="image" tabindex="46"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613011542.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="47"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613011612.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="48"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613011624.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="49"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613011643.png" alt="" loading="lazy"></figure>
</li>
</ol>
<h2 id="6-servlet">6、Servlet</h2>
<h3 id="61-servlet简介">6.1、Servlet简介</h3>
<ul>
<li>Servlet就是sun公司开发动态web的一门技术</li>
<li>Sun在这些API中提供一个接口叫做：Servlet，如果你想开发一个Servlet程序，只需要完成两个小步骤：
<ul>
<li>编写一个类，实现Servlet接口</li>
<li>把开发好的Java类部署到web服务器中。</li>
</ul>
</li>
</ul>
<p><strong>把实现了Servlet接口的Java程序叫做，Servlet</strong></p>
<h3 id="62-helloservlet">6.2、HelloServlet</h3>
<p>Serlvet接口Sun公司有两个默认的实现类：HttpServlet，GenericServlet</p>
<ol>
<li>
<p>构建一个普通的Maven项目，删掉里面的src目录，以后我们的学习就在这个项目里面建立Moudel；这个空的工程就是Maven主工程；</p>
</li>
<li>
<p>关于Maven父子工程的理解：</p>
<p>父项目中会有</p>
<pre><code class="language-xml">    &lt;modules&gt;
        &lt;module&gt;servlet-01&lt;/module&gt;
    &lt;/modules&gt;
</code></pre>
<p>子项目会有</p>
<pre><code class="language-xml">    &lt;parent&gt;
        &lt;artifactId&gt;javaweb-02-servlet&lt;/artifactId&gt;
        &lt;groupId&gt;com.kuang&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
</code></pre>
<p>父项目中的java子项目可以直接使用</p>
<pre><code class="language-java">son extends father
</code></pre>
</li>
<li>
<p>Maven环境优化</p>
<ol>
<li>修改web.xml为最新的</li>
<li>将maven的结构搭建完整</li>
</ol>
</li>
<li>
<p>编写一个Servlet程序</p>
<figure data-type="image" tabindex="50"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613011708.png" alt="" loading="lazy"></figure>
<ol>
<li>
<p>编写一个普通类</p>
</li>
<li>
<p>实现Servlet接口，这里我们直接继承HttpServlet</p>
<pre><code class="language-java">public class HelloServlet extends HttpServlet {
    
    //由于get或者post只是请求实现的不同的方式，可以相互调用，业务逻辑都一样；
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //ServletOutputStream outputStream = resp.getOutputStream();
        PrintWriter writer = resp.getWriter(); //响应流
        writer.print(&quot;Hello,Serlvet&quot;);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}

</code></pre>
</li>
</ol>
</li>
<li>
<p>编写Servlet的映射</p>
<p>为什么需要映射：我们写的是JAVA程序，但是要通过浏览器访问，而浏览器需要连接web服务器，所以我们需要再web服务中注册我们写的Servlet，还需给他一个浏览器能够访问的路径；</p>
<pre><code class="language-xml">
    &lt;!--注册Servlet--&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
        &lt;servlet-class&gt;com.cy.servlet.HelloServlet&lt;/servlet-class&gt;
    &lt;/servlet&gt;
    &lt;!--Servlet的请求路径--&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

</code></pre>
</li>
<li>
<p>配置Tomcat</p>
<p>注意：配置项目发布的路径就可以了</p>
</li>
<li>
<p>启动测试，OK！</p>
</li>
</ol>
<h3 id="63-servlet原理">6.3、Servlet原理</h3>
<p>Servlet是由Web服务器调用，web服务器在收到浏览器请求之后，会：</p>
<figure data-type="image" tabindex="51"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613011737.png" alt="" loading="lazy"></figure>
<h3 id="64-mapping问题">6.4、Mapping问题</h3>
<ol>
<li>
<p>一个Servlet可以指定一个映射路径</p>
<pre><code class="language-xml">    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
</code></pre>
</li>
<li>
<p>一个Servlet可以指定多个映射路径</p>
<pre><code class="language-xml">    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/hello2&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/hello3&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/hello4&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/hello5&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

</code></pre>
</li>
<li>
<p>一个Servlet可以指定通用映射路径</p>
<pre><code class="language-xml">    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/hello/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
</code></pre>
</li>
<li>
<p>默认请求路径</p>
<pre><code class="language-xml">    &lt;!--默认请求路径--&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
</code></pre>
</li>
<li>
<p>指定一些后缀或者前缀等等….</p>
<pre><code class="language-xml">
&lt;!--可以自定义后缀实现请求映射
    注意点，*前面不能加项目映射的路径
    hello/sajdlkajda.qinjiang
    --&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
    &lt;url-pattern&gt;*.cy&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
</li>
<li>
<p>优先级问题<br>
指定了固有的映射路径优先级最高，如果找不到就会走默认的处理请求；</p>
<pre><code class="language-xml">&lt;!--404--&gt;
&lt;servlet&gt;
    &lt;servlet-name&gt;error&lt;/servlet-name&gt;
    &lt;servlet-class&gt;com.cy.servlet.ErrorServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;error&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

</code></pre>
</li>
</ol>
<h3 id="65-servletcontext">6.5、ServletContext</h3>
<p>web容器在启动的时候，它会为每个web程序都创建一个对应的ServletContext对象，它代表了当前的web应用；</p>
<h4 id="1-共享数据">1、共享数据</h4>
<p>我在这个Servlet中保存的数据，可以在另外一个servlet中拿到；</p>
<pre><code class="language-java">public class HelloServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        
        //this.getInitParameter()   初始化参数
        //this.getServletConfig()   Servlet配置
        //this.getServletContext()  Servlet上下文
        ServletContext context = this.getServletContext();

        String username = &quot;CY&quot;; //数据
        context.setAttribute(&quot;username&quot;,username); //将一个数据保存在了ServletContext中，名字为：username 。值 username

    }

}

</code></pre>
<pre><code class="language-java">public class GetServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        ServletContext context = this.getServletContext();
        String username = (String) context.getAttribute(&quot;username&quot;);

        resp.setContentType(&quot;text/html&quot;);
        resp.setCharacterEncoding(&quot;utf-8&quot;);
        resp.getWriter().print(&quot;名字&quot;+username);

    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}

</code></pre>
<pre><code class="language-XML">    &lt;servlet&gt;
        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
        &lt;servlet-class&gt;com.cy.servlet.HelloServlet&lt;/servlet-class&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;


    &lt;servlet&gt;
        &lt;servlet-name&gt;getc&lt;/servlet-name&gt;
        &lt;servlet-class&gt;com.cy.servlet.GetServlet&lt;/servlet-class&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;getc&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/getc&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
</code></pre>
<p>测试访问结果；</p>
<h4 id="2-获取初始化参数">2、获取初始化参数</h4>
<pre><code class="language-xml">    &lt;!--配置一些web应用初始化参数--&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;url&lt;/param-name&gt;
        &lt;param-value&gt;jdbc:mysql://localhost:3306/mybatis&lt;/param-value&gt;
    &lt;/context-param&gt;
</code></pre>
<pre><code class="language-java">protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    ServletContext context = this.getServletContext();
    String url = context.getInitParameter(&quot;url&quot;);
    resp.getWriter().print(url);
}
</code></pre>
<h4 id="3-请求转发">3、请求转发</h4>
<pre><code class="language-java">@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    ServletContext context = this.getServletContext();
    System.out.println(&quot;进入了ServletDemo04&quot;);
    //RequestDispatcher requestDispatcher = context.getRequestDispatcher(&quot;/gp&quot;); //转发的请求路径
    //requestDispatcher.forward(req,resp); //调用forward实现请求转发；
    context.getRequestDispatcher(&quot;/gp&quot;).forward(req,resp);
}
</code></pre>
<figure data-type="image" tabindex="52"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613011803.png" alt="" loading="lazy"></figure>
<h4 id="4-读取资源文件">4、读取资源文件</h4>
<p>Properties</p>
<ul>
<li>在java目录下新建properties</li>
<li>在resources目录下新建properties</li>
</ul>
<p>发现：都被打包到了同一个路径下：classes，我们俗称这个路径为classpath:</p>
<p>思路：需要一个文件流；</p>
<pre><code class="language-properties">username=root12312
password=zxczxczxc
</code></pre>
<pre><code class="language-java">public class ServletDemo05 extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

        InputStream is = this.getServletContext().getResourceAsStream(&quot;/WEB-INF/classes/com/kuang/servlet/aa.properties&quot;);

        Properties prop = new Properties();
        prop.load(is);
        String user = prop.getProperty(&quot;username&quot;);
        String pwd = prop.getProperty(&quot;password&quot;);

        resp.getWriter().print(user+&quot;:&quot;+pwd);

    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}

</code></pre>
<p>访问测试即可ok；</p>
<h3 id="66-httpservletresponse">6.6、HttpServletResponse</h3>
<p>web服务器接收到客户端的http请求，针对这个请求，分别创建一个代表请求的HttpServletRequest对象，代表响应的一个HttpServletResponse；</p>
<ul>
<li>如果要获取客户端请求过来的参数：找HttpServletRequest</li>
<li>如果要给客户端响应一些信息：找HttpServletResponse</li>
</ul>
<h4 id="1-简单分类">1、简单分类</h4>
<p>负责向浏览器发送数据的方法</p>
<pre><code class="language-java">ServletOutputStream getOutputStream() throws IOException;
PrintWriter getWriter() throws IOException;
</code></pre>
<p>负责向浏览器发送响应头的方法</p>
<pre><code class="language-java">    void setCharacterEncoding(String var1);

    void setContentLength(int var1);

    void setContentLengthLong(long var1);

    void setContentType(String var1);

    void setDateHeader(String var1, long var2);

    void addDateHeader(String var1, long var2);

    void setHeader(String var1, String var2);

    void addHeader(String var1, String var2);

    void setIntHeader(String var1, int var2);

    void addIntHeader(String var1, int var2);
</code></pre>
<p>响应的状态码</p>
<pre><code class="language-java">    int SC_CONTINUE = 100;
    int SC_SWITCHING_PROTOCOLS = 101;
    int SC_OK = 200;
    int SC_CREATED = 201;
    int SC_ACCEPTED = 202;
    int SC_NON_AUTHORITATIVE_INFORMATION = 203;
    int SC_NO_CONTENT = 204;
    int SC_RESET_CONTENT = 205;
    int SC_PARTIAL_CONTENT = 206;
    int SC_MULTIPLE_CHOICES = 300;
    int SC_MOVED_PERMANENTLY = 301;
    int SC_MOVED_TEMPORARILY = 302;
    int SC_FOUND = 302;
    int SC_SEE_OTHER = 303;
    int SC_NOT_MODIFIED = 304;
    int SC_USE_PROXY = 305;
    int SC_TEMPORARY_REDIRECT = 307;
    int SC_BAD_REQUEST = 400;
    int SC_UNAUTHORIZED = 401;
    int SC_PAYMENT_REQUIRED = 402;
    int SC_FORBIDDEN = 403;
    int SC_NOT_FOUND = 404;
    int SC_METHOD_NOT_ALLOWED = 405;
    int SC_NOT_ACCEPTABLE = 406;
    int SC_PROXY_AUTHENTICATION_REQUIRED = 407;
    int SC_REQUEST_TIMEOUT = 408;
    int SC_CONFLICT = 409;
    int SC_GONE = 410;
    int SC_LENGTH_REQUIRED = 411;
    int SC_PRECONDITION_FAILED = 412;
    int SC_REQUEST_ENTITY_TOO_LARGE = 413;
    int SC_REQUEST_URI_TOO_LONG = 414;
    int SC_UNSUPPORTED_MEDIA_TYPE = 415;
    int SC_REQUESTED_RANGE_NOT_SATISFIABLE = 416;
    int SC_EXPECTATION_FAILED = 417;
    int SC_INTERNAL_SERVER_ERROR = 500;
    int SC_NOT_IMPLEMENTED = 501;
    int SC_BAD_GATEWAY = 502;
    int SC_SERVICE_UNAVAILABLE = 503;
    int SC_GATEWAY_TIMEOUT = 504;
    int SC_HTTP_VERSION_NOT_SUPPORTED = 505;
</code></pre>
<h4 id="2-下载文件">2、下载文件</h4>
<ol>
<li>向浏览器输出消息</li>
<li>下载文件
<ol>
<li>要获取下载文件的路径</li>
<li>下载的文件名是啥？</li>
<li>设置想办法让浏览器能够支持下载我们需要的东西</li>
<li>获取下载文件的输入流</li>
<li>创建缓冲区</li>
<li>获取OutputStream对象</li>
<li>将FileOutputStream流写入到buffer缓冲区</li>
<li>使用OutputStream将缓冲区中的数据输出到客户端！</li>
</ol>
</li>
</ol>
<pre><code class="language-java">@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    // 1. 要获取下载文件的路径
    String realPath = &quot;F:代码\\JavaWeb\\javaweb-02-servlet\\response\\target\\classes\\123.png&quot;;
    System.out.println(&quot;下载文件的路径：&quot;+realPath);
    // 2. 下载的文件名是啥？
    String fileName = realPath.substring(realPath.lastIndexOf(&quot;\\&quot;) + 1);
    // 3. 设置想办法让浏览器能够支持(Content-Disposition)下载我们需要的东西,中文文件名URLEncoder.encode编码，否则有可能乱码
    resp.setHeader(&quot;Content-Disposition&quot;,&quot;attachment;filename=&quot;+URLEncoder.encode(fileName,&quot;UTF-8&quot;));
    // 4. 获取下载文件的输入流
    FileInputStream in = new FileInputStream(realPath);
    // 5. 创建缓冲区
    int len = 0;
    byte[] buffer = new byte[1024];
    // 6. 获取OutputStream对象
    ServletOutputStream out = resp.getOutputStream();
    // 7. 将FileOutputStream流写入到buffer缓冲区,使用OutputStream将缓冲区中的数据输出到客户端！
    while ((len=in.read(buffer))&gt;0){
        out.write(buffer,0,len);
    }

    in.close();
    out.close();
}
</code></pre>
<h4 id="3-验证码功能">3、验证码功能</h4>
<p>验证怎么来的？</p>
<ul>
<li>前端实现</li>
<li>后端实现，需要用到 Java 的图片类，生产一个图片</li>
</ul>
<pre><code class="language-java">package com.kuang.servlet;

import javax.imageio.ImageIO;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.Random;

public class ImageServlet extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

        //如何让浏览器3秒自动刷新一次;
        resp.setHeader(&quot;refresh&quot;,&quot;3&quot;);
        
        //在内存中创建一个图片
        BufferedImage image = new BufferedImage(80,20,BufferedImage.TYPE_INT_RGB);
        //得到图片
        Graphics2D g = (Graphics2D) image.getGraphics(); //笔
        //设置图片的背景颜色
        g.setColor(Color.white);
        g.fillRect(0,0,80,20);
        //给图片写数据
        g.setColor(Color.BLUE);
        g.setFont(new Font(null,Font.BOLD,20));
        g.drawString(makeNum(),0,20);

        //告诉浏览器，这个请求用图片的方式打开
        resp.setContentType(&quot;image/jpeg&quot;);
        //网站存在缓存，不让浏览器缓存
        resp.setDateHeader(&quot;expires&quot;,-1);
        resp.setHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;);
        resp.setHeader(&quot;Pragma&quot;,&quot;no-cache&quot;);

        //把图片写给浏览器
        ImageIO.write(image,&quot;jpg&quot;, resp.getOutputStream());

    }

    //生成随机数
    private String makeNum(){
        Random random = new Random();
        String num = random.nextInt(9999999) + &quot;&quot;;
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i &lt; 7-num.length() ; i++) {
            sb.append(&quot;0&quot;);
        }
        num = sb.toString() + num;
        return num;
    }


    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}

</code></pre>
<h4 id="4-实现重定向">4、实现重定向</h4>
<figure data-type="image" tabindex="53"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613012114.png" alt="" loading="lazy"></figure>
<p>B一个web资源收到客户端A请求后，B他会通知A客户端去访问另外一个web资源C，这个过程叫重定向</p>
<p>常见场景：</p>
<ul>
<li>用户登录</li>
</ul>
<pre><code class="language-java">void sendRedirect(String var1) throws IOException;
</code></pre>
<p>测试：</p>
<pre><code class="language-java">@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

    /*
        resp.setHeader(&quot;Location&quot;,&quot;/r/img&quot;);
        resp.setStatus(302);
         */
    resp.sendRedirect(&quot;/r/img&quot;);//重定向
}
</code></pre>
<p>面试题：请你聊聊重定向和转发的区别？</p>
<p>相同点</p>
<ul>
<li>页面都会实现跳转</li>
</ul>
<p>不同点</p>
<ul>
<li>请求转发的时候，url不会产生变化</li>
<li>重定向时候，url地址栏会发生变化；</li>
</ul>
<figure data-type="image" tabindex="54"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613012129.png" alt="" loading="lazy"></figure>
<h4 id="5-简单实现登录重定向">5、简单实现登录重定向</h4>
<pre><code class="language-jsp">&lt;%--这里提交的路径，需要寻找到项目的路径--%&gt;
&lt;%--${pageContext.request.contextPath}代表当前的项目--%&gt;

&lt;form action=&quot;${pageContext.request.contextPath}/login&quot; method=&quot;get&quot;&gt;
    用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;br&gt;
    密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;br&gt;
    &lt;input type=&quot;submit&quot;&gt;
&lt;/form&gt;

</code></pre>
<pre><code class="language-JAVA">
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //处理请求
        String username = req.getParameter(&quot;username&quot;);
        String password = req.getParameter(&quot;password&quot;);

        System.out.println(username+&quot;:&quot;+password);

        //重定向时候一定要注意，路径问题，否则404；
        resp.sendRedirect(&quot;/r/success.jsp&quot;);
    }

</code></pre>
<pre><code class="language-xml">  &lt;servlet&gt;
    &lt;servlet-name&gt;requset&lt;/servlet-name&gt;
    &lt;servlet-class&gt;com.cy.servlet.RequestTest&lt;/servlet-class&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;requset&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/login&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
</code></pre>
<pre><code class="language-jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1&gt;Success&lt;/h1&gt;

&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<h3 id="67-httpservletrequest">6.7、HttpServletRequest</h3>
<p>HttpServletRequest代表客户端的请求，用户通过Http协议访问服务器，HTTP请求中的所有信息会被封装到HttpServletRequest，通过这个HttpServletRequest的方法，获得客户端的所有信息；</p>
<figure data-type="image" tabindex="55"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613012206.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="56"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613012223.png" alt="" loading="lazy"></figure>
<h4 id="获取参数请求转发">获取参数，请求转发</h4>
<figure data-type="image" tabindex="57"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613012235.png" alt="" loading="lazy"></figure>
<pre><code class="language-java">@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

    req.setCharacterEncoding(&quot;utf-8&quot;);
    resp.setCharacterEncoding(&quot;utf-8&quot;);

    String username = req.getParameter(&quot;username&quot;);
    String password = req.getParameter(&quot;password&quot;);
    String[] hobbys = req.getParameterValues(&quot;hobbys&quot;);
    System.out.println(&quot;=============================&quot;);
    //后台接收中文乱码问题
    System.out.println(username);
    System.out.println(password);
    System.out.println(Arrays.toString(hobbys));
    System.out.println(&quot;=============================&quot;);


    System.out.println(req.getContextPath());
    //通过请求转发
    //这里的 / 代表当前的web应用
    req.getRequestDispatcher(&quot;/success.jsp&quot;).forward(req,resp);

}
</code></pre>
<p><strong>面试题：请你聊聊重定向和转发的区别？</strong></p>
<p>相同点</p>
<ul>
<li>页面都会实现跳转</li>
</ul>
<p>不同点</p>
<ul>
<li>请求转发的时候，url不会产生变化   307</li>
<li>重定向时候，url地址栏会发生变化； 302</li>
</ul>
<h2 id="7-cookie-session">7、Cookie、Session</h2>
<h3 id="71-会话">7.1、会话</h3>
<p><strong>会话</strong>：用户打开一个浏览器，点击了很多超链接，访问多个web资源，关闭浏览器，这个过程可以称之为会话；</p>
<p><strong>有状态会话</strong>：一个同学来过教室，下次再来教室，我们会知道这个同学，曾经来过，称之为有状态会话；</p>
<p><strong>你能怎么证明你是清华的学生？</strong></p>
<p>你              清华</p>
<ol>
<li>发票                清华给你发票</li>
<li>学校登记        清华标记你来过了</li>
</ol>
<p><strong>一个网站，怎么证明你来过？</strong></p>
<p>客户端              服务端</p>
<ol>
<li>服务端给客户端一个 信件，客户端下次访问服务端带上信件就可以了； cookie</li>
<li>服务器登记你来过了，下次你来的时候我来匹配你； seesion</li>
</ol>
<h3 id="72-保存会话的两种技术">7.2、保存会话的两种技术</h3>
<p><strong>cookie</strong></p>
<ul>
<li>客户端技术   （响应，请求）</li>
</ul>
<p><strong>session</strong></p>
<ul>
<li>服务器技术，利用这个技术，可以保存用户的会话信息？ 我们可以把信息或者数据放在Session中！</li>
</ul>
<p>常见常见：网站登录之后，你下次不用再登录了，第二次访问直接就上去了！</p>
<h3 id="73-cookie">7.3、Cookie</h3>
<figure data-type="image" tabindex="58"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613012332.png" alt="" loading="lazy"></figure>
<ol>
<li>从请求中拿到cookie信息</li>
<li>服务器响应给客户端cookie</li>
</ol>
<pre><code class="language-java">Cookie[] cookies = req.getCookies(); //获得Cookie
cookie.getName(); //获得cookie中的key
cookie.getValue(); //获得cookie中的vlaue
new Cookie(&quot;lastLoginTime&quot;, System.currentTimeMillis()+&quot;&quot;); //新建一个cookie
cookie.setMaxAge(24*60*60); //设置cookie的有效期
resp.addCookie(cookie); //响应给客户端一个cookie
</code></pre>
<p><strong>cookie：一般会保存在本地的 用户目录下 appdata；</strong></p>
<p>一个网站cookie是否存在上限！<strong>聊聊细节问题</strong></p>
<ul>
<li>一个Cookie只能保存一个信息；</li>
<li>一个web站点可以给浏览器发送多个cookie，最多存放20个cookie；</li>
<li>Cookie大小有限制4kb；</li>
<li>300个cookie浏览器上限</li>
</ul>
<p><strong>删除Cookie；</strong></p>
<ul>
<li>不设置有效期，关闭浏览器，自动失效；</li>
<li>设置有效期时间为 0 ；</li>
</ul>
<p><strong>编码解码：</strong></p>
<pre><code class="language-java">URLEncoder.encode(&quot;CY&quot;,&quot;utf-8&quot;)
URLDecoder.decode(cookie.getValue(),&quot;UTF-8&quot;)
</code></pre>
<h3 id="74-session重点">7.4、Session（重点）</h3>
<figure data-type="image" tabindex="59"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613012402.png" alt="" loading="lazy"></figure>
<p>什么是Session：</p>
<ul>
<li>服务器会给每一个用户（浏览器）创建一个Seesion对象；</li>
<li>一个Seesion独占一个浏览器，只要浏览器没有关闭，这个Session就存在；</li>
<li>用户登录之后，整个网站它都可以访问！--&gt; 保存用户的信息；保存购物车的信息…..</li>
</ul>
<figure data-type="image" tabindex="60"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613012415.png" alt="" loading="lazy"></figure>
<p>Session和cookie的区别：</p>
<ul>
<li>Cookie是把用户的数据写给用户的浏览器，浏览器保存 （可以保存多个）</li>
<li>Session把用户的数据写到用户独占Session中，服务器端保存  （保存重要的信息，减少服务器资源的浪费）</li>
<li>Session对象由服务创建；</li>
</ul>
<p>使用场景：</p>
<ul>
<li>保存一个登录用户的信息；</li>
<li>购物车信息；</li>
<li>在整个网站中经常会使用的数据，我们将它保存在Session中；</li>
</ul>
<p>使用Session：</p>
<pre><code class="language-java">package com.cy.servlet;

import com.kuang.pojo.Person;

import javax.servlet.ServletException;
import javax.servlet.http.*;
import java.io.IOException;

public class SessionDemo01 extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        
        //解决乱码问题
        req.setCharacterEncoding(&quot;UTF-8&quot;);
        resp.setCharacterEncoding(&quot;UTF-8&quot;);
        resp.setContentType(&quot;text/html;charset=utf-8&quot;);
        
        //得到Session
        HttpSession session = req.getSession();
        //给Session中存东西
        session.setAttribute(&quot;name&quot;,new Person(&quot;秦疆&quot;,1));
        //获取Session的ID
        String sessionId = session.getId();

        //判断Session是不是新创建
        if (session.isNew()){
            resp.getWriter().write(&quot;session创建成功,ID:&quot;+sessionId);
        }else {
            resp.getWriter().write(&quot;session以及在服务器中存在了,ID:&quot;+sessionId);
        }

        //Session创建的时候做了什么事情；
//        Cookie cookie = new Cookie(&quot;JSESSIONID&quot;,sessionId);
//        resp.addCookie(cookie);

    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}

//得到Session
HttpSession session = req.getSession();

Person person = (Person) session.getAttribute(&quot;name&quot;);

System.out.println(person.toString());

HttpSession session = req.getSession();
session.removeAttribute(&quot;name&quot;);
//手动注销Session
session.invalidate();
</code></pre>
<p><strong>会话自动过期：web.xml配置</strong></p>
<pre><code class="language-xml">&lt;!--设置Session默认的失效时间--&gt;
&lt;session-config&gt;
    &lt;!--15分钟后Session自动失效，以分钟为单位--&gt;
    &lt;session-timeout&gt;15&lt;/session-timeout&gt;
&lt;/session-config&gt;
</code></pre>
<figure data-type="image" tabindex="61"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613012454.png" alt="" loading="lazy"></figure>
<h2 id="8-jsp">8、JSP</h2>
<h3 id="81-什么是jsp">8.1、什么是JSP</h3>
<p>Java Server Pages ： Java服务器端页面，也和Servlet一样，用于动态Web技术！</p>
<p>最大的特点：</p>
<ul>
<li>写JSP就像在写HTML</li>
<li>区别：
<ul>
<li>HTML只给用户提供静态的数据</li>
<li>JSP页面中可以嵌入JAVA代码，为用户提供动态数据；</li>
</ul>
</li>
</ul>
<h3 id="82-jsp原理">8.2、JSP原理</h3>
<p>思路：JSP到底怎么执行的！</p>
<ul>
<li>
<p>代码层面没有任何问题</p>
</li>
<li>
<p>服务器内部工作</p>
<p>tomcat中有一个work目录；</p>
<p>IDEA中使用Tomcat的会在IDEA的tomcat中生产一个work目录</p>
<figure data-type="image" tabindex="62"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613012516.png" alt="" loading="lazy"></figure>
<p>我电脑的地址：</p>
<pre><code class="language-java">C:\Users\Administrator\.IntelliJIdea2018.1\system\tomcat\Unnamed_javaweb-session-cookie\work\Catalina\localhost\ROOT\org\apache\jsp
</code></pre>
<p>发现页面转变成了Java程序！</p>
<figure data-type="image" tabindex="63"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613012553.png" alt="" loading="lazy"></figure>
</li>
</ul>
<p><strong>浏览器向服务器发送请求，不管访问什么资源，其实都是在访问Servlet！</strong></p>
<p>JSP最终也会被转换成为一个Java类！</p>
<p><strong>JSP 本质上就是一个Servlet</strong></p>
<pre><code class="language-java">//初始化
  public void _jspInit() {
      
  }
//销毁
  public void _jspDestroy() {
  }
//JSPService
  public void _jspService(.HttpServletRequest request,HttpServletResponse response)
      
</code></pre>
<ol>
<li>
<p>判断请求</p>
</li>
<li>
<p>内置一些对象</p>
<pre><code class="language-java">final javax.servlet.jsp.PageContext pageContext;  //页面上下文
javax.servlet.http.HttpSession session = null;    //session
final javax.servlet.ServletContext application;   //applicationContext
final javax.servlet.ServletConfig config;         //config
javax.servlet.jsp.JspWriter out = null;           //out
final java.lang.Object page = this;               //page：当前
HttpServletRequest request                        //请求
HttpServletResponse response                      //响应
</code></pre>
</li>
<li>
<p>输出页面前增加的代码</p>
<pre><code class="language-java">response.setContentType(&quot;text/html&quot;);       //设置响应的页面类型
pageContext = _jspxFactory.getPageContext(this, request, response,
                                          null, true, 8192, true);
_jspx_page_context = pageContext;
application = pageContext.getServletContext();
config = pageContext.getServletConfig();
session = pageContext.getSession();
out = pageContext.getOut();
_jspx_out = out;
</code></pre>
</li>
<li>
<p>以上的这些个对象我们可以在JSP页面中直接使用！</p>
</li>
</ol>
<figure data-type="image" tabindex="64"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613012856.png" alt="" loading="lazy"></figure>
<p>在JSP页面中；</p>
<p>只要是 JAVA代码就会原封不动的输出；</p>
<p>如果是HTML代码，就会被转换为：</p>
<pre><code class="language-java">out.write(&quot;&lt;html&gt;\r\n&quot;);
</code></pre>
<p>这样的格式，输出到前端！</p>
<h3 id="83-jsp基础语法">8.3、JSP基础语法</h3>
<p>任何语言都有自己的语法，JAVA中有,。 JSP 作为java技术的一种应用，它拥有一些自己扩充的语法（了解，知道即可！），Java所有语法都支持！</p>
<h4 id="jsp表达式"><strong>JSP表达式</strong></h4>
<pre><code class="language-jsp">  &lt;%--JSP表达式
  作用：用来将程序的输出，输出到客户端
  &lt;%= 变量或者表达式%&gt;
  --%&gt;
  &lt;%= new java.util.Date()%&gt;
</code></pre>
<h4 id="jsp脚本片段"><strong>jsp脚本片段</strong></h4>
<pre><code class="language-jsp">
  &lt;%--jsp脚本片段--%&gt;
  &lt;%
    int sum = 0;
    for (int i = 1; i &lt;=100 ; i++) {
      sum+=i;
    }
    out.println(&quot;&lt;h1&gt;Sum=&quot;+sum+&quot;&lt;/h1&gt;&quot;);
  %&gt;

</code></pre>
<p><strong>脚本片段的再实现</strong></p>
<pre><code class="language-jsp">  &lt;%
    int x = 10;
    out.println(x);
  %&gt;
  &lt;p&gt;这是一个JSP文档&lt;/p&gt;
  &lt;%
    int y = 2;
    out.println(y);
  %&gt;

  &lt;hr&gt;


  &lt;%--在代码嵌入HTML元素--%&gt;
  &lt;%
    for (int i = 0; i &lt; 5; i++) {
  %&gt;
    &lt;h1&gt;Hello,World  &lt;%=i%&gt; &lt;/h1&gt;
  &lt;%
    }
  %&gt;
</code></pre>
<h4 id="jsp声明">JSP声明</h4>
<pre><code class="language-jsp">  &lt;%!
    static {
      System.out.println(&quot;Loading Servlet!&quot;);
    }

    private int globalVar = 0;

    public void kuang(){
      System.out.println(&quot;进入了方法Kuang！&quot;);
    }
  %&gt;
</code></pre>
<p>JSP声明：会被编译到JSP生成Java的类中！其他的，就会被生成到_jspService方法中！</p>
<p>在JSP，嵌入Java代码即可！</p>
<pre><code class="language-jsp">&lt;%%&gt;
&lt;%=%&gt;
&lt;%!%&gt;

&lt;%--注释--%&gt;
</code></pre>
<p>JSP的注释，不会在客户端显示，HTML就会！</p>
<h3 id="84-jsp指令">8.4、JSP指令</h3>
<pre><code class="language-jsp">&lt;%@page args.... %&gt;
&lt;%@include file=&quot;&quot;%&gt;

&lt;%--@include会将两个页面合二为一--%&gt;

&lt;%@include file=&quot;common/header.jsp&quot;%&gt;
&lt;h1&gt;网页主体&lt;/h1&gt;

&lt;%@include file=&quot;common/footer.jsp&quot;%&gt;

&lt;hr&gt;


&lt;%--jSP标签
    jsp:include：拼接页面，本质还是三个
    --%&gt;
&lt;jsp:include page=&quot;/common/header.jsp&quot;/&gt;
&lt;h1&gt;网页主体&lt;/h1&gt;
&lt;jsp:include page=&quot;/common/footer.jsp&quot;/&gt;

</code></pre>
<h3 id="85-9大内置对象">8.5、9大内置对象</h3>
<ul>
<li>PageContext    存东西</li>
<li>Request     存东西</li>
<li>Response</li>
<li>Session      存东西</li>
<li>Application   【SerlvetContext】   存东西</li>
<li>config    【SerlvetConfig】</li>
<li>out</li>
<li>page ，不用了解</li>
<li>exception</li>
</ul>
<pre><code class="language-java">pageContext.setAttribute(&quot;name1&quot;,&quot;1号&quot;); //保存的数据只在一个页面中有效
request.setAttribute(&quot;name2&quot;,&quot;2号&quot;); //保存的数据只在一次请求中有效，请求转发会携带这个数据
session.setAttribute(&quot;name3&quot;,&quot;3号&quot;); //保存的数据只在一次会话中有效，从打开浏览器到关闭浏览器
application.setAttribute(&quot;name4&quot;,&quot;4号&quot;);  //保存的数据只在服务器中有效，从打开服务器到关闭服务器
</code></pre>
<p>request：客户端向服务器发送请求，产生的数据，用户看完就没用了，比如：新闻，用户看完没用的！</p>
<p>session：客户端向服务器发送请求，产生的数据，用户用完一会还有用，比如：购物车；</p>
<p>application：客户端向服务器发送请求，产生的数据，一个用户用完了，其他用户还可能使用，比如：聊天数据；</p>
<h3 id="86-jsp标签-jstl标签-el表达式">8.6、JSP标签、JSTL标签、EL表达式</h3>
<pre><code class="language-xml">&lt;!-- JSTL表达式的依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet.jsp.jstl&lt;/groupId&gt;
    &lt;artifactId&gt;jstl-api&lt;/artifactId&gt;
    &lt;version&gt;1.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- standard标签库 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;taglibs&lt;/groupId&gt;
    &lt;artifactId&gt;standard&lt;/artifactId&gt;
    &lt;version&gt;1.1.2&lt;/version&gt;
&lt;/dependency&gt;

</code></pre>
<p>EL表达式：  ${ }</p>
<ul>
<li><strong>获取数据</strong></li>
<li><strong>执行运算</strong></li>
<li><strong>获取web开发的常用对象</strong></li>
</ul>
<p><strong>JSP标签</strong></p>
<pre><code class="language-jsp">&lt;%--jsp:include--%&gt;

&lt;%--
http://localhost:8080/jsptag.jsp?name=kuangshen&amp;age=12
--%&gt;

&lt;jsp:forward page=&quot;/jsptag2.jsp&quot;&gt;
    &lt;jsp:param name=&quot;name&quot; value=&quot;kuangshen&quot;&gt;&lt;/jsp:param&gt;
    &lt;jsp:param name=&quot;age&quot; value=&quot;12&quot;&gt;&lt;/jsp:param&gt;
&lt;/jsp:forward&gt;
</code></pre>
<p><strong>JSTL表达式</strong></p>
<p>JSTL标签库的使用就是为了弥补HTML标签的不足；它自定义许多标签，可以供我们使用，标签的功能和Java代码一样！</p>
<p><strong>格式化标签</strong></p>
<p><strong>SQL标签</strong></p>
<p><strong>XML 标签</strong></p>
<p><strong>核心标签</strong> （掌握部分）</p>
<figure data-type="image" tabindex="65"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613013014.png" alt="" loading="lazy"></figure>
<p><strong>JSTL标签库使用步骤</strong></p>
<ul>
<li>引入对应的 taglib</li>
<li>使用其中的方法</li>
<li><strong>在Tomcat 也需要引入 jstl的包，否则会报错：JSTL解析错误</strong></li>
</ul>
<p>c：if</p>
<pre><code class="language-jsp">&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;


&lt;h4&gt;if测试&lt;/h4&gt;

&lt;hr&gt;

&lt;form action=&quot;coreif.jsp&quot; method=&quot;get&quot;&gt;
    &lt;%--
    EL表达式获取表单中的数据
    ${param.参数名}
    --%&gt;
    &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;${param.username}&quot;&gt;
    &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;
&lt;/form&gt;

&lt;%--判断如果提交的用户名是管理员，则登录成功--%&gt;
&lt;c:if test=&quot;${param.username=='admin'}&quot; var=&quot;isAdmin&quot;&gt;
    &lt;c:out value=&quot;管理员欢迎您！&quot;/&gt;
&lt;/c:if&gt;

&lt;%--自闭合标签--%&gt;
&lt;c:out value=&quot;${isAdmin}&quot;/&gt;

&lt;/body&gt;
</code></pre>
<p>c:choose   c:when</p>
<pre><code class="language-jsp">&lt;body&gt;

&lt;%--定义一个变量score，值为85--%&gt;
&lt;c:set var=&quot;score&quot; value=&quot;55&quot;/&gt;

&lt;c:choose&gt;
    &lt;c:when test=&quot;${score&gt;=90}&quot;&gt;
        你的成绩为优秀
    &lt;/c:when&gt;
    &lt;c:when test=&quot;${score&gt;=80}&quot;&gt;
        你的成绩为一般
    &lt;/c:when&gt;
    &lt;c:when test=&quot;${score&gt;=70}&quot;&gt;
        你的成绩为良好
    &lt;/c:when&gt;
    &lt;c:when test=&quot;${score&lt;=60}&quot;&gt;
        你的成绩为不及格
    &lt;/c:when&gt;
&lt;/c:choose&gt;

&lt;/body&gt;
</code></pre>
<p>c:forEach</p>
<pre><code class="language-jsp">&lt;%

    ArrayList&lt;String&gt; people = new ArrayList&lt;&gt;();
    people.add(0,&quot;张三&quot;);
    people.add(1,&quot;李四&quot;);
    people.add(2,&quot;王五&quot;);
    people.add(3,&quot;赵六&quot;);
    people.add(4,&quot;田六&quot;);
    request.setAttribute(&quot;list&quot;,people);
%&gt;


&lt;%--
var , 每一次遍历出来的变量
items, 要遍历的对象
begin,   哪里开始
end,     到哪里
step,   步长
--%&gt;
&lt;c:forEach var=&quot;people&quot; items=&quot;${list}&quot;&gt;
    &lt;c:out value=&quot;${people}&quot;/&gt; &lt;br&gt;
&lt;/c:forEach&gt;

&lt;hr&gt;

&lt;c:forEach var=&quot;people&quot; items=&quot;${list}&quot; begin=&quot;1&quot; end=&quot;3&quot; step=&quot;1&quot; &gt;
    &lt;c:out value=&quot;${people}&quot;/&gt; &lt;br&gt;
&lt;/c:forEach&gt;

</code></pre>
<h2 id="9-javabean">9、JavaBean</h2>
<p>实体类</p>
<p>JavaBean有特定的写法：</p>
<ul>
<li>必须要有一个无参构造</li>
<li>属性必须私有化</li>
<li>必须有对应的get/set方法；</li>
</ul>
<p>一般用来和数据库的字段做映射  ORM；</p>
<p>ORM ：对象关系映射</p>
<ul>
<li>表---&gt;类</li>
<li>字段--&gt;属性</li>
<li>行记录----&gt;对象</li>
</ul>
<p><strong>people表</strong></p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>age</th>
<th>address</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1号</td>
<td>3</td>
<td>西安</td>
</tr>
<tr>
<td>2</td>
<td>2号</td>
<td>18</td>
<td>西安</td>
</tr>
<tr>
<td>3</td>
<td>3号</td>
<td>100</td>
<td>西安</td>
</tr>
</tbody>
</table>
<pre><code class="language-java">class People{
    private int id;
    private String name;
    private int id;
    private String address;
}

class A{
    new People(1,&quot;1号&quot;,3，&quot;西安&quot;);
    new People(2,&quot;2号&quot;,3，&quot;西安&quot;);
    new People(3,&quot;3号&quot;,3，&quot;西安&quot;);
}
</code></pre>
<ul>
<li>过滤器</li>
<li>文件上传</li>
<li>邮件发送</li>
<li>JDBC 复习 ： 如何使用JDBC ,  JDBC crud， jdbc 事务</li>
</ul>
<h2 id="10-mvc三层架构">10、MVC三层架构</h2>
<p>什么是MVC：  Model     view     Controller  模型、视图、控制器</p>
<h3 id="101-早些年">10.1、早些年</h3>
<figure data-type="image" tabindex="66"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613013052.png" alt="" loading="lazy"></figure>
<p>用户直接访问控制层，控制层就可以直接操作数据库；</p>
<pre><code class="language-java">servlet--CRUD--&gt;数据库
弊端：程序十分臃肿，不利于维护  
servlet的代码中：处理请求、响应、视图跳转、处理JDBC、处理业务代码、处理逻辑代码

架构：没有什么是加一层解决不了的！
程序猿调用
|
JDBC
|
Mysql Oracle SqlServer ....
</code></pre>
<h3 id="102-mvc三层架构">10.2、MVC三层架构</h3>
<figure data-type="image" tabindex="67"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613013122.png" alt="" loading="lazy"></figure>
<p>Model</p>
<ul>
<li>业务处理 ：业务逻辑（Service）</li>
<li>数据持久层：CRUD   （Dao）</li>
</ul>
<p>View</p>
<ul>
<li>展示数据</li>
<li>提供链接发起Servlet请求 （a，form，img…）</li>
</ul>
<p>Controller  （Servlet）</p>
<ul>
<li>
<p>接收用户的请求 ：（req：请求参数、Session信息….）</p>
</li>
<li>
<p>交给业务层处理对应的代码</p>
</li>
<li>
<p>控制视图的跳转</p>
<pre><code class="language-java">登录---&gt;接收用户的登录请求---&gt;处理用户的请求（获取用户登录的参数，username，password）----&gt;交给业务层处理登录业务（判断用户名密码是否正确：事务）---&gt;Dao层查询用户名和密码是否正确--&gt;数据库
</code></pre>
</li>
</ul>
<h2 id="11-filter-重点">11、Filter （重点）</h2>
<p>Filter：过滤器 ，用来过滤网站的数据；</p>
<ul>
<li>处理中文乱码</li>
<li>登录验证….</li>
</ul>
<figure data-type="image" tabindex="68"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613013144.png" alt="" loading="lazy"></figure>
<p>Filter开发步骤：</p>
<ol>
<li>
<p>导包</p>
</li>
<li>
<p>编写过滤器</p>
<ol>
<li>
<p>导包不要错</p>
<figure data-type="image" tabindex="69"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613013158.png" alt="" loading="lazy"></figure>
<p>实现Filter接口，重写对应的方法即可</p>
<pre><code class="language-java">public class CharacterEncodingFilter implements Filter {

    //初始化：web服务器启动，就以及初始化了，随时等待过滤对象出现！
    public void init(FilterConfig filterConfig) throws ServletException {
        System.out.println(&quot;CharacterEncodingFilter初始化&quot;);
    }

    //Chain : 链
    /*
    1. 过滤中的所有代码，在过滤特定请求的时候都会执行
    2. 必须要让过滤器继续同行
        chain.doFilter(request,response);
     */
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        request.setCharacterEncoding(&quot;utf-8&quot;);
        response.setCharacterEncoding(&quot;utf-8&quot;);
        response.setContentType(&quot;text/html;charset=UTF-8&quot;);

        System.out.println(&quot;CharacterEncodingFilter执行前....&quot;);
        chain.doFilter(request,response); //让我们的请求继续走，如果不写，程序到这里就被拦截停止！
        System.out.println(&quot;CharacterEncodingFilter执行后....&quot;);
    }

    //销毁：web服务器关闭的时候，过滤会销毁
    public void destroy() {
        System.out.println(&quot;CharacterEncodingFilter销毁&quot;);
    }
}

</code></pre>
</li>
</ol>
</li>
<li>
<p>在web.xml中配置 Filter</p>
<pre><code class="language-xml">&lt;filter&gt;
    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;com.cy.filter.CharacterEncodingFilter&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
    &lt;!--只要是 /servlet的任何请求，会经过这个过滤器--&gt;
    &lt;url-pattern&gt;/servlet/*&lt;/url-pattern&gt;
    &lt;!--&lt;url-pattern&gt;/*&lt;/url-pattern&gt;--&gt;
&lt;/filter-mapping&gt;
</code></pre>
</li>
</ol>
<h2 id="12-监听器">12、监听器</h2>
<p>实现一个监听器的接口；（有N种）</p>
<ol>
<li>
<p>编写一个监听器</p>
<p>实现监听器的接口…</p>
<pre><code class="language-java">//统计网站在线人数 ： 统计session
public class OnlineCountListener implements HttpSessionListener {

    //创建session监听： 看你的一举一动
    //一旦创建Session就会触发一次这个事件！
    public void sessionCreated(HttpSessionEvent se) {
        ServletContext ctx = se.getSession().getServletContext();

        System.out.println(se.getSession().getId());

        Integer onlineCount = (Integer) ctx.getAttribute(&quot;OnlineCount&quot;);

        if (onlineCount==null){
            onlineCount = new Integer(1);
        }else {
            int count = onlineCount.intValue();
            onlineCount = new Integer(count+1);
        }

        ctx.setAttribute(&quot;OnlineCount&quot;,onlineCount);

    }

    //销毁session监听
    //一旦销毁Session就会触发一次这个事件！
    public void sessionDestroyed(HttpSessionEvent se) {
        ServletContext ctx = se.getSession().getServletContext();

        Integer onlineCount = (Integer) ctx.getAttribute(&quot;OnlineCount&quot;);

        if (onlineCount==null){
            onlineCount = new Integer(0);
        }else {
            int count = onlineCount.intValue();
            onlineCount = new Integer(count-1);
        }

        ctx.setAttribute(&quot;OnlineCount&quot;,onlineCount);

    }


    /*
    Session销毁：
    1. 手动销毁  getSession().invalidate();
    2. 自动销毁
     */
}

</code></pre>
</li>
<li>
<p>web.xml中注册监听器</p>
<pre><code class="language-xml">&lt;!--注册监听器--&gt;
&lt;listener&gt;
    &lt;listener-class&gt;com.kuang.listener.OnlineCountListener&lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre>
</li>
<li>
<p>看情况是否使用！</p>
</li>
</ol>
<h2 id="13-过滤器-监听器常见应用">13、过滤器、监听器常见应用</h2>
<p><strong>监听器：GUI编程中经常使用；</strong></p>
<pre><code class="language-java">public class TestPanel {
    public static void main(String[] args) {
        Frame frame = new Frame(&quot;中秋节快乐&quot;);  //新建一个窗体
        Panel panel = new Panel(null); //面板
        frame.setLayout(null); //设置窗体的布局

        frame.setBounds(300,300,500,500);
        frame.setBackground(new Color(0,0,255)); //设置背景颜色

        panel.setBounds(50,50,300,300);
        panel.setBackground(new Color(0,255,0)); //设置背景颜色

        frame.add(panel);

        frame.setVisible(true);

        //监听事件，监听关闭事件
        frame.addWindowListener(new WindowAdapter() {
            @Override
            public void windowClosing(WindowEvent e) {
                super.windowClosing(e);
            }
        });


    }
}
</code></pre>
<p>用户登录之后才能进入主页！用户注销后就不能进入主页了！</p>
<ol>
<li>
<p>用户登录之后，向Sesison中放入用户的数据</p>
</li>
<li>
<p>进入主页的时候要判断用户是否已经登录；要求：在过滤器中实现！</p>
<pre><code class="language-java">HttpServletRequest request = (HttpServletRequest) req;
HttpServletResponse response = (HttpServletResponse) resp;

if (request.getSession().getAttribute(Constant.USER_SESSION)==null){
    response.sendRedirect(&quot;/error.jsp&quot;);
}

chain.doFilter(request,response);
</code></pre>
</li>
</ol>
<h2 id="14-jdbc">14、JDBC</h2>
<p>什么是JDBC ： Java连接数据库！</p>
<figure data-type="image" tabindex="70"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613013240.png" alt="" loading="lazy"></figure>
<p>需要jar包的支持：</p>
<ul>
<li>java.sql</li>
<li>javax.sql</li>
<li>mysql-conneter-java…  连接驱动（必须要导入）</li>
</ul>
<p><strong>实验环境搭建</strong></p>
<pre><code class="language-sql">
CREATE TABLE users(
    id INT PRIMARY KEY,
    `name` VARCHAR(40),
    `password` VARCHAR(40),
    email VARCHAR(60),
    birthday DATE
);

INSERT INTO users(id,`name`,`password`,email,birthday)
VALUES(1,'张三','123456','zs@qq.com','2000-01-01');
INSERT INTO users(id,`name`,`password`,email,birthday)
VALUES(2,'李四','123456','ls@qq.com','2000-01-01');
INSERT INTO users(id,`name`,`password`,email,birthday)
VALUES(3,'王五','123456','ww@qq.com','2000-01-01');


SELECT	* FROM users;

</code></pre>
<p>导入数据库依赖</p>
<pre><code class="language-xml">&lt;!--mysql的驱动--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;version&gt;5.1.47&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>IDEA中连接数据库：</p>
<figure data-type="image" tabindex="71"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613013255.png" alt="" loading="lazy"></figure>
<p><strong>JDBC 固定步骤：</strong></p>
<ol>
<li>加载驱动</li>
<li>连接数据库,代表数据库</li>
<li>向数据库发送SQL的对象Statement : CRUD</li>
<li>编写SQL （根据业务，不同的SQL）</li>
<li>执行SQL</li>
<li>关闭连接</li>
</ol>
<pre><code class="language-java">public class TestJdbc {
    public static void main(String[] args) throws ClassNotFoundException, SQLException {
        //配置信息
        //useUnicode=true&amp;characterEncoding=utf-8 解决中文乱码
        String url=&quot;jdbc:mysql://localhost:3306/jdbc?useUnicode=true&amp;characterEncoding=utf-8&quot;;
        String username = &quot;root&quot;;
        String password = &quot;123456&quot;;

        //1.加载驱动
        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
        //2.连接数据库,代表数据库
        Connection connection = DriverManager.getConnection(url, username, password);

        //3.向数据库发送SQL的对象Statement,PreparedStatement : CRUD
        Statement statement = connection.createStatement();

        //4.编写SQL
        String sql = &quot;select * from users&quot;;

        //5.执行查询SQL，返回一个 ResultSet  ： 结果集
        ResultSet rs = statement.executeQuery(sql);

        while (rs.next()){
            System.out.println(&quot;id=&quot;+rs.getObject(&quot;id&quot;));
            System.out.println(&quot;name=&quot;+rs.getObject(&quot;name&quot;));
            System.out.println(&quot;password=&quot;+rs.getObject(&quot;password&quot;));
            System.out.println(&quot;email=&quot;+rs.getObject(&quot;email&quot;));
            System.out.println(&quot;birthday=&quot;+rs.getObject(&quot;birthday&quot;));
        }

        //6.关闭连接，释放资源（一定要做） 先开后关
        rs.close();
        statement.close();
        connection.close();
    }
}

</code></pre>
<p><strong>预编译SQL</strong></p>
<pre><code class="language-java">public class TestJDBC2 {
    public static void main(String[] args) throws Exception {
        //配置信息
        //useUnicode=true&amp;characterEncoding=utf-8 解决中文乱码
        String url=&quot;jdbc:mysql://localhost:3306/jdbc?useUnicode=true&amp;characterEncoding=utf-8&quot;;
        String username = &quot;root&quot;;
        String password = &quot;123456&quot;;

        //1.加载驱动
        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
        //2.连接数据库,代表数据库
        Connection connection = DriverManager.getConnection(url, username, password);

        //3.编写SQL
        String sql = &quot;insert into  users(id, name, password, email, birthday) values (?,?,?,?,?);&quot;;

        //4.预编译
        PreparedStatement preparedStatement = connection.prepareStatement(sql);

        preparedStatement.setInt(1,2);//给第一个占位符？ 的值赋值为1；
        preparedStatement.setString(2,&quot;Java&quot;);//给第二个占位符？ 的值赋值为狂神说Java；
        preparedStatement.setString(3,&quot;123456&quot;);//给第三个占位符？ 的值赋值为123456；
        preparedStatement.setString(4,&quot;24736743@qq.com&quot;);//给第四个占位符？ 的值赋值为1；
        preparedStatement.setDate(5,new Date(new java.util.Date().getTime()));//给第五个占位符？ 的值赋值为new Date(new java.util.Date().getTime())；

        //5.执行SQL
        int i = preparedStatement.executeUpdate();

        if (i&gt;0){
            System.out.println(&quot;插入成功@&quot;);
        }

        //6.关闭连接，释放资源（一定要做） 先开后关
        preparedStatement.close();
        connection.close();
    }
}

</code></pre>
<p><strong>事务</strong></p>
<p>要么都成功，要么都失败！</p>
<p>ACID原则：保证数据的安全。</p>
<pre><code class="language-java">开启事务
事务提交  commit()
事务回滚  rollback()
关闭事务

转账：
A:1000
B:1000
    
A(900)   --100--&gt;   B(1100) 
</code></pre>
<p><strong>Junit单元测试</strong></p>
<p>依赖</p>
<pre><code class="language-xml">&lt;!--单元测试--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;junit&lt;/groupId&gt;
    &lt;artifactId&gt;junit&lt;/artifactId&gt;
    &lt;version&gt;4.12&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>简单使用</p>
<p>@Test注解只有在方法上有效，只要加了这个注解的方法，就可以直接运行！</p>
<pre><code class="language-java">@Test
public void test(){
    System.out.println(&quot;Hello&quot;);
}
</code></pre>
<figure data-type="image" tabindex="72"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613013348.png" alt="" loading="lazy"></figure>
<p>失败的时候是红色：</p>
<figure data-type="image" tabindex="73"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613013404.png" alt="" loading="lazy"></figure>
<p><strong>搭建一个环境</strong></p>
<pre><code class="language-sql">CREATE TABLE account(
   id INT PRIMARY KEY AUTO_INCREMENT,
   `name` VARCHAR(40),
   money FLOAT
);

INSERT INTO account(`name`,money) VALUES('A',1000);
INSERT INTO account(`name`,money) VALUES('B',1000);
INSERT INTO account(`name`,money) VALUES('C',1000);
</code></pre>
<pre><code class="language-java">    @Test
    public void test() {
        //配置信息
        //useUnicode=true&amp;characterEncoding=utf-8 解决中文乱码
        String url=&quot;jdbc:mysql://localhost:3306/jdbc?useUnicode=true&amp;characterEncoding=utf-8&quot;;
        String username = &quot;root&quot;;
        String password = &quot;123456&quot;;

        Connection connection = null;

        //1.加载驱动
        try {
            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
            //2.连接数据库,代表数据库
             connection = DriverManager.getConnection(url, username, password);

            //3.通知数据库开启事务,false 开启
            connection.setAutoCommit(false);

            String sql = &quot;update account set money = money-100 where name = 'A'&quot;;
            connection.prepareStatement(sql).executeUpdate();

            //制造错误
            //int i = 1/0;

            String sql2 = &quot;update account set money = money+100 where name = 'B'&quot;;
            connection.prepareStatement(sql2).executeUpdate();

            connection.commit();//以上两条SQL都执行成功了，就提交事务！
            System.out.println(&quot;success&quot;);
        } catch (Exception e) {
            try {
                //如果出现异常，就通知数据库回滚事务
                connection.rollback();
            } catch (SQLException e1) {
                e1.printStackTrace();
            }
            e.printStackTrace();
        }finally {
            try {
                connection.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Intellij IDEA常用快捷键]]></title>
        <id>https://jonchan1013.github.io/post/intellij-idea-chang-yong-kuai-jie-jian/</id>
        <link href="https://jonchan1013.github.io/post/intellij-idea-chang-yong-kuai-jie-jian/">
        </link>
        <updated>2019-01-03T07:17:39.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="️最常用快捷键">✍️最常用快捷键</h3>
<ol>
<li>Alt+回车 导入包,自动修正</li>
<li>Ctrl+N  查找类</li>
</ol>
]]></summary>
        <content type="html"><![CDATA[<h3 id="️最常用快捷键">✍️最常用快捷键</h3>
<ol>
<li>Alt+回车 导入包,自动修正</li>
<li>Ctrl+N  查找类<!-- more -->
</li>
<li>Ctrl+Shift+N 查找文件</li>
<li>Ctrl+Alt+L  格式化代码</li>
<li>Ctrl+Alt+O 优化导入的类和包</li>
<li>Alt+Insert 生成代码(如get,set方法,构造函数等)</li>
<li>Ctrl+E或者Alt+Shift+C  最近更改的代码</li>
<li>Ctrl+R 替换文本</li>
<li>Ctrl+F 查找文本</li>
<li>Ctrl+Shift+Space 自动补全代码</li>
<li>Ctrl+空格 代码提示</li>
<li>Ctrl+Alt+Space 类名或接口名提示</li>
<li>Ctrl+P 方法参数提示</li>
<li>Ctrl+Shift+Alt+N 查找类中的方法或变量</li>
<li>Alt+Shift+C 对比最近修改的代码</li>
<li>Shift+F6  重构-重命名</li>
<li>Ctrl+Shift+先上键</li>
<li>Ctrl+X 删除行</li>
<li>Ctrl+D 复制行</li>
<li>Ctrl+/ 或 Ctrl+Shift+/  注释（// 或者/<em>...</em>/ ）</li>
<li>Ctrl+J  自动代码</li>
<li>Ctrl+E 最近打开的文件</li>
<li>Ctrl+H 显示类结构图</li>
<li>Ctrl+Q 显示注释文档</li>
<li>Alt+F1 查找代码所在位置</li>
<li>Alt+1 快速打开或隐藏工程面板</li>
<li>Ctrl+Alt+ left/right 返回至上次浏览的位置</li>
<li>Alt+ left/right 切换代码视图</li>
<li>Alt+ Up/Down 在方法间快速移动定位</li>
<li>Ctrl+Shift+Up/Down 代码向上/下移动。</li>
<li>F2 或Shift+F2 高亮错误或警告快速定位</li>
<li>代码标签输入完成后，按Tab，生成代码。</li>
<li>选中文本，按Ctrl+Shift+F7 ，高亮显示所有该文本，按Esc高亮消失。</li>
<li>Ctrl+W 选中代码，连续按会有其他效果</li>
<li>选中文本，按Alt+F3 ，逐个往下查找相同文本，并高亮显示。</li>
<li>Ctrl+Up/Down 光标跳转到第一行或最后一行下</li>
<li>Ctrl+B 快速打开光标处的类或方法</li>
<li>Ctrl＋E，可以显示最近编辑的文件列表</li>
<li>Shift＋Click可以关闭文件</li>
<li>Ctrl＋[或]可以跳到大括号的开头结尾</li>
<li>Ctrl＋Shift＋Backspace可以跳转到上次编辑的地方</li>
<li>Ctrl＋F12，可以显示当前文件的结构</li>
<li>Ctrl＋F7可以查询当前元素在当前文件中的引用，然后按F3可以选择</li>
<li>Ctrl＋Shift＋N，可以快速打开文件</li>
<li>Alt＋Q可以看到当前方法的声明</li>
<li>Ctrl＋W可以选择单词继而语句继而行继而函数</li>
<li>Alt＋F1可以将正在编辑的元素在各个面板中定位</li>
<li>Ctrl＋Shift＋Insert可以选择剪贴板内容并插入</li>
<li>Alt＋Insert可以生成构造器/Getter/Setter等</li>
<li>Ctrl＋Alt＋V 可以引入变量。例如把括号内的SQL赋成一个变量</li>
<li>Ctrl＋Alt＋T可以把代码包在一块内，例如try/catch</li>
<li>Alt＋Up and Alt＋Down可在方法间快速移动</li>
</ol>
<p>👨‍💻👨‍💻👨‍💻👨‍💻👨‍💻</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础总结-数组]]></title>
        <id>https://jonchan1013.github.io/post/java-ji-chu-zong-jie-shu-zu/</id>
        <link href="https://jonchan1013.github.io/post/java-ji-chu-zong-jie-shu-zu/">
        </link>
        <updated>2018-06-10T19:33:06.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="1-数组的基本概念">1、 数组的基本概念</h2>
<ul>
<li>数组可以看成是多个相同类型数据组合，对这些数据的统一管理。</li>
<li>数组变量属引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量。</li>
<li>数组的元素可以是任何数据类型，包括基本类型和引用类型。</li>
<li>C和C++中的数组都可以分配在栈上面，而JAVA中的数组是只能分配在堆上面的，因为JAVA中的数组是引用类型。</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h2 id="1-数组的基本概念">1、 数组的基本概念</h2>
<ul>
<li>数组可以看成是多个相同类型数据组合，对这些数据的统一管理。</li>
<li>数组变量属引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量。</li>
<li>数组的元素可以是任何数据类型，包括基本类型和引用类型。</li>
<li>C和C++中的数组都可以分配在栈上面，而JAVA中的数组是只能分配在堆上面的，因为JAVA中的数组是引用类型。</li>
</ul>
<!-- more -->
<h2 id="2-一维数组">2、一维数组</h2>
<p>一维数组的声明方式有2种：</p>
<ul>
<li>格式一：数组元素类型 数组名[ ]; 即type var[ ];</li>
<li>格式二：数组元素类型[ ] 数组名; 即type[ ] var;</li>
<li>格式二声明数组的方法与C#上声明一维数组的方法一样。</li>
</ul>
<p>例如：</p>
<pre><code class="language-java">int a1[ ];  
int[ ] a2;
double b[ ];
person[ ] p1;
String s1[ ];
</code></pre>
<p><strong>注意：JAVA语言中声明数组时不能指定其长度(数组中的元素个数)</strong></p>
<p>​    如：int a[5]; 这样声明一维数组是非法的。</p>
<h2 id="3-数组的模型">3、数组的模型</h2>
<ul>
<li>一维数组：一维数组就是一行，一行小格。</li>
<li>二维数组：二维数组就是一行加一列组成的一个平面分成的小格，有行有列。</li>
<li>三维数组：三维数组就是一个立方体。</li>
<li>人类对最多认识到三维空间。</li>
</ul>
<h2 id="4-数组对象的创建">4、数组对象的创建</h2>
<p>JAVA中使用关键字<strong>new</strong>创建数组对象。</p>
<p>格式为：数组名 = <strong>new</strong> 数组元素的类型[数组元素的个数]</p>
<p>例如：<img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200614033838.png" alt="" loading="lazy"></p>
<h2 id="5-元素为引用数据类型的数组">5、元素为引用数据类型的数组</h2>
<p><em><strong>注意：元素为引用数据类型的数组中的每一个元素都需要实例化。</strong></em></p>
<p>例如：</p>
<pre><code class="language-java">class Date{
      int year; int moth; int day;
      Date(int y; int m, int d){
      　　year=y ;
　　　　  month=m ;
　　　　  day=d ;
　　}
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200614034019.png" alt="" loading="lazy"></figure>
<h2 id="6-数组的初始化">6、数组的初始化</h2>
<h3 id="61-动态初始化">6.1 动态初始化</h3>
<p><em><strong>数组定义与为数组元素分配空间和赋值的操作分开进行</strong>。</em></p>
<p>例如：</p>
<pre><code class="language-java">public class Test{
    public static void main(String args[ ]){
    int a[ ];  //定义数组，即声明一个int类型的数组a[ ]
    a=new int[3];  //给数组元素分配内存空间。
    a[0]=3; a[1]=9; a[2]=8;  //给数组元素赋值。
    Date days[ ];
    days=new Date[3];
    days[0]=new Date(1, 4, 2004);
    days[1]=new Date(2, 4, 2004);
    days[2]=new Date(3, 4, 2004);
    }
}

class Date{
    int year, month, day;
    Date(int y, int m, int d){
        year = y ;
        month = m ;
        day = d ;
    }
}
</code></pre>
<h3 id="62-静态初始化">6.2 静态初始化</h3>
<p><em><strong>在定义数组的同时就为数组元素分配空间并赋值。</strong></em></p>
<p>例如：</p>
<pre><code class="language-java">puclic class Test{
        public static void main(String args[ ]){
            int a[ ] = { 3, 9, 8};   //在定义数组的同时给数组分配空间并赋值。
            Date days[ ] = {
                new Date(1, 4, 2004),
                new Date(2 ,4 ,2004),
                new Date(3 ,4, 2004)
        };
    }
}
class Date{
    int year, month, day;
    Date(int y, int m, int d){
        year = y ;
        month = m ;
        day = d ;
    }
}
</code></pre>
<h2 id="7-数组元素的默认初始化">7、数组元素的默认初始化</h2>
<p>​		数组是引用类型，它的元素相当于类的成员变量，因此给数组分配内存空间后，每个元素也被按照成员变量的规则被隐式初始化。</p>
<pre><code class="language-java">public class Test{
        public static void main(String args[ ]){
            int a[ ] = new int[5];
            Date[ ] days=new Date[3];
            System.out.println(a[3]);
            System.out.println(days[2]);
    }
}
class Date{
    int year, month, day;
    Date(int y, int m, int d){
        year = y ;
        month = m ;
        day = d ;
    }
}
</code></pre>
<p>输出结果：</p>
<p>System.out.println(a[3]);  打印出来的结果是：0。</p>
<p>System.out.println(days[2]); 打印出来的结果是：null(空)</p>
<h2 id="8-数组元素的引用">8、数组元素的引用</h2>
<p>​		定义并用运算符new为之分配内存空间后，才可以引用数组中的每个元素，数组元素的引用方式为：<strong>arrayName[index]，</strong> index为数组元素下标，可以是整型常量或整型表达式。如：<strong>a[3], b[i], c[6*i]。</strong></p>
<p>数组元素下标从0开始；长度为n的数组的合法下标取值范围为<strong>0～n—1。</strong></p>
<p>​    	每个数组都有一个属性length指明它的长度，例如：<strong>a.<strong><strong>length</strong></strong>的值为数组<strong><strong>a</strong></strong>的长度</strong>**(<strong><strong>元素个数</strong></strong>)****。**</p>
<h2 id="9-二维数组">9、二维数组</h2>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200614034607.png" alt="" loading="lazy"></figure>
<p>二维数组初始化：<img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200614034640.png" alt="" loading="lazy"></p>
<h2 id="10-理解java中的各个维度的数组模型">10、理解JAVA中的各个维度的数组模型</h2>
<figure data-type="image" tabindex="3"><img src="C:%5CUsers%5CCY%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200614034726096.png" alt="image-20200614034726096" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础总结-面向对象]]></title>
        <id>https://jonchan1013.github.io/post/java-ji-chu-mian-xiang-dui-xiang/</id>
        <link href="https://jonchan1013.github.io/post/java-ji-chu-mian-xiang-dui-xiang/">
        </link>
        <updated>2018-06-10T07:42:29.000Z</updated>
        <summary type="html"><![CDATA[<p>✍️面向对象的基本思想是，从现实世界中客观存在的事物出发来构造软件系统，并在系统的构造中尽可能运用人类的自然思维方式。<br>
面向对象更加强调运用人类在日常生活的逻辑思维中经常采用的思想方法与原则，如抽象、分类，继承、聚合、多态等。</p>
]]></summary>
        <content type="html"><![CDATA[<p>✍️面向对象的基本思想是，从现实世界中客观存在的事物出发来构造软件系统，并在系统的构造中尽可能运用人类的自然思维方式。<br>
面向对象更加强调运用人类在日常生活的逻辑思维中经常采用的思想方法与原则，如抽象、分类，继承、聚合、多态等。</p>
<!-- more -->
<h2 id="1-面向对象一">1、面向对象（一）</h2>
<h3 id="11-面向过程的思想和面向对象的思想">1.1 面向过程的思想和面向对象的思想</h3>
<p>​		面向对象和面向过程的思想有着本质上的区别, <strong>作为面向对象的思维来说，当你拿到一个问题时，你分析这个问题不再是第一步先做什么，第二步再做什么，这是面向过程的思维，你应该分析这个问题里面有哪些类和对象，这是第一点，然后再分析这些类和对象应该具有哪些属性和方法。这是第二点。最后分析类和类之间具体有什么关系，这是第三点。</strong></p>
<p>​		<strong>面向对象有一个非常重要的设计思维：合适的方法应该出现在合适的类里面。</strong></p>
<h3 id="12-简单理解面向对象">1.2 简单理解面向对象</h3>
<p>​		就是在程序里面首先分解出来的应该是注意不再是一步一步的过程了，而是首先考虑在这个问题域里面或者程序里面应该具有有哪些对象，所以从现在开始考虑任何问题脑子里不要再想着我实现这件事我第一步应该干什么，第二步应该干什么，如果这样想，那就是面向过程的思维了。面向对象的思维是，当我碰到这个问题域的时候，碰到这个程序的时候，我首先应该把这个问题里有哪些对象，对象与对象之间有什么关系抽象出来。</p>
<h3 id="13-面向对象的设计思想">1.3 面向对象的设计思想</h3>
<ul>
<li>面向对象的基本思想是，从现实世界中客观存在的事物出发来构造软件系统，并在系统的构造中尽可能运用人类的自然思维方式。</li>
<li>面向对象更加强调运用人类在日常生活的逻辑思维中经常采用的思想方法与原则，如抽象、分类，继承、聚合、多态等。</li>
<li>人在思考的时候，首先眼睛里看到的是一个一个的对象。</li>
</ul>
<h3 id="14-对象和类的概念">1.4  对象和类的概念</h3>
<p>​		对象是用于计算机语言对问题域中事物的描述，<strong>对象通过“属性（attribute）”和“方法（method）”来分别对应事物所具有的静态属性和动态属性</strong>。</p>
<p>​		<strong>类是用于描述同一类的对象的一个抽象的概念，类中定义了这一类对象所具有的静态属性和动态属性</strong></p>
<p>​		<strong>类可以看成一类对象的模板，对象可以看成该类的一个具体实例</strong>。</p>
<p>​		<strong>eg.什么叫瓶子？</strong></p>
<p>​		瓶子的定义：具有某些类特征的东西就是瓶子，比分说什么样的形状，比方说有个口，能倒水，能装水，一般有个盖等等。给瓶子下定义的过程，其实就是把瓶子里的某些东西抽象出来了，所以瓶子在这里是叫做一类事物的一个抽象，在你脑子里有瓶子的概念，可瓶子的概念在你脑子里到底是什么呢？瓶子的概念在你脑子里叫做一类事物的一个抽象。怎么抽象的呢？你往往抽象的是这两个方面：第一个方面我们叫它静态的属性，瓶子应该具有哪些特征，比分说瓶子应有个口，这是它的具有的一个静态属性，瓶子一般有一个盖，这也是它的具有一个静态属性，除此之外，你还可能给它总结动态的属性，什么动态的属性呢？比放说瓶子能倒水，这是它的动态属性。瓶子这个概念在你脑子里如果你细细的思维的话，其实你给它做了两方面的总结，一方面是静态的，一方面是动态的。反映到JAVA的类上，一个就是成员变量（静态属性），一个就是方法（动态属性）方法是可以执行的，可以动的。成员变量是某一个类的静态属性。所以你脑子里瓶子的概念实际上是一类事物的一个抽象，这种东西我们叫它类，椅子是类，桌子是类，学生是类。什么是对象呢？这一类事物的具体的某个实例就叫做对象。所以<strong>一类事物的具体的某一个东西，符合这类事物具体的特征的某个东西就叫做对象</strong>。瓶子是一个类，某个瓶子就是瓶子这个类里面的一个对象。</p>
<h3 id="15-如何抽象出一个类">1.5 如何抽象出一个类？</h3>
<p>​		有两个方面，一方面是它的静态属性，另一方面是它的动态属性。反映到JAVA里面的类怎么包装它呢？一方面成员变量，另一方面是方法。</p>
<p>​		eg.职员这个类该怎么抽象出来？也是从两个方面，一方面是它的静态属性，另一方面它的动态属性</p>
<p>​		职员有哪些属性呢？有姓名，年龄，目前工资数额等属性，他有哪些方法呢？让这个职员来显示姓名，显示年龄，修改姓名，领取工资。当然显示姓名，显示年龄，修改姓名，领取工资这些也可以让别人来做，但<strong>面向对象的设计思维是最合适的方法应该出现在最合适的类里面</strong>。显示姓名，显示年龄，修改姓名，领取工资由谁来做更合适呢，那就是职员自己最合适。所以这些方法应该出现在职员这个类里面。</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610155239.png" alt="" loading="lazy"></figure>
<p>​		对于类来说，它有一些属性或者称为成员变量，以后说属性或者成员变量指的是同一回事。具体的对象他有没有相关的一些属性或者叫成员变量呢？有，每一个人都有一份，只不过是取值不同而已。如从职员这个类实例化出来的两个职员：职员A和职员B，他们都有姓名，年龄，目前工资数额这些属性，但他们的名字，年龄，领取的工资数额都不一样。这样就能把职员A和职员B区分开来了，正是因为他们的属性值不一样，所以这个对象才能和另外的对象区分开来，<strong>所以通过属性是可以区分两个对象的</strong>。猫是一个类，这只猫是一个对象，这只猫和另外一只猫该怎么区分开来呢？那就得看你的猫这个类是怎么定义的了，猫有猫毛，毛有颜色。OK，这只猫是黑猫，另一只猫是白猫，这样通过猫毛的颜色区分开来了。如果只定义一个，如捉老鼠，白猫也能捉，黑猫也能捉，这样就没办法区分出黑猫和白猫了，所以<strong>根据方法是没办法区分两个对象的</strong>。所以<strong>每个对象都有自己的属性，属性值和另外一个对象一般是不一样的</strong>。</p>
<p>​		一定要区分类和对象，什么叫做类？什么叫做对象？类是一类事物的一个抽象，具有共同特征的一类事物的一个抽象。对象是这个类具体的某一个实例，所以以后说实例（instance）或者说对象（object）指的是同一回事。</p>
<h3 id="16-类对象之间的关系">1.6 类（对象）之间的关系</h3>
<h4 id="161-关联关系最弱的一种关系">1.6.1 关联关系(最弱的一种关系)</h4>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610155402.png" alt="" loading="lazy"></figure>
<p>​		类和类之间是有关系的，如学生和老师这两个类，老师可以教学生，学生可以向老师学习。这就是他们之间的关系。关系和关系之间是不同的，你和你老婆的关系和你和你其他女朋友的关系是不能混为一谈的。关系最弱的一种关系叫关联关系。关联关系反应到代码上往往是一个类的方法里面的参数是另一个类的具体的某一个对象，比如教授教研究生，教哪个研究生，教是教授这个类里面的一个方法，某个研究生是研究生这个类里面的一个具体的对象。<strong>关联关系是最弱的一种关系</strong>，咱们两个类之间有关系，或者两个对象之间有关系，但关系不是很紧密。</p>
<h4 id="162-继承关系比较强的一种关系">1.6.2 继承关系（比较强的一种关系）</h4>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610155535.png" alt="" loading="lazy"></figure>
<p>​		<strong>继承关系封装了这样一种逻辑：“XX是一种XX”，只要这东西能说通了，就可以考虑用继承关系来封装它</strong>。如：游泳运动员从运动员继承，游泳运动员是一种运动员，这能说得通，所以游泳运动员就是从运动员继承过来的，游泳运动员和运动员就是一种继承关系。学生是一个人，学生从人继承，老师是一个人，老师也从人继承，学生是一种老师，这说不通，所以学生和老师就不存在继承关系。所以将来做设计的时候要分清继承关系很简单，你只要说通这么一句话：“XX是一种XX”。OK，那他们之间就是继承关系。篮球运动员是一种球类运动员，这说得通，所以篮球运动员从球类运动员继承，这样继承很有可能会产生一棵继承树，运动员派生出来，派生出来的意思是游泳运动员这个类、球类运动员这个类、射击运动员类从它继承，相当于运动员派生出来了这些个不同的运动员，包括游泳的，球类的，射击的。球类的再派生足球的，篮球的，排球的。这就是一棵继承树，不过这棵树是比较理想化的情况，只有一个根节点。但实际当中，我们真实世界当中的继承关系不一定只从一个类继承，一个类可能从多个类继承过来，比如说：金丝猴从动物这个类继承，这很正常，但我还有另外一个专门的类：“应该受到保护的东西”，这也是一个类，金丝猴应该受到保护，所以金丝猴是一种应该受到保护的东西。所以金丝猴从“应该受到保护的东西”这个类继承过来。所以在现实情况当中，一个类完完全全有可能从多个不同的类继承，C++正是因为想封装这种继承关系，所以C++存在多重继承。</p>
<h4 id="163-聚合关系整体和部分比较强的一种关系">1.6.3 聚合关系（整体和部分）（比较强的一种关系）</h4>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610155626.png" alt="" loading="lazy"></figure>
<p>​		什么是聚合？<strong>聚合就是一个整体与部分的关系</strong>。我们说**“XX是XX的一部分”，只要说得通，那么他们之间的关系就是聚合关系**，队长是球队的一部分，队员是球队的一部分。所以队长和球队是聚合关系，队员和球队也是聚合关系。脑袋是人的以部分，身体和胳膊也是人的一部分，因此脑袋，身体和胳膊与人都是聚合关系。<strong>聚合关系分得再细一点的话就可以分成聚集关系和组合关系</strong>，比如球队、队长，队员，这三者是聚集关系，假如这个队长既是足球的队长，同时也是篮球的队长，一个人分属两个不同的球队，这是可以的，球队与队长之间没有我离不了你，你离不了我这种情况，所以如果分得更细的话，这种就叫做聚集关系。还有一种情况叫组合，组合说的是咱们俩密不可分，我是你必不可少的一部分。一个人的脑袋不可能既属于你又属于别人，身体也一样，不可能既属于你又属于别人。所以你的身体，脑袋和你是密不可分的，这是一种更加严格的聚合关系，专门给它取了个名字叫组合。</p>
<h4 id="164-实现关系">1.6.4 实现关系</h4>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610155715.png" alt="" loading="lazy"></figure>
<p>​		**作为父类来说，我觉得我应该具有这样一个方法，但我不知道怎么去实现，谁去实现，我的子类去实现，这就是实现关系。**和实现关系息息相关的还有一种关系叫多态。</p>
<h4 id="165-多态">1.6.5 多态</h4>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610155757.png" alt="" loading="lazy"></figure>
<h3 id="17-java与面向对象">1.7 Java与面向对象</h3>
<pre><code>	对象和类是分不开的，必须首先定义类才能有对象。首先定义方法才能调用。对象是JAVA里面的核心，做任何东西你首先都得给我造出一个对象才能做。静态属性简称属性，也叫成员变量，以后说属性或者说成员变量它们指的都是同一回事。
</code></pre>
<p>整个类可以看作是静态的属性还有方法他们之间的一个综合。怎么抽象出一个类的概念，还是那句话，你必须抽象出两个方面来，第一方面是看他们的静态属性，他们有哪些成员变量，第二方面是看他们的有哪些方法。</p>
<p>写JAVA程序时，我们一上来写的就是public class（声明一个类），在这个class里面我们写的是成员变量和方法。</p>
<p><strong>每一个JAVA里面的class（类）都对应了我们现实生活中某一类事物的一个抽象</strong>。比如说要在JAVA里面封装一只狗，具体怎么封装，如何写代码，代码如下：</p>
<pre><code class="language-java">/**
 * 一类事物封装到JAVA里面首先得写class，定义这个类，类名是什么可以自己取。
 * 这里把类名叫做Dog
 */
public class Dog {
    /**
     * 接下来就是写这个狗这个类的属性或者叫成员变量，
     * 比如说狗这个类的毛的颜色，怎么定义这个属性呢，
     * 首先得定义毛的一个类型,如使用int来定义毛的颜色类型
     */
    int furcolor; //定义属性：毛的颜色
    float height; //定义属性：狗的高度
    float weight; //定义属性：狗的体重

    /**
     * 狗的颜色，高度，体重这些属性定义完了，接下来要定义的就是方法了。
     * 如写一个CatchMouse（）方法，捉老鼠的方法。
     * CatchMouse这个方法里面有一个对象类型的参数，捉哪一只老鼠，这个对象参数是属于Mouse这个类的
     * @param m
     */
    void CatchMouse(Mouse m){
            //在方法体内写捉老鼠这个过程，怎么捉，跑着捉，走着捉
            System.out.println(&quot;我捉到老鼠了，汪汪！，老鼠要尖叫了！&quot;);
            /**
             * 老鼠尖叫一声，表示被狗咬到了，咬到了能不叫吗，很自然而然地想到，
             * 尖叫（scream()）这个方法是属于Mouse这个类里面的某一个方法。
             * 老鼠自己调用它，让它自己尖叫。这就是面向对象的思维。
             */
            m.scream();
    }

    public static void main(String[] args) {
        Dog  d = new Dog();//首先用new关键字创建一只狗
        Mouse m=new Mouse();//造出一只老鼠。
        d.CatchMouse(m);//然后用这只狗去抓老鼠，让狗调用CatchMouse()方法去捉某只老鼠。
    }
}
</code></pre>
<p>​		从这个意义上来讲，JAVA里面的每定义一个类实际上就相当于一种新的数据类型。就跟int ，float， String等一样，不过是一种新定义的类型而已。</p>
<h3 id="18-为什么使用面向对象编程">1.8 为什么使用面向对象编程？</h3>
<p>​		面向对象编程：一组对象互相配合通过沟通完成特定功能</p>
<p>做软件苦苦追求的一种境界是可重用性（reusable），可扩展性。如果是面向过程，一般情况是属性和方法它们是分开的，他们不是聚合的关系，不是合在一起的，这样要复用起来比较麻烦，复用的层次只是局限于方法这个层次上，而面向对象则不同，它是把属性和方法综合在一个里面。综合在一起复用的时候是整个对象进行复用。所以面向对象和面向过程相比，前者更加容易让我们达到可重用性。</p>
<h2 id="2-java面向对象二">2、Java面向对象（二）</h2>
<h3 id="21-java类的定义">2.1 Java类的定义</h3>
<pre><code class="language-java">//用class关键字定义一个类
class Person{
    private int id;
    private int age = 20;
    //方法的定义
    public int getAge(){
        return age;
    }
    public void setAge(int i){
        age = i;
    }
    public int getId(){
        return id;
    }
}
</code></pre>
<ul>
<li>
<p>类的定义主要有两方面组成一成员变量和方法。</p>
</li>
<li>
<p>声明成员变量的格式为: [&lt; modifiers&gt;] type &lt; attr_name&gt;[=defaultValue] ;<br>
例如:  private int id;    private int age = 20;</p>
</li>
<li>
<p>声明方法的格式为:<br>
[&lt; modifiers&gt;)] &lt; modifiers&gt; &lt;return_ type&gt; <name>([&lt; argu list&gt;]) {<br>
[&lt; statements&gt;]<br>
}    例如: public int getAge() {return age;}</p>
<p>​		JAVA里面有<strong>class</strong>关键字定义一个类，后面加上自定义的类名即可。如这里定义的person类，使用class person定义了一个person类，然后在person这个类的类体里面定义person这个类应该具有的成员变量（即属性）和方法，如这里定义的int id和int age这个两个成员变量，或者叫属性，这个id表示人的身份证号码，人应该具有这个属性，age表示人的年龄，这也是人应该具有的。这样就在person这个类里面定义了两个人应该有的属性，接下来就是定义方法了，这里定义了三个方法，分别是getAge()、setAge(int i)和getId()，分别用来获取人的年龄，设置人的年龄，获取人的id，getAge()方法获取了人的年龄后，将获取到的值返回，所以使用了return age语句，getId()方法也使用了return id语句用于返回获取到的id的值。</p>
</li>
</ul>
<h3 id="22-成员变量">2.2 成员变量</h3>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610160936.png" alt="" loading="lazy"></figure>
<p>**在JAVA里面的任何变量首先应该要声明，然后再赋值，然后再使用。**成员变量和局部变量有一个重要区别：<strong>成员变量在类里面声明时如果不进行初始化，那么JAVA会默认给它初始化，而局部变量JAVA不会默认给它初始化，所以在方法里面声明一个局部变量如果不给它初始化时就会出错</strong>。默认初始化大多数都是0，boolean类型的为false，引用类型的为null，如过不记得JAVA对成员变量默认的初始化是多少的话，那就这样做，定义一个成员变量，不给它初始化，然后直接打印这个成员变量，打印出来的结果就是JAVA默认的初始化的值。</p>
<h3 id="23-java面向对象的基本概念引用">2.3 Java面向对象的基本概念——引用</h3>
<figure data-type="image" tabindex="8"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610161110.png" alt="" loading="lazy"></figure>
<p>​		<strong>引用类型和基本类型有着巨大的区别</strong>，当声明一个int i=0时，系统会马上给这个i分配一个内存空间（在栈内存里面分配一小块区域用来装数字0），里面装着一个值为0，以后使用i这个名字马上就可以访问这个内存空间里面的值，这就是基本数据类型，所以<strong>基础类型就只占一块内存</strong>。基础类型之外的类型全都叫引用类型，我们定义一个Mouse m，这个m就是一个引用类型的数据。引用类型有什么重要的特征——<strong>引用类型占<strong><strong>2</strong></strong>块内存</strong>。我们定义好这个类之后，需要使用new关键字把这个类的对象实例化出来，也就是真真正正造出一个对象出来才能使用这个对象。</p>
<p><strong>如何在内存中区分类和对象</strong></p>
<p>类是静态的概念，是位于代码区里面。对象是new出来的，它是位于堆内存，为什么对象要位于堆内存？因为堆内存是用来动态分配内存的，只有在运行当中才会new一个对象放堆内存里面，那这个对象到底有多大个，这个东西你不知道，你没有办法提前知道，所以你没有办法提前分配内存给这个对象，你只有在运行期间才能去分配它。什么叫运行期间？敲JAVAC这个命令那是在编译期间，编译完成后再敲JAVA命令，那就是运行期间了。只有在运行期间，才能够明白这个对象到底要分配多大的空间给它，所以把它放在堆内存里面，堆内存比较大，动态分配内存用它。如果这个对象不用了，那它就是垃圾，那么就等着垃圾收集器把它收集回去，释放掉占用的内存。</p>
<p>​		记住，<strong>以后一提到引用，脑子里马上浮现引用那就是一小块内存指向一大块内存。</strong></p>
<h3 id="24-对象的创建和使用">2.4 对象的创建和使用</h3>
<ul>
<li>必须使用new关键字创建对象。</li>
<li>使用对象(引用) .成员变量或来引用对象的成员变量。</li>
<li>使用对象(引用) .方法(参数列表)来调用对象的方法。</li>
<li>同一类的每个对象有不同的成员变量存储空间。</li>
<li>同一类的每个对象共享该类的方法。</li>
</ul>
<h3 id="25-类和对象的关系">2.5 类和对象的关系</h3>
<figure data-type="image" tabindex="9"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610162714.png" alt="" loading="lazy"></figure>
<p><strong>在内存中分析类和对象的关系</strong></p>
<p>假设这里有一个类C，我们定义了一个类class C，然后在这个类里面定义了两个成员变量: int i和int j。定义好了这两个成员变量以后，我们写了一个main()方法（public static void main(Strng[] args)），程序开始执行。第一句我们写了 C c1 = new C()，这句的代码是我们相当于在堆内存里创建了一个对象，同时也创建了这个对象的一个引用对象c1，c1位于栈内存中，c1这个引用对象指向堆中一大块内存，这一大块内存里面装着new出来的那个对象。这里面我们一般来说是new出来两个对象c1和c2，当然，实际上，严格来讲，c1和c2叫做对象的引用，有时候，简称new出来了两个对象，c1和c2。你脑子里马上要浮现出两块内存，c1指向一块，c2指向一块。局部变量是分配在栈内存里面的，main方法里面的c1和c2都是局部变量，所以在栈里面分配了两小块内存出来，一块是c1的，一块是c2的，c1这块内存里面装着一个值，或者叫装着一个地址，这个地址是什么，我们不知道，我们只知道根据这个值就能找到new出来的C这个类里面的一个对象，而在这个对象里面有它自己的成员变量i和j，里面的两小块内存是分别用来装i和j的值的，因为每一个对象都有自己不同的成员变量的值，所以c1指向的那块对内存里面又分成一小块一小块内存，每一个小块的内存都装着这个对象的成员变量（或者叫属性）。如这里的第一小块装着i的值，第二小块装着j的值，所以当我们去访问第一小块里面装着的成员变量时，我们应该这样写：c1.i，这样就拿到了i的值，c1.j，这样就拿到了j的值。同理，c2这个对象也指向了一个new出来的C这个类里面的另一个对象，这个对象也有成员变量i和j，只不过和c1指向的那个对象里的i和j的值不同而已。要访问这个这个对象的成员变量时 ，也是要c2.i，c2.j这样去访问。</p>
<h3 id="26-构造方法">2.6 构造方法</h3>
<ul>
<li>
<p>使用new+构造方法创建-一个新的对象。</p>
</li>
<li>
<p>构造函数是定义在Java类中的一个用来初始化对象的函数。</p>
</li>
<li>
<p>构造函数与类同名且没有返回值。</p>
</li>
<li>
<p>例如: Person 类的构造函数:</p>
<pre><code class="language-java">public class Person(){
    int id;
    int age;
    Person(int n,int i){
        id = n;
        age = i;
    }
}
</code></pre>
<p>在面向对象里面有一个特殊的方法，叫构造方法。</p>
<p>构造方法是用来创建一个新的对象的，与new组合在一起用，使用new+构造方法创建一个新的对象。你new一个东西的时候，实际上你调用的是一个构造方法，构造方法就是把自己构造成一个新的对象，所以叫构造方法，构造一个新对象用的方法叫构造方法。</p>
<p>构造方法比较特殊，构造方法的名字必须和类的名字完全一模一样，包括大小写，并且没有返回值。如原来定义的一个person类，在类里面声明了两个成员变量id与age，这时候你可以再为这个person类定义一个它的构造方法person(int n，int i)，这个方法的名字和类名完全相同，并且没有返回值，也就是在这个方法前面不能写任何的方法的返回类型修饰符，连void都不可以写。</p>
</li>
<li>
<p>构造方法范例：</p>
<pre><code class="language-java">public class Person {
    int id;  //在person这类里面定义两个成员变量id和age,
    int age=20;  //给成员变量age赋了初值为20

    /**这里就是person这个类的一个构造方法
     * 构造方法的规则很简单，和类名要完全一样，一点都不能错，包括大小写。
     * 并且没有返回值，不能写void在它前面修饰
     * @param _id
     * @param _age
     */
    public Person(int _id,int _age ) {
        id = _id;
        age = _age;
    }
}
</code></pre>
<p>​		构造方法写好后就和new组合在一起使用，new的作用是构建一个新对象，创造一个新对象，所以new的时候实际当中调用的是构造方法。只有调用了这个构造方法才能构造出一个新的对象。例如：</p>
<pre><code class="language-java">public static void main(String[] args) {
    Person tom = new Person(1, 25); // 调用person这个构造方法创建一个新的对象，并给这个对象的成员变量赋初始值
}
</code></pre>
</li>
</ul>
<figure data-type="image" tabindex="10"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610161822.png" alt="" loading="lazy"></figure>
<p>​	<strong>下面是在main方法里面调用person构造方法时的内存分析情况：</strong></p>
<figure data-type="image" tabindex="11"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610161855.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610161922.png" alt="" loading="lazy"></figure>
<p>​		<strong>当方法调用完成之后，栈里面为它分配的空间全部都要消失，即把这个方法调用时分配给它的内存空间释放出来</strong>，所以这个构造方法person调用完成之后，栈内存里面分配的两小块内存_id和_age自动消失了。这样就把它们所占的空间让了出来，让其他的方法去占用。而new出来的对象则永远留在了堆内存里面。</p>
<figure data-type="image" tabindex="13"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610162016.png" alt="" loading="lazy"></figure>
<p>​		<strong>声明一个类，若没有在类中指定其构造方法（构造函数）时，编译器会为这个类自动添加形如类名( ){ }的构造函数。</strong></p>
<p><strong>如：</strong></p>
<pre><code class="language-java">class  point{//这里声明一个类时并没有给它指定其构造方法。
     int  x;
     int  y;
}
</code></pre>
<p>​		但在main方法里面我们却可以这样使用：</p>
<pre><code class="language-java">public static void main(String[] args){
     point  p = new  point();
}
</code></pre>
<p>​		这里这样写是可以的，当没有给这个类指明构造方法时，系统会默认地给这个类加上point ( ) { }这样一个空的构造方法。所以才可以在main方法中使用point p = new point(); 实际上你调用的就是编译器默认给它加上的point ( ) { }这个构造方法，在这个构造方法当中，默认地把类里面的成员变量x和y初始值设为0。正是因为系统给它默认加上这么一个构造方法，所以才能在main方法里面调用。但<strong>要记住一点，一旦给这个类里面指定了构造方法，那么系统就不会再给这个类添加构造方法了</strong>。</p>
<h2 id="3-封装">3、封装</h2>
<h3 id="31-封装概述">3.1 封装概述</h3>
<ul>
<li>
<p>概述：</p>
<p>​		面向对象编程语言是对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界无法直接操作和修改。<br>
封装可以被认为是一个保护屏障，防止该类的代码和数据被其他类随意访问。要访问该类的数据，必须通过指定的<br>
方式。适当的封装可以让代码更容易理解与维护，也加强了代码的安全性。</p>
</li>
<li>
<p>原则：</p>
<p>​		将属性隐藏起来，若需要访问某个属性，提供公共方法对其访问。</p>
</li>
</ul>
<h3 id="32-封装的步骤">3.2 封装的步骤</h3>
<ol>
<li>使用 private 关键字来修饰成员变量。</li>
<li>对需要访问的成员变量，提供对应的一对 getXxx 方法 、 setXxx 方法。</li>
</ol>
<h3 id="33-封装的操作private关键字">3.3 封装的操作——private关键字</h3>
<p><strong>private的含义</strong>：</p>
<ol>
<li>private是一个权限修饰符，代表最小权限。</li>
<li>可以修饰成员变量和成员方法。</li>
<li>被private修饰后的成员变量和成员方法，只在本类中才能访问。</li>
</ol>
<p><strong>private的使用格式</strong> ：</p>
<p>​	private 数据类型 变量名 ；</p>
<ol>
<li>使用 private 修饰成员变量，代码如下：</li>
</ol>
<pre><code class="language-java">public class Student {
  private String name;
  private int age;
}
</code></pre>
<ol start="2">
<li>提供 getXxx 方法 / setXxx 方法，可以访问成员变量，代码如下：</li>
</ol>
<pre><code class="language-java">public class Student {
  private String name;
  private int age;
 
  public void setName(String n) {
    name = n;
  }
 
  public String getName() {
    return name;
  }
 
  public void setAge(int a) {
    age = a;
  }
 
  public int getAge() {
    return age;
  }
}
</code></pre>
<h3 id="34-封装的优化1-this关键字">3.4 封装的优化1----this关键字</h3>
<ul>
<li>在类的方法定义中使用的this关键字代表使用该方法的对象的引用。</li>
<li>当必须指出当前使用方法的对象是谁时要使用this.</li>
<li>有时使用this可以处理方法中成员变量和参数重名的情况。</li>
<li>this可以看作是一一个变量，它的值是当前对象的引用</li>
</ul>
<pre><code class="language-java">public class Student {
  private String name;
  private int age;
 
  public void setName(String name) {
    //name = name;
    this.name = name;
  }
 
  public String getName() {
    return name;
  }
 
  public void setAge(int age) {
    //age = age;
    this.age = age;
  }
 
  public int getAge() {
    return age;
  }
}
</code></pre>
<p>小贴士：方法中只有一个变量名时，默认也是使用 this 修饰，可以省略不写。</p>
<p><strong>this是一个引用，它指向自身的这个对象。</strong></p>
<p>看内存分析图：<img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615022306.png" alt="" loading="lazy"></p>
<p>​		假设我们在堆内存new了一个对象，在这个对象里面你想象着他有一个引用this，this指向这个对象自己，所以这就是this，这个new出来的对象名字是什么，我们不知道，不知道也没关系，因为这并不影响这个对象在内存里面的存在，这个对象只要在内存中存在，他就一定有一个引用this。</p>
<p>看下面的例子分析：</p>
<pre><code class="language-java">
public class Leaf {

    int i = 0;

    public Leaf(int i) {
        this.i = i;
    }

    Leaf increament() {
        i++;
        return this;
    }

    void print() {
        System.out.println(&quot;i = &quot; + i);
    }

    public static void main(String[] args) {
        Leaf leaf = new Leaf(100);
        leaf.increament().increament().print();
    }
}
</code></pre>
<figure data-type="image" tabindex="14"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615022412.png" alt="" loading="lazy"></figure>
<p><strong>在内存中分析main方法的执行过程:</strong></p>
<p>首先分析第一句话：<strong>Leaf leaf = new Leaf(100);</strong></p>
<p>程序执行到这里的时候，栈空间里面有一个变量leaf，它指向了我们new出来的在堆空间里面的Leaf对象。new这个Leaf对象的时候，调用了构造方法Leaf(),这个构造方法里面有一个形参i，所以在栈空间里面给构造方法分配有一小块内存，名字叫i用来装传递过来的实参。这里传过来的实参是100，所以i里面装的值就是100。得到这个值之后，构造方法继续执行，执行this.i = i;这里就是把栈空间里面的i的值通过值传递给Leaf对象里面的成员变量i，所以成员变量i的值也变成了100。内存中的布局如下图所示：</p>
<figure data-type="image" tabindex="15"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615022457.png" alt="" loading="lazy"></figure>
<p>​		构造方法执行完之后，为这个构造方法分配的内存消失，所以栈里面的i所标记的那一小块内存会消失。因此第一句话执行完之后，内存中的布局如下图所示：</p>
<figure data-type="image" tabindex="16"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615022536.png" alt="" loading="lazy"></figure>
<p>接下来分析第二句话：<strong>leaf.increament().increament().print();</strong></p>
<p>首先逐个分析：leaf.increament()，这里是调用increament()方法，是对new出来的那个Leaf对象调用的，leaf是Leaf对象的引用对象，因此通过这个引用对象来调用increament()方法，即相当于是Leaf对象自己调用了increament()方法。increament()方法的定义如下：</p>
<pre><code class="language-java">Leaf increament(){
　　i++;
　　return this;
}
</code></pre>
<p>​		因此Leaf对象调用increament()方法时，首先执行方法体里面的第一句话i++;这样就把Leaf对象的成员变量i的值由原来的100变成了101。此时的内存布局如下图所示:</p>
<figure data-type="image" tabindex="17"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615022622.png" alt="" loading="lazy"></figure>
<p>接下来执行方法体里面的第二句话：<strong>return this;</strong></p>
<p>这里把this作为返回值，当有返回值的时候，首先会在栈里面给这个返回值分配一小块临时的存储空间。这块存储空间里面的内容是this里面的内容。this指向它自身，所以栈内存里面的那块临时存储空间里面装的this也是指向堆内存里面的Leaf对象。</p>
<p>​		所以leaf.increament().increament().print();这句话里面left.increament()这一小句话执行完之后，内存中的布局如下图所示:</p>
<figure data-type="image" tabindex="18"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615022741.png" alt="" loading="lazy"></figure>
<p>leaf.increament().increament().print();这句话里面的left.increament()这一小句话执行完之后，返回一个this，此时leaf.increament().increament().print();就相当于是this.increament().print();</p>
<p>接着栈里面的存储在临时空间里面的this调用increament()方法，而this指的就是Leaf对象，所以又是Leaf对象调用increament()方法。Leaf对象调用increament()方法时，又会执行方法体里面的i++，所以此时i又由原来的101变成了102。然后又执行return this，所以栈内存里面又多了一块临时存储空间，里面装的值也是this，这个this又是指向堆内存里面的Leaf对象。因此此时这个Leaf对象有了四个指向他自己的引用对象。</p>
<p>leaf.increament().increament().print();这句话里面的leaf.increament().increament()这一小句话执行完之后,都返回了一个this，所以此时的leaf.increament().increament().print();就相当于是这样子的：this.this.print();</p>
<p>接下来又是栈里面的那个新的this调用print()方法，使用this来调用，那就相当于是Leaf对象来调用，Leaf对象自己调用print()方法将自己的i属性的值打印出来，所以打印出来的结果应该是102。</p>
<p>因此main方法里面的整个程序执行完之后，内存中的布局如下图所示：</p>
<figure data-type="image" tabindex="19"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615022842.png" alt="" loading="lazy"></figure>
<p>​		this的总结：this一般出现在方法里面，当这个方法还没有调用的时候，this指的是谁并不知道。但是实际当中，你如果new了一个对象出来，那么this指的就是当前这个对象。对哪个对象调用方法，this指的就是调用方法的这个对象（你对哪个对象调用这个方法，this指的就是谁）。如果再new一个对象，这个对象他也有自己的this，他自己的this就当然指的是他自己了。</p>
<h3 id="35-封装的优化2-构造方法">3.5 封装的优化2----构造方法</h3>
<p>​		当一个对象被创建时候，构造方法用来初始化该对象，给对象的成员变量赋初始值。</p>
<blockquote>
<p>小贴士：无论你与否自定义构造方法，所有的类都有构造方法，因为Java自动提供了一个无参数构造方法，一旦自己定义了构造方法，Java自动提供的默认无参数构造方法就会失效。</p>
</blockquote>
<p><strong>构造方法的定义格式：</strong></p>
<pre><code class="language-java">修饰符 构造方法名(参数列表){
    // 方法体
}
</code></pre>
<p>​		构造方法的写法上，方法名与它所在的类名相同。它没有返回值，所以不需要返回值类型，甚至不需要void。使用<br>
构造方法后，代码如下：</p>
<pre><code class="language-java">public class Student {
  private String name;
  private int age;
  // 无参数构造方法
  public Student() {} 
  // 有参数构造方法
  public Student(String name,int age) {
    this.name = name;
    this.age = age; 
  }
}
</code></pre>
<p><strong>注意事项:</strong></p>
<ol>
<li>如果你不提供构造方法，系统会给出无参数构造方法。</li>
<li>如果你提供了构造方法，系统将不再提供无参数构造方法。</li>
<li>构造方法是可以重载的，既可以定义参数，也可以不定义参数。</li>
</ol>
<h3 id="36-标准代码javabean">3.6 标准代码——JavaBean</h3>
<p>​		JavaBean 是 Java语言编写类的一种标准规范。符合 JavaBean 的类，要求类必须是具体的和公共的，并且具有无参数的构造方法，提供用来操作成员变量的 set 和 get 方法。</p>
<pre><code class="language-java">public class ClassName{
  //成员变量
  //构造方法
  //无参构造方法【必须】
  //有参构造方法【建议】
  //成员方法    
  //getXxx()
  //setXxx()
}
</code></pre>
<p>编写符合 JavaBean 规范的类，以学生类为例，标准代码如下：</p>
<pre><code class="language-java">public class Student {
  //成员变量
  private String name;
  private int age;
 
  //构造方法
  public Student() {}
 
  public Student(String name,int age) {
    this.name = name;
    this.age = age;
  }
 
  //成员方法
  publicvoid setName(String name) {
    this.name = name;
  }
 
  public String getName() {
    return name;
  }
 
  publicvoid setAge(int age) {
    this.age = age;
  }
 
  publicint getAge() {
    return age;
  }
}
</code></pre>
<p>测试类，代码如下：</p>
<pre><code class="language-java">public class TestStudent {
  public static void main(String[] args) {
    //无参构造使用
    Student s= new Student();
    s.setName(&quot;柳岩&quot;);
    s.setAge(18);
    System.out.println(s.getName()+&quot;‐‐‐&quot;+s.getAge());
      //带参构造使用
    Student s2= new Student(&quot;赵丽颖&quot;,18);
    System.out.println(s2.getName()+&quot;‐‐‐&quot;+s2.getAge());
  }
}
</code></pre>
<h2 id="4-继承">4、继承</h2>
<h3 id="41-继承的概述">4.1 继承的概述</h3>
<p>​		多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那一个类即可。如图所示：</p>
<figure data-type="image" tabindex="20"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615023612.png" alt="" loading="lazy"></figure>
<p>​		其中，多个类可以称为子类，单独那一个类称为父类、超类（superclass）或者基类。<br>
​		继承描述的是事物之间的所属关系，这种关系是： is-a 的关系。例如，图中兔子属于食草动物，食草动物属于动物。可见，父类更通用，子类更具体。我们通过继承，可以使多种事物之间形成一种关系体系。<br>
<strong>定义：</strong></p>
<ul>
<li>继承：就是子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接访问父类中的非私有的属性和行为。</li>
</ul>
<p><strong>好处：</strong></p>
<ol>
<li>提高<strong>代码的复用性。</strong></li>
<li>类与类之间产生了关系，是<strong>多态的前提。</strong></li>
</ol>
<h3 id="42-继承的格式">4.2 继承的格式</h3>
<p>通过 extends 关键字，可以声明一个子类继承另外一个父类，定义格式如下：</p>
<pre><code class="language-java">class 父类 {
    ...
}
 
class 子类 extends 父类 {
    ...
}
</code></pre>
<p>继承演示，代码如下:</p>
<pre><code class="language-java">/*
 * 定义员工类Employee，做为父类
  */
class Employee {
    String name; // 定义name属性
    // 定义员工的工作方法
    public void work() {
        System.out.println(&quot;尽心尽力地工作&quot;);
    }
}
 
/*
 * 定义讲师类Teacher 继承 员工类Employee
 */
class Teacher extends Employee {
    // 定义一个打印name的方法
    public void printName() {
        System.out.println(&quot;name=&quot; + name);
    }
}
 
/*
 * 定义测试类
 */
public class ExtendDemo01 {
    public static void main(String[] args) {
        // 创建一个讲师类对象
        Teacher t = new Teacher();
      
        // 为该员工类的name属性进行赋值
        t.name = &quot;小明&quot;; 
      
        // 调用该员工的printName()方法
        t.printName(); // name = 小明
        
        // 调用Teacher类继承来的work()方法
        t.work();  // 尽心尽力地工作
    }
}
</code></pre>
<h3 id="43-继承后的特点成员变量">4.3 继承后的特点——成员变量</h3>
<p>当类之间产生了关系后，其中各类中的成员变量，又产生了哪些影响呢？</p>
<h4 id="成员变量不重名">成员变量不重名：</h4>
<p>如果子类父类中出现不重名的成员变量，这时的访问是没有影响的。代码如下：</p>
<pre><code class="language-java">class Fu {
    // Fu中的成员变量。
    int num = 5;
}
class Zi extends Fu {// Zi中的成员变量
    int num2 = 6;
    // Zi中的成员方法
    public void show() {
        // 访问父类中的num，
        System.out.println(&quot;Fu num=&quot;+num); // 继承而来，所以直接访问。
        // 访问子类中的num2
        System.out.println(&quot;Zi num2=&quot;+num2);
    }
}
class ExtendDemo02 {
    public static void main(String[] args) {
        // 创建子类对象
        Zi z = new Zi(); 
        // 调用子类中的show方法
        z.show();  
    }
}
 
演示结果：
Fu num = 5
Zi num2 = 6
</code></pre>
<h4 id="成员变量重名">成员变量重名:</h4>
<p>如果子类父类中出现重名的成员变量，这时的访问是有影响的。代码如下：</p>
<pre><code class="language-java"> 

    // Zi中的成员变量
    int num2 = 6;
    // Zi中的成员方法
    public void show() {
        // 访问父类中的num，
        System.out.println(&quot;Fu num=&quot;+num); // 继承而来，所以直接访问。
        // 访问子类中的num2
        System.out.println(&quot;Zi num2=&quot;+num2);
    }
}
class ExtendDemo02 {
    public static void main(String[] args) {
        // 创建子类对象
        Zi z = new Zi(); 
        // 调用子类中的show方法
        z.show();  
    }
}
 
演示结果：
Fu num = 5
Zi num2 = 6

class Fu {
    // Fu中的成员变量。
    int num = 5;
}
class Zi extends Fu {
    // Zi中的成员变量
    int num = 6;
    public void show() {
        // 访问父类中的num
        System.out.println(&quot;Fu num=&quot; + num);
        // 访问子类中的num
        System.out.println(&quot;Zi num=&quot; + num);
    }
}
class ExtendsDemo03 {
    public static void main(String[] args) {
        // 创建子类对象
        Zi z = new Zi(); 
        // 调用子类中的show方法
        z.show(); 
    }
}
演示结果：
Fu num = 6
Zi num = 6
</code></pre>
<p>​		子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用 super 关键字，修饰父类成员变量，类似于之前学过的 this 。</p>
<p>使用格式：</p>
<pre><code class="language-java">super.父类成员变量名
</code></pre>
<p>子类方法需要修改，代码如下：</p>
<pre><code class="language-java">class Zi extends Fu {
    // Zi中的成员变量
    int num = 6;
    public void show() {
        //访问父类中的num
        System.out.println(&quot;Fu num=&quot; + super.num);
        //访问子类中的num
        System.out.println(&quot;Zi num=&quot; + this.num);
    }
}
演示结果：
Fu num = 5
Zi num = 6
</code></pre>
<blockquote>
<p>小贴士：Fu 类中的成员变量是非私有的，子类中可以直接访问。若Fu 类中的成员变量私有了，子类是不能直接访问的。通常编码时，我们遵循封装的原则，使用private修饰成员变量，那么如何访问父类的私有成员变量呢？对！可以在父类中提供公共的getXxx方法和setXxx方法。</p>
</blockquote>
<h3 id="44-继承后的特点成员方法">4.4  继承后的特点——成员方法</h3>
<p>当类之间产生了关系，其中各类中的成员方法，又产生了哪些影响呢？</p>
<h4 id="成员方法不重名">成员方法不重名:</h4>
<p>如果子类父类中出现<strong>不重名</strong>的成员方法，这时的调用是<strong>没有影响</strong>的。对象调用方法时，会先在子类中查找有没有对应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法。代码如下:</p>
<pre><code class="language-java">class Fu{
    public void show(){
        System.out.println(&quot;Fu类中的show方法执行&quot;);
    }
}
class Zi extends Fu{
    public void show2(){
        System.out.println(&quot;Zi类中的show2方法执行&quot;);
    }
}
public  class ExtendsDemo04{
    public static void main(String[] args) {
        Zi z = new Zi();
        //子类中没有show方法，但是可以找到父类方法去执行
             z.show(); 
        z.show2();
    }
}
 
</code></pre>
<p><strong>成员方法重名——重写(Override):</strong></p>
<p>如果子类父类中出现<strong>重名</strong>的成员方法，这时的访问是一种特殊情况，叫做<strong>方法重写</strong> (Override)。</p>
<ul>
<li><strong>方法重写</strong> ：子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写。<strong>声明不变，重新实现。</strong></li>
</ul>
<p>代码如下:</p>
<pre><code class="language-java">class Fu {
    public void show() {
        System.out.println(&quot;Fu show&quot;);
    }
}
class Zi extends Fu {
    //子类重写了父类的show方法
    public void show() {
        System.out.println(&quot;Zi show&quot;);
    }
}
public class ExtendsDemo05{
    public static void main(String[] args) {
        Zi z = new Zi();
        // 子类中有show方法，只执行重写后的show方法
        z.show();  // Zi show
    }
}
</code></pre>
<h4 id="重写的应用">重写的应用:</h4>
<p>​		子类可以根据需要，定义特定于自己的行为。既沿袭了父类的功能名称，又根据子类的需要重新实现父类方法，从而进行扩展增强。比如新的手机增加来电显示头像的功能，代码如下：</p>
<pre><code class="language-java">class Phone{
	public void sendMessage(){
    	System.out.println(&quot;发短信&quot;);
	}
	public void call(){
    	System.out.println(&quot;打电话&quot;);
	}
	public void showNum(){
    	System.out.println(&quot;来电显示号码&quot;);
	}
}

//智能手机类
class NewPhone extends Phone {
    //重写父类的来电显示号码功能，并增加自己的显示姓名和图片功能
    public void showNum(){
        //调用父类已经存在的功能使用super
        super.showNum();
        //增加自己特有显示姓名和图片功能
        System.out.println(&quot;显示来电姓名&quot;);
        System.out.println(&quot;显示头像&quot;);
    }
}
 
public class ExtendsDemo06 {
    public static void main(String[] args) {
        // 创建子类对象
        NewPhone np = new NewPhone()；
        
        // 调用父类继承而来的方法
        np.call();
      
        // 调用子类重写的方法
        np.showNum();
    }
}
</code></pre>
<blockquote>
<p>小贴士：这里重写时，用到super.父类成员方法，表示调用父类的成员方法。</p>
</blockquote>
<p><strong>注意事项:</strong></p>
<ol>
<li>子类方法覆盖父类方法，必须要保证权限大于等于父类权限。</li>
<li>子类方法覆盖父类方法，返回值类型、函数名和参数列表都要一模一样。</li>
</ol>
<h3 id="45-继承后的特点构造方法">4.5 继承后的特点——构造方法</h3>
<p>当类之间产生了关系，其中各类中的构造方法，又产生了哪些影响呢？<br>
首先我们要回忆两个事情，构造方法的定义格式和作用。</p>
<ol>
<li>构造方法的名字是与类名一致的。所以子类是无法继承父类构造方法的。</li>
<li>构造方法的作用是初始化成员变量的。所以子类的初始化过程中，必须先执行父类的初始化动作。子类的构造方法中默认有一个 super() ，表示调用父类的构造方法，父类成员变量初始化后，才可以给子类使用。代码如下：</li>
</ol>
<pre><code class="language-java">class Fu {
  private int n;
  Fu(){
    System.out.println(&quot;Fu()&quot;);
  }
}

class Zi extends Fu {
  Zi(){
    // super（），调用父类构造方法
    super();
    System.out.println(&quot;Zi（）&quot;);
  }  
}

public class ExtendsDemo07{
  public static void main (String args[]){
    Zi zi = new Zi();
  }
}

输出结果：
Fu（）
Zi（）
</code></pre>
<h3 id="46-super和this">4.6 super和this</h3>
<h4 id="父类空间优先于子类对象产生">父类空间优先于子类对象产生</h4>
<p>在每次创建子类对象时，先初始化父类空间，再创建其子类对象本身。目的在于子类对象中包含了其对应的父类空间，便可以包含其父类的成员，如果父类成员非private修饰，则子类可以随意使用父类成员。代码体现在子类的构造方法调用时，一定先调用父类的构造方法。理解图解如下：<img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615025331.png" alt="" loading="lazy"></p>
<h4 id="super和this的含义">super和this的含义：</h4>
<ul>
<li>super ：代表父类的存储空间标识(可以理解为父亲的引用)。</li>
<li>this ：代表当前对象的引用(谁调用就代表谁)。</li>
</ul>
<h4 id="super和this的用法">super和this的用法:</h4>
<ol>
<li>访问成员</li>
</ol>
<pre><code class="language-java">this.成员变量       ‐‐    本类的
super.成员变量      ‐‐    父类的
 
this.成员方法名()    ‐‐    本类的    
super.成员方法名()   ‐‐    父类的
</code></pre>
<p>用法演示，代码如下：</p>
<pre><code class="language-java">class Animal {
    public void eat() {
        System.out.println(&quot;animal : eat&quot;);
    }
}
 
class Cat extends Animal {
    public void eat() {
        System.out.println(&quot;cat : eat&quot;);
    }
    public void eatTest() {
        this.eat();   // this  调用本类的方法
        super.eat();  // super 调用父类的方法
    }
}
 
public class ExtendsDemo08 {
    public static void main(String[] args) {
        Animal a = new Animal();
        a.eat();
        Cat c = new Cat();
        c.eatTest();
    }
}
 
输出结果为：
animal : eat
cat : eat
animal : eat
</code></pre>
<ol start="2">
<li>访问构造方法</li>
</ol>
<pre><code class="language-java">this(...)       ‐‐    本类的构造方法
super(...)      ‐‐    父类的构造方法
</code></pre>
<blockquote>
<p>​		子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。</p>
</blockquote>
<h3 id="47-继承的特点">4.7 继承的特点</h3>
<ol>
<li>Java只支持单继承，不支持多继承。</li>
</ol>
<pre><code class="language-java">//一个类只能有一个父类，不可以有多个父类。
class C extends A{}     //ok
class C extends A，B...  //error
</code></pre>
<ol start="2">
<li>Java支持多层继承(继承体系)。</li>
</ol>
<pre><code class="language-java">class A{}
class B extends A{}
class C extends B{}
</code></pre>
<blockquote>
<p>顶层父类是Object类。所有的类默认继承Object，作为父类。</p>
</blockquote>
<ol start="3">
<li>子类和父类是一种相对的概念。</li>
</ol>
<h2 id="5-多态">5、多态</h2>
<h3 id="51-概述">5.1 概述</h3>
<p>多态是继封装、继承之后，面向对象的第三大特性。<br>
生活中，比如跑的动作，小猫、小狗和大象，跑起来是不一样的。再比如飞的动作，昆虫、鸟类和飞机，飞起来也是不一样的。可见，同一行为，通过不同的事物，可以体现出来的不同的形态。多态，描述的就是这样的状态。</p>
<p>定义：</p>
<ul>
<li>多态： 是指同一行为，具有多个不同表现形式。</li>
</ul>
<p>前提（重点）：</p>
<ul>
<li>继承或者实现【二选一】</li>
</ul>
<ol start="2">
<li>方法的重写【意义体现：不重写，无意义】</li>
<li>父类引用指向子类对象【格式体现】</li>
</ol>
<h3 id="52-多态的体现">5.2 多态的体现</h3>
<p>多态体现的格式：</p>
<pre><code class="language-java">父类类型 变量名 = new 子类对象；
变量名.方法名();
</code></pre>
<blockquote>
<p>父类类型：指子类对象继承的父类类型，或者实现的父接口类型。</p>
</blockquote>
<p>代码如下:</p>
<pre><code class="language-java">Fu f = new Zi();
f.method();
</code></pre>
<p><strong>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，执行的是子类重写后方法。</strong><br>
代码如下：<br>
定义父类：</p>
<pre><code class="language-java">public abstract class Animal {  
    public abstract void eat();  
}  
</code></pre>
<p>定义子类：</p>
<pre><code class="language-java">class Cat extends Animal {  
    public void eat() {  
        System.out.println(&quot;吃鱼&quot;);  
    }  
}  
 
class Dog extends Animal {  
    public void eat() {  
        System.out.println(&quot;吃骨头&quot;);  
    }  
}
</code></pre>
<p>定义测试类：</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        // 多态形式，创建对象
        Animal a1 = new Cat();  
        // 调用的是 Cat 的 eat
        a1.eat();          
 
        // 多态形式，创建对象
        Animal a2 = new Dog(); 
        // 调用的是 Dog 的 eat
        a2.eat();               
    }  
}
</code></pre>
<h3 id="53-多态的好处">5.3 多态的好处</h3>
<p>实际开发的过程中，父类类型作为方法形式参数，传递子类对象给方法，进行方法的调用，更能体现出多态的扩展性与便利。代码如下：<br>
定义父类：</p>
<pre><code class="language-java">public abstract class Animal {  
    public abstract void eat();  
} 
</code></pre>
<p>定义子类：</p>
<pre><code class="language-java">class Cat extends Animal {  
    public void eat() {  
        System.out.println(&quot;吃鱼&quot;);  
    }  
}  
 
class Dog extends Animal {  
    public void eat() {  
        System.out.println(&quot;吃骨头&quot;);  
    }  
}
</code></pre>
<p>定义测试类：</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        // 多态形式，创建对象
        Cat c = new Cat();  
        Dog d = new Dog(); 
 
        // 调用showCatEat 
        showCatEat(c);
        // 调用showDogEat 
         showDogEat(d); 
 
        /*
        以上两个方法, 均可以被showAnimalEat(Animal a)方法所替代
        而执行效果一致
        */
        showAnimalEat(c);
        showAnimalEat(d); 
    }
 
    public static void showCatEat (Cat c){
        c.eat(); 
    }
 
    public static void showDogEat (Dog d){
        d.eat();
    }
 
    public static void showAnimalEat (Animal a){
        a.eat();
    }
}
</code></pre>
<p>由于多态特性的支持，showAnimalEat方法的Animal类型，是Cat和Dog的父类类型，父类类型接收子类对象，当然可以把Cat对象和Dog对象，传递给方法。<br>
当eat方法执行时，多态规定，执行的是子类重写的方法，那么效果自然与showCatEat、showDogEat方法一致，所以showAnimalEat完全可以替代以上两方法。<br>
不仅仅是替代，在扩展性方面，无论之后再多的子类出现，我们都不需要编写showXxxEat方法了，直接使用showAnimalEat都可以完成。<br>
所以，多态的好处，体现在，可以使程序编写的更简单，并有良好的扩展。</p>
<h3 id="54-引用类型转换">5.4 引用类型转换</h3>
<p>多态的转型分为向上转型与向下转型两种：</p>
<h4 id="向上转型">向上转型</h4>
<ul>
<li>向上转型：多态本身是子类类型向父类类型向上转换的过程，这个过程是默认的。当父类引用指向一个子类对象时，便是向上转型。<br>
使用格式：</li>
</ul>
<pre><code class="language-java">父类类型  变量名 = new 子类类型();
如：Animal a = new Cat();
</code></pre>
<h4 id="向下转型">向下转型</h4>
<p>向下转型：父类类型向子类类型向下转换的过程，这个过程是强制的。</p>
<p>一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。<br>
使用格式：</p>
<pre><code class="language-java">子类类型 变量名 = (子类类型) 父类变量名;
如:Cat c =(Cat) a;
</code></pre>
<h4 id="为什么要转型">为什么要转型</h4>
<p>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，不能调用子类拥有，而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点&quot;小麻烦&quot;。所以，想要调用子类特有的方法，必须做向下转型。<br>
转型演示，代码如下：<br>
定义类：</p>
<pre><code class="language-java">abstract class Animal {  
    abstract void eat();  
}  
 
class Cat extends Animal {  
    public void eat() {  
        System.out.println(&quot;吃鱼&quot;);  
    }  
    public void catchMouse() {  
        System.out.println(&quot;抓老鼠&quot;);  
    }  
}  
 
class Dog extends Animal {  
    public void eat() {  
        System.out.println(&quot;吃骨头&quot;);  
    }  
    public void watchHouse() {  
        System.out.println(&quot;看家&quot;);  
    }  
}
</code></pre>
<p>定义测试类：</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        // 向上转型  
        Animal a = new Cat();  
        a.eat();                // 调用的是 Cat 的 eat
 
        // 向下转型  
        Cat c = (Cat)a;       
        c.catchMouse();         // 调用的是 Cat 的 catchMouse
    }  
}
</code></pre>
<h4 id="转型的异常">转型的异常</h4>
<p>转型的过程中，一不小心就会遇到这样的问题，请看如下代码：</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        // 向上转型  
        Animal a = new Cat();  
        a.eat();               // 调用的是 Cat 的 eat
 
        // 向下转型  
        Dog d = (Dog)a;       
        d.watchHouse();        // 调用的是 Dog 的 watchHouse 【运行报错】
    }  
}
</code></pre>
<p>这段代码可以通过编译，但是运行时，却报出了 ClassCastException ，类型转换异常！这是因为，明明创建了Cat类型对象，运行时，当然不能转换成Dog对象的。这两个类型并没有任何继承关系，不符合类型转换的定义。<br>
为了避免ClassCastException的发生，Java提供了 instanceof 关键字，给引用变量做类型的校验，格式如下：</p>
<ul>
<li>变量名 instanceof 数据类型</li>
<li>如果变量属于该数据类型，返回true。</li>
<li>如果变量不属于该数据类型，返回false。</li>
</ul>
<p>所以，转换前，我们最好先做一个判断，代码如下：</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        // 向上转型  
        Animal a = new Cat();  
        a.eat();               // 调用的是 Cat 的 eat
 
        // 向下转型  
        if (a instanceof Cat){
            Cat c = (Cat)a;       
            c.catchMouse();        // 调用的是 Cat 的 catchMouse
        } else if (a instanceof Dog){
            Dog d = (Dog)a;       
            d.watchHouse();       // 调用的是 Dog 的 watchHouse
        }
    }  
}
</code></pre>
<h3 id="55-面向对象最核心的机制动态绑定也叫多态的理解">5.5 面向对象最核心的机制——动态绑定（也叫多态）的理解</h3>
<figure data-type="image" tabindex="21"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615031915.png" alt="" loading="lazy"></figure>
<h4 id="551-通过下面的例子理解动态绑定即多态">5.5.1 通过下面的例子理解动态绑定，即多态</h4>
<pre><code class="language-java">class Animal {
    /**
     * 声明一个私有的成员变量name。
     */
    private String name;

    /**
     * 在Animal类自定义的构造方法
     * @param name
     */
    Animal(String name) {
        this.name = name;
    }

    /**
     * 在Animal类里面自定义一个方法enjoy
     */
    public void enjoy() {
        System.out.println(&quot;动物的叫声……&quot;);
    }
}

/**
 * 子类Cat从父类Animal继承下来，Cat类拥有了Animal类所有的属性和方法。
 * @author gacl
 *
 */
class Cat extends Animal {
    /**
     * 在子类Cat里面定义自己的私有成员变量
     */
    private String eyesColor;

    /**
     * 在子类Cat里面定义Cat类的构造方法
     * @param n
     * @param c
     */
    Cat(String n, String c) {
        /**
         * 在构造方法的实现里面首先使用super调用父类Animal的构造方法Animal(String name)。
         * 把子类对象里面的父类对象先造出来。
         */
        super(n);
        eyesColor = c;
    }

    /**
     * 子类Cat对从父类Animal继承下来的enjoy方法不满意，在这里重写了enjoy方法。
     */
    public void enjoy() {
        System.out.println(&quot;我养的猫高兴地叫了一声……&quot;);
    }
}

/**
 * 子类Dog从父类Animal继承下来，Dog类拥有了Animal类所有的属性和方法。
 * @author gacl
 *
 */
class Dog extends Animal {
    /**
     * 在子类Dog里面定义自己的私有成员变量
     */
    private String furColor;

    /**
     * 在子类Dog里面定义Dog类的构造方法
     * @param n
     * @param c
     */
    Dog(String n, String c) {
        /**
         * 在构造方法的实现里面首先使用super调用父类Animal的构造方法Animal(String name)。
         * 把子类对象里面的父类对象先造出来。
         */
        super(n);
        furColor = c;
    }

    /**
     * 子类Dog对从父类Animal继承下来的enjoy方法不满意，在这里重写了enjoy方法。
     */
    public void enjoy() {
        System.out.println(&quot;我养的狗高兴地叫了一声……&quot;);
    }
}

/**
 * 子类Bird从父类Animal继承下来，Bird类拥有Animal类所有的属性和方法
 * @author gacl
 *
 */
class Bird extends Animal {
    /**
     * 在子类Bird里面定义Bird类的构造方法
     */
    Bird() {
        /**
         * 在构造方法的实现里面首先使用super调用父类Animal的构造方法Animal(String name)。
         * 把子类对象里面的父类对象先造出来。
         */
        super(&quot;bird&quot;);
    }

    /**
     * 子类Bird对从父类Animal继承下来的enjoy方法不满意，在这里重写了enjoy方法。
     */
    public void enjoy() {
        System.out.println(&quot;我养的鸟高兴地叫了一声……&quot;);
    }
}

/**
 * 定义一个类Lady(女士)
 * @author gacl
 *
 */
class Lady {
    /**
     * 定义Lady类的私有成员变量name和pet
     */
    private String name;
    private Animal pet;

    /**
     * 在Lady类里面定义自己的构造方法Lady()，
     * 这个构造方法有两个参数，分别为String类型的name和Animal类型的pet，
     * 这里的第二个参数设置成Animal类型可以给我们的程序带来最大的灵活性，
     * 因为作为养宠物来说，可以养猫，养狗，养鸟，只要是你喜欢的都可以养，
     * 因此把它设置为父类对象的引用最为灵活。
     * 因为这个Animal类型的参数是父类对象的引用类型，因此当我们传参数的时候，
     * 可以把这个父类的子类对象传过去，即传Dog、Cat和Bird等都可以。
     * @param name
     * @param pet
     */
    Lady(String name, Animal pet) {
        this.name = name;
        this.pet = pet;
    }

    /**
     * 在Lady类里面自定义一个方法myPetEnjoy()
     * 方法体内是让Lady对象养的宠物自己调用自己的enjoy()方法发出自己的叫声。
     */
    public void myPetEnjoy() {
        pet.enjoy();
    }
}

public class TestPolymoph {
    public static void main(String args[]) {
        /**
         * 在堆内存里面new了一只蓝猫对象出来，这个蓝猫对象里面包含有一个父类对象Animal。
         */
        Cat c = new Cat(&quot;Catname&quot;, &quot;blue&quot;);
        /**
         * 在堆内存里面new了一只黑狗对象出来，这个黑狗对象里面包含有一个父类对象Animal。
         */
        Dog d = new Dog(&quot;Dogname&quot;, &quot;black&quot;);
        /**
         * 在堆内存里面new了一只小鸟对象出来，这个小鸟对象里面包含有一个父类对象Animal。
         */
        Bird b = new Bird();

        /**
         * 在堆内存里面new出来3个小姑娘，名字分别是l1，l2，l3。
         * l1养了一只宠物是c(Cat)，l2养了一只宠物是d(Dog)，l3养了一只宠物是b(Bird)。
         * 注意：调用Lady类的构造方法时，传递过来的c，d，b是当成Animal来传递的，
         * 因此使用c，d，b这三个引用对象只能访问父类Animal里面的enjoy()方法。
         */
        Lady l1 = new Lady(&quot;l1&quot;, c);
        Lady l2 = new Lady(&quot;l2&quot;, d);
        Lady l3 = new Lady(&quot;l3&quot;, b);
        /**
         * 这三个小姑娘都调用myPetEnjoy()方法使自己养的宠物高兴地叫起来。
         */
        l1.myPetEnjoy();
        l2.myPetEnjoy();
        l3.myPetEnjoy();
    }
}
</code></pre>
<p>运行结果：<img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615032029.png" alt="" loading="lazy"></p>
<h4 id="552-画内存图理解动态绑定多态">5.5.2 画内存图理解动态绑定（多态）</h4>
<p>首先从main方法的第一句话开始分析：</p>
<p>Cat c = new Cat(&quot;Catname&quot;,&quot;blue&quot;);</p>
<p>程序执行到这里，栈空间里有一个变量c，c里面装着一系列的值，通过这些值可以找到位于堆内存里面new出来的Cat对象。因此c是Cat对象的一个引用，通过c可以看到这个Cat对象的全部。c指向new出来的Cat对象。在new这个Cat对象的时候，调用了Cat对象的构造方法Cat(String n,String c)，定义如下：</p>
<p>Cat(String n,String c){</p>
<p><strong>super(n);</strong></p>
<p>eyesColor=c;</p>
<p>}</p>
<p>因此在构造子类对象时首先使用父类对象的引用super调用父类的构造方法Animal(String name),定义如下：</p>
<p>Animal(String name){</p>
<p>this.name=name;</p>
<p>}</p>
<p>因此会把传过来的字符串“Catname”传递给父类对象的name属性。当Cat(String n,String c)构造方法调用结束后，真真正正在堆内存里面new出了一只Cat，这只Cat里面包含有父类对象Animal，这个Animal对象有自己的属性name，name属性的值为调用父类构造方法时传递过来的字符串Catname。除此之外，这只Cat还有自己的私有成员变量eyesColor，eyesColor属性的属性值为调用子类构造方法时传递过来的字符串blue。所以执行完这句话以后，内存中的布局是栈内存里面有一个引用c，c指向堆内存里面new出来的一只Cat，而这只Cat对象里面又包含有父类对象Animal，Animal对象有自己的属性name，属性值为Catname，Cat除了拥有从Animal类继承下来的name属性外，还拥有一个自己私有的属性eyesColor，属性值为blue。这就是执行完第一句话以后整个内存布局的情况如下图所示：</p>
<figure data-type="image" tabindex="22"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615032133.png" alt="" loading="lazy"></figure>
<p>接着看这句话：Lady l1 = new Lady(“l1”,c);</p>
<figure data-type="image" tabindex="23"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200615032154.png" alt="" loading="lazy"></figure>
<p>程序执行到这里,首先在栈内存里面多了一个引用变量l1,l1里面装着一个值，通过这个值可以找到在堆内存里面new出来的Lady对象。l1就是这个Lady对象的引用，l1指向Lady对象。在创建Lady对象时，调用Lady类的构造方法：Lady(String name,Animal pet)，其定义如下：</p>
<p>Lady(String name,Animal pet){</p>
<p>this.name=name;</p>
<p>this.pet=pet;</p>
<p>}</p>
<p>这个构造方法有两个参数，分别是String类型的name和Animal类型的pet，pet参数是一个父类对象的引用类型，这里把l1和c作为实参传递给了构造方法，接着在构造方法里面执行this.name=name，把传递过来的l1由传给Lady对象的name属性，因此Lady对象的name属性值为l1，这里也把前面new出来的那只Cat的引用c传递给了构造方法里面的参数pet，接着在构造方法里面执行this.pet=pet，pet参数又把c传过来的内容传递给Lady对象的pet属性，因此pet属性的属性值就是可以找到Cat对象的地址，因此Lady对象的pet属性也成为了Cat对象的引用对象了，通过pet里面装着的值是可以找到Cat对象的，因此pet也指向了Cat，但并不是全部指向Cat，pet指向的只是位于Cat对象内部的Animal对象，这是因为在调用构造方法时，是把c当成一个Animal对象的引用传过来的，把c作为一个Animal对象传递给了pet，所以得到的pet也是一个Animal对象的引用，因此这个pet引用指向的只能是位于Cat对象里面的Animal对象。在我pet引用对象眼里，你Cat对象就是一只普通的Animal，访问你的时候只能访问得到你里面的name属性，而你的eyesColor属性我是访问不到的，我能访问到你的name属性，访问的是位于你内部里面的父对象的name属性，因为我pet引用本身就是一个父类对象的引用，因此我可以访问父类对象的全部属性，而你子类对象Cat自己新增加的成员我pet引用是访问不了的。不过现在我pet引用不去访问你父类对象的成员变量name了，而是去访问你的成员方法enjoy了。首先是使用Lady对象的引用l1去调用Lady对象的myPetEnjoy()方法，myPetEnjoy()方法定义如下：</p>
<p>public void myPetEnjoy(){</p>
<p>pet.enjoy();</p>
<p>｝</p>
<p>然后在myPetEnjoy()方法体里面又使用pet引用对象去调用父类对象里面的enjoy方法。</p>
<p><strong>方法是放在代码区(code seg)里面的，里面的方法就是一句句代码。<strong>因此当</strong>使用pet引用去访问父类对象的方法时，首先是找到这个父类对象，然后看看它里面的方法到底在哪里存着，找到那个方法再去执行</strong>。这里头就比较有意思了，code seg里面有很多个enjoy方法，有父类的enjoy()方法，也有子类重写了从父类继续下来的enjoy()方法，那么调用的时候到底调用的是哪一个呢？是根据谁来确定呢？注意：这是根据你实际当中的对象来确定的，你实际当中new出来的是谁，就调用谁的enjoy方法，当你找这个方法的时候，通过pet引用能找得到这个方法，但调用代码区里面的哪一个enjoy方法不是通过引用类型来确定的，如果是通过引用类型pet来确定，那么调用的肯定是Animal的enjoy()方法，可是现在是根据实际的类型来确定，我们的程序运行以后才在堆内存里面创建出一只Cat，然后根据你实际当中new出来的类型来判断我到底应该调用哪一个enjoy()方法。如果是根据实际类型，那么调用的就应该是Cat的enjoy()方法。如果是根据引用类型，那么调用的就应该是Animal的enjoy()方法。现在动态绑定这种机制指的是实际当中new的是什么类型，就调用谁的enjoy方法。所以说虽然你是根据我父类里面的enjoy方法来调用，可是实际当中却是你new的是谁调用的就是谁的enjoy()方法。即实际当中调用的却是子类里面重写后的那个enjoy方法。当然，讲一点更深的机制，你实际当中找这个enjoy方法的时候，在父类对象的内部有一个enjoy方法的指针，指针指向代码区里面父类的Animal的enjoy方法，只不过当你new这个对象的时候，这个指针随之改变，你new的是什么对象，这个指针就指向这个对象重写后的那个enjoy方法，所以这就叫做动态绑定。只有在动起来的时候，也就是在程序运行期间，new出了这个对象了以后你才能确定到底要调用哪一个方法。我实际当中的地址才会绑定到相应的方法的地址上面，所以叫动态绑定。调这个方法的时候，只要你这个方法重写了，实际当中调哪一个，要看你实际当中new的是哪个对象，这就叫多态，也叫动态绑定。<strong>动态绑定带来莫大的好处是使程序的可扩展性达到了最好</strong>，我们原来做这个可扩展性的时候，首先都是要在方法里面判断一下这只动物是哪一类里面的动物，通过if (object instanceof class)这样的条件来判断这个new出来的对象到底是属于哪一个类里面的，如果是一只猫，就调用猫的enjoy方法，如果是一条狗，就调用狗的enjoy方法。如果我现在增加了一个Bird类，那么扩展的时候，你又得在方法里面写判断这只鸟属于哪一个类然后才能调用这只鸟的enjoy方法。每增加一个对象，你都要在方法里面增加一段判断这个对象到底属于哪个类里面的代码然后才能执行这个对象相应的方法。即每增加一个新的对象，都要改变方法里面的处理代码，而现在，你不需要再改变方法里面的处理代码了，因为有了动态绑定。你要增加哪一个对象，你实际当中把这个对象new出来就完了，不再用去修改对象的处理方法里面的代码了。也就是当你实际当中要增加别的东西的时候，很简单，你直接加上去就成了，不用去改原来的结构，你要在你们家大楼的旁边盖一个厨房，很简单，直接在旁边一盖就行了，大楼的主要支柱什么的你都不用动，这就可以让可扩展性达到了极致，这就为将来的可扩展打下了基础，<strong>也只有动态绑定（多态）这种机制能帮助我们做到这一点——让程序的可扩展性达到极致。因此动态绑定是面向对象的核心，如果没有动态绑定，那么面向对象绝对不可能发展得像现在这么流行，所以动态绑定是面向对象核心中的核心。</strong></p>
<p>**总结动态绑定（多态）：动态绑定是指在“执行期间”（而非编译期间）判断所引用的实际对象类型，根据其实际的类型调用其相应的方法。**所以实际当中找要调用的方法时是动态的去找的，new的是谁就找谁的方法，这就叫动态绑定。动态绑定帮助我们的程序的可扩展性达到了极致。</p>
<p><strong>多态的存在有三个必要的条件：</strong></p>
<ol>
<li><strong>要有继承（两个类之间存在继承关系，子类继承父类）</strong></li>
<li><strong>要有重写（在子类里面重写从父类继承下来的方法）</strong></li>
<li><strong>父类引用指向子类对象</strong></li>
</ol>
<p>这三个条件一旦满足，当你调用父类里面被重写的方法的时候，实际当中new的是哪个子类对象，就调用子类对象的方法（这个方法是从父类继承下来后重写后的方法）。</p>
<p>面向对象比较强调类和类之间，对象和对象之间的一种组织关系，如果能把这种组织关系组织得比较好的话，你的程序想扩展性比较好，比较健壮，维护性比较好这些都可以达到，关键看你的设计到底好还是不好。</p>
]]></content>
    </entry>
</feed>