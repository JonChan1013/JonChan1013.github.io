<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jonchan1013.github.io</id>
    <title>CY的学习博客</title>
    <updated>2020-07-08T09:24:37.508Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jonchan1013.github.io"/>
    <link rel="self" href="https://jonchan1013.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://jonchan1013.github.io/images/avatar.png</logo>
    <icon>https://jonchan1013.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, CY的学习博客</rights>
    <entry>
        <title type="html"><![CDATA[MongoDB]]></title>
        <id>https://jonchan1013.github.io/post/mongodb/</id>
        <link href="https://jonchan1013.github.io/post/mongodb/">
        </link>
        <updated>2020-07-08T09:19:58.000Z</updated>
        <summary type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200708172130.png" alt="" loading="lazy"></figure>
<h2 id="1-mongodb-简介">1、MongoDB 简介</h2>
<h3 id="11-什么是-mongodb">1.1 什么是 MongoDB</h3>
<p>MongoDB 是一个基于分布式文件存储的数据库。由 C++语言编写。在为 WEB 应用提供可扩展的高性能数据存储解决方案。</p>
]]></summary>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200708172130.png" alt="" loading="lazy"></figure>
<h2 id="1-mongodb-简介">1、MongoDB 简介</h2>
<h3 id="11-什么是-mongodb">1.1 什么是 MongoDB</h3>
<p>MongoDB 是一个基于分布式文件存储的数据库。由 C++语言编写。在为 WEB 应用提供可扩展的高性能数据存储解决方案。</p>
<!-- more -->
<p>MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。它支持的数据结构非常松散，是类似json 的bson 格式，因此可以存储比较复杂的数据类型。Mongo 最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redis]]></title>
        <id>https://jonchan1013.github.io/post/redis/</id>
        <link href="https://jonchan1013.github.io/post/redis/">
        </link>
        <updated>2020-07-07T08:30:47.000Z</updated>
        <summary type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200707163549.png" alt="" loading="lazy"></figure>
<h2 id="1-redis-介绍">1、Redis 介绍</h2>
<h3 id="11-redis-简介">1.1 Redis 简介</h3>
<p>​		<strong>Remote Dictionary Server(Redis)是一个开源的使用 ANSI C 语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库，并提供多种语言的 API。</strong><br>
​		它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Map),列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p>
]]></summary>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200707163549.png" alt="" loading="lazy"></figure>
<h2 id="1-redis-介绍">1、Redis 介绍</h2>
<h3 id="11-redis-简介">1.1 Redis 简介</h3>
<p>​		<strong>Remote Dictionary Server(Redis)是一个开源的使用 ANSI C 语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库，并提供多种语言的 API。</strong><br>
​		它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Map),列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p>
<!-- more -->
<h3 id="12-redis-的特点">1.2 Redis 的特点</h3>
<ol>
<li>支持多种数据结构，如 string(字符串)、 list(双向链表)、dict(hash 表)、set(集合)、zset(排序 set)、hyperloglog(基数估算)</li>
<li>支持持久化操作，可以进行 aof 及 rdb 数据持久化到磁盘，从而进行数据备份或数据恢复等操作，较好的防止数据丢失的手段。</li>
<li>支持通过 Replication 进行数据复制，通过 master-slave 机制，可以实时进行数据的同步复制，支持多级复制和增量复制，master-slave 机制是 Redis 进行 HA 的重要手段。</li>
<li><strong>单进程</strong>请求，所有命令串行执行，并发情况下不需要考虑数据一致性问题。</li>
</ol>
<h2 id="2-安装-redis-单机版">2、安装 Redis 单机版</h2>
<p>第一步 需要在 linux 系统中安装 gcc<br>
命令：yum install -y gcc-c++<br>
第二步 需要将下载好的 redis 压缩包添加到 linux 服务器中<br>
版本：redis-3.0.0.tar.gz<br>
redis 的版本：<strong>副版本号奇数版本号是测试版，不建议在生产环境中使用。</strong><br>
<strong>偶数版本时稳定版建议在生产环境中使用。</strong><br>
<strong>3.0 版本更新比较大。集成了集群技术</strong></p>
<p>第三步 解压压缩包<br>
命令：tar -zxvf redis......</p>
<p>第四步 编译 redis<br>
命令：进入 redis 的解压完毕的根目录下 执行命令：make</p>
<p>第五步 安装 redis<br>
命 令 ： 进 入 redis 的 解 压 完 毕 的 根 目 录 下 ， 执 行 命 令 ： make install<br>
PREFIX=/usr/local/redis</p>
<p>第六步：启动 redis</p>
<p><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200707170241.png" alt="" loading="lazy">1）前端启动<br>
在 bin 目录下执行命令： ./redis-server （ctrl+c）退出 redis</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200707170339.png" alt="" loading="lazy"></figure>
<p>2)修改拷贝过来的 redis.conf 配置文件<br>
命令：vim redis.conf<br>
将 daemonize no 改为 yes</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200707170910.png" alt="" loading="lazy"></figure>
<p>(3)启动 redis<br>
在 bin 目录下执行命令：./redis-server redis.conf</p>
<p>(4)查看 redis 启动是否成功<br>
输入命令：ps aux|grep redis</p>
<ol start="5">
<li>关闭 redis 的命令<br>
./redis-cli shutdown</li>
</ol>
<p>第七步：测试 redis<br>
在 bin 目录下启动 redis 自带的客户端 ./redis-cli<br>
常见 redis 命令：<br>
ping---&gt;pong</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200707171333.png" alt="" loading="lazy"></figure>
<h2 id="3-redis-数据类型">3、Redis 数据类型</h2>
<h3 id="31-string字符串">3.1 String(字符串)</h3>
<p>Redis 字符串是字节序列。Redis 字符串是二进制安全的，这意味着他们有一个已知的长度没有任何特殊字符终止，所以你可以存储任何东西，512 兆为上限</p>
<p>示例：<br>
redis 127.0.0.1:6379&gt; set name kevin<br>
OK<br>
redis 127.0.0.1:6379&gt; get name<br>
&quot;kevin&quot;</p>
<p>incr 让当前键值以 1 的数量递增，并返回递增后的值<br>
incrby 可以指定参数一次增加的数值，并返回递增后的值<br>
decr 让当前键值以 1 的数量递减 并返回递减后的值<br>
decrby 可以指定参数一次递减的数值，并返回递减后的值<br>
incrbyfloat 可以递增一个双精度浮点数<br>
append 作用是向键值的末尾追加 value。如果键不存在则将该键的值设置为 value。返<br>
回值是追加后字符串的总长度。<br>
mget/mset 作用与 get/set 相似，不过 mget/mset 可以同时获得/设置多个键的键值<br>
del 根据 key 来删除 value<br>
flushdb 清除当前库的所有数据</p>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200707172641.png" alt="" loading="lazy"></figure>
<h3 id="32-hashhash-表">3.2 Hash(hash 表)</h3>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200707173524.png" alt="" loading="lazy"></figure>
<p>Redis 的哈希是键值对的集合。 Redis 的哈希值是字符串字段和字符串值之间的映射，因此它们被用来表示对象<br>
示例：<br>
redis 127.0.0.1:6379&gt; hset key field value<br>
OK<br>
redis 127.0.0.1:6379&gt; hget key field<br>
value<br>
hset 存储一个哈希键值对的集合<br>
hset key field value</p>
<p>hget 获取一个哈希键的值<br>
hget key field</p>
<p>hmset 存储一个或多个哈希是键值对的集合<br>
hmset key field1 value1 ......fieldN keyN</p>
<p>hmget 获取多个指定的键的值<br>
hmget key field1 ... fieldN</p>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200707173657.png" alt="" loading="lazy"></figure>
<h3 id="33-list链表">3.3  List(链表)</h3>
<figure data-type="image" tabindex="8"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200707220524.png" alt="" loading="lazy"></figure>
<p>Redis 的链表是简单的字符串列表，排序插入顺序。您可以添加元素到 Redis 的列表的<br>
头部或尾部<br>
示例：<br>
redis 127.0.0.1:6379&gt; lpush tutoriallist redis<br>
(integer) 1<br>
redis 127.0.0.1:6379&gt; lpush tutoriallist mongodb<br>
(integer) 2<br>
redis 127.0.0.1:6379&gt; lpush tutoriallist rabitmq<br>
(integer) 3<br>
redis 127.0.0.1:6379&gt; lrange tutoriallist 0 10</p>
<ol>
<li>&quot;rabitmq&quot;</li>
<li>&quot;mongodb&quot;</li>
<li>&quot;redis<br>
lpush key value 向链表左侧添加<br>
rpush key value 向链表右侧添加<br>
lpop key 从左边移出一个元素<br>
rpop key 从右边移出一个元素</li>
</ol>
<figure data-type="image" tabindex="9"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200707222122.png" alt="" loading="lazy"></figure>
<p>llen key 返回链表中元素的个数 相当于关系型数据库中 select count(*)<br>
lrange key start end lrange 命令将返回索引从 start 到 stop 之间的所有元素。Redis 的列表起始索引为 0。<br>
lrange 也支持负索引 lrange nn -2 -1 如 -1 表示最右边第一个元素 -2 表示最右边第二个元素，依次类推。<br>
lindex key indexnumber 如果要将列表类型当做数组来用，lindex 命令是必不可少的。<br>
lindex 命令用来返回指定索引的元素，索引从 0 开始，如果是负数表示从右边开始计算的索引，最右边元素的索引是-1。<br>
Lset key indexnumber value 是另一个通过索引操作列表的命令，它会将索引为 index的元素赋值为 value。</p>
<figure data-type="image" tabindex="10"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200707222706.png" alt="" loading="lazy"></figure>
<h3 id="34-set集合">3.4 Set(集合)</h3>
<figure data-type="image" tabindex="11"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200707223508.png" alt="" loading="lazy"></figure>
<p>Redis 的集合是字符串的无序不重复集合。<br>
示例：<br>
redis 127.0.0.1:6379&gt; sadd tutoriallist redis<br>
(integer) 1<br>
redis 127.0.0.1:6379&gt; sadd tutoriallist mongodb<br>
(integer) 1<br>
redis 127.0.0.1:6379&gt; sadd tutoriallist rabitmq<br>
(integer) 1<br>
redis 127.0.0.1:6379&gt; sadd tutoriallist rabitmq<br>
(integer) 0<br>
redis 127.0.0.1:6379&gt; smembers tutoriallist</p>
<ol>
<li>&quot;rabitmq&quot;</li>
<li>&quot;mongodb&quot;</li>
<li>&quot;redis&quot;</li>
</ol>
<p>sadd key value 添加一个 string 元素到,key 对应的 set 集合中，成功返回 1,如果元素已经在集合中返回 0<br>
scard key 返回 set 的元素个数，如果 set 是空或者 key 不存在返回 0<br>
smembers key 返回 key 对应 set 的所有元素，结果是无序的<br>
sismember key value 判断 value 是否在 set 中，存在返回 1，0 表示不存在或者 key 不存在<br>
srem key value 从 key 对应 set 中移除给定元素，成功返回 1，如果 value 在集合中不存在或者 key 不存在返回 0</p>
<figure data-type="image" tabindex="12"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200707223554.png" alt="" loading="lazy"></figure>
<h3 id="35-sortedset有序集合zset">3.5  SortedSet(有序集合)zset</h3>
<p>Redis 的有序集合类似于 Redis 的集合，字符串不重复的集合。<br>
示例：<br>
redis 127.0.0.1:6379&gt; zadd tutoriallist 0 redis<br>
(integer) 1<br>
redis 127.0.0.1:6379&gt; zadd tutoriallist 0 mongodb<br>
(integer) 1<br>
redis 127.0.0.1:6379&gt; zadd tutoriallist 0 rabitmq<br>
(integer) 1<br>
redis 127.0.0.1:6379&gt; zadd tutoriallist 0 rabitmq<br>
(integer) 0<br>
redis 127.0.0.1:6379&gt; ZRANGEBYSCORE tutoriallist 0 1000</p>
<ol>
<li>&quot;redis&quot;</li>
<li>&quot;mongodb&quot;</li>
<li>&quot;rabitmq&quot;</li>
</ol>
<p>zadd key score value 将一个或多个 value 及其 socre 加入到 set 中<br>
zrange key start end 0 和-1 表示从索引为 0 的元素到最后一个元素（同 LRANGE 命令相似）</p>
<p>zrange key 0 -1 withscores 也可以连同 score 一块输出，使用 WITHSCORES 参数<br>
zremrangebyscore key start end 可用于范围删除操作</p>
<figure data-type="image" tabindex="13"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200707224101.png" alt="" loading="lazy"></figure>
<h3 id="36-redis-中的其他命令">3.6 Redis 中的其他命令</h3>
<p>ping 测试 redis 是否链接 如果已链接返回 PONG<br>
echo value 测试 redis 是否链接 如果已链接返回 echo 命令后给定的值<br>
keys * 返回所有的 key 可以加*通配<br>
exists key 判断 string 类型一个 key 是否存在 如果存在返回 1 否则返回 0<br>
expire key time(s) 设置一个 key 的过期时间 单位秒。时间到达后会删除 key 及 value<br>
ttl key 查询已设置过期时间的 key 的剩余时间 如果返回-2 表示该键值对已经被删除<br>
persist 移除给定 key 的过期时间<br>
select dbindex 选择数据库(0-15)<br>
move key dbIndex 将当前数据库中的 key 转移到其他数据库中<br>
dbsize 返回当前数据库中的 key 的数目<br>
info 获取服务器的信息和统计<br>
flushdb 删除当前选择的数据库中的 key<br>
flushall 删除所有数据库中的所有 key<br>
quit 退出连接</p>
<h2 id="4-redis-的配置以及持久化方案">4、Redis 的配置以及持久化方案</h2>
<h3 id="41-redisconf-文件">4.1 redis.conf 文件</h3>
<pre><code class="language-properties">#redis.conf
# Redis configuration file example.
# ./redis-server /path/to/redis.conf
################################## INCLUDES
###################################
#这在你有标准配置模板但是每个 redis 服务器又需要个性设置的时候很有用。
# include /path/to/local.conf
# include /path/to/other.conf
################################ GENERAL #####################################
#是否在后台执行，yes：后台运行；no：不是后台运行（老版本默认）
daemonize yes
#3.2 里的参数，是否开启保护模式，默认开启。要是配置里没有指定 bind 和密码。开启该参数后，redis只会本地进行访问，拒绝外部访问。要是开启了密码 和 bind，可以开启。否 则最好关闭，设置为no。
protected-mode yes
#redis 的进程文件
pidfile /var/run/redis/redis-server.pid
#redis 监听的端口号。
port 6379
#此参数确定了 TCP 连接中已完成队列(完成三次握手之后)的长度， 当然此值必须不大于 Linux 系统定
义的/proc/sys/net/core/somaxconn 值，默认是 511，而 Linux 的默认参数值是 128。当系统并发量大并且客户端速度缓慢的时候，可以将这二个参数一起参考设定。该内核参数默认值一般是 128，对于负载很大的服务程序来说大大的不够。一般会将它修改为 2048 或者更大。在/etc/sysctl.conf 中添加:net.core.somaxconn = 2048，然后在终端中执行 sysctl -p。
tcp-backlog 511
#指定 redis 只接收来自于该 IP 地址的请求，如果不进行设置，那么将处理所有请求
#bind 127.0.0.1
#配置 unix socket 来让 redis 支持监听本地连接。
# unixsocket /var/run/redis/redis.sock
#配置 unix socket 使用文件的权限
# unixsocketperm 700
# 此参数为设置客户端空闲超过 timeout，服务端会断开连接，为 0 则服务端不会主动断开连接，不能小于 0。
timeout 0
#tcp keepalive 参数。如果设置不为 0，就使用配置 tcp 的 SO_KEEPALIVE 值，使用 keepalive 有两个好处:检测挂掉的对端。降低中间设备出问题而导致网络看似连接却已经与对端端口的问题。在 Linux内核中，设置了 keepalive，redis 会定时给对端发送 ack。检测到对端关闭需要两倍的设置值。
tcp-keepalive 0
#指定了服务端日志的级别。级别包括：debug（很多信息，方便开发、测试），verbose（许多有用的信息，但是没有 debug 级别信息多），notice（适当的日志级别，适合生产环境），warn（只有非常重要的信息）
loglevel notice
#指定了记录日志的文件。空字符串的话，日志会打印到标准输出设备。后台运行的 redis 标准输出是/dev/null。
logfile /var/log/redis/redis-server.log
#是否打开记录 syslog 功能
# syslog-enabled no
#syslog 的标识符。
# syslog-ident redis
#日志的来源、设备
# syslog-facility local0
#数据库的数量，默认使用的数据库是 DB 0。可以通过”SELECT “命令选择一个 db
databases 16
################################ SNAPSHOTTING ################################
# 快照配置
# 注释掉“save”这一行配置项就可以让保存数据库功能失效
# 设置 sedis 进行数据库镜像的频率。
# 900 秒（15 分钟）内至少 1 个 key 值改变（则进行数据库保存--持久化）
# 300 秒（5 分钟）内至少 10 个 key 值改变（则进行数据库保存--持久化）
# 60 秒（1 分钟）内至少 10000 个 key 值改变（则进行数据库保存--持久化）
save 900 1
save 300 10
save 60 10000
#当 RDB 持久化出现错误后，是否依然进行继续进行工作，yes：不能进行工作，no：可以继续进行工作，可以通过 info 中的 rdb_last_bgsave_status 了解 RDB 持久化是否有错误
stop-writes-on-bgsave-error yes
#使用压缩 rdb 文件，rdb 文件压缩使用 LZF 压缩算法，yes：压缩，但是需要一些 cpu 的消耗。no：不压缩，需要更多的磁盘空间
rdbcompression yes
#是否校验 rdb 文件。从 rdb 格式的第五个版本开始，在 rdb 文件的末尾会带上 CRC64 的校验和。这跟有利于文件的容错性，但是在保存 rdb 文件的时候，会有大概 10%的性能损耗，所以如果你追求高性能，可以关闭该配置。
rdbchecksum yes
#rdb 文件的名称
dbfilename dump.rdb
#数据目录，数据库的写入会在这个目录。rdb、aof 文件也会写在这个目录
dir /root/temp
################################# REPLICATION
#################################
#复制选项，slave 复制对应的 master。
# slaveof &lt;masterip&gt; &lt;masterport&gt;
#如果 master 设置了 requirepass，那么 slave 要连上 master，需要有 master 的密码才行。
masterauth 就是用来配置 master 的密码，这样可以在连上 master 后进行认证。
# masterauth &lt;master-password&gt;
#当从库同主机失去连接或者复制正在进行，从机库有两种运行方式：1) 如果slave-serve-stale-data 设置为 yes(默认设置)，从库会继续响应客户端的请求。2) 如果slave-serve-stale-data 设置为 no，除去 INFO 和 SLAVOF 命令之外的任何请求都会返回一个错误”SYNC with master in progress”。
slave-serve-stale-data yes
#作为从服务器，默认情况下是只读的（yes），可以修改成 NO，用于写（不建议）。
slave-read-only yes
#是否使用 socket 方式复制数据。目前 redis 复制提供两种方式，disk 和 socket。如果新的 slave连上来或者重连的 slave 无法部分同步，就会执行全量同步，master 会生成 rdb 文件。有 2 种方式：disk 方式是 master 创建一个新的进程把 rdb 文件保存到磁盘，再把磁盘上的 rdb 文件传递给 slave。socket 是 master 创建一个新的进程，直接把 rdb 文件以 socket 的方式发给 slave。disk 方式的时候，当一个 rdb 保存的过程中，多个 slave 都能共享这个 rdb 文件。socket 的方式就的一个个 slave顺序复制。在磁盘速度缓慢，网速快的情况下推荐用 socket 方式。
repl-diskless-sync no
#diskless 复制的延迟时间，防止设置为 0。一旦复制开始，节点不会再接收新 slave 的复制请求直到下一个 rdb 传输。所以最好等待一段时间，等更多的 slave 连上来。
repl-diskless-sync-delay 5
#slave 根据指定的时间间隔向服务器发送 ping 请求。时间间隔可以通过repl_ping_slave_period来设置，默认 10 秒。
# repl-ping-slave-period 10
#复制连接超时时间。master 和 slave 都有超时时间的设置。master 检测到 slave 上次发送的时间超过 repl-timeout，即认为 slave 离线，清除该 slave 信息。slave 检测到上次和 master 交互的时间超过 repl-timeout，则认为 master 离线。需要注意的是 repl-timeout 需要设置一个比repl-ping-slave-period 更大的值，不然会经常检测到超时。
# repl-timeout 60
#是否禁止复制 tcp 链接的 tcp nodelay 参数，可传递 yes 或者 no。默认是 no，即使用 tcp nodelay。如果 master 设置了 yes 来禁止 tcp nodelay 设置，在把数据复制给 slave 的时候，会减少包的数量和更小的网络带宽。但是这也可能带来数据的延迟。默认我们推荐更小的延迟，但是在数据量传输很大的场景下，建议选择 yes。
repl-disable-tcp-nodelay no
#复制缓冲区大小，这是一个环形复制缓冲区，用来保存最新复制的命令。这样在 slave 离线的时候，不需要完全复制 master 的数据，如果可以执行部分同步，只需要把缓冲区的部分数据复制给 slave，就能恢复正常复制状态。缓冲区的大小越大，slave 离线的时间可以更长，复制缓冲区只有在有 slave 连接的时候才分配内存。没有 slave 的一段时间，内存会被释放出来，默认 1m。
# repl-backlog-size 5mb
#master 没有 slave 一段时间会释放复制缓冲区的内存，repl-backlog-ttl 用来设置该时间长度。
单位为秒。
# repl-backlog-ttl 3600
#当 master 不可用，Sentinel 会根据 slave 的优先级选举一个 master。最低的优先级的 slave，当选 master。而配置成 0，永远不会被选举。
slave-priority 100
#redis 提供了可以让 master 停止写入的方式，如果配置了 min-slaves-to-write，健康的 slave的个数小于 N，mater 就禁止写入。master 最少得有多少个健康的 slave 存活才能执行写命令。这个配置虽然不能保证 N 个 slave 都一定能接收到 master 的写操作，但是能避免没有足够健康的 slave 的时候，master 不能写入来避免数据丢失。设置为 0 是关闭该功能。
# min-slaves-to-write 3
#延迟小于 min-slaves-max-lag 秒的 slave 才认为是健康的 slave。
# min-slaves-max-lag 10
# 设置 1 或另一个设置为 0 禁用这个特性。
# Setting one or the other to 0 disables the feature.
# By default min-slaves-to-write is set to 0 (feature disabled) and
# min-slaves-max-lag is set to 10.
################################## SECURITY
###################################
#requirepass 配置可以让用户使用 AUTH 命令来认证密码，才能使用其他命令。这让 redis 可以使用在不受信任的网络中。为了保持向后的兼容性，可以注释该命令，因为大部分用户也不需要认证。使用requirepass 的时候需要注意，因为 redis 太快了，每秒可以认证 15w 次密码，简单的密码很容易被攻破，所以最好使用一个更复杂的密码。
# requirepass foobared
#把危险的命令给修改成其他名称。比如 CONFIG 命令可以重命名为一个很难被猜到的命令，这样用户不能使用，而内部工具还能接着使用。
# rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52
#设置成一个空的值，可以禁止一个命令
# rename-command CONFIG &quot;&quot;
################################### LIMITS
####################################
# 设置能连上 redis 的最大客户端连接数量。默认是 10000 个客户端连接。由于 redis 不区分连接是客户端连接还是内部打开文件或者和 slave 连接等，所以 maxclients 最小建议设置到 32。如果超过了maxclients，redis 会给新的连接发送’max number of clients reached’，并关闭连接。
# maxclients 10000
#redis 配置的最大内存容量。当内存满了，需要配合 maxmemory-policy 策略进行处理。注意 slave的输出缓冲区是不计算在 maxmemory 内的。所以为了防止主机内存使用完，建议设置的 maxmemory 需要更小一些。
# maxmemory &lt;bytes&gt;
#内存容量超过 maxmemory 后的处理策略。
#volatile-lru：利用 LRU 算法移除设置过过期时间的 key。
#volatile-random：随机移除设置过过期时间的 key。
#volatile-ttl：移除即将过期的 key，根据最近过期时间来删除（辅以 TTL）
#allkeys-lru：利用 LRU 算法移除任何 key。
#allkeys-random：随机移除任何 key。
#noeviction：不移除任何 key，只是返回一个写错误。
#上面的这些驱逐策略，如果 redis 没有合适的 key 驱逐，对于写命令，还是会返回错误。redis 将不再接收写请求，只接收 get 请求。写命令包括：set setnx setex append incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby getset mset msetnx exec sort。
# maxmemory-policy noeviction
#lru 检测的样本数。使用 lru 或者 ttl 淘汰算法，从需要淘汰的列表中随机选择 sample 个 key，选出闲置时间最长的 key 移除。
# maxmemory-samples 5
############################## APPEND ONLY MODE ###############################
#默认 redis 使用的是 rdb 方式持久化，这种方式在许多应用中已经足够用了。但是 redis 如果中途宕机，会导致可能有几分钟的数据丢失，根据 save 来策略进行持久化，Append Only File 是另一种持久化方式，可以提供更好的持久化特性。Redis 会把每次写入的数据在接收后都写入 appendonly.aof文件，每次启动时 Redis 都会先把这个文件的数据读入内存里，先忽略 RDB 文件。
appendonly no
#aof 文件名
appendfilename &quot;appendonly.aof&quot;
#aof 持久化策略的配置
#no 表示不执行 fsync，由操作系统保证数据同步到磁盘，速度最快。
#always 表示每次写入都执行 fsync，以保证数据同步到磁盘。
#everysec 表示每秒执行一次 fsync，可能会导致丢失这 1s 数据。
appendfsync everysec
# 在 aof 重写或者写入 rdb 文件的时候，会执行大量 IO，此时对于everysec 和 always 的 aof 模式来说，执行 fsync 会造成阻塞过长时间，no-appendfsync-on-rewrite 字段设置为默认设置为 no。如果对延迟要求很高的应用，这个字段可以设置为 yes，否则还是设置为 no，这样对持久化特性来说这是更安全的选择。设置为 yes 表示 rewrite 期间对新写操作不 fsync,暂时存在内存中,等 rewrite 完成后再写入，默认为 no，建议 yes。Linux 的默认 fsync 策略是 30 秒。可能丢失 30 秒数据。
no-appendfsync-on-rewrite no
#aof 自动重写配置。当目前 aof 文件大小超过上一次重写的 aof 文件大小的百分之多少进行重写，即当aof 文件增长到一定大小的时候 Redis 能够调用 bgrewriteaof 对日志文件进行重写。当前 AOF 文件大小是上次日志重写得到 AOF 文件大小的二倍（设置为 100）时，自动启动新的日志重写过程。
auto-aof-rewrite-percentage 100
#设置允许重写的最小 aof 文件大小，避免了达到约定百分比但尺寸仍然很小的情况还要重写
auto-aof-rewrite-min-size 64mb
#aof 文件可能在尾部是不完整的，当 redis 启动的时候，aof 文件的数据被载入内存。重启可能发生在redis 所在的主机操作系统宕机后，尤其在 ext4 文件系统没有加上 data=ordered 选项（redis 宕机或者异常终止不会造成尾部不完整现象。）出现这种现象，可以选择让 redis 退出，或者导入尽可能多的数据。如果选择的是 yes，当截断的 aof 文件被导入的时候，会自动发布一个 log 给客户端然后 load。如果是 no，用户必须手动 redis-check-aof 修复 AOF 文件才可以。
aof-load-truncated yes
################################ LUA SCRIPTING ###############################
# 如果达到最大时间限制（毫秒），redis 会记个 log，然后返回 error。当一个脚本超过了最大时限。只有 SCRIPT KILL 和 SHUTDOWN NOSAVE 可以用。第一个可以杀没有调 write 命令的东西。要是已经调用了 write，只能用第二个命令杀。
lua-time-limit 5000
################################ REDIS CLUSTER ###############################
#集群开关，默认是不开启集群模式。
# cluster-enabled yes
#集群配置文件的名称，每个节点都有一个集群相关的配置文件，持久化保存集群的信息。这个文件并不需要手动配置，这个配置文件有 Redis 生成并更新，每个 Redis 集群节点需要一个单独的配置文件，请确保与实例运行的系统中配置文件名称不冲突
# cluster-config-file nodes-6379.conf
#节点互连超时的阀值。集群节点超时毫秒数
# cluster-node-timeout 15000
#在进行故障转移的时候，全部 slave 都会请求申请为 master，但是有些 slave 可能与 master 断开连接一段时间了，导致数据过于陈旧，这样的 slave 不应该被提升为 master。该参数就是用来判断 slave节点与 master 断线的时间是否过长。判断方法是：
#比较 slave 断开连接的时间和(node-timeout * slave-validity-factor) +
repl-ping-slave-period
#如果节点超时时间为三十秒, 并且 slave-validity-factor 为 10,假设默认的repl-ping-slave-period 是 10 秒，即如果超过 310 秒 slave 将不会尝试进行故障转移
# cluster-slave-validity-factor 10
#master 的 slave 数量大于该值，slave 才能迁移到其他孤立 master 上，如这个参数若被设为 2，那么只有当一个主节点拥有 2 个可工作的从节点时，它的一个从节点会尝试迁移。
# cluster-migration-barrier 1
#默认情况下，集群全部的 slot 有节点负责，集群状态才为 ok，才能提供服务。设置为 no，可以在 slot没有全部分配的时候提供服务。不建议打开该配置，这样会造成分区的时候，小分区的 master 一直在接受写请求，而造成很长时间数据不一致。
# cluster-require-full-coverage yes
################################## SLOW LOG
###################################
###slog log 是用来记录 redis 运行中执行比较慢的命令耗时。当命令的执行超过了指定时间，就记录在 slow log 中，slog log 保存在内存中，所以没有 IO 操作。
#执行时间比 slowlog-log-slower-than 大的请求记录到 slowlog 里面，单位是微秒，所以 1000000就是 1 秒。注意，负数时间会禁用慢查询日志，而 0 则会强制记录所有命令。
slowlog-log-slower-than 10000
#慢查询日志长度。当一个新的命令被写进日志的时候，最老的那个记录会被删掉。这个长度没有限制。只要有足够的内存就行。你可以通过 SLOWLOG RESET 来释放内存。
slowlog-max-len 128
################################ LATENCY MONITOR
##############################
#延迟监控功能是用来监控 redis 中执行比较缓慢的一些操作，用 LATENCY 打印 redis 实例在跑命令时的耗时图表。只记录大于等于下边设置的值的操作。0 的话，就是关闭监视。默认延迟监控功能是关闭的，如果你需要打开，也可以通过 CONFIG SET 命令动态设置。
latency-monitor-threshold 0
############################# EVENT NOTIFICATION
##############################
#键空间通知使得客户端可以通过订阅频道或模式，来接收那些以某种方式改动了 Redis 数据集的事件。因为开启键空间通知功能需要消耗一些 CPU ，所以在默认配置下，该功能处于关闭状态。
#notify-keyspace-events 的参数可以是以下字符的任意组合，它指定了服务器该发送哪些类型的通知：
##K 键空间通知，所有通知以 __keyspace@__ 为前缀
##E 键事件通知，所有通知以 __keyevent@__ 为前缀
##g DEL 、 EXPIRE 、 RENAME 等类型无关的通用命令的通知
##$ 字符串命令的通知
##l 列表命令的通知
##s 集合命令的通知
##h 哈希命令的通知
##z 有序集合命令的通知
##x 过期事件：每当有过期键被删除时发送
##e 驱逐(evict)事件：每当有键因为 maxmemory 政策而被删除时发送
##A 参数 g$lshzxe 的别名
#输入的参数中至少要有一个 K 或者 E，否则的话，不管其余的参数是什么，都不会有任何 通知被分发。详细使用可以参考 http://redis.io/topics/notifications
notify-keyspace-events &quot;&quot;
############################### ADVANCED CONFIG
###############################
#数据量小于等于 hash-max-ziplist-entries 的用 ziplist，大于 hash-max-ziplist-entries用 hash
hash-max-ziplist-entries 512 #value 大小小于等于 hash-max-ziplist-value 的用ziplist，大于 hash-max-ziplist-value 用 hash。
hash-max-ziplist-value 64
#数据量小于等于 list-max-ziplist-entries 用 ziplist，大于 list-max-ziplist-entries用 list。
list-max-ziplist-entries 512#value 大小小于等于 list-max-ziplist-value 的用ziplist，大于 list-max-ziplist-value 用 list。
list-max-ziplist-value 64
#数据量小于等于 set-max-intset-entries 用 iniset，大于 set-max-intset-entries 用 set。
set-max-intset-entries 512
#数据量小于等于 zset-max-ziplist-entries 用 ziplist，大于 zset-max-ziplist-entries用 zset。
zset-max-ziplist-entries 128#value 大小小于等于 zset-max-ziplist-value 用 ziplist，大于 zset-max-ziplist-value 用 zset。
zset-max-ziplist-value 64
#value 大小小于等于 hll-sparse-max-bytes 使用稀疏数据结构（sparse），大于hll-sparse-max-bytes 使用稠密的数据结构（dense）。一个比 16000 大的 value 是几乎没用的，建议的 value 大概为 3000。如果对 CPU 要求不高，对空间要求较高的，建议设置到 10000 左右。
hll-sparse-max-bytes 3000
#Redis 将在每 100 毫秒时使用 1 毫秒的 CPU 时间来对 redis 的 hash 表进行重新 hash，可以降低内存的使用。当你的使用场景中，有非常严格的实时性需要，不能够接受 Redis 时不时的对请求有 2 毫秒的延迟的话，把这项配置为 no。如果没有这么严格的实时性要求，可以设置为 yes，以便能够尽可能快的释放内存。
activerehashing yes
##对客户端输出缓冲进行限制可以强迫那些不从服务器读取数据的客户端断开连接，用来强制关闭传输缓慢的客户端。
#对于 normal client，第一个 0 表示取消 hard limit，第二个 0 和第三个 0 表示取消 soft limit，normal client 默认取消限制，因为如果没有寻问，他们是不会接收数据的。
client-output-buffer-limit normal 0 0 0#对于 slave client 和 MONITER client，如果client-output-buffer 一旦超过 256mb，又或者超过 64mb 持续 60 秒，那么服务器就会立即断开客户端连接。
client-output-buffer-limit slave 256mb 64mb 60#对于 pubsub client，如果client-output-buffer 一旦超过 32mb，又或者超过 8mb 持续 60 秒，那么服务器就会立即断开客户端连接。
client-output-buffer-limit pubsub 32mb 8mb 60
#redis 执行任务的频率为 1s 除以 hz。
hz 10
#在 aof 重写的时候，如果打开了 aof-rewrite-incremental-fsync 开关，系统会每 32MB 执行一次 fsync。这对于把文件写入磁盘是有帮助的，可以避免过大的延迟峰值。
aof-rewrite-incremental-fsync yes
</code></pre>
<h3 id="42-redis-的数据持久化">4.2 Redis 的数据持久化</h3>
<h4 id="421-rdb-方式">4.2.1 RDB 方式</h4>
<p>对内存中数据库状态进行快照<br>
RDB 方式：将 Redis 在内存中的数据库状态保存到磁盘里面，RDB 文件是一个经过压缩的二进制文件，通过该文件可以还原生成 RDB 文件时的数据库状态（默认下，持久化到dump.rdb 文件，并且在 redis 重启后，自动读取其中文件，据悉，通常情况下一千万的字符串类型键，1GB 的快照文件，同步到内存中的 时间是 20-30 秒）<br>
RDB 的生成方式：<br>
1）执行命令手动生成<br>
有两个 Redis 命令可以用于生成 RDB 文件，一个是 SAVE，另一个是 BGSAVE SAVE命令会阻塞 Redis 服务器进程，直到 RDB 文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求，BGSAVE 命令会派生出一个子进程，然后由子进程负责创建RDB 文件，服务器进程（父进程）继续处理命令请求，创建 RDB 文件结束之前，客户端发送的 BGSAVE 和 SAVE 命令会被服务器拒绝<br>
2）通过配置自动生成<br>
可以设置服务器配置的 save 选项，让服务器每隔一段时间自动执行一次 <strong>BGSAVE</strong> 命令，可以通过 save 选项设置多个保存条件，但只要其中任意一个条件被满足，服务器就会执行 BGSAVE 命令<br>
例如：<br>
save 900 1<br>
save 300 10<br>
save 60 10000<br>
那么只要满足以下三个条件中的任意一个，BGSAVE 命令就会被执行<br>
服务器在 900 秒之内，对数据库进行了至少 1 次修改<br>
服务器在 300 秒之内，对数据库进行了至少 10 次修改<br>
服务器在 60 秒之内，对数据库进行了至少 10000 次修改</p>
<h4 id="422-aof-方式">4.2.2 AOF 方式</h4>
<p>AOF 持久化方式在 redis 中默认是关闭的，需要修改配置文件开启该方式。<br>
AOF：把每条命令都写入文件，类似 mysql 的 binlog 日志<br>
AOF 方式：是通过保存 Redis 服务器所执行的写命令来记录数据库状态的文件。<br>
AOF 文件刷新的方式，有三种：<br>
appendfsync always - 每提交一个修改命令都调用 fsync 刷新到 AOF 文件，非常非常慢，但也非常安全<br>
appendfsync everysec - 每秒钟都调用 fsync 刷新到 AOF 文件，很快，但可能会丢失一秒以内的数据<br>
appendfsync no - 依靠 OS 进行刷新，redis 不主动刷新 AOF，这样最快，但安全性就差<br>
默认并推荐每秒刷新，这样在速度和安全上都做到了兼顾</p>
<p>AOF 数据恢复方式<br>
服务器在启动时，通过载入和执行 AOF 文件中保存的命令来还原服务器关闭之前的数据库状态，具体过程：</p>
<ul>
<li>载入 AOF 文件</li>
<li>创建模拟客户端</li>
<li>从 AOF 文件中读取一条命令</li>
<li>使用模拟客户端执行命令</li>
<li>循环读取并执行命令，直到全部完成</li>
<li>如果同时启用了 RDB 和 AOF 方式，AOF 优先，启动时只加载 AOF 文件恢复数据</li>
</ul>
<h2 id="5-安装-redis-集群">5、安装 Redis 集群</h2>
<h3 id="51-redis-集群介绍">5.1 Redis 集群介绍</h3>
<p>​		Redis3.0 版本之后支持 Cluster。<strong>集群要求集群节点中必须要支持主备模式，也就说集中的主节点(Master)至少要有一个从节点(Slave)</strong><br>
​		每一个蓝色的圈都代表着一个 redis 集群中的主节点。它们任何两个节点之间都是相互连通的。客户端可以与任何一个节点相连接，然后就可以访问集群中的任何一个节点。对其进行存取和其他操作</p>
<h4 id="511-redis-cluster-架构图">5.1.1 Redis-Cluster 架构图</h4>
<figure data-type="image" tabindex="14"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200708010154.png" alt="" loading="lazy"></figure>
<h4 id="512-redis-cluster-选举容错">5.1.2 Redis-Cluster 选举:容错</h4>
<p>​		Redis 之间通过互相的 ping-pong 判断是否节点可以连接上。如果有一半以上的节点去ping 一个节点的时候没有回应，集群就认为这个节点宕机了，然后去连接它的从节点。如果某个节点和所有从节点全部挂掉，我们集群就进入 fail 状态。还有就是如果有一半以上的主节点宕机，那么我们集群同样进入 fail 了状态。这就是我们的 redis 的投票机制，具体原理如下图所示：</p>
<figure data-type="image" tabindex="15"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200708010227.png" alt="" loading="lazy"></figure>
<p>投票过程是集群中所有 master 参与,如果半数以上 master 节点与 master 节点通信超时(cluster-node-timeout),认为当前 master 节点挂掉.<br>
什么时候整个集群不可用(cluster_state:fail)?</p>
<ol>
<li>如果集群任意 master 挂掉,且当前 master 没有 slave。此时集群进入 fail 状态,也可以理解成集群的 slot 映射[0-16383]不完整时进入 fail 状态。</li>
<li>如果集群超过半数以上 master 挂掉，无论是否有 slave，集群进入 fail 状态.</li>
</ol>
<h4 id="513-redis-cluster-数据存储">5.1.3 Redis-Cluster 数据存储</h4>
<p>​		当我们的存取的 key 到达的时候，redis 会根据 crc16 的算法得出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点，然后直接自动跳转到这个对应的节点上进行存取操作。</p>
<figure data-type="image" tabindex="16"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200708010312.png" alt="" loading="lazy"></figure>
<p>例如：在 Node1 执行 set name kevin</p>
<ol>
<li>使用 CRC16 算法对 key 进行计算，得到一个数字，然后对数字进行取余。<br>
CRC16 : name = 26384<br>
26384%16384 = 10000</li>
<li>查找到包含 10000 插槽的节点，比如是 node2，自动跳转到 node2</li>
<li>在 node2 上执行 set name kevin 命令完成数据的插入</li>
<li>如果在 node1 上执行 get name，先使用 CRC16 算法对 key 进行计算，在使用16384 取余，得到插槽的下标，然后跳到拥有该插槽的 node2 中执行 get name 命令，并返回结果。</li>
</ol>
<h3 id="52-安装集群">5.2 安装集群</h3>
<h4 id="521-需求">5.2.1 需求</h4>
<p>搭建一个 Redis 的最小集群，使用伪集群方式。<br>
Redis 中最小的集群三对主从。<br>
在 192.168.0.179 中安装 6 个 redis 实例。<br>
如果使用已经使用过的单机版创建集群时，需要删除 dump.rdb 与 apeendonly.aof 文件。<br>
6 个 redis 实例的端口分配：8001、8002、8003、8004、8005、8006</p>
<h4 id="522-集群步骤">5.2.2 集群步骤</h4>
<p>redis 集群时需要使用一个 ruby 的脚本来完成集群。</p>
<p>第一步 安装 ruby 环境<br>
命令： yum install ruby</p>
<p>第二步 安装 ruby 的包管理器<br>
命令：yum install rubygems</p>
<p>第三步 进入到 redis 的安装目录下的 src 目录下找到到 redis-trib.rb 这个文件 这是集群时需要的脚本</p>
<p>第四步 这个脚本的执行需要依赖于一些其他的 ruby 包 所以我们还要下载一个<br>
redis-3.0.0.gem<br>
将这个文件上传到 linux 服务器中</p>
<p>第五步 安装这个 ruby 包<br>
命令：gem install redis-3.0.0.gem</p>
<p>第六步 先启动 redis 的 6 个实例<br>
先在 local 目录下创建一个目录名称为：redis-cluster<br>
命令：mkdir redis-cluster</p>
<p>第七步 将安装好的 redis 下的 bin 目录拷贝到 redis-cluster 目录下 并起名为 redis01<br>
命令：进入到 redis 目录下执行：cp -r bin ../redis-cluster/redis01</p>
<p>第九步 修改 redis.conf 配置文件<br>
命令：vim redis.conf<br>
(1)修改端口：默认的为 6379 将六个 redis 实例的端口改成从 7001-7006 在配置文件<br>
的 port 属性中。<br>
(2)修改开启集群 在配置文件中搜索 cluster 找到后 将默认为注释的 cluster-enabled yes 去掉注释</p>
<p>第十步 将这个 redis01 拷贝 6 份到当前这个目录下<br>
命令：cp -r redis01/ redis02<br>
cp -r redis01/ redis03<br>
cp -r redis01/ redis04<br>
cp -r redis01/ redis05<br>
cp -r redis01/ redis06</p>
<p>第十一步 修改拷贝的这些 redis 的端口<br>
命令：<br>
[root@localhost redis-cluster]# vim redis02/redis.conf<br>
[root@localhost redis-cluster]# vim redis03/redis.conf<br>
[root@localhost redis-cluster]# vim redis04/redis.conf<br>
[root@localhost redis-cluster]# vim redis05/redis.conf<br>
[root@localhost redis-cluster]# vim redis06/redis.conf</p>
<figure data-type="image" tabindex="17"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200708011226.png" alt="" loading="lazy"></figure>
<p>第十二步 把创建集群的 ruby 脚本复制到 redis-cluster 中<br>
命令：[root@localhost src]# cp *.rb /usr/local/redis-cluster/</p>
<p>第十二步 创建一个能够批量启动的脚本程序<br>
命令：vim startall.sh</p>
<p>第十三步 在脚本文件中添加命令<br>
命令：</p>
<p>cd redis01<br>
./redis-server redis.conf<br>
cd ..<br>
cd redis02<br>
./redis-server redis.conf<br>
cd ..<br>
cd redis03<br>
./redis-server redis.conf<br>
cd ..<br>
cd redis04<br>
./redis-server redis.conf<br>
cd ..<br>
cd redis05<br>
./redis-server redis.conf<br>
cd ..<br>
cd redis06<br>
./redis-server redis.conf<br>
cd ..</p>
<p>第十四步 将批量启动脚本设置为可执行权限<br>
命令:chmod +x startall.sh</p>
<p>第十五步 执行这个批量启动的脚本<br>
命令：[root@localhost redis-cluster]# ./startall.sh</p>
<p>第十六步 查看 redis 是否启动成功<br>
命令：ps aux|grep redis</p>
<figure data-type="image" tabindex="18"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200708013049.png" alt="" loading="lazy"></figure>
<p>第十七步 创建集群<br>
命 令 ： ./redis-trib.rb create --replicas 1 192.168.0.179:8001 192.168.0.179:8002 192.168.0.179:8003 192.168.0.179:8004 192.168.0.179:8005 192.168.0.179:8006</p>
<figure data-type="image" tabindex="19"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200708013922.png" alt="" loading="lazy"></figure>
<p>如果控制台输出如下信息表集群成功</p>
<figure data-type="image" tabindex="20"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200708014103.png" alt="" loading="lazy"></figure>
<p>测试 Redis 集群<br>
测试 Redis 集群：可以连接集群中的任意一个节点进行测试 注意一定要有-c 参数，否则能连上，但是无法操作 redis 集群<br>
命令：[root@localhost redis-cluster]# ./redis01/redis-cli -h 192.168.0.179 -p 8001 -c</p>
<p>关闭 Redis 集群<br>
命令：./redis-cli -h 192.168.0.179 -p 8001 shutdown</p>
<p>也可以编写一个批量关闭的脚本<br>
命令：vim shutdown.sh<br>
redis01 /redis-cli -h 192.168.0.179 -p 8001 shutdown<br>
redis02 /redis-cli -h 192.168.0.179 -p 8002 shutdown<br>
redis03 /redis-cli -h 192.168.0.179 -p 8003 shutdown<br>
redis04 /redis-cli -h 192.168.0.179 -p 8004 shutdown<br>
redis05 /redis-cli -h 192.168.0.179 -p 8005 shutdown<br>
redis06 /redis-cli -h 192.168.0.179 -p 8006 shutdown</p>
<h2 id="6-使用-jedisapi-操作-redis">6、使用 JedisAPI 操作 Redis</h2>
<p>Jedis 集成了 redis 的一些命令操作，封装了对 redis 命令的 Java 客户端。</p>
<h3 id="61-使用-jedis-操作-redis-单机版">6.1 使用 Jedis 操作 Redis 单机版</h3>
<ol>
<li>创建工程</li>
<li>修改 POM 文件添加 Jedis 坐标</li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.cy&lt;/groupId&gt;
    &lt;artifactId&gt;JedisDemo&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;redis.clients&lt;/groupId&gt;
            &lt;artifactId&gt;jedis&lt;/artifactId&gt;
            &lt;version&gt;2.9.0&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<ol start="3">
<li>测试 Jedis 操作 Redis 单机版</li>
</ol>
<pre><code class="language-java">	/**
     * Jedis单机版测试
     */
    public static void testJedisSingle(){
        //创建一个Jedis对象
        Jedis jedis = new Jedis(&quot;124.70.181.124&quot;,6379);
        //调用Jedis的API完成对Redis的操作。在jedis中方法的命名与操作Redis的命令相同
        String result = jedis.set(&quot;key1&quot;, &quot;hello&quot;);
        System.out.println(result);
        String str = jedis.get(&quot;key1&quot;);
        System.out.println(str);
        System.out.println(&quot;--------------------------&quot;);
        Long rel = jedis.hset(&quot;user&quot;, &quot;username&quot;, &quot;cy&quot;);
        System.out.println(rel);
        String hrel = jedis.hget(&quot;user&quot;, &quot;username&quot;);
        System.out.println(hrel);
        jedis.close();

    }
</code></pre>
<ol start="4">
<li>测试使用连接池操作 Redis 单机版</li>
</ol>
<pre><code class="language-java">	/**
     * 使用连接池
     */
    public static void testJedisPool(){
        //创建连接池
        JedisPool pool = new JedisPool(&quot;124.70.181.124&quot;,6379);
        //取出实例
        Jedis jedis = pool.getResource();
        String s = jedis.hget(&quot;user&quot;, &quot;username&quot;);
        System.out.println(s);
        jedis.close();
    }

</code></pre>
<h3 id="62-使用-jedis-操作-redis-集群">6.2 使用 Jedis 操作 Redis 集群</h3>
<pre><code class="language-java"> 	/**
     * 集群测试
     */
    public static void testJedisCluster() throws IOException {
        //创建HostAndPort:集群中的的一个节点
        Set&lt;HostAndPort&gt; nodes=new HashSet&lt;&gt;();
        nodes.add(new HostAndPort(&quot;124.70.181.124&quot;,8001));
        nodes.add(new HostAndPort(&quot;124.70.181.124&quot;,8002));
        nodes.add(new HostAndPort(&quot;124.70.181.124&quot;,8003));
        nodes.add(new HostAndPort(&quot;124.70.181.124&quot;,8004));
        nodes.add(new HostAndPort(&quot;124.70.181.124&quot;,8005));
        nodes.add(new HostAndPort(&quot;124.70.181.124&quot;,8006));
        // 创建操作集群的jedis对象
        JedisCluster jedisCluster = new JedisCluster(nodes);
        //在jedisCluster中方法的命名与操作Redis的命令相同
        jedisCluster.set(&quot;name&quot;,&quot;cy&quot;);
        String name = jedisCluster.get(&quot;name&quot;);
        System.out.println(name);
        jedisCluster.close();
    }
</code></pre>
<h2 id="7-spring-整合-jedis">7、Spring 整合 Jedis</h2>
<h3 id="71-整合单机版">7.1 整合单机版</h3>
<ol>
<li>创建工程</li>
<li>修改 POM 文件添加 Jedis 与 Spring 的坐标</li>
</ol>
<pre><code class="language-java">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;com.bjsxt&lt;/groupId&gt;
  &lt;artifactId&gt;springJedisDemo&lt;/artifactId&gt;
  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
  
  &lt;dependencies&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;redis.clients&lt;/groupId&gt;
			&lt;artifactId&gt;jedis&lt;/artifactId&gt;
			&lt;version&gt;2.9.0&lt;/version&gt;
		&lt;/dependency&gt;
		
		&lt;dependency&gt;
		        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
				&lt;artifactId&gt;spring-context&lt;/artifactId&gt;
				&lt;version&gt;4.1.3.RELEASE&lt;/version&gt;
			&lt;/dependency&gt;
			&lt;dependency&gt;
				&lt;groupId&gt;org.springframework&lt;/groupId&gt;
				&lt;artifactId&gt;spring-beans&lt;/artifactId&gt;
				&lt;version&gt;4.1.3.RELEASE&lt;/version&gt;
			&lt;/dependency&gt;
	&lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<ol start="3">
<li>创建 JedisDao 接口与接口实现类</li>
</ol>
<p>JedisDao</p>
<pre><code class="language-java">public interface JedisDao {
	
	public String set(String key,String value);
	public String get(String key);
	public Long hset(String hkey,String key,String value);
	public String hget(String hkey,String key);
}

</code></pre>
<p>JedisDaoImplSingle</p>
<pre><code class="language-java">public class JedisDaoImplSingle implements JedisDao {
	
	@Autowired
	private JedisPool jedisPool;
	

	@Override
	public String set(String key, String value) {
		Jedis jedis = this.jedisPool.getResource();
		return jedis.set(key, value);
	}

	@Override
	public String get(String key) {
		Jedis jedis = this.jedisPool.getResource();
		return jedis.get(key);
	}

	@Override
	public Long hset(String hkey, String key, String value) {
		Jedis jedis = this.jedisPool.getResource();
		return jedis.hset(hkey, key, value);
	}

	@Override
	public String hget(String hkey, String key) {
		Jedis jedis = this.jedisPool.getResource();
		return jedis.hget(hkey, key);
	}
}

</code></pre>
<ol start="4">
<li>在 Spring 配置文件中整合 Jedis</li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
	xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
	xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
	xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
	xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
	&lt;context:component-scan base-package=&quot;com.cy.jedisdao&quot;/&gt;
	&lt;!-- jedisPool的配置 --&gt;
	&lt;bean id=&quot;poolconfig&quot; class=&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt;
	        &lt;!-- 最大连接数 --&gt;
		&lt;property name=&quot;maxTotal&quot; value=&quot;30&quot; /&gt;
		&lt;!-- 最大空闲连接数 --&gt;
		&lt;property name=&quot;maxIdle&quot; value=&quot;10&quot; /&gt;
		&lt;!-- 每次释放连接的最大数目 --&gt;
		&lt;property name=&quot;numTestsPerEvictionRun&quot; value=&quot;1024&quot; /&gt;
		&lt;!-- 释放连接的扫描间隔（毫秒） --&gt;
		&lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;30000&quot; /&gt;
		&lt;!-- 连接最小空闲时间 --&gt;
		&lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;1800000&quot; /&gt;
		&lt;!-- 连接空闲多久后释放, 当空闲时间&gt;该值 且 空闲连接&gt;最大空闲连接数 时直接释放 --&gt;
		&lt;property name=&quot;softMinEvictableIdleTimeMillis&quot; value=&quot;10000&quot; /&gt;
		&lt;!-- 获取连接时的最大等待毫秒数,小于零:阻塞不确定的时间,默认-1 --&gt;
		&lt;property name=&quot;maxWaitMillis&quot; value=&quot;1500&quot; /&gt;
		&lt;!-- 在获取连接的时候检查有效性, 默认false --&gt;
		&lt;property name=&quot;testOnBorrow&quot; value=&quot;true&quot; /&gt;
		&lt;!-- 在空闲时检查有效性, 默认false --&gt;
		&lt;property name=&quot;testWhileIdle&quot; value=&quot;true&quot; /&gt;
		&lt;!-- 连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true --&gt;
		&lt;property name=&quot;blockWhenExhausted&quot; value=&quot;false&quot; /&gt;
	&lt;/bean&gt;
	&lt;!-- 配置JedidesPool --&gt;
	&lt;bean id=&quot;jedisPool&quot; class=&quot;redis.clients.jedis.JedisPool&quot;&gt;
		&lt;constructor-arg name=&quot;poolConfig&quot;&gt;
			&lt;ref bean=&quot;poolconfig&quot;/&gt;
		&lt;/constructor-arg&gt;
		&lt;constructor-arg name=&quot;host&quot;&gt;
			&lt;value&gt;124.70.181.124&lt;/value&gt;
		&lt;/constructor-arg&gt;
		&lt;constructor-arg name=&quot;port&quot;&gt;
			&lt;value&gt;6379&lt;/value&gt;
		&lt;/constructor-arg&gt;
	&lt;/bean&gt;
    	&lt;!-- JedisDaoImplSingle --&gt;
	&lt;bean id=&quot;jedisDaoImplSingle&quot; class=&quot;com.cy.jedisdao.impl.JedisDaoImplSingle&quot;&gt;&lt;/bean&gt; 
&lt;/beans&gt;
</code></pre>
<ol start="5">
<li>测试单机版</li>
</ol>
<p>public class Test {</p>
<pre><code class="language-java">public static void main(String[] args) {
	Test.testJedisSingle();
}

/**
 * 测试单机版Jedis
 */
public static void testJedisSingle(){
	ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext-Jedis.xml&quot;);
	JedisDao jd = (JedisDao)ac.getBean(&quot;jedisDaoImplSingle&quot;);
	String str = jd.set(&quot;hello&quot;, &quot;Redis&quot;);
	System.out.println(str);
	String result = jd.get(&quot;hello&quot;);
	System.out.println(result);
}
}
</code></pre>
<h3 id="72-整合集群版">7.2 整合集群版</h3>
<ol>
<li>添加 JedisDao 实现类。基于 JedisCluster 的实现</li>
</ol>
<pre><code class="language-java">public class JedisDaoImplCluster implements JedisDao {

	@Autowired
	private JedisCluster jedisCluster;
	
	@Override
	public String set(String key, String value) {
		return this.jedisCluster.set(key, value);
	}

	@Override
	public String get(String key) {
		return this.jedisCluster.get(key);
	}

	@Override
	public Long hset(String hkey, String key, String value) {
		return this.jedisCluster.hset(hkey, key, value);
	}

	@Override
	public String hget(String hkey, String key) {
		return this.jedisCluster.hget(hkey, key);
	}

}
</code></pre>
<ol start="2">
<li>在 Spring 配置文件中整合 JedisCluster</li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
	xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
	xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
	xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
	xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
	&lt;context:component-scan base-package=&quot;com.cy.jedisdao&quot;/&gt;
	&lt;!-- jedisPool的配置 --&gt;
	&lt;bean id=&quot;poolconfig&quot; class=&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt;
	        &lt;!-- 最大连接数 --&gt;
		&lt;property name=&quot;maxTotal&quot; value=&quot;30&quot; /&gt;
		&lt;!-- 最大空闲连接数 --&gt;
		&lt;property name=&quot;maxIdle&quot; value=&quot;10&quot; /&gt;
		&lt;!-- 每次释放连接的最大数目 --&gt;
		&lt;property name=&quot;numTestsPerEvictionRun&quot; value=&quot;1024&quot; /&gt;
		&lt;!-- 释放连接的扫描间隔（毫秒） --&gt;
		&lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;30000&quot; /&gt;
		&lt;!-- 连接最小空闲时间 --&gt;
		&lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;1800000&quot; /&gt;
		&lt;!-- 连接空闲多久后释放, 当空闲时间&gt;该值 且 空闲连接&gt;最大空闲连接数 时直接释放 --&gt;
		&lt;property name=&quot;softMinEvictableIdleTimeMillis&quot; value=&quot;10000&quot; /&gt;
		&lt;!-- 获取连接时的最大等待毫秒数,小于零:阻塞不确定的时间,默认-1 --&gt;
		&lt;property name=&quot;maxWaitMillis&quot; value=&quot;1500&quot; /&gt;
		&lt;!-- 在获取连接的时候检查有效性, 默认false --&gt;
		&lt;property name=&quot;testOnBorrow&quot; value=&quot;true&quot; /&gt;
		&lt;!-- 在空闲时检查有效性, 默认false --&gt;
		&lt;property name=&quot;testWhileIdle&quot; value=&quot;true&quot; /&gt;
		&lt;!-- 连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true --&gt;
		&lt;property name=&quot;blockWhenExhausted&quot; value=&quot;false&quot; /&gt;
	&lt;/bean&gt;
	&lt;!-- 配置JedidesPool --&gt;
	&lt;bean id=&quot;jedisPool&quot; class=&quot;redis.clients.jedis.JedisPool&quot;&gt;
		&lt;constructor-arg name=&quot;poolConfig&quot;&gt;
			&lt;ref bean=&quot;poolconfig&quot;/&gt;
		&lt;/constructor-arg&gt;
		&lt;constructor-arg name=&quot;host&quot;&gt;
			&lt;value&gt;124.70.181.124&lt;/value&gt;
		&lt;/constructor-arg&gt;
		&lt;constructor-arg name=&quot;port&quot;&gt;
			&lt;value&gt;6379&lt;/value&gt;
		&lt;/constructor-arg&gt;
	&lt;/bean&gt;
	&lt;!-- JedisDaoImplSingle --&gt;
	&lt;!-- &lt;bean id=&quot;jedisDaoImplSingle&quot; class=&quot;com.bjsxt.jedisdao.impl.JedisDaoImplSingle&quot;&gt;&lt;/bean&gt; --&gt;
	
	
	&lt;!-- JedislCluster --&gt;
     &lt;!-- 这里等同于做了
        创建HostAndPort:集群中的的一个节点
        Set&lt;HostAndPort&gt; nodes=new HashSet&lt;&gt;();
        nodes.add(new HostAndPort(&quot;124.70.181.124&quot;,8001));
        nodes.add(new HostAndPort(&quot;124.70.181.124&quot;,8002));
        nodes.add(new HostAndPort(&quot;124.70.181.124&quot;,8003));
        nodes.add(new HostAndPort(&quot;124.70.181.124&quot;,8004));
        nodes.add(new HostAndPort(&quot;124.70.181.124&quot;,8005));
        nodes.add(new HostAndPort(&quot;124.70.181.124&quot;,8006));
        创建操作集群的jedis对象
        JedisCluster jedisCluster = new JedisCluster(nodes);
        --&gt; 
	&lt;bean id=&quot;jedisCluster&quot; class=&quot;redis.clients.jedis.JedisCluster&quot;&gt;
		&lt;constructor-arg name=&quot;nodes&quot;&gt;
			&lt;set&gt;
				&lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;
					&lt;constructor-arg name=&quot;host&quot;&gt;
					 &lt;value&gt;124.70.181.124&lt;/value&gt;
					&lt;/constructor-arg&gt;
					&lt;constructor-arg name=&quot;port&quot;&gt;
					  &lt;value&gt;8001&lt;/value&gt;
					&lt;/constructor-arg&gt;
				&lt;/bean&gt;
				&lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;
					&lt;constructor-arg name=&quot;host&quot;&gt;
					 &lt;value&gt;124.70.181.124&lt;/value&gt;
					&lt;/constructor-arg&gt;
					&lt;constructor-arg name=&quot;port&quot;&gt;
					  &lt;value&gt;8002&lt;/value&gt;
					&lt;/constructor-arg&gt;
				&lt;/bean&gt;
				&lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;
					&lt;constructor-arg name=&quot;host&quot;&gt;
					 &lt;value&gt;124.70.181.124&lt;/value&gt;
					&lt;/constructor-arg&gt;
					&lt;constructor-arg name=&quot;port&quot;&gt;
					  &lt;value&gt;8003&lt;/value&gt;
					&lt;/constructor-arg&gt;
				&lt;/bean&gt;
				&lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;
					&lt;constructor-arg name=&quot;host&quot;&gt;
					 &lt;value&gt;124.70.181.124&lt;/value&gt;
					&lt;/constructor-arg&gt;
					&lt;constructor-arg name=&quot;port&quot;&gt;
					  &lt;value&gt;8004&lt;/value&gt;
					&lt;/constructor-arg&gt;
				&lt;/bean&gt;
				&lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;
					&lt;constructor-arg name=&quot;host&quot;&gt;
					 &lt;value&gt;124.70.181.124&lt;/value&gt;
					&lt;/constructor-arg&gt;
					&lt;constructor-arg name=&quot;port&quot;&gt;
					  &lt;value&gt;8005&lt;/value&gt;
					&lt;/constructor-arg&gt;
				&lt;/bean&gt;
				&lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;
					&lt;constructor-arg name=&quot;host&quot;&gt;
					 &lt;value&gt;124.70.181.124&lt;/value&gt;
					&lt;/constructor-arg&gt;
					&lt;constructor-arg name=&quot;port&quot;&gt;
					  &lt;value&gt;8006&lt;/value&gt;
					&lt;/constructor-arg&gt;
				&lt;/bean&gt;
			&lt;/set&gt;
		&lt;/constructor-arg&gt;
		&lt;constructor-arg name=&quot;poolConfig&quot;&gt;
			&lt;ref bean=&quot;poolconfig&quot;/&gt;
		&lt;/constructor-arg&gt;
	&lt;/bean&gt;
	
	&lt;!-- JedisDaoImplCluster --&gt;
	&lt;bean id=&quot;jedisDaoImplCluster&quot; class=&quot;com.cy.jedisdao.impl.JedisDaoImplCluster&quot;&gt;&lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<ol start="3">
<li>测试集群版</li>
</ol>
<pre><code class="language-java">public class Test {

	public static void main(String[] args) {
		//Test.testJedisSingle();
		Test.testJedisCluster();
	}

	/**
	 * 测试单机版Jedis
	 */
	public static void testJedisSingle(){
		ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext-Jedis.xml&quot;);
		JedisDao jd = (JedisDao)ac.getBean(&quot;jedisDaoImplSingle&quot;);
		String str = jd.set(&quot;hello&quot;, &quot;Redis&quot;);
		System.out.println(str);
		String result = jd.get(&quot;hello&quot;);
		System.out.println(result);
	}
	
	/**
	 * 测试集群版Jedis
	 */
	public static void testJedisCluster(){
		ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext-Jedis.xml&quot;);
		JedisDao jd = (JedisDao)ac.getBean(&quot;jedisDaoImplCluster&quot;);
		String str = jd.set(&quot;name&quot;, &quot;cy&quot;);
		System.out.println(str);
		String result = jd.get(&quot;name&quot;);
		System.out.println(result);
	}
}

</code></pre>
<h2 id="8-redis-desktop-manager-的使用">8、Redis Desktop Manager 的使用</h2>
<figure data-type="image" tabindex="21"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200708143600.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="22"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200708143629.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="23"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200708143700.png" alt="" loading="lazy"></figure>
<h2 id="9-实战案例">9、实战案例</h2>
<ol>
<li>
<p>需求<br>
1）实现用户添加功能。<br>
2）实现用户查询功能，并使用 Redis 作为查询缓存。<br>
3）实现用户更新功能，同步缓存。</p>
</li>
<li>
<p>数据库的表结构</p>
</li>
</ol>
<pre><code class="language-mysql">CREATE TABLE `users` (
`userid` int(11) NOT NULL AUTO_INCREMENT,
`username` varchar(30) DEFAULT NULL,
`userage` int(11) DEFAULT NULL,
PRIMARY KEY (`userid`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;
</code></pre>
<ol start="3">
<li>创建项目</li>
<li>修改 POM 文件</li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.cy&lt;/groupId&gt;
    &lt;artifactId&gt;usermanger&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;war&lt;/packaging&gt;

    &lt;parent&gt;
        &lt;groupId&gt;com.cy&lt;/groupId&gt;
        &lt;artifactId&gt;redis-parent&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;redis.clients&lt;/groupId&gt;
            &lt;artifactId&gt;jedis&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- 单元测试 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- 日志处理 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- Mybatis --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- MySql --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- 连接池 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- Spring --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- JSP相关 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;jstl&lt;/groupId&gt;
            &lt;artifactId&gt;jstl&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;!-- Jackson Json处理工具包 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
            &lt;version&gt;${jackson.version}&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;resources&gt;
            &lt;resource&gt;
                &lt;directory&gt;src/main/java&lt;/directory&gt;
                &lt;includes&gt;
                    &lt;include&gt;**/*.xml&lt;/include&gt;
                &lt;/includes&gt;
            &lt;/resource&gt;
            &lt;resource&gt;
                &lt;directory&gt;src/main/resources&lt;/directory&gt;
                &lt;includes&gt;
                    &lt;include&gt;**/*.xml&lt;/include&gt;
                    &lt;include&gt;**/*.properties&lt;/include&gt;
                &lt;/includes&gt;
            &lt;/resource&gt;
        &lt;/resources&gt;
        &lt;!-- tomcat插件，由于子项目不一定每个都是web项目，所以该插件只是声明，并未开启 --&gt;
        &lt;plugins&gt;
            &lt;!-- 配置Tomcat插件 --&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;
                &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;
                &lt;configuration&gt;
                    &lt;path&gt;/&lt;/path&gt;
                    &lt;port&gt;8080&lt;/port&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;

</code></pre>
<ol start="5">
<li>框架整合</li>
</ol>
<figure data-type="image" tabindex="24"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200708164009.png" alt="" loading="lazy"></figure>
<ol start="6">
<li>
<p>添加用户</p>
</li>
<li>
<p>根据用户 ID 查询用户</p>
<ol>
<li>创建 findUser.jsp</li>
</ol>
<pre><code class="language-jsp">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;
&lt;title&gt;Insert title here&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
	&lt;form action=&quot;/user/findUserById&quot; method=&quot;post&quot;&gt;
		用户ID:&lt;input type=&quot;text&quot; name=&quot;userid&quot;/&gt;
		&lt;input type=&quot;submit&quot; value=&quot;OKOK&quot;/&gt;
	&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="2">
<li>UserMapper 与 UserMapper 映射配置文件</li>
</ol>
<p>UserMapper 接口</p>
<pre><code class="language-java">public interface UserMapper {

	public void insertUser(Users user);
	
	public List&lt;Users&gt; selectUserAll();
	
	Users findUserById(int userid);
	
	void updateUser(Users users);
}
</code></pre>
<p>映射配置文件</p>
<pre><code class="language-java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.bjsxt.mapper.UserMapper&quot; &gt;

  &lt;insert id=&quot;insertUser&quot; parameterType=&quot;com.bjsxt.pojo.Users&quot;&gt;
  		insert into users(username,userage) values(#{username},#{userage})
  &lt;/insert&gt;
  
  &lt;select id=&quot;selectUserAll&quot; resultType=&quot;com.bjsxt.pojo.Users&quot;&gt;
  		select * from users
  &lt;/select&gt;
  
  &lt;select id=&quot;findUserById&quot; resultType=&quot;com.bjsxt.pojo.Users&quot;&gt;
  		select * from users where userid = #{userid}
  &lt;/select&gt;
  
  &lt;select id=&quot;updateUser&quot; parameterType=&quot;com.bjsxt.pojo.Users&quot;&gt;
  		update users set username = #{username},userage = #{userage} where userid=#{userid}
  &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<ol start="3">
<li>实现业务</li>
</ol>
<pre><code class="language-java">@Service
public class UserServiceImpl implements UserService {

	@Autowired
	private UserMapper userMapper;

	@Autowired
	private JedisDao jedisDao;

	@Value(&quot;${REDIS_USERS_PRIFX}&quot;)
	private String REDIS_USERS_PRIFX;

	@Override
	public void addUser(Users users) {
		this.userMapper.insertUser(users);
	}

	@Override
	public Users findUserById(int userid) {
        //先在redis中查询，如果没有再从数据库中查询并将查询结果放入redis中，并且返回user到controller
		try {
			// 查询缓存
			String json = this.jedisDao.get(this.REDIS_USERS_PRIFX + &quot;:&quot; + userid);
			// 在缓存中是否命中
			if (json != null &amp;&amp; json.length() &gt; 0) {
				System.out.println(&quot;.........................&quot;);
				Users user = JsonUtils.jsonToPojo(json, Users.class);
				return user;
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		// 查询数据库
		Users user = this.userMapper.findUserById(userid);
		System.out.println(&quot;,,,,,,,,,,,,,,,,,,,,,,,,,,,,,&quot;);
		try {
			// 放入到redis中
			String res = JsonUtils.objectToJson(user);
			this.jedisDao.set(this.REDIS_USERS_PRIFX + &quot;:&quot; + userid, res);
			this.jedisDao.expire(this.REDIS_USERS_PRIFX + &quot;:&quot; + userid, 60);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return user;
	}

	@Override
	public void updateUser(Users users) {
		this.userMapper.updateUser(users);
		try{
			//同步redis
			this.jedisDao.del(this.REDIS_USERS_PRIFX+&quot;:&quot;+users.getUserid());
		}catch(Exception e){
			e.printStackTrace();
		}
	}
}
</code></pre>
<ol start="4">
<li>controller</li>
</ol>
<pre><code class="language-java">@Controller
@RequestMapping(&quot;/user&quot;)
public class UserController {

	@Autowired
	private UserService userService;
	/**
	 * 添加用户
	 */
	@RequestMapping(&quot;/addUser&quot;)
	public String addUser(Users user){
		this.userService.addUser(user);
		return &quot;ok&quot;;
	}
	
	/**
	 * 根据用户ID查询用户
	 */
	@RequestMapping(&quot;/findUserById&quot;)
	public String showUser(Model model,int userid){
		Users users = this.userService.findUserById(userid);
		model.addAttribute(&quot;users&quot;, users);
		return &quot;showUser&quot;;
	}
	
	/**
	 * 更新用户
	 */
	@RequestMapping(&quot;/updateUser&quot;)
	public String updateUser(Users users){
		this.userService.updateUser(users);
		return &quot;ok&quot;;
	}
}
</code></pre>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RabbitMQ]]></title>
        <id>https://jonchan1013.github.io/post/rabbitmq/</id>
        <link href="https://jonchan1013.github.io/post/rabbitmq/">
        </link>
        <updated>2020-07-06T05:11:14.000Z</updated>
        <summary type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200707162914.png" alt="" loading="lazy"></figure>
<h2 id="1-amqp-简介">1、AMQP 简介</h2>
<h3 id="11-amqp-是什么">1.1 AMQP 是什么?</h3>
<p>AMQP(Advanced Message Queuing Protocol,高级消息队列协议)是进程之间传递异步消息的网络协议。</p>
]]></summary>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200707162914.png" alt="" loading="lazy"></figure>
<h2 id="1-amqp-简介">1、AMQP 简介</h2>
<h3 id="11-amqp-是什么">1.1 AMQP 是什么?</h3>
<p>AMQP(Advanced Message Queuing Protocol,高级消息队列协议)是进程之间传递异步消息的网络协议。</p>
<!-- more -->
<h3 id="12-amqp-工作过程">1.2 AMQP 工作过程</h3>
<p>发布者(Publisher)发布消息(Message),经过交换机(Exchange)，交换机根据路由规则将收到消息分发给交换机绑定的队列(Queue)，最后 AMQP 代理会将消息投递给订阅了此队列的消费者，或者消费者按照需求自行获取。</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200706171158.png" alt="" loading="lazy"></figure>
<h3 id="13-队列">1.3 队列</h3>
<p>队列是数据结构中概念。数据存储在一个队列中，数据是有顺序的，先进的先出，后进后出。其中一侧负责进数据，另一次负责出数据。</p>
<p>MQ（消息队列）很多功能都是基于此队列结构实现的</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200706171229.png" alt="" loading="lazy"></figure>
<h2 id="2-rabbitmq-简介">2、RabbitMQ 简介</h2>
<h3 id="21-rabbitmq-介绍">2.1 RabbitMQ 介绍</h3>
<p>RabbitMQ 是由 Erlang 语言编写的基于 AMQP 的消息中间件。而消息中间件作为分布式系统重要组件之一，可以解决应用耦合，异步消息，流量削峰等问题。</p>
<h4 id="211-解决应用耦合">2.1.1 解决应用耦合</h4>
<ol>
<li>不使用 MQ 时</li>
</ol>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200706171358.png" alt="" loading="lazy"></figure>
<ol start="2">
<li>使用 MQ 解决耦合</li>
</ol>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200706171415.png" alt="" loading="lazy"></figure>
<h3 id="22-rabbitmq-适用场景">2.2 RabbitMQ 适用场景</h3>
<p>排队算法、秒杀活动、消息分发、异步处理、数据同步、处理耗时任务、流量销峰等。</p>
<h2 id="3-rabbitmq-原理">3、RabbitMQ 原理</h2>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200706171458.png" alt="" loading="lazy"></figure>
<h3 id="31-message">3.1 Message</h3>
<p>消息。消息是不具名的，它由消息头消息体组成。消息体是不透明的，而消息头则由一系列可选属性组成，这些属性包括：routing-key(路由键)、priority(相对于其他消息的优先权)、delivery-mode(指出消息可能持久性存储)等。</p>
<h3 id="32-publisher">3.2 Publisher</h3>
<p>消息的生产者。也是一个向交换器发布消息的客户端应用程序。</p>
<h3 id="33-consumer">3.3 Consumer</h3>
<p>消息的消费者。表示一个从消息队列中取得消息的客户端应用程序。</p>
<h3 id="34-exchange">3.4 Exchange</h3>
<p>交换器。用来接收生产者发送的消息并将这些消息路由给服务器中的队列。</p>
<p>三种常用的交换器类型</p>
<ol>
<li>direct(发布与订阅 完全匹配)</li>
<li>fanout(广播)</li>
<li>topic(主题，规则匹配)</li>
</ol>
<h3 id="35-binding">3.5 Binding</h3>
<p>绑定。用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。</p>
<h3 id="36-queue">3.6 Queue</h3>
<p>消息队列。用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者链接到这个队列将其取走。</p>
<h3 id="37-routing-key">3.7 Routing-key</h3>
<p>路由键。RabbitMQ 决定消息该投递到哪个队列的规则。（也可以理解为队列的名称，路由键是 key，队列是 value）</p>
<p>队列通过路由键绑定到交换器。</p>
<p>消息发送到 MQ 服务器时，消息将拥有一个路由键，即便是空的，RabbitMQ 也会将其和绑定使用的路由键进行匹配。</p>
<p>如果相匹配，消息将会投递到该队列。</p>
<p>如果不匹配，消息将会进入黑洞。</p>
<h3 id="38-connection">3.8 Connection</h3>
<p>链接。指 rabbit 服务器和服务建立的 TCP 链接。</p>
<h3 id="39-channel">3.9 Channel</h3>
<p>信道。</p>
<p>1，Channel 中文叫做信道，是 TCP 里面的虚拟链接。例如：电缆相当于 TCP，信道是一个独立光纤束，一条 TCP 连接上创建多条信道是没有问题的。</p>
<p>2，TCP 一旦打开，就会创建 AMQP 信道。</p>
<p>3，无论是发布消息、接收消息、订阅队列，这些动作都是通过信道完成的。</p>
<h3 id="310-virtual-host">3.10 Virtual Host</h3>
<p>虚拟主机。表示一批交换器，消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在链接时指定，RabbitMQ 默认的 vhost 是/</p>
<h3 id="311-borker">3.11 Borker</h3>
<p>表示消息队列服务器实体。</p>
<h3 id="312-交换器和队列的关系">3.12 交换器和队列的关系</h3>
<p>交换器是通过路由键和队列绑定在一起的，如果消息拥有的路由键跟队列和交换器的路由键匹配，那么消息就会被路由到该绑定的队列中。</p>
<p>也就是说，消息到队列的过程中，消息首先会经过交换器，接下来交换器在通过路由键匹配分发消息到具体的队列中。</p>
<p>路由键可以理解为匹配的规则。</p>
<h3 id="313-rabbitmq-为什么需要信道为什么不是-tcp-直接通信">3.13 RabbitMQ 为什么需要信道？为什么不是 TCP 直接通信？</h3>
<ol>
<li>
<p>TCP 的创建和销毁开销特别大。创建需要 3 次握手，销毁需要 4 次分手。</p>
</li>
<li>
<p>如果不用信道，那应用程序就会以 TCP 链接 Rabbit，高峰时每秒成千上万条链接会造成资源巨大的浪费，而且操作系统每秒处理 TCP 链接数也是有限制的，必定造成性能瓶颈。</p>
</li>
<li>
<p>信道的原理是一条线程一条通道，多条线程多条通道同用一条 TCP 链接。一条 TCP链接可以容纳无限的信道，即使每秒成千上万的请求也不会成为性能的瓶颈。</p>
</li>
</ol>
<h2 id="4-erlang-安装">4、Erlang 安装</h2>
<p>RabbitMQ 是使用 Erlang 语言编写的，所以需要先配置 Erlang</p>
<ol>
<li>
<p>修改主机名<br>
RabbitMQ 是通过主机名进行访问的，必须指定能访问的主机名。</p>
<p>vim /etc/sysconfig/network</p>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200706172227.png" alt="" loading="lazy"></figure>
<p>vim /etc/hosts</p>
<p>新添加了一行，前面为服务器 ip，空格后面添加计算机主机名</p>
<figure data-type="image" tabindex="8"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200706172349.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>安装依赖</p>
</li>
</ol>
<p>yum -y install make gcc gcc-c++ kernel-devel m4 ncurses-devel openssl-devel unixODBC unixODBC-devel</p>
<ol start="3">
<li>
<p>上传并解压<br>
上传 otp_src_22.0.tar.gz 到/usr/local/tmp 目录中，进入目录并解压。<br>
<strong>解压时注意，此压缩包不具有 gzip 属性，解压参数没有 z，只有 xf</strong></p>
<p>cd /usr/local/tmp</p>
<p>tar xf otp_src_22.0.tar.gz</p>
</li>
<li>
<p>配置参数</p>
<p>先新建/usr/local/erlang 文件夹，作为安装文件夹</p>
<p>#mkdir -p /usr/local/erlang</p>
</li>
</ol>
<p>​	进入文件夹</p>
<p>​	cd otp_src_22.0</p>
<p>​	配置参数</p>
<p>​	./configure --prefix=/usr/local/erlang --with-ssl --enable-threads --enable-smp-support --enable-kernel-poll --enable-hipe --without-javac</p>
<figure data-type="image" tabindex="9"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200706172649.png" alt="" loading="lazy"></figure>
<ol start="5">
<li>
<p>编译并安装</p>
<p>编译</p>
<p>make</p>
<p>安装</p>
<p>make install</p>
</li>
</ol>
<figure data-type="image" tabindex="10"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200706173422.png" alt="" loading="lazy"></figure>
<ol start="6">
<li>
<p>修改环境变量</p>
<p>修改/etc/profile 文件</p>
<p>#vim /etc/profile</p>
<p>在文件中添加下面代码</p>
<p>export PATH=$PATH:/usr/local/erlang/bin</p>
</li>
</ol>
<figure data-type="image" tabindex="11"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200706173629.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200706173647.png" alt="" loading="lazy"></figure>
<h2 id="5-安装-rabbitmq">5、安装 RabbitMQ</h2>
<ol>
<li>
<p>上传并解压<br>
上传 rabbitmq-server-generic-unix-3.7.17.tar.xz 到/usr/loca/tmp 中</p>
<p>cd /usr/local/tmp</p>
<p>tar xf rabbitmq-server-generic-unix-3.7.17.tar.xz</p>
</li>
<li>
<p>复制到 local 下<br>
复制解压文件到/usr/local 下，命名为 rabbitmq</p>
<p>cp -r rabbitmq_server-3.7.17 /usr/local/rabbitmq</p>
</li>
<li>
<p>配置环境变量</p>
<p>vim /etc/profile</p>
<p>在文件中添加</p>
<p>export PATH=$PATH:/usr/local/rabbitmq/sbin</p>
<p>解析文件</p>
<p>source /etc/profile</p>
</li>
<li>
<p>开启 web 管理插件<br>
进入 rabbitmq/sbin 目录</p>
<p>cd /usr/local/rabbitmq/sbin</p>
<p>查看插件列表</p>
<p>./rabbitmq-plugins list</p>
<p>生效管理插件</p>
<p>./rabbitmq-plugins enable rabbitmq_management</p>
</li>
<li>
<p>后台运行<br>
启动 rabbitmq。</p>
<p>./rabbitmq-server（前台）</p>
<p>./rabbitmq-server -detached（后台）</p>
<p>停止命令，如果无法停止，使用 kill -9 进程号进行关闭</p>
<p>./rabbitmqctl stop_app</p>
<p>启动成功信息如下：</p>
</li>
</ol>
<figure data-type="image" tabindex="13"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200707031245.png" alt="" loading="lazy"></figure>
<ol start="6">
<li>
<p>查看 web 管理界面</p>
<p>默认可以在安装 rabbitmq 的电脑上通过用户名：guest 密码 guest 进行访问 web 管理界面</p>
<p>端口号：15672（放行端口，或关闭防火墙）</p>
<p>在浏览器中输入：http://124.70.181.124:15672/</p>
</li>
</ol>
<figure data-type="image" tabindex="14"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200707031918.png" alt="" loading="lazy"></figure>
<h2 id="6-rabbitmq-账户管理">6、RabbitMq 账户管理</h2>
<ol>
<li>创建账户</li>
</ol>
<p>语法：./rabbitmqctl add_user username password</p>
<pre><code>cd /usr/local/rabbitmq/sbin

./rabbitmqctl add_user admin admin123
</code></pre>
<ol start="2">
<li>
<p>给用户授予管理员角色<br>
其中 smallming 为新建用户的用户名</p>
<p>./rabbitmqctl set_user_tags admin administrator</p>
</li>
<li>
<p>给用户授权<br>
“/” 表示 RabbitMQ 根虚拟主机</p>
<p>admin 表示用户名</p>
<p>&quot;.<em>&quot; &quot;.</em>&quot; &quot;.*&quot; 表示完整权限</p>
<p>./rabbitmqctl set_permissions -p &quot;/&quot; admin &quot;.<em>&quot; &quot;.</em>&quot; &quot;.*&quot;</p>
</li>
<li>
<p>登录<br>
使用新建账户和密码在 windows 中访问 rabbitmq 并登录</p>
<p>在浏览器地址栏输入：</p>
<p>http://ip:15672/</p>
<p>用户名：admin</p>
<p>密码：admin</p>
<figure data-type="image" tabindex="15"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200707094930.png" alt="" loading="lazy"></figure>
</li>
</ol>
<h2 id="7-exchange-交换器交换机">7、Exchange 交换器（交换机）</h2>
<p>交换器负责接收客户端传递过来的消息，并转发到对应的队列中。在 RabbitMQ 中支持四种交换器</p>
<ol>
<li>
<p><strong>Direct Exchange：直连交换器（默认）</strong></p>
</li>
<li>
<p><strong>Fanout Exchange：扇形交换器</strong></p>
</li>
<li>
<p><strong>Topic Exchange：主题交换器</strong></p>
</li>
<li>
<p><strong>Header Exchange：首部交换器。</strong></p>
</li>
</ol>
<p>在 RabbitMq 的 Web 管理界面中 Exchanges 选项卡就可以看见这四个交换器。</p>
<figure data-type="image" tabindex="16"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200707110332.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="17"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200707162639.png" alt="" loading="lazy"></figure>
<h3 id="71-direct-交换器">7.1 direct 交换器</h3>
<figure data-type="image" tabindex="18"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200707110359.png" alt="" loading="lazy"></figure>
<p>direct 交换器是 RabbitMQ 默认交换器。默认会进行<strong>公平调度</strong>。所有接受者依次从消息队列中获取值。Publisher 给哪个队列发消息，就一定是给哪个队列发送消息。对交换器</p>
<p>绑定的其他队列没有任何影响。</p>
<p>（代码演示）一个队列需要绑定多个消费者</p>
<p>需要使用注解/API：</p>
<p>org.springframework.amqp.core.Queue:队列</p>
<p>AmqpTemplate：操作 RabbitMQ 的接口。负责发送或接收消息</p>
<p>@RabbitListener(queues = &quot;&quot;) 注解某个方法为接收消息方法</p>
<h4 id="711-代码">7.1.1 代码</h4>
<ol>
<li>父项目添加依赖</li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.cy&lt;/groupId&gt;
    &lt;artifactId&gt;amqp_rabbit&lt;/artifactId&gt;
    &lt;packaging&gt;pom&lt;/packaging&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;modules&gt;
        &lt;module&gt;amqp_rabbit_consumer&lt;/module&gt;
    &lt;/modules&gt;

    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;
                &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;
                &lt;scope&gt;import&lt;/scope&gt;
                &lt;type&gt;pom&lt;/type&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;


    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;!-- Spring Boot提供的关于AMQP协议实现的启动器。可以使用AMQP协议快速的访问MQ消息中间件。 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<ol start="2">
<li>编写日志消息消费者（只消费Info日志）</li>
</ol>
<pre><code class="language-java">import org.springframework.amqp.rabbit.annotation.*;
import org.springframework.stereotype.Component;

/**
 * 日志消息消费者，只消费Info日志。
 * 日志消息存储在队列 log-info-queue
 * 使用的交换器名称是 log-ex-direct
 * 交换器类型是 direct
 * 队列的路由键是 direct-rk-info
 * &lt;p&gt;
 * 注解RabbitListener - 监听注解。可以描述类型和方法。
 * 类型 - 当前类型监听某个队列。
 * 方法 - 当前方法监听某个队列。
 * 属性 -
 * bindings - QueueBinding[]类型，代表这个类型或方法监听的队列、交换器、路由键的绑定方式
 * 注解QueueBinding -
 * 属性 -
 * value - 绑定监听的队列是什么
 * exchange - 队列对应的交换器是什么
 * key - 队列的路由键是什么
 * 注解Queue - 描述一个队列
 * 属性 -
 * value|name - 队列名称
 * autoDelete - 是否自动删除。默认为&quot;&quot;, 如果队列名称定义，不自动删除；队列名称不定义，队列为自动删除队列。
 * 如果是自动删除，代表所有的consumer关闭后，队列自动删除。
 * 注解Exchange - 描述一个交换器
 * 属性 -
 * value|name - 交换器名称
 * type - 交换器的类型，可选direct|fanout|topic， 默认direct
 * autoDelete - 是否自动删除，默认为false。不自动删除。
 */
@RabbitListener(bindings = {
        @QueueBinding(
                value = @Queue(value = &quot;log-info-queue&quot;, autoDelete = &quot;false&quot;),
                exchange = @Exchange(value = &quot;log-ex-direct&quot;, type = &quot;direct&quot;, autoDelete = &quot;false&quot;),
                key = &quot;direct-rk-info&quot;
        )
})
@Component
public class InfoLogConsumer {
    /**
     * 消息消费的方法。当队列log-info-queue中出现消息，立刻消费。
     * &lt;p&gt;
     * RabbitHandler注解 - 配合类型上的RabbitListener注解，标记当前的方法，是一个监听消息队列，消费消息的方法。
     *如果RabbitListener注解在方法上，此注解就不需要了
     * @param msg 消息内容。
     */
    @RabbitHandler
    public void onMessage(String msg) {
        System.out.println(&quot;InfoLogConsumer 消费消息：&quot; + msg);
    }
}

</code></pre>
<ol start="3">
<li>创建springboot启动类</li>
</ol>
<pre><code class="language-java">@SpringBootApplication
public class RabbitConsumerApplication {
    public static void main(String[] args) {
        SpringApplication.run(RabbitConsumerApplication.class, args);
    }
}
</code></pre>
<ol start="4">
<li>编写配置文件</li>
</ol>
<pre><code class="language-yaml">spring:
  rabbitmq:
    host: 124.70.181.124  # RabbitMQ服务的地址，默认localhost
    port: 5672  # RabbitMQ的端口，默认5672。
    username: admin # 访问RabbitMQ的用户名，默认guest
    password: admin # 访问RabbitMQ的密码，默认guest
    virtual-host: /  # 访问RabbitMQ的哪一个虚拟主机，默认为 /
</code></pre>
<figure data-type="image" tabindex="19"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200707111159.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="20"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200707111241.png" alt="" loading="lazy"></figure>
<ol start="5">
<li>编写日志消息消费者（只消费error和warn日志）</li>
</ol>
<pre><code class="language-java">import org.springframework.amqp.rabbit.annotation.Exchange;
import org.springframework.amqp.rabbit.annotation.Queue;
import org.springframework.amqp.rabbit.annotation.QueueBinding;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Component;

/**
 * 日志消息消费者，消费error和warn日志。
 * error日志消息存储在队列 log-error-queue
 * warn日志消息存储在队列 log-warn-queue
 * 使用的交换器名称是 log-ex-direct
 * 交换器类型是 direct
 * error队列的路由键是 direct-rk-error
 * warn队列的路由键是 direct-rk-warn
 */
@Component
public class LogConsumer {
    @RabbitListener(bindings = {
            @QueueBinding(value = @Queue(value = &quot;log-error-queue&quot;, autoDelete = &quot;false&quot;),
                    exchange = @Exchange(value = &quot;log-ex-direct&quot;, type = &quot;direct&quot;, autoDelete = &quot;false&quot;),
                    key = &quot;direct-rk-error&quot;
            )
    })
    public void onLogErrorMessage(String msg) {
        System.out.println(&quot;错误日志信息：&quot; + msg);
    }

    @RabbitListener(bindings = {
            @QueueBinding(value = @Queue(value = &quot;log-warn-queue&quot;, autoDelete = &quot;false&quot;),
                    exchange = @Exchange(value = &quot;log-ex-direct&quot;, type = &quot;direct&quot;, autoDelete = &quot;false&quot;),
                    key = &quot;direct-rk-warn&quot;
            )
    })
    public void onLogWarnMessage(String msg) {
        System.out.println(&quot;警告日志信息:&quot; + msg);
    }
}

</code></pre>
<figure data-type="image" tabindex="21"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200707114704.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="22"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200707114913.png" alt="" loading="lazy"></figure>
<ol start="6">
<li>编写publisher配置信息</li>
</ol>
<pre><code class="language-yaml">spring:
  rabbitmq:
    host: 124.70.181.124  # RabbitMQ服务的地址，默认localhost
    port: 5672  # RabbitMQ的端口，默认5672。
    username: admin # 访问RabbitMQ的用户名，默认guest
    password: admin # 访问RabbitMQ的密码，默认guest
    virtual-host: /  # 访问RabbitMQ的哪一个虚拟主机，默认为 /
</code></pre>
<ol start="7">
<li>编写测试类</li>
</ol>
<pre><code class="language-java">/**
 * 消息发送者测试类型
 */
@SpringBootTest(classes = RabbitPublisherApplication.class)
@RunWith(SpringRunner.class)
public class TestPublisher {

    @Autowired
    private LogMessageSender sender;

    private String exchange = &quot;log-ex-direct&quot;;
    private String rkInfo = &quot;direct-rk-info&quot;;
    private String rkError = &quot;direct-rk-error&quot;;
    private String rkWarn = &quot;direct-rk-warn&quot;;

    @Test
    public void testSend(){
        Random r = new Random();
        // 发送10条消息。
        for(int i = 0 ; i &lt; 10; i++){
            // rInt%3 - 0：投递消息到info；1：投递消息到error；2：投递消息到warn
            int rInt = r.nextInt(100);
            if(rInt%3 == 0){
                this.sender.sendMessage(exchange, rkInfo, &quot;发送Info日志消息 - index=&quot;+i+&quot;；rInt=&quot;+rInt);
            }else if(rInt%3 == 1){
                this.sender.sendMessage(exchange, rkError, &quot;发送error日志消息 - index=&quot;+i+&quot;；rInt=&quot;+rInt);
            }else{
                this.sender.sendMessage(exchange, rkWarn, &quot;发送warn日志消息 - index=&quot;+i+&quot;；rInt=&quot;+rInt);
            }
        }
    }
}

</code></pre>
<p>先启动consumer再启动publisher测试类：</p>
<figure data-type="image" tabindex="23"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200707133200.png" alt="" loading="lazy"></figure>
<ol start="8">
<li>消费者集群搭建</li>
</ol>
<p>先复制一个消费者启动类，然后启动，集群就搭建完成了</p>
<p>编写测试类：</p>
<pre><code class="language-java">    @Test
    public void testSend2Consumers(){
        for(int i = 0; i &lt; 10; i++){
            this.sender.sendMessage(exchange, rkInfo, &quot;info消息&quot;+i);
            this.sender.sendMessage(exchange, rkError, &quot;error消息&quot;+i);
            this.sender.sendMessage(exchange, rkWarn, &quot;warn消息&quot;+i);
        }
    }

</code></pre>
<figure data-type="image" tabindex="24"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200707135016.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="25"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200707135031.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="26"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200707135214.png" alt="" loading="lazy"></figure>
<h3 id="72-fanout-交换器">7.2 fanout 交换器</h3>
<figure data-type="image" tabindex="27"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200707141028.png" alt="" loading="lazy"></figure>
<p>扇形交换器，实际上做的事情就是广播，fanout 会把消息发送给所有的绑定在当前交换器上的队列。<strong>对应 Consumer 依然采用公平调度方式。</strong></p>
<p>注：不再需要routing-key</p>
<p>（代码演示）一个交换器需要绑定多个队列</p>
<p>需要使用注解/API：</p>
<p>FanoutExchange：fanout 交换器</p>
<p>Binding：绑定交换器和队列</p>
<p>BindingBuilder：Binding 的构建器</p>
<p>amq.fanout:内置 fanout 交换器名称</p>
<h4 id="721-代码">7.2.1 代码</h4>
<ol>
<li>
<p>编写实体类</p>
<pre><code class="language-java">// 实体类型
public class User implements Serializable {
    // 定义一个序列化唯一ID。
    public static final long serialVersionUID = 1L;
    private Long id;
    private String name;
    private int age;

    public User(){}

    @Override
    public String toString() {
        return &quot;User{&quot; +
                &quot;id=&quot; + id +
                &quot;, name='&quot; + name + '\'' +
                &quot;, age=&quot; + age +
                '}';
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        User user = (User) o;
        return age == user.age &amp;&amp;
                Objects.equals(id, user.id) &amp;&amp;
                Objects.equals(name, user.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id, name, age);
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}

</code></pre>
<ol start="2">
<li>编写consumer</li>
</ol>
<p>第二个参数 routingKey 对于 fanout 没有意义的</p>
<pre><code class="language-java">/**
 * 广播交换器，消费者。
 */
@Component
public class FanoutConsumers {
    /**
     * 消费消息的方法。
     * 不再需要Routing-key
     * @param user 消息体内容。
     */
    @RabbitListener(bindings = {
            @QueueBinding(
                    value = @Queue(value = &quot;queue-user-1&quot;, autoDelete = &quot;false&quot;),
                    exchange = @Exchange(value = &quot;ex-fanout&quot;, type = &quot;fanout&quot;, autoDelete = &quot;false&quot;)
            )
    })
    public void onMessage1(User user){
        System.out.println(&quot;onMessage1 run : &quot; + user);
    }

    @RabbitListener(bindings = {
            @QueueBinding(
                    value = @Queue(value = &quot;queue-user-2&quot;, autoDelete = &quot;false&quot;),
                    exchange = @Exchange(value = &quot;ex-fanout&quot;, type = &quot;fanout&quot;)
            )
    })
    public void onMessage2(User user){
        System.out.println(&quot;onMessage2 run : &quot; + user);
    }
}

</code></pre>
<ol start="3">
<li>编写publisher</li>
</ol>
<pre><code class="language-java">/**
 * 发送消息类型。消息发送到fanout交换器中。
 * 交换器名称是： ex-fanout
 */
@Component
public class UserMessageSender {
    @Autowired
    private AmqpTemplate template;

    /**
     * 发送消息方法。
     * @param user
     */
    public void send(User user){
        this.template.convertAndSend(&quot;ex-fanout&quot;, &quot;&quot;, user);
    }
}

</code></pre>
<ol start="4">
<li>编写测试类</li>
</ol>
<pre><code class="language-java">@Autowired
    private UserMessageSender userMessageSender;

   @Test
    public void testSendUserMessage2Fanout(){
        for(int i = 0; i &lt; 3; i++){
            User user = new User();
            user.setId((long) i);
            user.setName(&quot;姓名 - &quot; + i);
            user.setAge(20+i);

            this.userMessageSender.send(user);
        }
    }
</code></pre>
</li>
</ol>
<h3 id="73-topic-交换器">7.3 topic 交换器</h3>
<figure data-type="image" tabindex="28"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200707150313.png" alt="" loading="lazy"></figure>
<p>允许在路由键（RoutingKey）中出现匹配规则。</p>
<p>路由键的写法和包写法相同。com.cy.xxxx.xxx 格式。</p>
<p>在绑定时可以带有下面特殊符号，中间可以出现:</p>
<ul>
<li>
<p>*: 代表一个单词（两个.之间内容）</p>
</li>
<li>
<p>#: 0 个或多个字符</p>
</li>
</ul>
<p>接收方依然是公平调度，同一个队列中内容轮换获取值。</p>
<p>需要使用注解/API：</p>
<p>TopicExchange：Topic 交换器</p>
<p>amq.topic:内置 topic 交换器名称</p>
<h4 id="731-代码">7.3.1 代码</h4>
<ol>
<li>编写consumer</li>
</ol>
<pre><code class="language-java">/**
 * 主题消息消费者。
 */
@Component
public class TopicConsumers {
    /**
     * 短信消息消费者，对应的routingKey是 user.rk.sms | order.rk.sms | pay.rk.sms | reg.rk.sms 等。
     * 分别代表，用户登录短信|订单下订成功通知短信|支付成功通知短信|注册码通知短信 等。
     */
    @RabbitListener(bindings = {
            @QueueBinding(
                    value = @Queue(value = &quot;queue-sms-topic&quot;, autoDelete = &quot;false&quot;),
                    exchange = @Exchange(value = &quot;ex-topic&quot;, type = &quot;topic&quot;),
                    key = &quot;*.rk.sms&quot;
            )
    })
    public void onUserSMSMessage(String message){
        System.out.println(&quot;用户短信消息内容是：&quot; + message);
    }

    /**
     * 路由键包括： user.rk.email | reg.rk.email | pay.rk.email
     * @param message
     */
    @RabbitListener(bindings = {
            @QueueBinding(
                    value = @Queue(value = &quot;queue-email-topic&quot;, autoDelete = &quot;false&quot;),
                    exchange = @Exchange(value = &quot;ex-topic&quot;, type = &quot;topic&quot;),
                    key = &quot;*.rk.email&quot;
            )
    })
    public void onUserEmailMessage(String message){
        System.out.println(&quot;用户邮件消息内容是：&quot; + message);
    }

    /**
     * 所有的和 rk相关的消息，统一处理消费。
     * 包含的路由键有： user.rk.sms | user.rk.email | reg.rk.sms | reg.rk.email 等。
     * 不发短信，不发邮件，作为一个日志记录工具存在。
     * @param message
     */
    @RabbitListener(bindings = {
            @QueueBinding(
                    value = @Queue(value = &quot;queue-all-topic&quot;, autoDelete = &quot;false&quot;),
                    exchange = @Exchange(value = &quot;ex-topic&quot;, type = &quot;topic&quot;),
                    key = &quot;*.rk.*&quot;
            )
    })
    public void onUserServiceMessage(String message){
        System.out.println(&quot;执行的消息处理逻辑是：&quot; + message);
    }
}


</code></pre>
<ol start="2">
<li>编写publisher</li>
</ol>
<pre><code class="language-java">/**
 * 发送消息到主题交换器
 */
@Component
public class TopicMessageSender {
    @Autowired
    private AmqpTemplate template;

    /**
     * 发送消息的方法
     * @param exchange
     * @param routingKey
     * @param message
     */
    public void send(String exchange, String routingKey, String message){
        template.convertAndSend(exchange, routingKey, message);
    }
}

</code></pre>
<ol start="3">
<li>编写测试类</li>
</ol>
<pre><code class="language-java">@Autowired
private TopicMessageSender topicMessageSender;


@Test
    public void testSendMessage2Topic(){
        // 随机数%6
        // 0 rk - user.rk.sms *.rk.*  *.rk.sms
        // 1 rk - user.rk.email   *.rk.* *.rk.email
        // 2 rk - order.rk.sms *.rk.*  *.rk.sms
        // 3 rk - order.rk.email  *.rk.* *.rk.email
        // 4 rk - reg.rk.sms *.rk.*  *.rk.sms
        // 5 rk - reg.rk.qq  *.rk.*
        Random r = new Random();
        for(int i = 0; i &lt; 10; i++){
            int rInt = r.nextInt(100);
            if(rInt%6 == 0){
                this.topicMessageSender.send(&quot;ex-topic&quot;,
                        &quot;user.rk.sms&quot;,
                        &quot;用户登录验证码是123456 - 发送短信&quot;);
            }else if(rInt%6 == 1){
                this.topicMessageSender.send(&quot;ex-topic&quot;,
                        &quot;user.rk.email&quot;,
                        &quot;用户登录验证码是123456 - 发送到邮箱&quot;);
            }else if(rInt%6 == 2){
                this.topicMessageSender.send(&quot;ex-topic&quot;,
                        &quot;order.rk.sms&quot;,
                        &quot;订单下订成功 - 发送短信&quot;);
            }else if(rInt%6 == 3){
                this.topicMessageSender.send(&quot;ex-topic&quot;,
                        &quot;order.rk.email&quot;,
                        &quot;订单下订成功 - 发送到邮箱&quot;);
            }else if(rInt%6 == 4){
                this.topicMessageSender.send(&quot;ex-topic&quot;,
                        &quot;reg.rk.sms&quot;,
                        &quot;注册验证码是654321 - 发送短信&quot;);
            }else if(rInt%6 == 5){
                this.topicMessageSender.send(&quot;ex-topic&quot;,
                        &quot;reg.rk.qq&quot;,
                        &quot;注册验证码是654321 - 发送QQ信息&quot;);
            }
        }
    }

</code></pre>
<p>结果：</p>
<figure data-type="image" tabindex="29"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200707162555.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="30"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200707162450.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ActiveMQ]]></title>
        <id>https://jonchan1013.github.io/post/activemq/</id>
        <link href="https://jonchan1013.github.io/post/activemq/">
        </link>
        <updated>2020-07-06T05:08:13.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="1-activemq-简介">1、 ActiveMQ 简介</h2>
<h3 id="11-什么是-activemq">1.1 什么是 ActiveMQ</h3>
<p>​		ActiveMQ 是 Apache 出品，最流行的，能力强劲的开源消息总线。ActiveMQ 是一个完全支持 JMS1.1 和 J2EE 1.4 规范的 JMS Provider 实现，尽管 JMS 规范出台已经是很久的事情了，但是 JMS 在当今的 J2EE 应用中间仍然扮演着特殊的地位。</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="1-activemq-简介">1、 ActiveMQ 简介</h2>
<h3 id="11-什么是-activemq">1.1 什么是 ActiveMQ</h3>
<p>​		ActiveMQ 是 Apache 出品，最流行的，能力强劲的开源消息总线。ActiveMQ 是一个完全支持 JMS1.1 和 J2EE 1.4 规范的 JMS Provider 实现，尽管 JMS 规范出台已经是很久的事情了，但是 JMS 在当今的 J2EE 应用中间仍然扮演着特殊的地位。</p>
<!-- more -->
<h3 id="12-什么是消息">1.2 什么是消息</h3>
<p>​	“消息”是在两台计算机间传送的数据单位。消息可以非常简单，例如只包含文本字符串；也可以更复杂，可能包含嵌入对象。</p>
<h3 id="13-什么是队列">1.3 什么是队列</h3>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200702112943.png" alt="" loading="lazy"></figure>
<h3 id="14-什么是消息队列">1.4 什么是消息队列</h3>
<p>“消息队列”是在消息的传输过程中保存消息的容器。</p>
<h3 id="15-常用消息服务应用">1.5 常用消息服务应用</h3>
<h4 id="151-activemq">1.5.1 ActiveMQ</h4>
<p>ActiveMQ 是 Apache 出品，最流行的，能力强劲的开源消息总线。ActiveMQ 是一个完全支持 JMS1.1 和 J2EE 1.4 规范的 JMS Provider 实现。</p>
<h4 id="152-rabbitmq">1.5.2 RabbitMQ</h4>
<p>RabbitMQ 是一个在 AMQP 基础上完成的，可复用的企业消息系统。他遵循 Mozilla Public License 开源协议。开发语言为 Erlang。</p>
<h4 id="153-rocketmq">1.5.3 RocketMQ</h4>
<p>由阿里巴巴定义开发的一套消息队列应用服务。</p>
<h2 id="2-消息服务的应用场景">2、 消息服务的应用场景</h2>
<p>消息队列的主要特点是<strong>异步处理</strong>，主要目的是<strong>减少请求响应时间和解耦</strong>。所以主要的使用场景就是将比较耗时而且**不需要即时（同步）**返回结果的操作作为消息放入消息队列。同时由于使用了消息队列，只要保证消息格式不变，消息的发送方和接收方并不需要彼此联系，也不需要受对方的影响，即解耦和。</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200702113244.png" alt="" loading="lazy"></figure>
<h3 id="21-异步处理">2.1 异步处理</h3>
<p>例如： <strong>用户注册:</strong></p>
<p>用户注册流程：<br>
1）注册处理以及写数据库<br>
2）发送注册成功的手机短信<br>
3）发送注册成功的邮件信息</p>
<p>如果用消息中间件：则可以创建两个线程来做这些事情，直接发送消息给消息中间件，然后让邮件服务和短信服务自己去消息中间件里面去取消息，然后取到消息后再自己做对应的业务操作。就是这么方便</p>
<h3 id="22-应用的解耦">2.2 应用的解耦</h3>
<p>例如：<strong>订单处理：</strong></p>
<p>生成订单流程：<br>
1）在购物车中点击结算<br>
2）完成支付<br>
3）创建订单<br>
4）调用库存系统<br>
订单完成后，订单系统并不去直接调用库存系统，而是发送消息到消息中间件，写入一个订单信息。库存系统自己去消息中间件上去获取，然后做发货处理，并更新库存，这样能够实现互联网型应用追求的快这一个属性。而库存系统读取订单后库存应用这个操作也是非常快的，所以有消息中间件对解耦来说也是一个不错的方向。</p>
<h3 id="23-流量的削峰">2.3 流量的削峰</h3>
<p>例如：<strong>秒杀功能：</strong></p>
<p>秒杀流程：<br>
1）用户点击秒杀<br>
2）发送请求到秒杀应用<br>
3）在请求秒杀应用之前将请求放入到消息队列<br>
4）秒杀应用从消息队列中获取请求并处理。<br>
比如，系统举行秒杀活动，热门商品。流量蜂拥而至 100 件商品，10 万人挤进来怎么办？10 万秒杀的操作，放入消息队列。秒杀应用处理消息队列中的 10 万个请求中的前 100个，其他的打回，通知失败。流量峰值控制在消息队列处，秒杀应用不会瞬间被怼死.</p>
<h2 id="3-jms">3、JMS</h2>
<h3 id="31-什么是-jms">3.1 什么是 JMS</h3>
<p>JMS（Java Messaging Service）是 Java 平台上有关面向消息中间件的技术规范，它便于消息系统中的 Java 应用程序进行消息交换,并且通过提供标准的产生、发送、接收消息的接口，简化企业应用的开发。</p>
<h3 id="32-jms-模型">3.2 JMS 模型</h3>
<h4 id="321-点对点模型point-to-point">3.2.1 点对点模型(Point To Point)</h4>
<p>生产者发送一条消息到 queue，只有一个消费者能收到。</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200702113738.png" alt="" loading="lazy"></figure>
<h4 id="322-发布订阅模型publishsubscribe">3.2.2 发布订阅模型(Publish/Subscribe)</h4>
<p>发布者发送到 topic 的消息，只有订阅了 topic 的订阅者才会收到消息。</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200702113806.png" alt="" loading="lazy"></figure>
<h2 id="4-activemq-安装">4、ActiveMQ 安装</h2>
<ol>
<li>
<p>下载activemq，下载地址：http://archive.apache.org/dist/activemq。测试版本为apache-activemq-5.15.8。</p>
</li>
<li>
<p>在/ursr/local/目录下新建activemq文件夹，并进入该文件夹，执行如下命令解压文件。</p>
</li>
</ol>
<pre><code>cd /usr/local
mkdir activemq
tar -xzvf apache-activemq-5.15.8-bin.tar.gz
mv apache-activemq-5.15.8 /usr/local/activemq/
</code></pre>
<ol start="3">
<li>
<p>检查权限</p>
<p>ls -al apache-activemq-5.15.8/bin<br>
如果权限不足,则无法执行,需要修改文件权限:<br>
chmod 755 activemq</p>
</li>
</ol>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200702114351.png" alt="" loading="lazy"></figure>
<ol start="4">
<li>
<p>启动 ActiveMQ</p>
<p>./activemq start</p>
</li>
</ol>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200702114519.png" alt="" loading="lazy"></figure>
<ol start="5">
<li>
<p>测试 ActiveMQ</p>
<ol>
<li>
<p>检查进程</p>
<p>ps aux | grep activemq<br>
见到下述内容即代表启动成功</p>
</li>
</ol>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200702114848.png" alt="" loading="lazy"></figure>
<ol start="2">
<li>
<p>管理界面</p>
<p>使用浏览器访问 ActiveMQ 管理应用, 地址如下:<br>
http://ip:8161/admin/<br>
用户名: admin<br>
密码: admin<br>
ActiveMQ 使用的是 jetty 提供 HTTP 服务.启动稍慢,建议短暂等待再访问测试.<br>
见到如下界面代表服务启动成功</p>
</li>
</ol>
<figure data-type="image" tabindex="8"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200702115054.png" alt="" loading="lazy"></figure>
<ol start="3">
<li>修改访问端口</li>
</ol>
<p>修改 ActiveMQ 配置文件: /usr/local/activemq/conf/jetty.xml</p>
<figure data-type="image" tabindex="9"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200702115133.png" alt="" loading="lazy"></figure>
<p>配置文件修改完毕，保存并重新启动 ActiveMQ 服务。</p>
<ol start="4">
<li>修改用户名和密码</li>
</ol>
<p>修改 conf/users.properties 配置文件.内容为: 用户名=密码<br>
保存并重启 ActiveMQ 服务即可.</p>
</li>
<li>
<p>重启 ActiveMQ<br>
/usr/local/activemq/apache-activemq-5.15.8/bin/activemq restart</p>
</li>
<li>
<p>关闭 ActiveMQ<br>
/usr/local/activemq/bin/activemq stop</p>
</li>
<li>
<p>配置文件 activemq.xml<br>
配置文件中,配置的是 ActiveMQ 的核心配置信息. 是提供服务时使用的配置. 可以修改启动的访问端口. 即 java 编程中访问 ActiveMQ 的访问端口.<br>
默认端口为 61616.<br>
使用协议是: tcp 协议.<br>
修改端口后, 保存并重启 ActiveMQ 服务即可.</p>
</li>
<li>
<p>ActiveMQ 目录介绍<br>
从它的目录来说,还是很简单的:</p>
<ul>
<li>bin 存放的是脚本文件</li>
<li>conf 存放的是基本配置文件</li>
<li>data 存放的是日志文件</li>
<li>docs 存放的是说明文档</li>
<li>examples 存放的是简单的实例</li>
<li>lib 存放的是 activemq 所需 jar 包</li>
<li>webapps 用于存放项目的目录</li>
</ul>
</li>
</ol>
<h2 id="5-activemq-术语">5、ActiveMQ 术语</h2>
<ol>
<li>
<p>Destination<br>
目的地，JMS Provider（消息中间件）负责维护，用于对 Message 进行管理的对象。MessageProducer 需要指定 Destination 才能发送消息，MessageReceiver 需要指定 Destination才能接收消息。</p>
</li>
<li>
<p>Producer<br>
消息生成者，负责发送 Message 到目的地。</p>
</li>
<li>
<p>Consumer | Receiver<br>
消息消费者，负责从目的地中消费【处理|监听|订阅】Message。</p>
</li>
<li>
<p>Message<br>
消息，消息封装一次通信的内容。</p>
</li>
</ol>
<h2 id="6-activemq-应用">6、 ActiveMQ 应用</h2>
<h3 id="61-activemq-常用-api-简介">6.1 ActiveMQ 常用 API 简介</h3>
<p>下述 API 都是接口类型,由定义在 javax.jms 包中.<br>
是 JMS 标准接口定义.</p>
<ol>
<li>
<p>ConnectionFactory<br>
链接工厂, 用于创建链接的工厂类型.</p>
</li>
<li>
<p>Connection<br>
链接. 用于建立访问 ActiveMQ 连接的类型, 由链接工厂创建.</p>
</li>
<li>
<p>Session<br>
会话, 一次持久有效有状态的访问. 由链接创建.</p>
</li>
<li>
<p>Destination &amp; Queue<br>
目的地, 用于描述本次访问 ActiveMQ 的消息访问目的地. 即 ActiveMQ 服务中的具体队列. 由会话创建.<br>
interface Queue extends Destination</p>
</li>
<li>
<p>MessageProducer<br>
消息生成者, 在一次有效会话中, 用于发送消息给 ActiveMQ 服务的工具. 由会话创建.</p>
</li>
<li>
<p>MessageConsumer<br>
消息消费者【消息订阅者，消息处理者】, 在一次有效会话中, 用于从 ActiveMQ 服务中获取消息的工具. 由会话创建.</p>
</li>
<li>
<p>Message<br>
消息, 通过消息生成者向 ActiveMQ 服务发送消息时使用的数据载体对象或消息消费者从 ActiveMQ 服务中获取消息时使用的数据载体对象. 是所有消息【文本消息，对象消息等】具体类型的顶级接口. 可以通过会话创建或通过会话从 ActiveMQ 服务中获取.</p>
</li>
</ol>
<h3 id="62-jms-helloworld">6.2 JMS-HelloWorld</h3>
<h4 id="621-处理文本消息">6.2.1 处理文本消息</h4>
<h5 id="6211-创建消息生产者">6.2.1.1 创建消息生产者</h5>
<ol>
<li>修改 POM 文件添加 ActiveMQ 坐标</li>
</ol>
<pre><code class="language-xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;
        &lt;artifactId&gt;activemq-all&lt;/artifactId&gt;
        &lt;version&gt;5.15.8&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<ol start="2">
<li>编写消息的生产者</li>
</ol>
<pre><code class="language-java">public class HelloWorldProducer {
    /**
     * 生产消息
     */
    public void sendHelloWorldActiveMQ(String msg) {

        //定义链接工厂
        ConnectionFactory connectionFactory = null;

        //定义链接对象
        Connection connection = null;

        //定义会话
        Session session = null;

        //定义目的地
        Destination destination = null;

        //定义消息的发送者
        MessageProducer messageProducer = null;

        //定义消息
        Message message = null;

        try {
            /**
             * userName:访问 ActiveMQ 服务的用户名。用户密码。默认的为 admin。用户名可以通过jetty-ream.properties 文件进行修改
             * password:访问 ActiveMQ 服务的用户名。用户密码。默认的为 admin。用户名可以通过jetty-ream.properties 文件进行修改
             * brokerURL:访问 ActiveMQ 服务的路径地址。 路径结构为:协议名://主机地址:端口号
             */
            connectionFactory = new ActiveMQConnectionFactory(&quot;admin&quot;, &quot;admin&quot;, &quot;tcp://124.70.181.124:61616&quot;);

            //创建连接对象
            connection = connectionFactory.createConnection();
            //启动连接
            connection.start();

            /**
             * transacted:是否使用事务 可选值为：   true|false
             * true:使用事务 当设置次变量值。  Session.SESSION_TRANSACTED
             * false:不适用事务,设置次变量 则 acknowledgeMode 参数必须设置
             * acknowledgeMode:
             * Session.AUTO_ACKNOWLEDGE:自动消息确认机制
             * Session.CLIENT_ACKNOWLEDGE:客户端确认机制
             * Session.DUPS_OK_ACKNOWLEDGE:有副本的客户端确认消息机制
             */
            session = connection.createSession(false, session.AUTO_ACKNOWLEDGE);
            //创建目的地，目的地名称即队列的名称。消息的消费者需要通过此名称访问对应的队列
            destination = session.createQueue(&quot;HelloWorld-destination&quot;);
            //创建消息的生产者
            messageProducer = session.createProducer(destination);
            //创建消息对象
            message = session.createTextMessage(msg);
            //发送消息
            messageProducer.send(message);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (messageProducer != null) {
                try {
                    messageProducer.close();
                } catch (JMSException e) {
                    e.printStackTrace();
                }
            }
            if (session != null) {
                try {
                    session.close();
                } catch (JMSException e) {
                    e.printStackTrace();
                }
            }
            if (connection != null) {
                try {
                    connection.close();
                } catch (JMSException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

</code></pre>
<h5 id="6212-创建消息消费者">6.2.1.2 创建消息消费者</h5>
<ol>
<li>修改 POM 文件添加 ActiveMQ 坐标</li>
</ol>
<pre><code class="language-xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;
        &lt;artifactId&gt;activemq-all&lt;/artifactId&gt;
        &lt;version&gt;5.15.8&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<ol start="2">
<li>编写消息的消费者</li>
</ol>
<pre><code class="language-java">public class HelloWorldConsumer {
    /**
     * 消费消息
     */
    public void receiveHelloWorldActiveMQ() {

        //定义链接工厂
        ConnectionFactory connectionFactory = null;

        //定义链接对象
        Connection connection = null;

        //定义会话
        Session session = null;

        //定义目的地
        Destination destination = null;

        //定义消息的接收者
        MessageConsumer messageConsumer = null;

        //定义消息
        Message message = null;

        try {
            /**
             * userName:访问 ActiveMQ 服务的用户名。用户密码。默认的为 admin。用户名可以通过jetty-ream.properties 文件进行修改
             * password:访问 ActiveMQ 服务的用户名。用户密码。默认的为 admin。用户名可以通过jetty-ream.properties 文件进行修改
             * brokerURL:访问 ActiveMQ 服务的路径地址。 路径结构为:协议名://主机地址:端口号
             */
            connectionFactory = new ActiveMQConnectionFactory(&quot;admin&quot;, &quot;admin&quot;, &quot;tcp://124.70.181.124:61616&quot;);

            //创建连接对象
            connection = connectionFactory.createConnection();
            //启动连接
            connection.start();

            /**
             * transacted:是否使用事务 可选值为：   true|false
             * true:使用事务 当设置次变量值。  Session.SESSION_TRANSACTED
             * false:不适用事务,设置次变量 则 acknowledgeMode 参数必须设置
             * acknowledgeMode:
             * Session.AUTO_ACKNOWLEDGE:自动消息确认机制
             * Session.CLIENT_ACKNOWLEDGE:客户端确认机制
             * Session.DUPS_OK_ACKNOWLEDGE:有副本的客户端确认消息机制
             */
            session = connection.createSession(false, session.AUTO_ACKNOWLEDGE);
            //创建目的地，目的地名称即队列的名称。消息的消费者需要通过此名称访问对应的队列
            destination = session.createQueue(&quot;HelloWorld-destination&quot;);
            //创建消息的消费者
            messageConsumer = session.createConsumer(destination);
            //创建消息对象
            message = messageConsumer.receive();
            //处理消息
            String msg=((TextMessage)message).getText();
            System.out.println(&quot;从ActiveMQ中取得的文本信息：&quot;+msg);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (messageConsumer != null) {
                try {
                    messageConsumer.close();
                } catch (JMSException e) {
                    e.printStackTrace();
                }
            }
            if (session != null) {
                try {
                    session.close();
                } catch (JMSException e) {
                    e.printStackTrace();
                }
            }
            if (connection != null) {
                try {
                    connection.close();
                } catch (JMSException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

</code></pre>
<h5 id="6213-测试">6.2.1.3 测试</h5>
<ol>
<li>producer</li>
</ol>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        HelloWorldProducer helloWorldProducer = new HelloWorldProducer();
        helloWorldProducer.sendHelloWorldActiveMQ(&quot;HelloActiveMQ!&quot;);
    }
}
</code></pre>
<figure data-type="image" tabindex="10"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200702151912.png" alt="" loading="lazy"></figure>
<ol start="2">
<li>Consumer</li>
</ol>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        HelloWorldConsumer helloWorldConsumer = new HelloWorldConsumer();
        helloWorldConsumer.receiveHelloWorldActiveMQ();
    }
}
</code></pre>
<figure data-type="image" tabindex="11"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200702152153.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200702152322.png" alt="" loading="lazy"></figure>
<p>由于我们消息确认机制使用的是自动的，所以ActiveMQ会自动从队列中将消息移除。</p>
<h4 id="622-处理对象消息">6.2.2 处理对象消息</h4>
<h5 id="6221-定义消息对象">6.2.2.1 定义消息对象</h5>
<pre><code class="language-java">public class Users implements Serializable {
    private int userid;
    private String username;
    private int userage;

    public int getUserid() {
        return userid;
    }

    public void setUserid(int userid) {
        this.userid = userid;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public int getUserage() {
        return userage;
    }

    public void setUserage(int userage) {
        this.userage = userage;
    }

    @Override
    public String toString() {
        return &quot;Users{&quot; +
                &quot;userid=&quot; + userid +
                &quot;, username='&quot; + username + '\'' +
                &quot;, userage=&quot; + userage +
                '}';
    }
}

</code></pre>
<h5 id="6222-创建生产者">6.2.2.2 创建生产者</h5>
<pre><code class="language-java">public class UsersProducer {
    /**
     * 生产消息
     */
    public void sendHelloWorldActiveMQ(Users users) {

        //定义链接工厂
        ConnectionFactory connectionFactory = null;

        //定义链接对象
        Connection connection = null;

        //定义会话
        Session session = null;

        //定义目的地
        Destination destination = null;

        //定义消息的发送者
        MessageProducer messageProducer = null;

        //定义消息
        Message message = null;

        try {
            /**
             * userName:访问 ActiveMQ 服务的用户名。用户密码。默认的为 admin。用户名可以通过jetty-ream.properties 文件进行修改
             * password:访问 ActiveMQ 服务的用户名。用户密码。默认的为 admin。用户名可以通过jetty-ream.properties 文件进行修改
             * brokerURL:访问 ActiveMQ 服务的路径地址。 路径结构为:协议名://主机地址:端口号
             */
            connectionFactory = new ActiveMQConnectionFactory(&quot;admin&quot;, &quot;admin&quot;, &quot;tcp://124.70.181.124:61616&quot;);

            //创建连接对象
            connection = connectionFactory.createConnection();
            //启动连接
            connection.start();

            /**
             * transacted:是否使用事务 可选值为：   true|false
             * true:使用事务 当设置次变量值。  Session.SESSION_TRANSACTED
             * false:不适用事务,设置次变量 则 acknowledgeMode 参数必须设置
             * acknowledgeMode:
             * Session.AUTO_ACKNOWLEDGE:自动消息确认机制
             * Session.CLIENT_ACKNOWLEDGE:客户端确认机制
             * Session.DUPS_OK_ACKNOWLEDGE:有副本的客户端确认消息机制
             */
            session = connection.createSession(false, session.AUTO_ACKNOWLEDGE);
            //创建目的地，目的地名称即队列的名称。消息的消费者需要通过此名称访问对应的队列
            destination = session.createQueue(&quot;my-users&quot;);
            //创建消息的生产者
            messageProducer = session.createProducer(destination);
            //创建消息对象
            message = session.createObjectMessage(users);
            //发送消息
            messageProducer.send(message);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (messageProducer != null) {
                try {
                    messageProducer.close();
                } catch (JMSException e) {
                    e.printStackTrace();
                }
            }
            if (session != null) {
                try {
                    session.close();
                } catch (JMSException e) {
                    e.printStackTrace();
                }
            }
            if (connection != null) {
                try {
                    connection.close();
                } catch (JMSException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

</code></pre>
<h5 id="6223-定义消息消费者">6.2.2.3  定义消息消费者</h5>
<pre><code class="language-java">public class UsersConsumer {
    /**
     * 消费消息
     */
    public void receiveHelloWorldActiveMQ() {

        //定义链接工厂
        ConnectionFactory connectionFactory = null;

        //定义链接对象
        Connection connection = null;

        //定义会话
        Session session = null;

        //定义目的地
        Destination destination = null;

        //定义消息的接收者
        MessageConsumer messageConsumer = null;

        //定义消息
        Message message = null;

        try {
            /**
             * userName:访问 ActiveMQ 服务的用户名。用户密码。默认的为 admin。用户名可以通过jetty-ream.properties 文件进行修改
             * password:访问 ActiveMQ 服务的用户名。用户密码。默认的为 admin。用户名可以通过jetty-ream.properties 文件进行修改
             * brokerURL:访问 ActiveMQ 服务的路径地址。 路径结构为:协议名://主机地址:端口号
             */
            connectionFactory = new ActiveMQConnectionFactory(&quot;admin&quot;, &quot;admin&quot;, &quot;tcp://124.70.181.124:61616&quot;);

            //创建连接对象
            connection = connectionFactory.createConnection();
            //启动连接
            connection.start();

            /**
             * transacted:是否使用事务 可选值为：   true|false
             * true:使用事务 当设置次变量值。  Session.SESSION_TRANSACTED
             * false:不适用事务,设置次变量 则 acknowledgeMode 参数必须设置
             * acknowledgeMode:
             * Session.AUTO_ACKNOWLEDGE:自动消息确认机制
             * Session.CLIENT_ACKNOWLEDGE:客户端确认机制
             * Session.DUPS_OK_ACKNOWLEDGE:有副本的客户端确认消息机制
             */
            session = connection.createSession(false, session.AUTO_ACKNOWLEDGE);
            //创建目的地，目的地名称即队列的名称。消息的消费者需要通过此名称访问对应的队列
            destination = session.createQueue(&quot;my-users&quot;);
            //创建消息的消费者
            messageConsumer = session.createConsumer(destination);
            //创建消息对象
            message = messageConsumer.receive();
            //处理消息
            ObjectMessage objectMessage = (ObjectMessage) message;
            Users users = (Users) objectMessage.getObject();

            System.out.println(&quot;从ActiveMQ中取得的对象信息：&quot;+users.toString());
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (messageConsumer != null) {
                try {
                    messageConsumer.close();
                } catch (JMSException e) {
                    e.printStackTrace();
                }
            }
            if (session != null) {
                try {
                    session.close();
                } catch (JMSException e) {
                    e.printStackTrace();
                }
            }
            if (connection != null) {
                try {
                    connection.close();
                } catch (JMSException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
</code></pre>
<h5 id="6224-测试">6.2.2.4 测试</h5>
<p>producer：</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        /*HelloWorldProducer helloWorldProducer = new HelloWorldProducer();
        helloWorldProducer.sendHelloWorldActiveMQ(&quot;HelloActiveMQ!&quot;);*/
        UsersProducer usersProducer = new UsersProducer();
        Users users = new Users();
        users.setUserid(1);
        users.setUsername(&quot;张三&quot;);
        users.setUserage(18);
        usersProducer.sendHelloWorldActiveMQ(users);
    }
}

</code></pre>
<figure data-type="image" tabindex="13"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200702164028.png" alt="" loading="lazy"></figure>
<p>consumer：</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
/*        HelloWorldConsumer helloWorldConsumer = new HelloWorldConsumer();
        helloWorldConsumer.receiveHelloWorldActiveMQ();*/
        UsersConsumer usersConsumer = new UsersConsumer();
        usersConsumer.receiveHelloWorldActiveMQ();
    }
}
</code></pre>
<h4 id="623-jms-实现队列服务监听">6.2.3 JMS - 实现队列服务监听</h4>
<p>队列服务监听使用的观察者设计模式</p>
<p>这样做的目的是，每次producer发送消息到ActiveMQ中，不必每次重启consumer</p>
<h5 id="6231-创建消息生产者">6.2.3.1 创建消息生产者</h5>
<pre><code class="language-java">public class HelloWorldProducer2 {
    /**
     * 生产消息
     */
    public void sendHelloWorldActiveMQ(String msg) {

        //定义链接工厂
        ConnectionFactory connectionFactory = null;

        //定义链接对象
        Connection connection = null;

        //定义会话
        Session session = null;

        //定义目的地
        Destination destination = null;

        //定义消息的发送者
        MessageProducer messageProducer = null;

        //定义消息
        Message message = null;

        try {
            /**
             * userName:访问 ActiveMQ 服务的用户名。用户密码。默认的为 admin。用户名可以通过jetty-ream.properties 文件进行修改
             * password:访问 ActiveMQ 服务的用户名。用户密码。默认的为 admin。用户名可以通过jetty-ream.properties 文件进行修改
             * brokerURL:访问 ActiveMQ 服务的路径地址。 路径结构为:协议名://主机地址:端口号
             */
            connectionFactory = new ActiveMQConnectionFactory(&quot;admin&quot;, &quot;admin&quot;, &quot;tcp://124.70.181.124:61616&quot;);

            //创建连接对象
            connection = connectionFactory.createConnection();
            //启动连接
            connection.start();

            /**
             * transacted:是否使用事务 可选值为：   true|false
             * true:使用事务 当设置次变量值。  Session.SESSION_TRANSACTED
             * false:不适用事务,设置次变量 则 acknowledgeMode 参数必须设置
             * acknowledgeMode:
             * Session.AUTO_ACKNOWLEDGE:自动消息确认机制
             * Session.CLIENT_ACKNOWLEDGE:客户端确认机制
             * Session.DUPS_OK_ACKNOWLEDGE:有副本的客户端确认消息机制
             */
            session = connection.createSession(false, session.AUTO_ACKNOWLEDGE);
            //创建目的地，目的地名称即队列的名称。消息的消费者需要通过此名称访问对应的队列
            destination = session.createQueue(&quot;my-destination&quot;);
            //创建消息的生产者
            messageProducer = session.createProducer(destination);
            //创建消息对象
            message = session.createTextMessage(msg);
            //发送消息
            messageProducer.send(message);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (messageProducer != null) {
                try {
                    messageProducer.close();
                } catch (JMSException e) {
                    e.printStackTrace();
                }
            }
            if (session != null) {
                try {
                    session.close();
                } catch (JMSException e) {
                    e.printStackTrace();
                }
            }
            if (connection != null) {
                try {
                    connection.close();
                } catch (JMSException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

</code></pre>
<h5 id="6232-消息消费者">6.2.3.2 消息消费者</h5>
<pre><code class="language-java">public class HelloWorldConsumer2 {
    /**
     * 消费消息
     */
    public void receiveHelloWorldActiveMQ() {

        //定义链接工厂
        ConnectionFactory connectionFactory = null;

        //定义链接对象
        Connection connection = null;

        //定义会话
        Session session = null;

        //定义目的地
        Destination destination = null;

        //定义消息的接收者
        MessageConsumer messageConsumer = null;

        //定义消息
        Message message = null;

        try {
            /**
             * userName:访问 ActiveMQ 服务的用户名。用户密码。默认的为 admin。用户名可以通过jetty-ream.properties 文件进行修改
             * password:访问 ActiveMQ 服务的用户名。用户密码。默认的为 admin。用户名可以通过jetty-ream.properties 文件进行修改
             * brokerURL:访问 ActiveMQ 服务的路径地址。 路径结构为:协议名://主机地址:端口号
             */
            connectionFactory = new ActiveMQConnectionFactory(&quot;admin&quot;, &quot;admin&quot;, &quot;tcp://124.70.181.124:61616&quot;);

            //创建连接对象
            connection = connectionFactory.createConnection();
            //启动连接
            connection.start();

            /**
             * transacted:是否使用事务 可选值为：   true|false
             * true:使用事务 当设置次变量值。  Session.SESSION_TRANSACTED
             * false:不适用事务,设置次变量 则 acknowledgeMode 参数必须设置
             * acknowledgeMode:
             * Session.AUTO_ACKNOWLEDGE:自动消息确认机制
             * Session.CLIENT_ACKNOWLEDGE:客户端确认机制
             * Session.DUPS_OK_ACKNOWLEDGE:有副本的客户端确认消息机制
             */
            session = connection.createSession(false, session.AUTO_ACKNOWLEDGE);
            //创建目的地，目的地名称即队列的名称。消息的消费者需要通过此名称访问对应的队列
            destination = session.createQueue(&quot;my-destination&quot;);
            //创建消息的消费者
            messageConsumer = session.createConsumer(destination);

            messageConsumer.setMessageListener(new MessageListener() {
                public void onMessage(Message message) {
                    /**
                     * ActiveMQ 回调的方法。通过该方法将消息传递到 consumer
                     */
                    String msg= null;
                    try {
                        msg = ((TextMessage)message).getText();
                    } catch (JMSException e) {
                        e.printStackTrace();
                    }
                    System.out.println(&quot;从ActiveMQ中取得的文本信息：&quot;+msg);
                }
            });

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<h5 id="6233-测试">6.2.3.3 测试</h5>
<p>consumer</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
/*        HelloWorldConsumer helloWorldConsumer = new HelloWorldConsumer();
        helloWorldConsumer.receiveHelloWorldActiveMQ();*/
       /* UsersConsumer usersConsumer = new UsersConsumer();
        usersConsumer.receiveHelloWorldActiveMQ();*/

        HelloWorldConsumer2 helloWorldConsumer2 = new HelloWorldConsumer2();
        helloWorldConsumer2.receiveHelloWorldActiveMQ();
    }
}
</code></pre>
<p>producer</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        /*HelloWorldProducer helloWorldProducer = new HelloWorldProducer();
        helloWorldProducer.sendHelloWorldActiveMQ(&quot;HelloActiveMQ!&quot;);*/
       /* UsersProducer usersProducer = new UsersProducer();
        Users users = new Users();
        users.setUserid(1);
        users.setUsername(&quot;张三&quot;);
        users.setUserage(18);
        usersProducer.sendHelloWorldActiveMQ(users);*/

        HelloWorldProducer2 helloWorldProducer2 = new HelloWorldProducer2();
        helloWorldProducer2.sendHelloWorldActiveMQ(&quot;Hello ActiveMQ1&quot;);
    }
}
</code></pre>
<figure data-type="image" tabindex="14"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200706095439.png" alt="" loading="lazy"></figure>
<p>producer</p>
<pre><code class="language-java">helloWorldProducer2.sendHelloWorldActiveMQ(&quot;Hello ActiveMQ2&quot;);
</code></pre>
<figure data-type="image" tabindex="15"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200706095835.png" alt="" loading="lazy"></figure>
<p>期间没有重启consumer</p>
<h4 id="624-topic-模型">6.2.4 Topic 模型</h4>
<h5 id="6241-publishsubscribe-处理模式topic">6.2.4.1 Publish/Subscribe 处理模式（Topic）</h5>
<p>消息生产者（发布）将消息发布到 topic 中，同时有多个消息消费者（订阅）消费该消息。<br>
和点对点方式不同，发布到 topic 的消息会被所有订阅者消费。<br>
当生产者发布消息，不管是否有消费者。都不会保存消息<br>
一定要先有消息的消费者，后有消息的生产者。</p>
<figure data-type="image" tabindex="16"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200706101359.png" alt="" loading="lazy"></figure>
<h5 id="6242-创建生产者">6.2.4.2 创建生产者</h5>
<pre><code class="language-java">public class HelloWorldProducerTopic {
    /**
     * 生产消息
     */
    public void sendHelloWorldActiveMQ(String msg) {

        //定义链接工厂
        ConnectionFactory connectionFactory = null;

        //定义链接对象
        Connection connection = null;

        //定义会话
        Session session = null;

        //定义目的地
        Destination destination = null;

        //定义消息的发送者
        MessageProducer messageProducer = null;

        //定义消息
        Message message = null;

        try {
            /**
             * userName:访问 ActiveMQ 服务的用户名。用户密码。默认的为 admin。用户名可以通过jetty-ream.properties 文件进行修改
             * password:访问 ActiveMQ 服务的用户名。用户密码。默认的为 admin。用户名可以通过jetty-ream.properties 文件进行修改
             * brokerURL:访问 ActiveMQ 服务的路径地址。 路径结构为:协议名://主机地址:端口号
             */
            connectionFactory = new ActiveMQConnectionFactory(&quot;admin&quot;, &quot;admin&quot;, &quot;tcp://124.70.181.124:61616&quot;);

            //创建连接对象
            connection = connectionFactory.createConnection();
            //启动连接
            connection.start();

            /**
             * transacted:是否使用事务 可选值为：   true|false
             * true:使用事务 当设置次变量值。  Session.SESSION_TRANSACTED
             * false:不适用事务,设置次变量 则 acknowledgeMode 参数必须设置
             * acknowledgeMode:
             * Session.AUTO_ACKNOWLEDGE:自动消息确认机制
             * Session.CLIENT_ACKNOWLEDGE:客户端确认机制
             * Session.DUPS_OK_ACKNOWLEDGE:有副本的客户端确认消息机制
             */
            session = connection.createSession(false, session.AUTO_ACKNOWLEDGE);
            //创建目的地，目的地名称即队列的名称。消息的消费者需要通过此名称访问对应的队列
            destination = session.createTopic(&quot;test-topic&quot;);
            //创建消息的生产者
            messageProducer = session.createProducer(destination);
            //创建消息对象
            message = session.createTextMessage(msg);
            //发送消息
            messageProducer.send(message);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (messageProducer != null) {
                try {
                    messageProducer.close();
                } catch (JMSException e) {
                    e.printStackTrace();
                }
            }
            if (session != null) {
                try {
                    session.close();
                } catch (JMSException e) {
                    e.printStackTrace();
                }
            }
            if (connection != null) {
                try {
                    connection.close();
                } catch (JMSException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

</code></pre>
<h5 id="6243-创建消费者">6.2.4.3 创建消费者</h5>
<p>HelloWorldConsumerTopic:</p>
<pre><code class="language-java">public class HelloWorldConsumerTopic implements Runnable{
    /**
     * 消费消息
     */
    public void receiveHelloWorldActiveMQ() {

        //定义链接工厂
        ConnectionFactory connectionFactory = null;

        //定义链接对象
        Connection connection = null;

        //定义会话
        Session session = null;

        //定义目的地
        Destination destination = null;

        //定义消息的接收者
        MessageConsumer messageConsumer = null;

        //定义消息
        Message message = null;

        try {
            /**
             * userName:访问 ActiveMQ 服务的用户名。用户密码。默认的为 admin。用户名可以通过jetty-ream.properties 文件进行修改
             * password:访问 ActiveMQ 服务的用户名。用户密码。默认的为 admin。用户名可以通过jetty-ream.properties 文件进行修改
             * brokerURL:访问 ActiveMQ 服务的路径地址。 路径结构为:协议名://主机地址:端口号
             */
            connectionFactory = new ActiveMQConnectionFactory(&quot;admin&quot;, &quot;admin&quot;, &quot;tcp://124.70.181.124:61616&quot;);

            //创建连接对象
            connection = connectionFactory.createConnection();
            //启动连接
            connection.start();

            /**
             * transacted:是否使用事务 可选值为：   true|false
             * true:使用事务 当设置次变量值。  Session.SESSION_TRANSACTED
             * false:不适用事务,设置次变量 则 acknowledgeMode 参数必须设置
             * acknowledgeMode:
             * Session.AUTO_ACKNOWLEDGE:自动消息确认机制
             * Session.CLIENT_ACKNOWLEDGE:客户端确认机制
             * Session.DUPS_OK_ACKNOWLEDGE:有副本的客户端确认消息机制
             */
            session = connection.createSession(false, session.AUTO_ACKNOWLEDGE);
            //创建目的地，目的地名称即队列的名称。消息的消费者需要通过此名称访问对应的队列
            destination = session.createTopic(&quot;test-topic&quot;);
            //创建消息的消费者
            messageConsumer = session.createConsumer(destination);

            messageConsumer.setMessageListener(new MessageListener() {
                public void onMessage(Message message) {
                    /**
                     * ActiveMQ 回调的方法。通过该方法将消息传递到 consumer
                     */
                    String msg= null;
                    try {
                        msg = ((TextMessage)message).getText();
                    } catch (JMSException e) {
                        e.printStackTrace();
                    }
                    System.out.println(&quot;从ActiveMQ中取得的文本信息Topic1:&quot;+msg);
                }
            });

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public void run() {
        this.receiveHelloWorldActiveMQ();
    }
}

</code></pre>
<p>HelloWorldConsumerTopic2:</p>
<pre><code class="language-java">public class HelloWorldConsumerTopic2 implements Runnable{
    /**
     * 消费消息
     */
    public void receiveHelloWorldActiveMQ() {

        //定义链接工厂
        ConnectionFactory connectionFactory = null;

        //定义链接对象
        Connection connection = null;

        //定义会话
        Session session = null;

        //定义目的地
        Destination destination = null;

        //定义消息的接收者
        MessageConsumer messageConsumer = null;

        //定义消息
        Message message = null;

        try {
            /**
             * userName:访问 ActiveMQ 服务的用户名。用户密码。默认的为 admin。用户名可以通过jetty-ream.properties 文件进行修改
             * password:访问 ActiveMQ 服务的用户名。用户密码。默认的为 admin。用户名可以通过jetty-ream.properties 文件进行修改
             * brokerURL:访问 ActiveMQ 服务的路径地址。 路径结构为:协议名://主机地址:端口号
             */
            connectionFactory = new ActiveMQConnectionFactory(&quot;admin&quot;, &quot;admin&quot;, &quot;tcp://124.70.181.124:61616&quot;);

            //创建连接对象
            connection = connectionFactory.createConnection();
            //启动连接
            connection.start();

            /**
             * transacted:是否使用事务 可选值为：   true|false
             * true:使用事务 当设置次变量值。  Session.SESSION_TRANSACTED
             * false:不适用事务,设置次变量 则 acknowledgeMode 参数必须设置
             * acknowledgeMode:
             * Session.AUTO_ACKNOWLEDGE:自动消息确认机制
             * Session.CLIENT_ACKNOWLEDGE:客户端确认机制
             * Session.DUPS_OK_ACKNOWLEDGE:有副本的客户端确认消息机制
             */
            session = connection.createSession(false, session.AUTO_ACKNOWLEDGE);
            //创建目的地，目的地名称即队列的名称。消息的消费者需要通过此名称访问对应的队列
            destination = session.createTopic(&quot;test-topic&quot;);
            //创建消息的消费者
            messageConsumer = session.createConsumer(destination);

            messageConsumer.setMessageListener(new MessageListener() {
                public void onMessage(Message message) {
                    /**
                     * ActiveMQ 回调的方法。通过该方法将消息传递到 consumer
                     */
                    String msg= null;
                    try {
                        msg = ((TextMessage)message).getText();
                    } catch (JMSException e) {
                        e.printStackTrace();
                    }
                    System.out.println(&quot;从ActiveMQ中取得的文本信息Topic2:&quot;+msg);
                }
            });

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public void run() {
        this.receiveHelloWorldActiveMQ();
    }
}
</code></pre>
<p>HelloWorldConsumerTopic3:</p>
<pre><code class="language-java">public class HelloWorldConsumerTopic3 implements Runnable{
    /**
     * 消费消息
     */
    public void receiveHelloWorldActiveMQ() {

        //定义链接工厂
        ConnectionFactory connectionFactory = null;

        //定义链接对象
        Connection connection = null;

        //定义会话
        Session session = null;

        //定义目的地
        Destination destination = null;

        //定义消息的接收者
        MessageConsumer messageConsumer = null;

        //定义消息
        Message message = null;

        try {
            /**
             * userName:访问 ActiveMQ 服务的用户名。用户密码。默认的为 admin。用户名可以通过jetty-ream.properties 文件进行修改
             * password:访问 ActiveMQ 服务的用户名。用户密码。默认的为 admin。用户名可以通过jetty-ream.properties 文件进行修改
             * brokerURL:访问 ActiveMQ 服务的路径地址。 路径结构为:协议名://主机地址:端口号
             */
            connectionFactory = new ActiveMQConnectionFactory(&quot;admin&quot;, &quot;admin&quot;, &quot;tcp://124.70.181.124:61616&quot;);

            //创建连接对象
            connection = connectionFactory.createConnection();
            //启动连接
            connection.start();

            /**
             * transacted:是否使用事务 可选值为：   true|false
             * true:使用事务 当设置次变量值。  Session.SESSION_TRANSACTED
             * false:不适用事务,设置次变量 则 acknowledgeMode 参数必须设置
             * acknowledgeMode:
             * Session.AUTO_ACKNOWLEDGE:自动消息确认机制
             * Session.CLIENT_ACKNOWLEDGE:客户端确认机制
             * Session.DUPS_OK_ACKNOWLEDGE:有副本的客户端确认消息机制
             */
            session = connection.createSession(false, session.AUTO_ACKNOWLEDGE);
            //创建目的地，目的地名称即队列的名称。消息的消费者需要通过此名称访问对应的队列
            destination = session.createTopic(&quot;test-topic&quot;);
            //创建消息的消费者
            messageConsumer = session.createConsumer(destination);

            messageConsumer.setMessageListener(new MessageListener() {
                public void onMessage(Message message) {
                    /**
                     * ActiveMQ 回调的方法。通过该方法将消息传递到 consumer
                     */
                    String msg= null;
                    try {
                        msg = ((TextMessage)message).getText();
                    } catch (JMSException e) {
                        e.printStackTrace();
                    }
                    System.out.println(&quot;从ActiveMQ中取得的文本信息Topic3:&quot;+msg);
                }
            });

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public void run() {
        this.receiveHelloWorldActiveMQ();
    }
}
</code></pre>
<h5 id="6244-测试">6.2.4.4 测试</h5>
<p>consunmer:</p>
<pre><code class="language-java">public class TestConsumer {
    public static void main(String[] args) {
        HelloWorldConsumerTopic helloWorldConsumerTopic = new HelloWorldConsumerTopic();
        Thread t1 = new Thread(helloWorldConsumerTopic);
        t1.start();

        HelloWorldConsumerTopic2 helloWorldConsumerTopic2 = new HelloWorldConsumerTopic2();
        Thread t2 = new Thread(helloWorldConsumerTopic2);
        t2.start();

        HelloWorldConsumerTopic3 helloWorldConsumerTopic3 = new HelloWorldConsumerTopic3();
        Thread t3 = new Thread(helloWorldConsumerTopic3);
        t3.start();
    }
}

</code></pre>
<p>producer:</p>
<pre><code class="language-java">public class TestProducer {
    public static void main(String[] args) {
        HelloWorldProducerTopic helloWorldProducerTopic = new HelloWorldProducerTopic();
        helloWorldProducerTopic.sendHelloWorldActiveMQ(&quot;Hello-Topic&quot;);
    }
}
</code></pre>
<figure data-type="image" tabindex="17"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200706103105.png" alt="" loading="lazy"></figure>
<h2 id="7-spring-整合-activemq">7、Spring 整合 ActiveMQ</h2>
<h3 id="71-创建-spring-activemq-producer">7.1  创建 spring-activemq-producer</h3>
<ol>
<li>修改 POM 文件</li>
</ol>
<p>父项目POM文件：</p>
<pre><code class="language-xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
	xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
	&lt;groupId&gt;com.cy&lt;/groupId&gt;
	&lt;artifactId&gt;parent&lt;/artifactId&gt;
	&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
	&lt;packaging&gt;pom&lt;/packaging&gt;

	&lt;!-- 对依赖的jar包的版本统一进行定义 --&gt;
	&lt;properties&gt;
		&lt;activemq.version&gt;5.9.0&lt;/activemq.version&gt;
		&lt;xbean.version&gt;4.5&lt;/xbean.version&gt;
		&lt;jms.version&gt;4.1.6.RELEASE&lt;/jms.version&gt;
		&lt;activemq-pool.version&gt;5.9.0&lt;/activemq-pool.version&gt;
		&lt;solrj.version&gt;4.10.3&lt;/solrj.version&gt;
		&lt;jedis.version&gt;2.9.0&lt;/jedis.version&gt;
		&lt;junit.version&gt;4.12&lt;/junit.version&gt;
		&lt;spring.version&gt;4.1.3.RELEASE&lt;/spring.version&gt;
		&lt;mybatis.version&gt;3.2.8&lt;/mybatis.version&gt;
		&lt;mybatis.spring.version&gt;1.2.2&lt;/mybatis.spring.version&gt;
		&lt;mysql.version&gt;5.1.32&lt;/mysql.version&gt;
		&lt;slf4j.version&gt;1.6.4&lt;/slf4j.version&gt;
		&lt;druid.version&gt;1.0.9&lt;/druid.version&gt;
		&lt;jstl.version&gt;1.2&lt;/jstl.version&gt;
		&lt;servlet-api.version&gt;2.5&lt;/servlet-api.version&gt;
		&lt;tomcat.version&gt;2.2&lt;/tomcat.version&gt;
		&lt;jsp-api.version&gt;2.0&lt;/jsp-api.version&gt;
		&lt;zkClient-version&gt;0.10&lt;/zkClient-version&gt;
		&lt;dubbo-version&gt;2.5.4&lt;/dubbo-version&gt;
		&lt;jackson.version&gt;2.4.2&lt;/jackson.version&gt;
		&lt;commons-net.version&gt;3.3&lt;/commons-net.version&gt;
		&lt;commons-fileupload.version&gt;1.3.1&lt;/commons-fileupload.version&gt;
	&lt;/properties&gt;


	&lt;!-- jar包的依赖注入 ，由于该工程是一个父工程，所以jar包在该pom文件中只是声明 --&gt;
	&lt;dependencyManagement&gt;
		&lt;dependencies&gt;
		&lt;!-- ActiveMQ客户端完整jar包依赖 --&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;
			&lt;artifactId&gt;activemq-all&lt;/artifactId&gt;
			&lt;version&gt;${activemq.version}&lt;/version&gt;
		&lt;/dependency&gt;
		&lt;!-- ActiveMQ和Spring整合配置文件标签处理jar包依赖 --&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.apache.xbean&lt;/groupId&gt;
			&lt;artifactId&gt;xbean-spring&lt;/artifactId&gt;
			&lt;version&gt;${xbean.version}&lt;/version&gt;
		&lt;/dependency&gt;
		&lt;!-- Spring-JMS插件相关jar包依赖 --&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework&lt;/groupId&gt;
			&lt;artifactId&gt;spring-jms&lt;/artifactId&gt;
			&lt;version&gt;${jms.version}&lt;/version&gt;
		&lt;/dependency&gt;
		&lt;!-- Spring-JMS插件相关jar包依赖 --&gt;
		&lt;dependency&gt;
		    &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;
		    &lt;artifactId&gt;activemq-pool&lt;/artifactId&gt;
		    &lt;version&gt;${activemq-pool.version}&lt;/version&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
		    &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;
		    &lt;artifactId&gt;activemq-jms-pool&lt;/artifactId&gt;
		    &lt;version&gt;${activemq-pool.version}&lt;/version&gt;
		&lt;/dependency&gt;
		
		&lt;dependency&gt;
			&lt;groupId&gt;org.apache.solr&lt;/groupId&gt;
			&lt;artifactId&gt;solr-solrj&lt;/artifactId&gt;
			&lt;version&gt;${solrj.version}&lt;/version&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;redis.clients&lt;/groupId&gt;
			&lt;artifactId&gt;jedis&lt;/artifactId&gt;
			&lt;version&gt;${jedis.version}&lt;/version&gt;
		&lt;/dependency&gt;
			&lt;!-- 单元测试 --&gt;
			&lt;dependency&gt;
				&lt;groupId&gt;junit&lt;/groupId&gt;
				&lt;artifactId&gt;junit&lt;/artifactId&gt;
				&lt;version&gt;${junit.version}&lt;/version&gt;
			&lt;/dependency&gt;
			&lt;!-- 日志处理 --&gt;
			&lt;dependency&gt;
				&lt;groupId&gt;org.slf4j&lt;/groupId&gt;
				&lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
				&lt;version&gt;${slf4j.version}&lt;/version&gt;
			&lt;/dependency&gt;
			&lt;!-- Mybatis --&gt;
			&lt;dependency&gt;
				&lt;groupId&gt;org.mybatis&lt;/groupId&gt;
				&lt;artifactId&gt;mybatis&lt;/artifactId&gt;
				&lt;version&gt;${mybatis.version}&lt;/version&gt;
			&lt;/dependency&gt;
			&lt;dependency&gt;
				&lt;groupId&gt;org.mybatis&lt;/groupId&gt;
				&lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
				&lt;version&gt;${mybatis.spring.version}&lt;/version&gt;
			&lt;/dependency&gt;
			&lt;!-- MySql --&gt;
			&lt;dependency&gt;
				&lt;groupId&gt;mysql&lt;/groupId&gt;
				&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
				&lt;version&gt;${mysql.version}&lt;/version&gt;
			&lt;/dependency&gt;
			&lt;!-- 连接池 --&gt;
			&lt;dependency&gt;
				&lt;groupId&gt;com.alibaba&lt;/groupId&gt;
				&lt;artifactId&gt;druid&lt;/artifactId&gt;
				&lt;version&gt;${druid.version}&lt;/version&gt;
			&lt;/dependency&gt;
			&lt;!-- Spring --&gt;
			&lt;dependency&gt;
				&lt;groupId&gt;org.springframework&lt;/groupId&gt;
				&lt;artifactId&gt;spring-context&lt;/artifactId&gt;
				&lt;version&gt;${spring.version}&lt;/version&gt;
			&lt;/dependency&gt;
			&lt;dependency&gt;
				&lt;groupId&gt;org.springframework&lt;/groupId&gt;
				&lt;artifactId&gt;spring-beans&lt;/artifactId&gt;
				&lt;version&gt;${spring.version}&lt;/version&gt;
			&lt;/dependency&gt;
			&lt;dependency&gt;
				&lt;groupId&gt;org.springframework&lt;/groupId&gt;
				&lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
				&lt;version&gt;${spring.version}&lt;/version&gt;
			&lt;/dependency&gt;
			&lt;dependency&gt;
				&lt;groupId&gt;org.springframework&lt;/groupId&gt;
				&lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
				&lt;version&gt;${spring.version}&lt;/version&gt;
			&lt;/dependency&gt;
			&lt;dependency&gt;
				&lt;groupId&gt;org.springframework&lt;/groupId&gt;
				&lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;
				&lt;version&gt;${spring.version}&lt;/version&gt;
			&lt;/dependency&gt;
			&lt;!-- JSP相关 --&gt;
			&lt;dependency&gt;
				&lt;groupId&gt;jstl&lt;/groupId&gt;
				&lt;artifactId&gt;jstl&lt;/artifactId&gt;
				&lt;version&gt;${jstl.version}&lt;/version&gt;
			&lt;/dependency&gt;
			&lt;dependency&gt;
				&lt;groupId&gt;javax.servlet&lt;/groupId&gt;
				&lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
				&lt;version&gt;${servlet-api.version}&lt;/version&gt;
				&lt;scope&gt;provided&lt;/scope&gt;
			&lt;/dependency&gt;
			&lt;dependency&gt;
				&lt;groupId&gt;javax.servlet&lt;/groupId&gt;
				&lt;artifactId&gt;jsp-api&lt;/artifactId&gt;
				&lt;version&gt;${jsp-api.version}&lt;/version&gt;
				&lt;scope&gt;provided&lt;/scope&gt;
			&lt;/dependency&gt;
			&lt;!-- 文件上传组件 --&gt;
			&lt;dependency&gt;
				&lt;groupId&gt;commons-fileupload&lt;/groupId&gt;
				&lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;
				&lt;version&gt;${commons-fileupload.version}&lt;/version&gt;
			&lt;/dependency&gt;
			
			&lt;dependency&gt;
				&lt;groupId&gt;commons-net&lt;/groupId&gt;
				&lt;artifactId&gt;commons-net&lt;/artifactId&gt;
				&lt;version&gt;${commons-net.version}&lt;/version&gt;
			&lt;/dependency&gt;
			
			&lt;!-- Jackson Json处理工具包 --&gt;
			&lt;dependency&gt;
				&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
				&lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
				&lt;version&gt;${jackson.version}&lt;/version&gt;
			&lt;/dependency&gt;
		&lt;/dependencies&gt;
	&lt;/dependencyManagement&gt;

	&lt;build&gt;
		&lt;resources&gt;
			&lt;resource&gt;
				&lt;directory&gt;src/main/java&lt;/directory&gt;
				&lt;includes&gt;
					&lt;include&gt;**/*.xml&lt;/include&gt;
				&lt;/includes&gt;
			&lt;/resource&gt;
			&lt;resource&gt;
				&lt;directory&gt;src/main/resources&lt;/directory&gt;
				&lt;includes&gt;
					&lt;include&gt;**/*.xml&lt;/include&gt;
					&lt;include&gt;**/*.properties&lt;/include&gt;
				&lt;/includes&gt;
			&lt;/resource&gt;
		&lt;/resources&gt;
		&lt;!-- tomcat插件，由于子项目不一定每个都是web项目，所以该插件只是声明，并未开启 --&gt;
		&lt;pluginManagement&gt;
			&lt;plugins&gt;
				&lt;!-- 配置Tomcat插件 --&gt;
				&lt;plugin&gt;
					&lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;
					&lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;
					&lt;version&gt;${tomcat.version}&lt;/version&gt;
				&lt;/plugin&gt;
			&lt;/plugins&gt;
		&lt;/pluginManagement&gt;
	&lt;/build&gt;
&lt;/project&gt;
</code></pre>
<p>spring-active-producer项目POM文件：</p>
<pre><code class="language-xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
	xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
	&lt;parent&gt;
		&lt;groupId&gt;com.cy&lt;/groupId&gt;
		&lt;artifactId&gt;parent&lt;/artifactId&gt;
		&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
	&lt;/parent&gt;
	&lt;groupId&gt;com.cy&lt;/groupId&gt;
	&lt;artifactId&gt;spring-activemq-producer&lt;/artifactId&gt;
	&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
	&lt;packaging&gt;war&lt;/packaging&gt;

	&lt;dependencies&gt;
		&lt;!-- ActiveMQ客户端完整jar包依赖 --&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;
			&lt;artifactId&gt;activemq-all&lt;/artifactId&gt;
		&lt;/dependency&gt;
		&lt;!-- ActiveMQ和Spring整合配置文件标签处理jar包依赖 --&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.apache.xbean&lt;/groupId&gt;
			&lt;artifactId&gt;xbean-spring&lt;/artifactId&gt;
		&lt;/dependency&gt;
		&lt;!-- Spring-JMS插件相关jar包依赖 --&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework&lt;/groupId&gt;
			&lt;artifactId&gt;spring-jms&lt;/artifactId&gt;
		&lt;/dependency&gt;
			&lt;dependency&gt;
		    &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;
		    &lt;artifactId&gt;activemq-pool&lt;/artifactId&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
		    &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;
		    &lt;artifactId&gt;activemq-jms-pool&lt;/artifactId&gt;
		&lt;/dependency&gt;
		&lt;!-- 单元测试 --&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;junit&lt;/groupId&gt;
			&lt;artifactId&gt;junit&lt;/artifactId&gt;
		&lt;/dependency&gt;
		&lt;!-- 日志处理 --&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.slf4j&lt;/groupId&gt;
			&lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
		&lt;/dependency&gt;
		&lt;!-- spring --&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework&lt;/groupId&gt;
			&lt;artifactId&gt;spring-context&lt;/artifactId&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework&lt;/groupId&gt;
			&lt;artifactId&gt;spring-beans&lt;/artifactId&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework&lt;/groupId&gt;
			&lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
		&lt;/dependency&gt;

		&lt;!-- JSP相关 --&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;jstl&lt;/groupId&gt;
			&lt;artifactId&gt;jstl&lt;/artifactId&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;javax.servlet&lt;/groupId&gt;
			&lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
			&lt;scope&gt;provided&lt;/scope&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;javax.servlet&lt;/groupId&gt;
			&lt;artifactId&gt;jsp-api&lt;/artifactId&gt;
			&lt;scope&gt;provided&lt;/scope&gt;
		&lt;/dependency&gt;
	&lt;/dependencies&gt;

	&lt;build&gt;
		&lt;plugins&gt;
			&lt;!-- 配置Tomcat插件 --&gt;
			&lt;plugin&gt;
				&lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;
				&lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;
				&lt;configuration&gt;
					&lt;path&gt;/&lt;/path&gt;
					&lt;port&gt;8080&lt;/port&gt;
				&lt;/configuration&gt;
			&lt;/plugin&gt;
		&lt;/plugins&gt;
	&lt;/build&gt;
&lt;/project&gt;
</code></pre>
<ol start="2">
<li>整合 ActiveMQ</li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
	xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:jms=&quot;http://www.springframework.org/schema/jms&quot;
	xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
	xmlns:amq=&quot;http://activemq.apache.org/schema/core&quot;
	xsi:schemaLocation=&quot;
		http://www.springframework.org/schema/beans 
		http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/jms
		http://www.springframework.org/schema/jms/spring-jms.xsd
		http://activemq.apache.org/schema/core
		http://activemq.apache.org/schema/core/activemq-core.xsd
		http://www.springframework.org/schema/context
		http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;


	&lt;!-- 需要创建一个连接工厂,连接ActiveMQ. ActiveMQConnectionFactory. 需要依赖ActiveMQ提供的amq标签 --&gt;
	&lt;!-- amq:connectionFactory 是bean标签的子标签, 会在spring容器中创建一个bean对象. 可以为对象命名. 
		类似: &lt;bean id=&quot;&quot; class=&quot;ActiveMQConnectionFactory&quot;&gt;&lt;/bean&gt; --&gt;
	&lt;amq:connectionFactory brokerURL=&quot;tcp://192.168.70.151:61616&quot;
		userName=&quot;admin&quot; password=&quot;admin&quot; id=&quot;amqConnectionFactory&quot; /&gt;
		
	&lt;!-- 配置池化的ConnectionFactory。 为连接ActiveMQ的connectionFactory提供连接池 --&gt;
	&lt;bean id=&quot;pooledConnectionFactory&quot; class=&quot;org.apache.activemq.pool.PooledConnectionFactoryBean&quot;&gt;
		&lt;property name=&quot;connectionFactory&quot; ref=&quot;amqConnectionFactory&quot;&gt;&lt;/property&gt;
		&lt;property name=&quot;maxConnections&quot; value=&quot;10&quot;&gt;&lt;/property&gt;
	&lt;/bean&gt;
	&lt;!-- spring管理JMS相关代码的时候,必须依赖jms标签库. spring-jms提供的标签库. --&gt;
	&lt;!-- 定义Spring-JMS中的连接工厂对象 CachingConnectionFactory - spring框架提供的连接工厂对象. 
		不能真正的访问MOM容器. 类似一个工厂的代理对象. 需要提供一个真实工厂,实现MOM容器的连接访问. --&gt;
	&lt;!-- 配置有缓存的ConnectionFactory，session的缓存大小可定制。 --&gt;
	&lt;bean id=&quot;connectionFactory&quot;
		class=&quot;org.springframework.jms.connection.CachingConnectionFactory&quot;&gt;
		&lt;property name=&quot;targetConnectionFactory&quot; ref=&quot;amqConnectionFactory&quot;&gt;&lt;/property&gt;
		&lt;property name=&quot;sessionCacheSize&quot; value=&quot;3&quot;&gt;&lt;/property&gt;
	&lt;/bean&gt;

	&lt;!-- JmsTemplate配置 --&gt;
	&lt;bean id=&quot;template&quot; class=&quot;org.springframework.jms.core.JmsTemplate&quot;&gt;
		&lt;!-- 给定连接工厂, 必须是spring创建的连接工厂. --&gt;
		&lt;property name=&quot;connectionFactory&quot; ref=&quot;connectionFactory&quot;&gt;&lt;/property&gt;
		&lt;!-- 可选 - 默认目的地命名 --&gt;
		&lt;property name=&quot;defaultDestinationName&quot; value=&quot;test-spring&quot;&gt;&lt;/property&gt;
	&lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<h3 id="72-创建-spring-activemq-consumer">7.2 创建 spring-activemq-consumer</h3>
<p>是一个 jar 工程</p>
<ol>
<li>修改 POM 文件</li>
</ol>
<pre><code class="language-xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;parent&gt;
    &lt;groupId&gt;com.cy&lt;/groupId&gt;
    &lt;artifactId&gt;parent&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
  &lt;/parent&gt;
  &lt;groupId&gt;com.cy&lt;/groupId&gt;
  &lt;artifactId&gt;spring-activemq-consumer&lt;/artifactId&gt;
  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
  
  	&lt;dependencies&gt;
		&lt;!-- activemq客户端 --&gt;
		&lt;dependency&gt;
		    &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;
		    &lt;artifactId&gt;activemq-all&lt;/artifactId&gt;
		&lt;/dependency&gt;
		&lt;!-- spring框架对JMS标准的支持 --&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework&lt;/groupId&gt;
			&lt;artifactId&gt;spring-jms&lt;/artifactId&gt;
		&lt;/dependency&gt;
		&lt;!-- ActiveMQ和spring整合的插件 --&gt;
		&lt;dependency&gt;
		    &lt;groupId&gt;org.apache.xbean&lt;/groupId&gt;
		    &lt;artifactId&gt;xbean-spring&lt;/artifactId&gt;
		&lt;/dependency&gt;
		
		
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework&lt;/groupId&gt;
			&lt;artifactId&gt;spring-context&lt;/artifactId&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework&lt;/groupId&gt;
			&lt;artifactId&gt;spring-beans&lt;/artifactId&gt;
		&lt;/dependency&gt;
	&lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<ol start="2">
<li>整合 ActiveMQ</li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
	xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 
	xmlns:jms=&quot;http://www.springframework.org/schema/jms&quot; 
	xmlns:amq=&quot;http://activemq.apache.org/schema/core&quot;
	xsi:schemaLocation=&quot;
		http://www.springframework.org/schema/beans 
		http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/jms
		http://www.springframework.org/schema/jms/spring-jms.xsd
		http://activemq.apache.org/schema/core
		http://activemq.apache.org/schema/core/activemq-core.xsd&quot;&gt;
	&lt;!-- 需要创建一个连接工厂,连接ActiveMQ. ActiveMQConnectionFactory. 需要依赖ActiveMQ提供的amq标签 --&gt;
	&lt;!-- amq:connectionFactory 是bean标签的子标签, 会在spring容器中创建一个bean对象.
		可以为对象命名. 类似: &lt;bean id=&quot;&quot; class=&quot;ActiveMQConnectionFactory&quot;&gt;&lt;/bean&gt;
	 --&gt;
	&lt;amq:connectionFactory brokerURL=&quot;tcp://192.168.70.151:61616&quot;
		userName=&quot;admin&quot; password=&quot;admin&quot; id=&quot;amqConnectionFactory&quot;/&gt;

	&lt;!-- spring管理JMS相关代码的时候,必须依赖jms标签库. spring-jms提供的标签库. --&gt;
	&lt;!-- 定义Spring-JMS中的连接工厂对象
		CachingConnectionFactory - spring框架提供的连接工厂对象. 不能真正的访问MOM容器.
			类似一个工厂的代理对象. 需要提供一个真实工厂,实现MOM容器的连接访问.
	 --&gt;
	&lt;bean id=&quot;connectionFactory&quot; 
		class=&quot;org.springframework.jms.connection.CachingConnectionFactory&quot;&gt;
		&lt;property name=&quot;targetConnectionFactory&quot; ref=&quot;amqConnectionFactory&quot;&gt;&lt;/property&gt;
		&lt;property name=&quot;sessionCacheSize&quot; value=&quot;3&quot;&gt;&lt;/property&gt;
	&lt;/bean&gt;
	
	&lt;!-- 注册监听器 --&gt;
	&lt;!-- 开始注册监听. 
		需要的参数有:
			acknowledge - 消息确认机制
			container-type - 容器类型 default|simple
			simple:SimpleMessageListenerContainer最简单的消息监听器容器，只能处理固定数量的JMS会话，且不支持事务。
			default:DefaultMessageListenerContainer是一个用于异步消息监听器容器 ，且支持事务         
			destination-type - 目的地类型. 使用队列作为目的地.
			connection-factory - 连接工厂, spring-jms使用的连接工厂,必须是spring自主创建的
			不能使用三方工具创建的工程. 如: ActiveMQConnectionFactory.
	 --&gt;
	&lt;jms:listener-container acknowledge=&quot;auto&quot; container-type=&quot;default&quot;
		destination-type=&quot;queue&quot; connection-factory=&quot;connectionFactory&quot; &gt;
		&lt;!-- 在监听器容器中注册某监听器对象.
			destination - 设置目的地命名
			ref - 指定监听器对象
		 --&gt;
		&lt;jms:listener destination=&quot;test-spring&quot; ref=&quot;myListener&quot;/&gt;
	&lt;/jms:listener-container&gt;
	
&lt;/beans&gt;
</code></pre>
<h3 id="73-整合测试">7.3 整合测试</h3>
<p>需求：<br>
1）在 producer 中创建 Users 对象<br>
2）将 Users 对象传递到 ActiveMQ 中<br>
3）在 Consumer 中获取 Users 对象并在控制台打印</p>
<ol>
<li>
<p>Producer 发送消息</p>
<ol>
<li>如果使用了连接池需要添加两个坐标</li>
</ol>
<p>PooledConnectionFactoryBean</p>
<pre><code class="language-xml">&lt;dependency&gt;
	&lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;
	&lt;artifactId&gt;activemq-pool&lt;/artifactId&gt;
	&lt;version&gt;5.9.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
	&lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;
	&lt;artifactId&gt;activemq-jms-pool&lt;/artifactId&gt;
	&lt;version&gt;5.9.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
<li>发送消息</li>
</ol>
<pre><code class="language-java">@Service
public class UserServiceImpl implements UserService {

	@Autowired
	private JmsTemplate jmsTemplate;
	
	@Override
	public void addUser(final Users user) {
		//发送消息
		this.jmsTemplate.send(new MessageCreator() {
			
			@Override
			public Message createMessage(Session session) throws JMSException {
				Message message = session.createObjectMessage(user);
				return message;
			}
		});
	}

}
</code></pre>
</li>
<li>
<p>Consumer 接收消息</p>
<ol>
<li>接收消息</li>
</ol>
<pre><code class="language-java">/**
 * 消息服务监听器
 * @author Administrator
 *
 */
@Component(value=&quot;myListener&quot;)
public class MyMessageListener implements MessageListener{

	@Autowired
	private UserService userService;
	
	@Override
	public void onMessage(Message message) {
		//处理消息
		ObjectMessage objMessage = (ObjectMessage)message;
		Users user=null;
		try {
			user = (Users)objMessage.getObject();
		} catch (JMSException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		this.userService.showUser(user);
	}
}

</code></pre>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Swagger]]></title>
        <id>https://jonchan1013.github.io/post/swagger/</id>
        <link href="https://jonchan1013.github.io/post/swagger/">
        </link>
        <updated>2020-07-01T07:51:56.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="1-swagger-简介">1、Swagger 简介</h2>
<h3 id="11-前言">1.1 前言</h3>
<p>​		接口文档对于前后端开发人员都十分重要。尤其近几年流行前后端分离后接口文档又变成重中之重。接口文档固然重要，但是由于项目周期等原因后端人员经常出现无法及时更新，导致前端人员抱怨接口文档和实际情况不一致。<br>
​        很多人员会抱怨别人写的接口文档不规范，不及时更新。当时当自己写的时候确实最烦去写接口文档。这种痛苦只有亲身经历才会牢记于心。<br>
​        如果接口文档可以实时动态生成就不会出现上面问题。<br>
​        Swagger 可以完美的解决上面的问题。</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="1-swagger-简介">1、Swagger 简介</h2>
<h3 id="11-前言">1.1 前言</h3>
<p>​		接口文档对于前后端开发人员都十分重要。尤其近几年流行前后端分离后接口文档又变成重中之重。接口文档固然重要，但是由于项目周期等原因后端人员经常出现无法及时更新，导致前端人员抱怨接口文档和实际情况不一致。<br>
​        很多人员会抱怨别人写的接口文档不规范，不及时更新。当时当自己写的时候确实最烦去写接口文档。这种痛苦只有亲身经历才会牢记于心。<br>
​        如果接口文档可以实时动态生成就不会出现上面问题。<br>
​        Swagger 可以完美的解决上面的问题。</p>
<!-- more -->
<h3 id="12-open-api-是什么">1.2 Open API 是什么</h3>
<p>​		Open API 规范(OpenAPI Specification)以前叫做Swagger 规范，是<br>
REST API 的API 描述格式。<br>
​		Open API 文件允许描述整个API，包括：</p>
<ul>
<li>
<p>每个访问地址的类型。POST 或GET。</p>
</li>
<li>
<p>每个操作的参数。包括输入输出参数。</p>
</li>
<li>
<p>认证方法。</p>
</li>
<li>
<p>连接信息，声明，使用团队和其他信息。<br>
Open API 规范可以使用YAML 或JSON 格式进行编写。这样更利于我们和机器进行阅读。</p>
<p>OpenAPI 规范（OAS）为 RESTful API 定义了一个与语言无关的标准接口，允许人和计算机发现和理解服务的功能，而无需访问源代码，文档或通过网络流量检查。正确定义后，消费者可以使用最少量的实现逻辑来理解远程服务并与之交互。<br>
然后，文档生成工具可以使用OpenAPI 定义来显示API，使用各种编程语言生成服务器和客户端的代码生成工具，测试工具以及许多其他用例。</p>
<p>源码和说明参照：</p>
<p>https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.<br>
0.0.md#oasDocument</p>
</li>
</ul>
<h3 id="13-swagger-简介">1.3 Swagger 简介</h3>
<p>​		Swagger 是一套围绕Open API 规范构建的开源工具，可以帮助设计，构建，记录和使用REST API。<br>
​		Swagger 工具包括的组件：<br>
​		Swagger Editor ：基于浏览器编辑器，可以在里面编写Open API规范。类似Markdown 具有实时预览描述文件的功能。<br>
​		Swagger UI：将Open API 规范呈现为交互式API 文档。用可视化UI 展示描述文件。</p>
<p>​		Swagger Codegen：将 OpenAPI 规范生成为服务器存根和客户端库。通过Swagger Codegen 可以将描述文件生成 html 格式和cwiki 形式的接口文档，同时也可以生成多种言语的客户端和服务端代码。<br>
​		Swagger Inspector：和 Swagger UI 有点类似，但是可以返回更多信息，也会保存请求的实际参数数据。<br>
​		Swagger Hub：集成了上面所有项目的各个功能，你可以以项目和版本为单位，将你的描述文件上传到Swagger Hub 中。在 SwaggerHub 中可以完成上面项目的所有工作，需要注册账号，分免费版和收费版。<br>
​		使用Swagger，就是把相关的信息存储在它定义的描述文件里面（yml 或 json 格式），再通过维护这个描述文件可以去更新接口文档，以及生成各端代码。</p>
<h2 id="2-springfox">2、Springfox</h2>
<p>​		使用 Swagger 时如果碰见版本更新或迭代时，只需要更改Swagger 的描述文件即可。但是在频繁的更新项目版本时很多开发人员认为即使修改描述文件（yml 或json）也是一定的工作负担，久而久之就直接修改代码，而不去修改描述文件了，这样基于描述文件生成接口文档也失去了意义。<br>
​		Marty Pitt 编写了一个基于 Spring 的组件 swagger-springmvc。Spring-fox 就是根据这个组件发展而来的全新项目。<br>
​		Spring-fox 是根据代码生成接口文档，所以正常的进行更新项目版本，修改代码即可，而不需要跟随修改描述文件。<br>
​		Spring-fox 利用自身AOP 特性，把Swagger 集成进来，底层还是Swagger。但是使用起来确方便很多。<br>
​		所以在实际开发中，都是直接使用spring-fox。<br>
​		附：官网地址</p>
<p>​		http://springfox.github.io/springfox/</p>
<p>​		附：官方源码</p>
<p>​		https://github.com/springfox/springfox</p>
<h2 id="3-swagger-极致用法">3、Swagger 极致用法</h2>
<h3 id="31-编写springboot-项目">3.1  编写SpringBoot 项目</h3>
<p>​	编写SpringBoot 项目，项目中controller 中包含一个Handler，测试项目，保证程序可以正确运行。</p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/people&quot;)
public class DemoController {

	@RequestMapping(&quot;/getPeople&quot;)
	public People getPeople(Long id, String name){
		People peo = new People();
		peo.setId(id);
		peo.setName(name);
		peo.setAddress(&quot;海淀&quot;);
		return peo;
	}
}
</code></pre>
<h3 id="32-导入spring-fox-依赖">3.2 导入Spring-fox 依赖</h3>
<p>​		在项目的pom.xml 中导入Spring-fox 依赖。目前最新版本为2.9.2，所以导入的依赖也是这个版本。其中 springfox-swagger2 是核心内容的封装。springfox-swagger-ui 是对swagger-ui 的封装。</p>
<pre><code class="language-xml">&lt;dependency&gt;
	&lt;groupId&gt;io.springfox&lt;/groupId&gt;
	&lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;
	&lt;version&gt;2.9.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
	&lt;groupId&gt;io.springfox&lt;/groupId&gt;
	&lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;
	&lt;version&gt;2.9.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="33-添加注解">3.3 添加注解</h3>
<p>​		在SpringBoot 的<strong>启动类</strong>中添加@EnableSwagger2 注解。<br>
​		添加此注解后表示对当前项目中全部控制器进行扫描。应用Swagger2</p>
<pre><code class="language-java">@SpringBootApplication
@EnableSwagger2
public class MyApp {
	public static void main(String [] args){
		SpringApplication.run(MyApp.class,args);
	}
}
</code></pre>
<h3 id="34-访问swagger-ui">3.4 访问swagger-ui</h3>
<p>​		启动项目后在浏览器中输入http://ip:port/swagger-ui.html 即可以访问到swagger-ui 页面，在页面中可以可视化的进行操作项目中所有接口。</p>
<h2 id="4-swagger-ui-使用">4、Swagger-UI 使用</h2>
<p>​		访问 swagger-ui.html 后可以在页面中看到所有需要生成接口文档的控制器名称。</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200701174528.png" alt="" loading="lazy"></figure>
<p>每个控制器中间包含多所有控制器方法的各种访问方式。如果使用的是@RequestMapping 进行映射，将显示下面的所有请求方式。如果使用@PostMapping 将只有Post 方式可以能访问，下面也就只显示Post 的一个。</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200701174547.png" alt="" loading="lazy"></figure>
<p>点击某个请求方式中try it out</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200701174601.png" alt="" loading="lazy"></figure>
<p>会出现界面要求输入的值。输入完成后点击Execute 按钮，下面会出现Request URL 已经不同状态码相应回来的结果。</p>
<h2 id="5-swagger-配置">5、Swagger 配置</h2>
<p>可以在项目中创建SwaggerConfig，进行配置文档内容。</p>
<h3 id="51-配置基本信息">5.1 配置基本信息</h3>
<p>Docket：摘要对象，通过对象配置描述文件的信息。<br>
apiInfo:设置描述文件中info。参数类型ApiInfo<br>
select():返回 ApiSelectorBuilder 对象，通过对象调用 build()可以创建Docket 对象<br>
ApiInfoBuilder：ApiInfo 构建器。</p>
<pre><code class="language-java">@Configuration
public class SwaggerConfig {
	@Bean
	public Docket getDocket(){
        return new Docket(DocumentationType.SWAGGER_2)
			.apiInfo(swaggerDemoApiInfo())
			.select()
			.build();
}
private ApiInfo swaggerDemoApiInfo(){
	return new ApiInfoBuilder()
		.contact(new Contact(&quot;Swagger&quot;, &quot;http://www.百度.com&quot;,&quot;xxx@163.com&quot;))
		//文档标题
		.title(&quot;这里是 Swagger 的标题&quot;)
		//文档描述
		.description(&quot;这里是 Swagger 的描述&quot;)
		//文档版本
		.version(&quot;1.0.0&quot;)
		.build();
	}
}
</code></pre>
<h3 id="52-设置扫描的包">5.2 设置扫描的包</h3>
<p>可以通过apis()方法设置哪个包中内容被扫描</p>
<pre><code class="language-java">@Bean
public Docket getDocket() {
	return new Docket(DocumentationType.SWAGGER_2)
		.apiInfo(getApiInfo())
		.select()
        .apis(RequestHandlerSelectors.basePackage(&quot;com.cy.controller&quot;))
		.build();
}
</code></pre>
<h3 id="53-自定义注解设置不需要生成接口文档的方法">5.3 自定义注解设置不需要生成接口文档的方法</h3>
<ol>
<li>
<p>自定义注解</p>
<p>注解名称随意。</p>
<pre><code class="language-java">@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface NotIncludeSwagger {
}
</code></pre>
</li>
<li>
<p>添加规则</p>
</li>
</ol>
<p>通 过 public ApiSelectorBuilder apis(Predicate<RequestHandler> selector)可以设置生成规则。<br>
public static <T> Predicate<T> not(Predicate<T> predicate) :表示不允许的条件。<br>
withMethodAnnotation：表示此注解是方法级别注解。</p>
<ol start="3">
<li>添加NotIncludeSwagger 注解</li>
</ol>
<p>在不需要生成接口文档的方法上面添加@NotIncludeSwagger 注解后，该方法将不会被Swagger 进行生成在接口文档中。</p>
<pre><code class="language-java">@NotIncludeSwagger
@RequestMapping(&quot;/getPeople2&quot;)
public People getPeople2(Integer id, String name, String address){
	People peo = new People();
	peo.setId(id);
	peo.setName(name);
	peo.setAddress(address);
	return peo;
}
</code></pre>
<h3 id="54-设置范围">5.4 设置范围</h3>
<p>通过 public ApiSelectorBuilder paths(Predicate<String> selector)可以设置满足什么样规则的url 被生成接口文档。可以使用正则表达式进行匹配。<br>
下面例子中表示只有以/demo/开头的 url 才能被swagger 生成接口文档。<br>
如何希望全部扫描可以使用paths(PathSelectors.any())</p>
<pre><code class="language-java">@Bean
public Docket getDocket(){
	return new Docket(DocumentationType.SWAGGER_2)
		.apiInfo(swaggerDemoApiInfo())
		.select()
		.paths(allowPaths())
		.build();
}
private Predicate&lt;String&gt; allowPaths(){
	return or(
		regex(&quot;/demo/.*&quot;)
	);
}
</code></pre>
<h2 id="6-swagger2-常用注解">6、Swagger2 常用注解</h2>
<h3 id="61-api">6.1 Api</h3>
<p>@Api 是类上注解。控制整个类生成接口信息的内容。<br>
tags：类的名称。可以有多个值，多个值表示多个副本。<br>
description:描述，已过时。</p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/people&quot;)
@Api(tags = {&quot;mydemo&quot;},description = &quot;描述&quot;)
public class DemoController {
</code></pre>
<p>在swagger-ui.html 中显示效果。</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200702102613.png" alt="" loading="lazy"></figure>
<h3 id="62-apioperation">6.2 ApiOperation</h3>
<p>@ApiOperation 写在方法上，对方法进行总体描述</p>
<ul>
<li>value：接口描述</li>
<li>notes：提示信息<br>
代码示例：</li>
</ul>
<pre><code class="language-java">@ApiOperation(value=&quot;接口描述&quot;,notes = &quot;接口提示信息&quot;)
</code></pre>
<p>在swagger-ui 中显示效果</p>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200702102714.png" alt="" loading="lazy"></figure>
<h3 id="63-apiparam">6.3 ApiParam</h3>
<p>@ApiParam 写在方法参数前面。用于对参数进行描述或说明是否为必添项等说明。<br>
name：参数名称<br>
value：参数描述<br>
required：是否是必须</p>
<pre><code class="language-java">public People getPeople(Integer id, @ApiParam(value=&quot;姓名&quot;,required = true) Stringname, String address)
</code></pre>
<p>swagger-ui 显示效果如下：</p>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200702102804.png" alt="" loading="lazy"></figure>
<h3 id="64-apimodel">6.4 ApiModel</h3>
<p>@ApiModel 是类上注解，主要应用Model，也就是说这个注解一<br>
般都是写在实体类上。</p>
<ul>
<li>value：名称</li>
<li>description：描述<br>
代码示例：</li>
</ul>
<pre><code class="language-java">@ApiModel(value = &quot;人类&quot;,description = &quot;描述&quot;)
public class People {
</code></pre>
<p>swagger-ui.html 效果展示</p>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200702102900.png" alt="" loading="lazy"></figure>
<h3 id="65-apimodelproperty">6.5 ApiModelProperty</h3>
<p>@ApiModelProperty 可以用在方法或属性上。用于当对象作为参数时定义这个字段的内容。<br>
value：描述<br>
name：重写属性名<br>
required：是否是必须的<br>
example：示例内容<br>
hidden：是否隐藏。<br>
代码示例：</p>
<pre><code class="language-java">@ApiModelProperty(value = &quot;姓名&quot;,name = &quot;name&quot;,required = true,example = &quot;张三&quot;)
private String name;
</code></pre>
<p>swagger-ui.html 效果展示</p>
<figure data-type="image" tabindex="8"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200702102946.png" alt="" loading="lazy"></figure>
<h3 id="66-apiignore">6.6  ApiIgnore</h3>
<p>@ApiIgnore 用于方法或类或参数上，表示这个方法或类被忽略。和之前讲解的自定义注解@NotIncludeSwagger 效果类似。只是这个注解是Swagger 内置的注解，而@NotIncludeSwagger 是我们自定义的注解。</p>
<h3 id="67-apiimplicitparam">6.7 ApiImplicitParam</h3>
<p>@ApiImplicitParam 用在方法上，表示单独的请求参数，总体功能和@ApiParam 类似。<br>
name：属性名<br>
value：描述<br>
required：是否是必须的<br>
paramType：属性类型<br>
dataType：数据类型<br>
代码示例：</p>
<pre><code class="language-java">@PostMapping(&quot;/getPeople&quot;)
@ApiImplicitParam(name = &quot;address&quot;,value = &quot;地址&quot;,required = true,paramType =&quot;query&quot;,dataType = &quot;string&quot;)
public People getPeople(Integer id, @ApiParam(value=&quot;姓名&quot;,required = true) Stringname, String address){
</code></pre>
<p>swagger-ui.html 效果展示</p>
<figure data-type="image" tabindex="9"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200702103120.png" alt="" loading="lazy"></figure>
<p>如果希望在方法上配置多个参数时，使用@ApiImplicitParams 进行配置。示例如下：</p>
<pre><code class="language-java">@ApiImplicitParams(value={@ApiImplicitParam(name=&quot;id&quot;,value = &quot;编号&quot;,required =true),@ApiImplicitParam(name=&quot;name&quot;,value = &quot;姓名&quot;,required = true)})
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[FastDFS]]></title>
        <id>https://jonchan1013.github.io/post/fastdfs/</id>
        <link href="https://jonchan1013.github.io/post/fastdfs/">
        </link>
        <updated>2020-06-30T06:55:20.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="1-简介">1、简介</h2>
<p>FastDFS 是一个开源的轻量级分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。特别适合以文件为载体的在线服务，如相册网站、视频网站等等。</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="1-简介">1、简介</h2>
<p>FastDFS 是一个开源的轻量级分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。特别适合以文件为载体的在线服务，如相册网站、视频网站等等。</p>
<!-- more -->
<p>技术论坛： http://bbs.chinaunix.net/forum-240-1.html<br>
资源地址： https://sourceforge.net/projects/fastdfs/<br>
源码资源： https://github.com/happyfish100</p>
<p>FastDFS 为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用 FastDFS 很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。<br>
FastDFS 服务端有两个角色：跟踪器（tracker）和存储节点（storage）。跟踪器主要做调度工作，在访问上起负载均衡的作用。<br>
存储节点存储文件，完成文件管理的所有功能：就是这样的存储、同步和提供存取接口，FastDFS 同时对文件的 metadata 进行管理。所谓文件的 meta data 就是文件的相关属性，以键值对（key value）方式表示，如：width=1024，其中的 key 为 width，value 为 1024。文件metadata 是文件属性列表，可以包含多个键值对。<br>
跟踪器和存储节点都可以由一台或多台服务器构成。跟踪器和存储节点中的服务器均可以随时增加或下线而不会影响线上服务。其中跟踪器中的所有服务器都是对等的，可以根据服务器的压力情况随时增加或减少。<br>
为了支持大容量，存储节点（服务器）采用了分卷（或分组）的组织方式。存储系统由一个或多个卷组成，卷与卷之间的文件是相互独立的，所有卷的文件容量累加就是整个存储系统中的文件容量。一个卷可以由一台或多台存储服务器组成，一个卷下的存储服务器中的文件都是相同的，卷中的多台存储服务器起到了冗余备份和负载均衡的作用。<br>
在卷中增加服务器时，同步已有的文件由系统自动完成，同步完成后，系统自动将新增服务器切换到线上提供服务。<br>
当存储空间不足或即将耗尽时，可以动态添加卷。只需要增加一台或多台服务器，并将它们配置为一个新的卷，这样就扩大了存储系统的容量。<br>
FastDFS 中的文件标识分为两个部分：卷名和文件名，二者缺一不可。</p>
<h3 id="11-架构图">1.1 架构图</h3>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200630172517.png" alt="" loading="lazy"></figure>
<h3 id="12-上传流程">1.2 上传流程</h3>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200630172540.png" alt="" loading="lazy"></figure>
<p>​	client 询问 tracker 上传到的 storage，不需要附加参数；<br>
​	tracker 返回一台可用的 storage；<br>
​	client 直接和 storage 通讯完成文件上传</p>
<h3 id="13-下载流程">1.3 下载流程</h3>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200630172732.png" alt="" loading="lazy"></figure>
<p>​	client 询问 tracker 下载文件的 storage，参数为文件标识（组名和文件名）；<br>
​	tracker 返回一台可用的 storage；<br>
​	client 直接和 storage 通讯完成文件下载。</p>
<h3 id="14-术语简介">1.4 术语简介</h3>
<ul>
<li><strong>Tracker Server</strong>：跟踪服务器，主要做调度工作，在访问上起负载均衡的作用。记录 storageserver 的状态，是连接 Client 和 Storage server 的枢纽。</li>
<li><strong>Storage Server</strong>：存储服务器，文件和 meta data 都保存到存储服务器上</li>
<li><strong>group</strong>：组，也称为卷。同组内服务器上的文件是完全相同的</li>
<li><strong>文件标识</strong>：包括两部分：组名和文件名（包含路径）</li>
<li><strong>meta data</strong>：文件相关属性，键值对（Key Value Pair）方式，如：width=1024,heigth=768</li>
</ul>
<h3 id="15-同步机制">1.5 同步机制</h3>
<p>​	同一组内的 storage server 之间是对等的，文件上传、删除等操作可以在任意一台 storage server 上进行；<br>
​		文件同步只在同组内的 storage server 之间进行，采用 push 方式，即源服务器同步给目标服务器；<br>
​		源头数据才需要同步，备份数据不需要再次同步，否则就构成环路了；<br>
​		上述第二条规则有个例外，就是新增加一台storage server 时，由已有的一台storage server将已有的所有数据（包括源头数据和备份数据）同步给该新增服务器</p>
<h3 id="16-fastdfs-运行时目录结构">1.6 FastDFS 运行时目录结构</h3>
<h4 id="161-tracker-server-目录">1.6.1 Tracker Server 目录</h4>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200630173335.png" alt="" loading="lazy"></figure>
<h4 id="162-storage-server-目录">1.6.2 Storage Server 目录</h4>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200630173358.png" alt="" loading="lazy"></figure>
<h3 id="17-fastdfs-和其他文件存储的简单对比">1.7 FastDFS 和其他文件存储的简单对比</h3>
<h4 id="171-fastdfs-和集中存储方式对比">1.7.1 FastDFS 和集中存储方式对比</h4>
<table>
<thead>
<tr>
<th style="text-align:center">指标</th>
<th style="text-align:center">FastDFS</th>
<th style="text-align:center">NFS</th>
<th style="text-align:center">集中存储设备如 NetApp 、NAS</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">线性扩容性</td>
<td style="text-align:center">高</td>
<td style="text-align:center">差</td>
<td style="text-align:center">差</td>
</tr>
<tr>
<td style="text-align:center">文件高并发访问性能</td>
<td style="text-align:center">高</td>
<td style="text-align:center">差</td>
<td style="text-align:center">一般</td>
</tr>
<tr>
<td style="text-align:center">文件访问方式</td>
<td style="text-align:center">专有 API</td>
<td style="text-align:center">POSIX</td>
<td style="text-align:center">支持 POSIX</td>
</tr>
<tr>
<td style="text-align:center">硬件成本</td>
<td style="text-align:center">较低</td>
<td style="text-align:center">中等</td>
<td style="text-align:center">高</td>
</tr>
<tr>
<td style="text-align:center">相同内容文件只保存一份</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">不支持</td>
<td style="text-align:center">不支持</td>
</tr>
</tbody>
</table>
<h4 id="172-fastdfs-和-mogilefs-对比">1.7.2 FastDFS 和 mogileFS 对比</h4>
<table>
<thead>
<tr>
<th style="text-align:center">指标</th>
<th style="text-align:center">FastDFS</th>
<th style="text-align:center">mogileFS</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">系统简洁性</td>
<td style="text-align:center">简洁<br/>只有两个角色：tracker 和storage</td>
<td style="text-align:center">一般<br/>有三个角色：tracker、storage和存储文件信息的 mysql db</td>
</tr>
<tr>
<td style="text-align:center">系统性能</td>
<td style="text-align:center">很高（没有使用数据库，文件同步直接点对点，不经过tracker 中转）</td>
<td style="text-align:center">高（使用 mysql 来存储文件索 引 等 信 息 ， 文 件 同 步 通 过tracker 调度和中转）</td>
</tr>
<tr>
<td style="text-align:center">系统稳定性</td>
<td style="text-align:center">高（C 语言开发，可以支持高并发和高负载）</td>
<td style="text-align:center">一般（Perl 语言开发，高并发和高负载支持一般）</td>
</tr>
<tr>
<td style="text-align:center">RAID 方式</td>
<td style="text-align:center">分组（组内冗余），灵活性较大</td>
<td style="text-align:center">动态冗余，灵活性一般</td>
</tr>
<tr>
<td style="text-align:center">通信协议</td>
<td style="text-align:center">专有协议<br/>下载文件支持 HTTP</td>
<td style="text-align:center">HTTP</td>
</tr>
<tr>
<td style="text-align:center">技术文档</td>
<td style="text-align:center">较详细</td>
<td style="text-align:center">较少</td>
</tr>
<tr>
<td style="text-align:center">文 件 附 加 属 性（meta data）</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">不支持</td>
</tr>
<tr>
<td style="text-align:center">相同内容文件只保存一份</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">不支持</td>
</tr>
<tr>
<td style="text-align:center">下载文件时支持文件偏移量（断点续传）</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">不支持</td>
</tr>
</tbody>
</table>
<h2 id="2-安装">2、安装</h2>
<p>准备两个 Linux 服务器。两个服务器分别作为 tracker 服务器（跟踪服务器）和 storage<br>
服务器（存储服务器）。<br>
Tracker 服务器 ： 192.168.2.109<br>
Storage 服务器 ： 192.168.2.110<br>
本次学习中，所有的安装包都存放在/root/upload 目录中。解压后的安装包根据具体命令查看。（/usr/local/fastdfs）</p>
<h3 id="21-核心安装">2.1 核心安装</h3>
<p>Tracker Server 和 Storage Server 完全一致的安装。<br>
安装 FastDFS 5.08 版本</p>
<ol>
<li>
<p>安装 FastDFS 依赖</p>
<p>FastDFS 是 C 语言开发的应用。安装必须使用 make、cmake 和 gcc 编译器。<br>
yum install -y make cmake gcc gcc-c++</p>
</li>
<li>
<p>解压 FastDFS 核心库</p>
<p>libfastcommon 是从 FastDFS 和 FastDHT 中提取出来的公共 C 函数库<br>
cd /root/upload<br>
unzip libfastcommon-master.zip -d /usr/local/fastdfs</p>
</li>
<li>
<p>进入解压后的目录</p>
<p>cd /usr/local/fastdfs/libfastcommon-master</p>
</li>
<li>
<p>编译安装</p>
<p>libfastcommon 没有提供 make 命令安装文件。使用的是 shell 脚本执行编译和安装。shell脚本为 make.sh<br>
编译<br>
./make.sh<br>
安装<br>
./make.sh install<br>
有固定的默认安装位置。在/usr/lib64 和/usr/include/fastcommon 两个目录中。</p>
</li>
<li>
<p>创建软连接</p>
<p>因为 FastDFS 主程序设置的 lib 目录是/usr/local/lib，所以需要创建软链接<br>
ln -s /usr/lib64/libfastcommon.so /usr/local/lib/libfastcommon.so<br>
ln -s /usr/lib64/libfastcommon.so /usr/lib/libfastcommon.so<br>
ln -s /usr/local/lib64/libfdfsclient.so /usr/local/lib/libfdfsclient.so<br>
ln -s /usr/local/lib64/libfdfsclient.so /usr/lib/libfdfsclient.so</p>
</li>
<li>
<p>解压 FastDFS 主程序</p>
<p>本案例使用 5.08 版本 FastDFS。<br>
cd /root/upload<br>
tar -zxf FastDFS_v5.08.tar.gz -C /usr/local/fastdfs</p>
</li>
<li>
<p>进入 FastDFS 主程序源码目录</p>
<p>cd /usr/local/fastdfs/FastDFS</p>
</li>
<li>
<p>修改安装路径</p>
<p>此操作可选。在集群环境中使用默认安装路径安装。两种安装方式都尝试一下。<br>
vi /usr/local/fastdfs/FastDFS/make.sh<br>
TARGET_PREFIX=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>E</mi><mi>S</mi><mi>T</mi><mi>D</mi><mi>I</mi><mi>R</mi><mi mathvariant="normal">/</mi><mi>u</mi><mi>s</mi><mi>r</mi><mo>−</mo><mo>&gt;</mo><mi>T</mi><mi>A</mi><mi>R</mi><mi>G</mi><mi>E</mi><msub><mi>T</mi><mi>P</mi></msub><mi>R</mi><mi>E</mi><mi>F</mi><mi>I</mi><mi>X</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">DESTDIR/usr -&gt; TARGET_PREFIX=</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord">/</span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">G</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span></span></span>DESTDIR/usr/local</p>
</li>
<li>
<p>编译安装</p>
<p>./make.sh<br>
./make.sh install<br>
安装后，FastDFS 主程序所在位置是：<br>
/usr/local/bin - 可执行文件所在位置。默认安装在/usr/bin 中。<br>
/etc/fdfs - 配置文件所在位置。就是默认位置。<br>
/usr/local/lib64 - 主程序代码所在位置。默认在/usr/bin 中。<br>
/usr/local/include/fastdfs - 包含的一些插件组所在位置。默认在/usr/include/fastdfs 中。</p>
</li>
<li>
<p>FastDFS 安装后资源简介</p>
<ol>
<li>服务脚本</li>
</ol>
<p>/etc/init.d/目录中，脚本文件是 - fdfs-storaged 和 fdfs-trackerd<br>
ls /etc/init.d/ | grep fdfs</p>
<ol start="2">
<li>
<p>配置文件模板</p>
<p>/etc/fdfs/ 目 录 中 ， 配 置 文 件 是 - client.conf.sample 、 storage.conf.sample 和tracker.conf.sample<br>
ls /etc/fdfs/<br>
tracker.conf.sample - 跟踪器服务配置文件模板<br>
storage.conf.sample - 存储服务器配置文件模板<br>
client.conf.sample - FastDFS 提供的命令行客户端配置文件模板。可以通过命令行测试FastDFS 有效性。</p>
</li>
<li>
<p>内置命令</p>
<p>/usr/local/bin/目录中。命令有若干。可通过命令在控制台访问 FastDFS。<br>
ls /usr/local/bin/ | grep fdfs</p>
</li>
</ol>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200701105145.png" alt="" loading="lazy"></figure>
<p><strong>以上为通用安装，FastDFS 的跟踪服务和存储服务是通过配置实现的。后续内容为跟踪服务和存储服务的具体配置。</strong></p>
</li>
</ol>
<h3 id="22-tracker-基础配置">2.2 tracker 基础配置</h3>
<p>​	只在 tracker server 节点中配置。192.168.2.109</p>
<ol>
<li>
<p>创建跟踪服务配置文件</p>
<p>FastDFS 提供了配置文件模板，可以根据模板创建需要使用的配置文件。cd /etc/fdfs<br>
cp tracker.conf.sample tracker.conf</p>
</li>
<li>
<p>修改配置文件</p>
<p>tracker.conf 配置文件用于描述跟踪服务的行为，需要进行下述修改：<br>
vi /etc/fdfs/tracker.conf<br>
port=22122 # 默认服务端口<br>
base_path=/home/yuqing/fastdfs -&gt; base_path=/fastdfs/tracker（自定义目录）<br>
base_path 是 FastDFSTracker 启动后使用的根目录。也就是 data 和 logs 所在位置。</p>
</li>
<li>
<p>创建自定义目录<br>
为配置文件中定义的 base_path 变量创建对应的目录。<br>
mkdir -p /fastdfs/tracker</p>
</li>
<li>
<p>修改启动服务脚本<br>
vi /etc/init.d/fdfs_trackerd<br>
将 PRG=/usr/bin/fdfs_trackerd 修改为 PRG=/usr/local/bin/fdfs_trackerd</p>
</li>
<li>
<p>启动服务<br>
/etc/init.d/fdfs_trackerd start<br>
启动成功后，配置文件中 base_path 指向的目录中出现 FastDFS 服务相关数据目录（data目录、logs 目录）</p>
</li>
<li>
<p>查看服务状态<br>
/etc/init.d/fdfs_trackerd status<br>
ps aux | grep fdfs</p>
</li>
<li>
<p>停止服务<br>
/etc/init.d/fdfs_trackerd stop</p>
</li>
<li>
<p>重启服务<br>
/etc/init.d/fdfs_trackerd restart</p>
</li>
<li>
<p>设置开启自启<br>
vi /etc/rc.d/rc.local<br>
新增内容 - /etc/init.d/fdfs_trackerd start</p>
</li>
</ol>
<h3 id="23-storage-基础配置">2.3 storage 基础配置</h3>
<p>只在 storage server 中配置。192.168.2.100</p>
<ol>
<li>
<p>创建存储服务配置文件<br>
FastDFS 提供了配置文件模板，可以根据模板创建需要使用的配置文件。<br>
cd /etc/fdfs<br>
cp storage.conf.sample storage.conf</p>
</li>
<li>
<p>修改配置文件<br>
storage.conf 配置文件用于描述存储服务的行为，需要进行下述修改：<br>
vi /etc/fdfs/storage.conf<br>
<strong>base_path=/home/yuqing/fastdfs -&gt; base_path=/fastdfs/storage/base （自定义目录）</strong><br>
<strong>store_path0=/home/yuqing/fastdfs -&gt; store_path0=/fastdfs/storage/store（自定义目录）</strong><br>
<strong>tracker_server=192.168.2.109:22122 -&gt; tracker_server=tracker 服务 IP:22122</strong><br>
base_path - 基础路径。用于保存 storage server 基础数据内容和日志内容的目录。<br>
store_path0 - 存储路径。是用于保存 FastDFS 中存储文件的目录，就是要创建 256*256个子目录的位置。<br>
base_path 和 store_path0 可以使用同一个目录。<br>
tracker_server - 跟踪服务器位置。就是跟踪服务器的 ip 和端口。</p>
</li>
<li>
<p>创建自定义目录<br>
mkdir -p /fastdfs/storage/base<br>
mkdir -p /fastdfs/storage/store</p>
</li>
<li>
<p>修改服务脚本<br>
vi /etc/init.d/fdfs_storaged<br>
将 PRG=/usr/bin/fdfs_storaged 修改为 PRG=/usr/local/bin/fdfs_storaged</p>
</li>
<li>
<p>启动服务（<em>要求 tracker 服务必须已启动</em>）<br>
/etc/init.d/fdfs_storaged start<br>
启动成功后，配置文件中 base_path 指向的目录中出现 FastDFS 服务相关数据目录（data目录、logs 目录），配置文件中的 store_path0 指向的目录中同样出现 FastDFS 存储相关数据录（data 目录）。其中$store_path0/data/目录中默认创建若干子孙目录（两级目录层级总计 256<em>256 个目录），是用于存储具体文件数据的。<br>
Storage 服务器启动比较慢，因为第一次启动的时候，需要创建 256</em>256 个目录。</p>
</li>
<li>
<p>查看服务状态<br>
/etc/init.d/fdfs_storaged status<br>
ps aux | grep fdfs</p>
</li>
<li>
<p>停止服务<br>
/etc/init.d/fdfs_storaged stop</p>
</li>
<li>
<p>重启服务<br>
/etc/init.d/fdfs_storaged restart</p>
</li>
<li>
<p>设置开机自启<br>
vi /etc/rc.d/rc.local<br>
新增内容 - /etc/init.d/fdfs_storaged start</p>
<p><em><strong>因启动前提为 tracker 服务必须已启动，不推荐开启自启。</strong></em></p>
</li>
</ol>
<h3 id="24-客户端基础配置">2.4 客户端基础配置</h3>
<p>不是必须的。就是用于使用命令行测试 FastDFS 才需要配置的。</p>
<ol>
<li>
<p>创建客户端配置文件<br>
在 tracker 服务结点所在服务器中配置客户端。同样通过配置文件模板创建对应配置文件。<br>
cd /etc/fdfs<br>
cp client.conf.sample client.conf</p>
</li>
<li>
<p>修改配置文件<br>
client.conf 配置文件中主要描述客户端的行为，需要进行下述修改：<br>
vi /etc/fdfs/client.conf<br>
<strong>base_path=/home/yuqing/fastdfs -&gt; base_path=/fastdfs/client （自定义目录）</strong><br>
<strong>tracker_server=192.168.2.109:22122 -&gt; tracker_server=tracker 服务 IP:22122</strong><br>
base_path - 就是客户端命令行执行过程时临时数据存储位置。</p>
</li>
<li>
<p>创建自定义目录<br>
mkdir -p /fastdfs/client</p>
</li>
</ol>
<h3 id="25-控制台测试-fastdfs">2.5 控制台测试 FastDFS</h3>
<p>​		命令所在： /usr/local/bin 目录。 （如果在安装 FastDFS 过程中，没有修改 make.sh 文件中的 TARGET_PREFIX 属性值，命令所在为/usr/bin 目录）</p>
<ol>
<li>
<p>上传文件<br>
/usr/local/bin/fdfs_upload_file /etc/fdfs/client.conf /要上传的文件<br>
上传结束后，返回 group1/M00/00/00/xxxxxxxxxx.xxx ，检查 storage 服务结点中的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>t</mi><mi>o</mi><mi>r</mi><msub><mi>e</mi><mi>p</mi></msub><mi>a</mi><mi>t</mi><mi>h</mi><mn>0</mn><mi mathvariant="normal">/</mi><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi><mi mathvariant="normal">/</mi><mn>00</mn><mi mathvariant="normal">/</mi><mn>00</mn><mi mathvariant="normal">/</mi><mi mathvariant="normal">目</mi><mi mathvariant="normal">录</mi><mi mathvariant="normal">中</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">否</mi><mi mathvariant="normal">有</mi><mi mathvariant="normal">上</mi><mi mathvariant="normal">传</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">文</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">（</mi><mo>∗</mo><mo>∗</mo><mi mathvariant="normal">一</mi><mi mathvariant="normal">般</mi><mi mathvariant="normal">情</mi><mi mathvariant="normal">况</mi><mi mathvariant="normal">上</mi><mi mathvariant="normal">传</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">文</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">按</mi><mi mathvariant="normal">顺</mi><mi mathvariant="normal">序</mi><mi mathvariant="normal">保</mi><mi mathvariant="normal">存</mi><mi mathvariant="normal">在</mi></mrow><annotation encoding="application/x-tex">store_path0/data/00/00/目录中是否有上传的文件（**一般情况上传的文件按顺序保存在</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord">0</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord">0</span><span class="mord">0</span><span class="mord">/</span><span class="mord">0</span><span class="mord">0</span><span class="mord">/</span><span class="mord cjk_fallback">目</span><span class="mord cjk_fallback">录</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">否</span><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">上</span><span class="mord cjk_fallback">传</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">文</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">（</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord">∗</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">般</span><span class="mord cjk_fallback">情</span><span class="mord cjk_fallback">况</span><span class="mord cjk_fallback">上</span><span class="mord cjk_fallback">传</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">文</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">按</span><span class="mord cjk_fallback">顺</span><span class="mord cjk_fallback">序</span><span class="mord cjk_fallback">保</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">在</span></span></span></span>store_path0/data/00/00/目录中，不能完全保证**）。<br>
本次 测 试 的 上 传 文 件 结 果 ：group1/M00/00/00/wKgCbltTYaeACDWgAAVCLEPUQWI.tar.gz<br>
卷名 ： group1<br>
文件名 ： M00/00/00/wKgCbltTYaeACDWgAAVCLEPUQWI.tar.gz<br>
其中 M00 是一个虚拟目录，相当于 windows 中的快捷方式，引用的是$store_path0/data目录。</p>
</li>
<li>
<p>删除文件<br>
/usr/local/bin/fdfs_delete_file /etc/fdfs/client.conf group1/M00/00/00/xxxxxxx.xxx<br>
删除结束后，检查$store_path0/data/00/00/目录中是否还有文件。</p>
</li>
</ol>
<h3 id="26-安装-nginx-组件">2.6 安装 Nginx 组件</h3>
<p>​		如果 FastDFS 中保存的是图片信息。希望在 WEB 应用中可以直接访问 FastDFS 中的图片进行显示。如果操作？<br>
​		安装 Nginx 是为了 WEB 应用中可以使用 HTTP 协议直接访问 Storage 服务中存储的文件。在 storage 结点所在服务器安装 Nginx 组件。<br>
​		需要安装两部分内容。<br>
Nginx 应用，在安装 nginx 应用的时候，同时要在 nginx 中增加一个 FastDFS 的组件。Module。</p>
<ol>
<li>
<p>解压 fastdfs-nginx-module_v1.16.tar.gz</p>
<p>tar -zxf fastdfs-nginx-module_v1.16.tar.gz -C /usr/local/fastdfs</p>
</li>
<li>
<p>修改 fastdfs-nginx-module_v1.16.tar.gz 源文件中的配置</p>
<p><em>此操作必须修改，否则 Nginx 编译会报错。</em></p>
<p>cd /usr/local/fastdfs/fastdfs-nginx-module/src<br>
vi /usr/local/fastdfs/fastdfs-nginx-module/src/config<br>
参数是用于配置安装 nginx 中的 FastDFS 组件的时候，在什么位置查找 FastDFS 核心代码。</p>
<p>源数据：</p>
<pre><code class="language-html">ngx_addon_name=ngx_http_fastdfs_module
HTTP_MODULES=&quot;$HTTP_MODULES ngx_http_fastdfs_module&quot;
NGX_ADDON_SRCS=&quot;$NGX_ADDON_SRCS
$ngx_addon_dir/ngx_http_fastdfs_module.c&quot;
CORE_INCS=&quot;$CORE_INCS /usr/local/include/fastdfs /usr/local/include/fastcommon/&quot;
CORE_LIBS=&quot;$CORE_LIBS -L/usr/local/lib -lfastcommon -lfdfsclient&quot;
CFLAGS=&quot;$CFLAGS -D_FILE_OFFSET_BITS=64
-DFDFS_OUTPUT_CHUNK_SIZE='256*1024'
-DFDFS_MOD_CONF_FILENAME='\&quot;/etc/fdfs/mod_fastdfs.conf\&quot;'&quot;
</code></pre>
<p>修 改 后 内 容 ： （ 如 果 安 装 FastDFS 时 ， 没 有 修 改 make.sh 文 件 ， 则 改 为 ：CORE_INCS=&quot;$CORE_INCS /usr/include/fastdfs /usr/include/fastcommon/&quot;）</p>
</li>
</ol>
<pre><code class="language-html">ngx_addon_name=ngx_http_fastdfs_module
HTTP_MODULES=&quot;$HTTP_MODULES ngx_http_fastdfs_module&quot;
NGX_ADDON_SRCS=&quot;$NGX_ADDON_SRCS
$ngx_addon_dir/ngx_http_fastdfs_module.c&quot;
CORE_INCS=&quot;$CORE_INCS /usr/local/include/fastdfs /usr/include/fastcommon/&quot;
CORE_LIBS=&quot;$CORE_LIBS -L/usr/local/lib -lfastcommon -lfdfsclient&quot;
CFLAGS=&quot;$CFLAGS -D_FILE_OFFSET_BITS=64
-DFDFS_OUTPUT_CHUNK_SIZE='256*1024'
-DFDFS_MOD_CONF_FILENAME='\&quot;/etc/fdfs/mod_fastdfs.conf\&quot;'&quot;
</code></pre>
<ol start="3">
<li>
<p>安装 Nginx</p>
<ol>
<li>
<p>安装 Nginx 需要的依赖<br>
yum install -y gcc gcc-c++ make automake autoconf libtool pcre pcre-devel   zlib zlib-devel openssl openssl-devel</p>
</li>
<li>
<p>使用 SFTP 上传文件到 Linux<br>
进入到本地的应用所在目录。<br>
cd /xxxx 目录<br>
sftp 192.168.2.110<br>
输入用户名和密码。使用哪一个用户登录，上传的文件就在该用户对应的主目录下。如：root 用户，上传的文件在/root 目录中。</p>
<p>上传的命令：<br>
put 文件名<br>
下载的命令：<br>
get 文件名</p>
</li>
<li>
<p>解压 Nginx<br>
tar -zxf nginx-1.8.0.tar.gz -C /usr/local/fastdfs/</p>
</li>
<li>
<p>进入 Nginx 源码目录<br>
cd /usr/local/fastdfs/nginx-1.8.0/</p>
</li>
<li>
<p>配置 Nginx 安装信息<br>
./configure <br>
--prefix=/usr/local/nginx <br>
--pid-path=/var/run/nginx/nginx.pid <br>
--lock-path=/var/lock/nginx.lock <br>
--error-log-path=/var/log/nginx/error.log <br>
--http-log-path=/var/log/nginx/access.log <br>
--with-http_gzip_static_module <br>
--http-client-body-temp-path=/var/temp/nginx/client <br>
--http-proxy-temp-path=/var/temp/nginx/proxy <br>
--http-fastcgi-temp-path=/var/temp/nginx/fastcgi <br>
--http-uwsgi-temp-path=/var/temp/nginx/uwsgi <br>
--http-scgi-temp-path=/var/temp/nginx/scgi <br>
<em><strong>--add-module=/usr/local/fastdfs/fastdfs-nginx-module/src</strong></em><br>
<em><strong>--add-module 必须定义，此配置信息是用于指定安装 Nginx 时需要加载的模块，如果未指定，Nginx 安装过程不会加载 fastdfs-nginx-module 模块，后续功能无法实现。</strong></em></p>
</li>
<li>
<p>创建目录<br>
Nginx 运行时需要创建若干临时文件，如果默认安装不需创建此目录。<br>
mkdir -p /var/temp/nginx</p>
</li>
<li>
<p>编译安装<br>
make<br>
make install</p>
</li>
<li>
<p>配置 fastdfs-nginx-module 模块配置文件<br>
复制配置文件/usr/local/fastdfs/fastdfs-nginx-module/src/mod_fastdfs.conf 到/etc/fdfs 目录中</p>
<p>cp /usr/local/fastdfs/fastdfs-nginx-module/src/mod_fastdfs.conf /etc/fdfs/<br>
cd /etc/fdfs/<br>
修改配置文件 mod_fastdfs.conf<br>
vi mod_fastdfs.conf<br>
源配置：</p>
</li>
</ol>
<pre><code>connect_timeout=2 #连接超时时间，单位秒
tracker_server=tracker:22122 #tracker 服务结点
url_have_group_name = false #URL 中是否包含 group 名称
store_path0=/home/yuqing/fastdfs # storage 服务结点的存储位置，与配置 storage 结点一致
</code></pre>
<p>参考修改值：</p>
<pre><code>connect_timeout=10
tracker_server=192.168.2.109:22122
url_have_group_name = true
store_path0=/fastdfs/storage/store
</code></pre>
<ol start="9">
<li>
<p>提供 FastDFS 需要的 HTTP 配置文件<br>
复制 FastDFS 安装包中的两个配置文件（http.conf 和 mime.types）到/etc/fdfs 目录中<br>
cp /usr/local/fastdfs/FastDFS/conf/http.conf /etc/fdfs/<br>
cp /usr/local/fastdfs/FastDFS/conf/mime.types /etc/fdfs/</p>
</li>
<li>
<p>创建 nginx 启动需要的软连接<br>
创建软连接<br>
ln -s /usr/local/lib64/libfdfsclient.so /usr/lib64/libfdfsclient.so<br>
nginx 启动后，会在默认的/usr/lib64 目录中查找需要的 so 文件。如果在安装 FastDFS时，修改了 make.sh 文件中的 TARGET_PREFIX 参数，则必须创建此软连接</p>
</li>
<li>
<p>创建网络访问存储服务的软连接<br>
ln -s /fastdfs/storage/store/data/ /fastdfs/storage/store/data/M00<br>
在上传文件到 FastDFS 后，FastDFS 会返回 group1/M00/00/00/xxxxxxxxxx.xxx。其中group1 是卷名，在 mod_fastdfs.conf 配置文件中已配置了 url_have_group_name，以保证 URL解析正确。而其中的 M00 是 FastDFS 保存数据时使用的虚拟目录，需要将这个虚拟目录定位到真实数据目录上。</p>
</li>
<li>
<p>修改 nginx 配置文件<br>
cd /usr/local/nginx/conf<br>
vi nginx.conf<br>
参考修改配置：（部分配置信息，不要完整复制）</p>
<pre><code>user root; # Nginx 需要访问 linux 文件系统，必须有文件系统的权限。User root 代表nginx 访问文件系统的权限是 root 用户权限。如果不开启权限，可能有 404 访问错误。
server{
listen 8888; # storage 配置中，有 http.server_port=8888 的配置信息，必须一致。配置文件是/etc/fdfs/storaged.conf
server_name localhost;
location ~/group([0-9])/M00{
ngx_fastdfs_module;
}
}
</code></pre>
</li>
</ol>
</li>
<li>
<p>测试 WEB 访问存储服务中的文件<br>
使用浏览器查看 FastDFS 中保存的文件：<br>
http://ip:8888/group1/M00/00/00/x xxxxxx.xxx<br>
测试上传的文件： group1/M00/00/00/wKgCbltTmv-ASTG2AAAmTx4ns0s172.jpg<br>
测试 WEB 访问地址：<br>
http://192.168.2.110:8888/group1/M00/00/00/wKgCbltTmv-ASTG2AAAmTx4ns0s172.jpg</p>
</li>
</ol>
<h2 id="3-java-客户端-api-简单应用">3、 Java 客户端 API 简单应用</h2>
<h3 id="31-依赖">3.1 依赖</h3>
<pre><code class="language-xml">&lt;dependency&gt;
	&lt;groupId&gt;cn.bestwu&lt;/groupId&gt;
	&lt;artifactId&gt;fastdfs-client-java&lt;/artifactId&gt;
	&lt;version&gt;1.27&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
	&lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
	&lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;
	&lt;version&gt;3.4&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
	&lt;groupId&gt;commons-io&lt;/groupId&gt;
	&lt;artifactId&gt;commons-io&lt;/artifactId&gt;
	&lt;version&gt;2.4&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="32-创建客户端">3.2 创建客户端</h3>
<h4 id="321-根据-conf-文件创建客户端">3.2.1 根据 conf 文件创建客户端</h4>
<ol>
<li>
<p>conf 配置文件</p>
<pre><code># 配置连接超时
connect_timeout=10
# 网络工作的超时， 一次连接的超时时长。
network_timeout=30
# 连接中的使用字符集
charset=UTF-8
# tracker的http协议端口，和FastDFS中的tracker服务的配置文件tracker.conf中的http.server_port一致
http.tracker_http_port=8080

# tracker服务器的所在地址。 就是IP：port
tracker_server=192.168.89.152:22122
</code></pre>
</li>
<li>
<p>代码</p>
<pre><code class="language-java">public class TestInitClient {

    public static void main(String[] args) {
        // 创建FastDFS  Java 客户端。
        try {
            // 加载客户端配置文件，就是刚定义的conf配置文件。
            ClientGlobal.init(&quot;src/main/resources/test/fdfs.conf&quot;);

            // 创建Tracker服务器的客户端连接对象。 无参构造其中默认会调用一个有参构造
            // new TrackerClient(TrackerGlobal.g_tracker_group), 绑定tracker服务器的IP地址和端口。
            // 绑定配置文件中的tracker_server属性信息。
            TrackerClient trackerClient = new TrackerClient();
            // 通过Tracker客户端对象，获取Tracker服务端对象。
            TrackerServer trackerServer = trackerClient.getConnection();
            // 通过Tracker客户端和服务端对象，获取Storage服务端对象。
            StorageServer storageServer = trackerClient.getStoreStorage(trackerServer);
            // 通过Tracker服务端对象和Storage服务端对象，来创建Storage客户端访问对象，实现文件的上传和下载。
            // 最终使用的，用于文件处理的对象。
            StorageClient storageClient = new StorageClient(trackerServer, storageServer);

            System.out.println(&quot;trackerClient : &quot; + trackerClient);
            System.out.println(&quot;trackerServer : &quot; + trackerServer);
            System.out.println(&quot;storageServer : &quot; + storageServer);
            System.out.println(&quot;storageClient : &quot; + storageClient);
        }catch(IOException e1){ // 配置文件找不到之类的 IO异常。
            e1.printStackTrace();
        }catch(MyException e2){ // FastDFS 的java客户端API定义的自定义异常。
            // 如：tracker服务器连接错误， Storage服务器连接错误
            e2.printStackTrace();
        }
    }

}
</code></pre>
</li>
</ol>
<h4 id="322-根据-properties-文件创建客户端">3.2.2 根据 properties 文件创建客户端</h4>
<ol>
<li>
<p>properties 配置文件</p>
<pre><code class="language-properties"># 连接超时
fastdfs.connect_timeout_in_seconds=10
# 网络超时
fastdfs.network_timeout_in_seconds=30
# 连接的字符集
fastdfs.charset=UTF-8
# tracker服务器的配置文件中的http端口配置
fastdfs.http_tracker_http_port=8080

# tracker服务器的IP：端口
fastdfs.tracker_servers=192.168.89.152:22122
</code></pre>
</li>
<li>
<p>代码</p>
<pre><code class="language-java">public class TestInitClientByProperties {
    public static void main(String[] args) {
        // 加载properties配置文件
        Properties properties = new Properties();
        try {
            properties.load(TestInitClientByProperties.class.getClassLoader().getResourceAsStream(&quot;test/fdfs.properties&quot;));
        }catch (IOException e){
            e.printStackTrace();
            System.out.println(&quot;Properties配置文件加载错误&quot;);
            return;
        }

        try{
            // 通过ClientGlobal对象加载配置内容
            ClientGlobal.initByProperties(properties);

            TrackerClient trackerClient = new TrackerClient(ClientGlobal.g_tracker_group);
            TrackerServer trackerServer = trackerClient.getConnection();
            StorageServer storageServer = trackerClient.getStoreStorage(trackerServer);
            StorageClient storageClient = new StorageClient(trackerServer, storageServer);

            System.out.println(&quot;trackerClient : &quot; + trackerClient);
            System.out.println(&quot;trackerServer : &quot; + trackerServer);
            System.out.println(&quot;storageServer : &quot; + storageServer);
            System.out.println(&quot;storageClient : &quot; + storageClient);
        }catch(IOException e1){
            e1.printStackTrace();
        }catch(MyException e2){
            e2.printStackTrace();
        }
    }
}

</code></pre>
</li>
</ol>
<h3 id="33-定义fastdfs-工具类">3.3  定义FastDFS 工具类</h3>
<pre><code class="language-java">package com.cy.fdfs.test;

import org.csource.fastdfs.*;

public class FastDFSClientUtils {
    // 定义FastDFS配置文件地址路径
    private static final String configFile = &quot;src/main/resources/test/fdfs.conf&quot;;
    // 要使用的FastDFS客户端对象。
    private static StorageClient storageClient;
    private static TrackerClient trackerClient;
    private static TrackerServer trackerServer;
    private static StorageServer storageServer;

    static{
        // 初始化代码块， 初始化需要使用的客户端对象。
        try {
            ClientGlobal.init(configFile);
            trackerClient = new TrackerClient();
            trackerServer = trackerClient.getConnection();
            storageServer = trackerClient.getStoreStorage(trackerServer);
            storageClient = new StorageClient(trackerServer, storageServer);
        }catch(Exception e){
            e.printStackTrace();
            // 初始化错误。
            throw new ExceptionInInitializerError(e);
        }
    }

    // 获取Storage客户端对象的方法。 工具方法。
    public static StorageClient getStorageClient(){
        return storageClient;
    }

    public static void main(String[] args) {
        StorageClient storageClient = FastDFSClientUtils.getStorageClient();
        System.out.println(&quot;storageClient : &quot; + storageClient);
    }
}

</code></pre>
<h3 id="34-文件上传">3.4 文件上传</h3>
<ol>
<li>代码</li>
</ol>
<pre><code class="language-java">package com.cy.fdfs.test;

import org.csource.common.MyException;
import org.csource.common.NameValuePair;
import org.csource.fastdfs.StorageClient;

import java.io.IOException;

// 文件上传到FastDFS
public class TestUpload {

    public static void main(String[] args) {
        // 获取Storage客户端对象
        StorageClient storageClient = FastDFSClientUtils.getStorageClient();

        // 准备上传文件需要的信息
        String local_file = &quot;testFile/1.jpg&quot;;
        String ext_file_name = &quot;jpg&quot;;
        NameValuePair[] meta_list = new NameValuePair[]{
                new NameValuePair(&quot;fileName&quot;, &quot;1.jpg&quot;),
                new NameValuePair(&quot;uploadUser&quot;, &quot;cy&quot;)
        };

        // 上传文件到FastDFS
        /*
         * String[] upload_file(String local_file, String ext_file_name, NameValuePair[] meta_list);
         * local_file - 要上传的本地文件的地址
         * ext_file_name - 要上传的文件的后缀名。FastDFS使用uuid管理上传的文件命名，需要提供文件的后缀名。
         * meta_list - 要上传的文件的元数据。如：文件的原始名称，文件的大小，文件的创建者等。
         *   可有可无的，如果不需要FastDFS记录，则传递null即可。
         *
         * 返回值：返回上传后的文件在FastDFS中的卷名和文件名。 如：group1 , 00/00/xxxxx.jpg
         */
        String[] fileIds = null;
        try{
            fileIds = storageClient.upload_file(local_file, ext_file_name, meta_list);
        }catch(IOException e){
            e.printStackTrace();
        }catch(MyException e){
            e.printStackTrace();
        }

        // 解析上传的结果
        System.out.println(&quot;返回字符串数组长度 - &quot; + fileIds.length);
        System.out.println(&quot;0下标位置 - &quot; + fileIds[0]);
        System.out.println(&quot;1下标位置 - &quot; + fileIds[1]);

    }

}

</code></pre>
<ol start="2">
<li>
<p>结果</p>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200701151511.png" alt="" loading="lazy"></figure>
</li>
</ol>
<h3 id="35-文件下载">3.5 文件下载</h3>
<ol>
<li>代码</li>
</ol>
<pre><code class="language-java">package com.cy.fdfs.test;

import org.apache.commons.io.IOUtils;
import org.csource.common.MyException;
import org.csource.common.NameValuePair;
import org.csource.fastdfs.StorageClient;

import java.io.FileOutputStream;
import java.io.IOException;

// 下载文件
public class TestDownload {
    public static void main(String[] args) {
        // 获取Storage客户端对象
        StorageClient storageClient = FastDFSClientUtils.getStorageClient();

        // 准备下载文件的信息资源
        String groupName = &quot;group1&quot;;
        String remoteFileName = &quot;M00/00/00/wKhZmV2m1tiAFtwTAADW-MWxcrw364.jpg&quot;;

        // 下载文件
        /*
         * byte[] download_file(String group_name, String remote_file_name);
         * group_name - 要下载的文件的卷名
         * remote_file_name - 要下载的文件的远程名称，就是FastDFS服务器中的文件名称。
         * 返回值：就是要下载的文件的字节数组。
         */
        byte[] datas = null;
        try{
            datas = storageClient.download_file(groupName,remoteFileName);
        }catch (IOException e){
            e.printStackTrace();
        }catch (MyException e){
            e.printStackTrace();
        }

        // 查询要下载的文件的元数据，获取文件的原始名称，作为下载文件的文件名。
        /*
         * NameValuePair[] get_metadata(String group_name, String remote_file_name)
         * group_name - 要获取元数据的文件的卷名
         * remote_file_name - 要获取元数据的文件的远程文件名
         * 返回值：文件的元数据数组。
         */
        NameValuePair[] metaList = null;
        try{
            metaList = storageClient.get_metadata(groupName, remoteFileName);
        }catch(IOException e){
            e.printStackTrace();
        }catch (MyException e){
            e.printStackTrace();
        }

        String fileName = &quot;&quot;;
        for(NameValuePair nvp : metaList){
            if(nvp.getName().equals(&quot;fileName&quot;)){
                fileName = nvp.getValue();
            }
        }

        // 处理下载后的数据信息
        try{
            IOUtils.write(datas, new FileOutputStream(&quot;downloadFile/&quot;+fileName));
        }catch(IOException e){
            e.printStackTrace();
        }

        System.out.println(&quot;文件下载成功，下载文件名称是：&quot; + fileName);
    }
}
</code></pre>
<ol start="2">
<li>
<p>结果：</p>
<figure data-type="image" tabindex="8"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200701151636.png" alt="" loading="lazy"></figure>
</li>
</ol>
<h3 id="36-删除文件">3.6 删除文件</h3>
<ol>
<li>
<p>代码</p>
<pre><code class="language-java">package com.cy.fdfs.test;

import org.csource.common.MyException;
import org.csource.fastdfs.StorageClient;

import java.io.IOException;

// 删除文件
public class TestDelete {
    public static void main(String[] args) {
        // 获取Storage客户端对象
        StorageClient storageClient = FastDFSClientUtils.getStorageClient();

        // 准备要删除的文件的信息
        String groupName = &quot;group1&quot;;
        String remoteFileName = &quot;M00/00/00/wKhZmV2m1tiAFtwTAADW-MWxcrw364.jpg&quot;;

        // 删除文件
        /*
         * int delete_file(String group_name, String remote_file_name)
         * group_name - 要删除的文件的卷名
         * remote_file_name - 要删除的文件的文件名，FastDFS中的文件名。
         * 返回值： 是否删除文件成功。 0 代表删除成功， 其他代表删除失败。
         */
        int flag = 0;
        try{
            flag = storageClient.delete_file(groupName, remoteFileName);
        }catch(IOException e){
            e.printStackTrace();
        }catch (MyException e){
            e.printStackTrace();
        }

        // 处理删除结果
        System.out.println(flag == 0 ? &quot;删除文件成功&quot; : &quot;删除文件失败&quot;);
    }
}
</code></pre>
<ol start="2">
<li>结果</li>
</ol>
<figure data-type="image" tabindex="9"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200701151758.png" alt="" loading="lazy"></figure>
</li>
</ol>
<h2 id="4-web-应用中使用-fastdfs">4、WEB 应用中使用 FastDFS</h2>
<figure data-type="image" tabindex="10"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200701154535.png" alt="" loading="lazy"></figure>
<h3 id="41-依赖">4.1 依赖</h3>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.cy&lt;/groupId&gt;
    &lt;artifactId&gt;fdfs&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;war&lt;/packaging&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;cn.bestwu&lt;/groupId&gt;
            &lt;artifactId&gt;fastdfs-client-java&lt;/artifactId&gt;
            &lt;version&gt;1.27&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.12&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;!-- MyBatis --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
            &lt;version&gt;3.4.6&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- mybatis整合spring插件 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
            &lt;version&gt;1.3.1&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- mysql数据库驱动 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;5.1.39&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;5.0.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
            &lt;version&gt;5.0.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
            &lt;version&gt;5.0.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;
            &lt;version&gt;5.0.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;
            &lt;version&gt;5.0.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;jstl&lt;/artifactId&gt;
            &lt;version&gt;1.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
            &lt;version&gt;2.5&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;
            &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;
            &lt;version&gt;2.2&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;
            &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;
            &lt;version&gt;4.1.6&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
            &lt;version&gt;2.9.5&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
            &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;
            &lt;version&gt;3.4&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;commons-io&lt;/groupId&gt;
            &lt;artifactId&gt;commons-io&lt;/artifactId&gt;
            &lt;version&gt;2.4&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;
            &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;
            &lt;version&gt;1.3.1&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
    &lt;build&gt;
        &lt;pluginManagement&gt;
            &lt;plugins&gt;
                &lt;plugin&gt;
                    &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;
                    &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;
                    &lt;version&gt;2.2&lt;/version&gt;
                &lt;/plugin&gt;
            &lt;/plugins&gt;
        &lt;/pluginManagement&gt;

        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;
                &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;
                &lt;configuration&gt;
                    &lt;port&gt;80&lt;/port&gt;
                    &lt;path&gt;/&lt;/path&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

&lt;/project&gt;
</code></pre>
<h3 id="42-数据库建模">4.2 数据库建模</h3>
<pre><code class="language-mysql">drop table if exists t_files;

create table t_files(
    id bigint not null auto_increment,
    file_name varchar(255), -- 文件的原始名称
    group_name varchar(32), -- 文件在FastDFS中的卷名
    remote_file_name varchar(255), -- 文件在FastDFS中的文件名， UUID
    file_path varchar(255), -- 文件在FastDFS中的路径， 就是卷名+远程文件名
    primary key(id)
);
</code></pre>
<h3 id="43-fastdfs-配置">4.3 FastDFS 配置</h3>
<pre><code class="language-properties">connect_timeout = 10
network_timeout = 30
charset = UTF-8
http.tracker_http_port = 8080
tracker_server = 192.168.89.152:22122
</code></pre>
<h3 id="44-spring-配置">4.4 Spring 配置</h3>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/mvc
        http://www.springframework.org/schema/mvc/spring-mvc.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;

    &lt;mvc:annotation-driven/&gt;

    &lt;context:component-scan base-package=&quot;com.cy&quot;&gt;&lt;/context:component-scan&gt;

    &lt;!-- 文件上传的转换器 --&gt;
    &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;
        &lt;!-- 限制文件上传大小 --&gt;
        &lt;property name=&quot;maxUploadSize&quot; value=&quot;2048000&quot; /&gt;
        &lt;!-- 内存缓存大小 --&gt;
        &lt;property name=&quot;maxInMemorySize&quot; value=&quot;2048&quot; /&gt;
        &lt;!-- 处理文本文件的字符集 --&gt;
        &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot; /&gt;
    &lt;/bean&gt;

    &lt;!-- 连接池数据源 --&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/fdfsfile&quot; /&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;
        &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt;
    &lt;/bean&gt;

    &lt;!-- 会话工厂 --&gt;
    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
        &lt;property name=&quot;mapperLocations&quot;&gt;
            &lt;array&gt;
                &lt;value&gt;classpath:com/cy/mapper/*.xml&lt;/value&gt;
            &lt;/array&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;!-- Mapper工厂 --&gt;
    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
        &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot; /&gt;
        &lt;property name=&quot;basePackage&quot; value=&quot;com.cy.mapper&quot; /&gt;
    &lt;/bean&gt;

    &lt;!-- 事务管理器 --&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;

    &lt;!-- 事务通知 --&gt;
    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
        &lt;tx:attributes&gt;
            &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot; isolation=&quot;DEFAULT&quot;
            rollback-for=&quot;java.lang.Exception&quot;/&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;

    &lt;!-- 事务切面 --&gt;
    &lt;aop:config&gt;
        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution( * com.cy.service.*.*(..))&quot;/&gt;
    &lt;/aop:config&gt;

&lt;/beans&gt;
</code></pre>
<ol start="5">
<li>web.xml 配置</li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;
         xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;
         id=&quot;WebApp_ID&quot; version=&quot;2.5&quot;&gt;

    &lt;welcome-file-list&gt;
        &lt;welcome-file&gt;/index&lt;/welcome-file&gt;
    &lt;/welcome-file-list&gt;
    
    &lt;filter&gt;
        &lt;filter-name&gt;charsetFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;UTF-8&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;charsetFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;mvc&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;0&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;mvc&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    
&lt;/web-app&gt;
</code></pre>
<ol start="6">
<li>FastDFS 工具类定义</li>
</ol>
<pre><code class="language-java">package com.cy.fdfs.test;

import org.csource.fastdfs.*;

public class FastDFSClientUtils {
    // 定义FastDFS配置文件地址路径
    private static final String configFile = &quot;src/main/resources/test/fdfs.conf&quot;;
    // 要使用的FastDFS客户端对象。
    private static StorageClient storageClient;
    private static TrackerClient trackerClient;
    private static TrackerServer trackerServer;
    private static StorageServer storageServer;

    static{
        // 初始化代码块， 初始化需要使用的客户端对象。
        try {
            ClientGlobal.init(configFile);
            trackerClient = new TrackerClient();
            trackerServer = trackerClient.getConnection();
            storageServer = trackerClient.getStoreStorage(trackerServer);
            storageClient = new StorageClient(trackerServer, storageServer);
        }catch(Exception e){
            e.printStackTrace();
            // 初始化错误。
            throw new ExceptionInInitializerError(e);
        }
    }

    // 获取Storage客户端对象的方法。 工具方法。
    public static StorageClient getStorageClient(){
        return storageClient;
    }

    public static void main(String[] args) {
        StorageClient storageClient = FastDFSClientUtils.getStorageClient();
        System.out.println(&quot;storageClient : &quot; + storageClient);
    }
}

</code></pre>
<h3 id="47-实体类型">4.7  实体类型</h3>
<pre><code class="language-java">package com.cy.entity;

import java.io.Serializable;
import java.util.Objects;

// 文件相关信息的实体类
public class FileInfo implements Serializable {
    private Long id;
    private String fileName;
    private String groupName;
    private String remoteFileName;
    private String filePath;

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        FileInfo fileInfo = (FileInfo) o;
        return Objects.equals(id, fileInfo.id) &amp;&amp;
                Objects.equals(fileName, fileInfo.fileName) &amp;&amp;
                Objects.equals(groupName, fileInfo.groupName) &amp;&amp;
                Objects.equals(remoteFileName, fileInfo.remoteFileName) &amp;&amp;
                Objects.equals(filePath, fileInfo.filePath);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id, fileName, groupName, remoteFileName, filePath);
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getFileName() {
        return fileName;
    }

    public void setFileName(String fileName) {
        this.fileName = fileName;
    }

    public String getGroupName() {
        return groupName;
    }

    public void setGroupName(String groupName) {
        this.groupName = groupName;
    }

    public String getRemoteFileName() {
        return remoteFileName;
    }

    public void setRemoteFileName(String remoteFileName) {
        this.remoteFileName = remoteFileName;
    }

    public String getFilePath() {
        return filePath;
    }

    public void setFilePath(String filePath) {
        this.filePath = filePath;
    }
}

</code></pre>
<h3 id="48-mapper-接口定义">4.8 Mapper 接口定义</h3>
<pre><code class="language-java">package com.cy.mapper;

import com.cy.entity.FileInfo;

import java.util.List;

// 文件数据的数据访问接口
public interface FileInfoMapper {
    /**
     * 新增文件相关数据到数据库
     * @param fileInfo 要新增的数据
     */
    void insertFileInfo(FileInfo fileInfo);

    /**
     * 查询所有的文件相关数据
     * @return
     */
    List&lt;FileInfo&gt; selectFileInfos();

    /**
     * 主键查询详情
     * @param id
     * @return
     */
    FileInfo selectById(Long id);
}

</code></pre>
<h3 id="49-mapper-配置文件">4.9 Mapper 配置文件</h3>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.cy.mapper.FileInfoMapper&quot;&gt;
    &lt;insert id=&quot;insertFileInfo&quot;&gt;
        insert into t_files(id, file_name, group_name, remote_file_name, file_path)
        values(default, #{fileName}, #{groupName}, #{remoteFileName}, #{filePath})
    &lt;/insert&gt;
    &lt;select id=&quot;selectFileInfos&quot; resultType=&quot;com.cy.entity.FileInfo&quot;&gt;
        select id, file_name as fileName, group_name as groupName, remote_file_name as remoteFileName,
            file_path as filePath
        from t_files
    &lt;/select&gt;
    &lt;select id=&quot;selectById&quot; resultType=&quot;com.cy.entity.FileInfo&quot;&gt;
        select id, file_name as fileName, group_name as groupName, remote_file_name as remoteFileName,
            file_path as filePath
        from t_files
        where id = #{id}
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="410-服务接口">4.10 服务接口</h3>
<pre><code class="language-java">package com.cy.service;

import com.cy.entity.FileInfo;
import org.springframework.web.multipart.MultipartFile;

import java.io.InputStream;
import java.util.List;

// 文件处理服务接口
public interface FileService {
    /**
     * 上传文件到FastDFS中，把文件的一些相关数据保存到数据库中。
     * @param file - 要上传的文件
     * @return true - 成功 ； false - 失败
     */
    boolean uploadFile(MultipartFile file);

    /**
     * 查询所有的可下载的文件的数据
     * @return 数据库中的数据集合
     */
    List&lt;FileInfo&gt; getFileInfos();

    /**
     * 获取要下载的文件
     * @param fileInfoId 文件在数据库中的主键
     * @return 要下载的文件的输入流
     */
    InputStream getFile(Long fileInfoId);

    FileInfo getFileInfoById(Long fileInfoId);
}
</code></pre>
<h3 id="411-服务实现">4.11 服务实现</h3>
<pre><code class="language-java">package com.cy.service.impl;

import com.cy.entity.FileInfo;
import com.cy.fdfs.FastDFSCommonsUtils;
import com.cy.mapper.FileInfoMapper;
import com.cy.service.FileService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.InputStream;
import java.util.Arrays;
import java.util.List;

// 文件处理服务实现
@Service
public class FileServiceImpl implements FileService {
    @Autowired
    private FileInfoMapper fileInfoMapper;
    @Override
    public boolean uploadFile(MultipartFile file) {
        try {
            String[] result = FastDFSCommonsUtils.upload(file.getInputStream(), file.getOriginalFilename());
            if(result == null){
                // 上传失败
                return false;
            }
            // System.out.println(Arrays.toString(result));
            // 将文件相关信息保存到数据库
            FileInfo fileInfo = new FileInfo();
            fileInfo.setFileName(file.getOriginalFilename());
            fileInfo.setGroupName(result[0]);
            fileInfo.setRemoteFileName(result[1]);
            fileInfo.setFilePath(result[0]+&quot;/&quot;+result[1]);
            this.fileInfoMapper.insertFileInfo(fileInfo);
            return true;
        }catch (Exception e){ // 上传失败
            e.printStackTrace();
            return false;
        }
    }

    @Override
    public List&lt;FileInfo&gt; getFileInfos() {
        return this.fileInfoMapper.selectFileInfos();
    }

    @Override
    public InputStream getFile(Long fileInfoId) {
        // 访问数据库，获取要下载的文件的详情信息
        FileInfo fileInfo = this.fileInfoMapper.selectById(fileInfoId);

        // 访问FastDFS，获取要下载的文件的具体内容
        InputStream inputStream = FastDFSCommonsUtils.download(fileInfo.getGroupName(), fileInfo.getRemoteFileName());

        // 返回
        return inputStream;
    }

    @Override
    public FileInfo getFileInfoById(Long fileInfoId) {
        return this.fileInfoMapper.selectById(fileInfoId);
    }
}
</code></pre>
<h3 id="412-控制器">4.12 控制器</h3>
<pre><code class="language-java">package com.cy.controller;

import com.cy.entity.FileInfo;
import com.cy.service.FileService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.multipart.MultipartFile;

import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.List;

// 文件控制器，实现上传、下载功能
@Controller
public class FileController {
    @Autowired
    private FileService fileService;
    /**
     * 文件上传
     * @param uploadFile 要上传的文件
     * @return
     */
    @RequestMapping(&quot;/uploadFile&quot;)
    public String uploadFile(MultipartFile uploadFile){
//        System.out.println(&quot;上传文件的原始名称 - &quot; + uploadFile.getOriginalFilename());
//        System.out.println(&quot;上传文件的大小 - &quot; + uploadFile.getSize());
        // 上传文件到FastDFS中
        boolean flag = this.fileService.uploadFile(uploadFile);
        System.out.println(flag ? &quot;上传成功&quot; : &quot;上传失败&quot;);

        return &quot;redirect:/index&quot;;
    }

    /**
     * 进入到首页面的方法。
     * 在进入首页面之前，需要先访问数据库，查询可以下载的文件的相关信息。
     * @return
     */
    @RequestMapping(value = {&quot;/&quot;, &quot;/index&quot;})
    public String toIndex(Model model){
        List&lt;FileInfo&gt; list = this.fileService.getFileInfos();
        model.addAttribute(&quot;list&quot;, list);
        return &quot;forward:/index.jsp&quot;;
    }

    /**
     * 下载文件
     * @param fileInfoId 要下载的文件在数据库中的相关数据主键
     */
    @RequestMapping(value=&quot;/downloadFile/{fileInfoId}&quot;)
    public void downloadFile(@PathVariable(&quot;fileInfoId&quot;) Long fileInfoId, HttpServletResponse response){
        // 获取要传递给客户端的文件数据
        InputStream inputStream = null;
        try {
            inputStream = this.fileService.getFile(fileInfoId);
            FileInfo fileInfo = this.fileService.getFileInfoById(fileInfoId);
            // 设置响应头， 响应为下载，下载的文件名是什么
            response.setContentType(&quot;application/octet-stream&quot;);
            response.setHeader(&quot;content-disposition&quot;, &quot;attachement;filename=&quot;+fileInfo.getFileName());

            // 通过输出流输出文件内容到客户端
            OutputStream outputStream = response.getOutputStream();

            byte[] temp = new byte[512];
            int len = 0;
            while((len = inputStream.read(temp)) != -1){
                outputStream.write(temp, 0, len);
            }

            // 刷新缓存
            outputStream.flush();
        }catch(Exception e){
            e.printStackTrace();
        }finally {
            if(inputStream != null){ // 回收资源
                try {
                    inputStream.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
</code></pre>
<h3 id="413-页面indexjsp">4.13 页面index.jsp</h3>
<pre><code class="language-jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;

&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;FastDFS WEB应用&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;center&gt;
        &lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; action=&quot;/uploadFile&quot;&gt;
            选择要上传的文件:&lt;input type=&quot;file&quot; name=&quot;uploadFile&quot;&gt;
            &amp;nbsp;&amp;nbsp;&amp;nbsp;
            &lt;input type=&quot;submit&quot; value=&quot;上传&quot;&gt;
        &lt;/form&gt;
        &lt;table border=&quot;1&quot; style=&quot;width: 800px&quot;&gt;
            &lt;thead&gt;
            &lt;tr&gt;
                &lt;th&gt;文件原始名称&lt;/th&gt;
                &lt;th&gt;文件卷标名称&lt;/th&gt;
                &lt;th&gt;文件远程名称&lt;/th&gt;
                &lt;th&gt;操作&lt;/th&gt;
            &lt;/tr&gt;
            &lt;/thead&gt;
            &lt;tbody&gt;
            &lt;c:forEach items=&quot;${list}&quot; var=&quot;fileInfo&quot;&gt;
                &lt;tr&gt;
                    &lt;th&gt;${fileInfo.fileName}&lt;/th&gt;
                    &lt;th&gt;${fileInfo.groupName}&lt;/th&gt;
                    &lt;th&gt;${fileInfo.remoteFileName}&lt;/th&gt;
                    &lt;th&gt;&lt;a href=&quot;/downloadFile/${fileInfo.id}&quot;&gt;下载&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;
                        &lt;a href=&quot;http://192.168.89.153:8888/${fileInfo.filePath}&quot; target=&quot;_blank&quot;&gt;预览&lt;/a&gt;&lt;/th&gt;
                &lt;/tr&gt;
            &lt;/c:forEach&gt;
            &lt;/tbody&gt;
        &lt;/table&gt;
    &lt;/center&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Dubbo]]></title>
        <id>https://jonchan1013.github.io/post/dubbo/</id>
        <link href="https://jonchan1013.github.io/post/dubbo/">
        </link>
        <updated>2020-06-30T06:29:39.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="1-dubbo简介">1、Dubbo简介</h2>
<h3 id="11-dubbo是什么">1.1 Dubbo是什么</h3>
<p><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200624160121.png" alt="" loading="lazy"><br>
Dubbo 官网地址：http://dubbo.apache.org/zh-cn/<br>
Dubbo 最早是 Alibaba 开源的分布式服务框架，它最大的特点是按照分层的方式来架构，使用这种方式可以使各个层之间解耦合（或者最大限度地松耦合）。从服务模型的角度来看，Dubbo 采用的是一种非常简单的模型，要么是提供方提供服务，要么是消费方消费服务，所以基于这一点可以抽象出服务提供方（Provider）和服务消费方（Consumer）两个角色。</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="1-dubbo简介">1、Dubbo简介</h2>
<h3 id="11-dubbo是什么">1.1 Dubbo是什么</h3>
<p><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200624160121.png" alt="" loading="lazy"><br>
Dubbo 官网地址：http://dubbo.apache.org/zh-cn/<br>
Dubbo 最早是 Alibaba 开源的分布式服务框架，它最大的特点是按照分层的方式来架构，使用这种方式可以使各个层之间解耦合（或者最大限度地松耦合）。从服务模型的角度来看，Dubbo 采用的是一种非常简单的模型，要么是提供方提供服务，要么是消费方消费服务，所以基于这一点可以抽象出服务提供方（Provider）和服务消费方（Consumer）两个角色。</p>
<!-- more -->
<h3 id="12-发展历史">1.2 发展历史</h3>
<p>​	Dubbo 是最开始是阿里巴巴内部使用的 RPC 框架。</p>
<p>​	2011 年对外提供。<br>
​	2012 年停止更新。<br>
​	2017 年开始继续更新。<br>
​	2019 年捐献给 Apache，由 Apache 维护 2.7 以上版本。</p>
<h3 id="13-dubbo能做什么">1.3 Dubbo能做什么</h3>
<ul>
<li>Dubbo 可实现透明化的远程方法调用，就像调用本地方法一样调用远程方法，只需简单配置即可，没有任何 API 侵入。</li>
<li>软负载均衡及容错机制，可在内网替代 F5 等硬件负载均衡器，降低成本，减少单点。</li>
<li>软负载均衡及容错机制，可在内网替代 F5 等硬件负载均衡器，降低成本，减少单点。</li>
</ul>
<h3 id="14-dubbo产生的背景">1.4 Dubbo产生的背景</h3>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200624171428.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p>单一应用架构（单体架构）</p>
<p>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM) 是关键。</p>
</li>
<li>
<p>垂直应用架构</p>
<p>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。<br>
此时，用于加速前端页面开发的 Web 框架(MVC) 是关键。</p>
</li>
<li>
<p>分布式服务架构（RPC 架构）<br>
当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。<br>
此时，用于提高业务复用及整合的分布式服务框架(RPC) 是关键。</p>
</li>
<li>
<p>流动计算架构（SOA 架构）</p>
<p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。<br>
此时，用于提高机器利用率的资源调度和治理中心(SOA) 是关键。</p>
</li>
</ul>
<h2 id="2-dubbo架构讲解">2、Dubbo架构讲解</h2>
<h3 id="21-架构图">2.1 架构图</h3>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200624171618.png" alt="" loading="lazy"></figure>
<h3 id="22-架构说明">2.2 架构说明</h3>
<ol>
<li>
<p>虚线<br>
虚线表示异步，实线表示同步。异步不阻塞线程性能高，同步阻塞线程必须等待响应结果才能继续执行，相对性能低。</p>
</li>
<li>
<p>Provider<br>
暴露服务的服务提供方。</p>
</li>
<li>
<p>Container<br>
服务运行容器。Dubbo 完全基于 Spring 实现的。</p>
</li>
<li>
<p>Registry<br>
服务注册与发现的注册中心。注册中心，放置所有 Provider 对外提供的信息。包含Provider 的 IP，访问端口，访问遵守的协议，对外提供的接口，接口中有哪些方法等相关信息。</p>
</li>
<li>
<p>Consumer<br>
调用远程服务的服务消费方。</p>
</li>
<li>
<p>Monitor<br>
统计服务的调用次调和调用时间的监控中心。监控中心，监控 Provider 的压力情况等。每隔 2 分钟 Consumer 和 Provider 会把调用次数发送给 Monitor，由 Monitor 进行统计。</p>
</li>
</ol>
<h3 id="23-执行流程">2.3 执行流程</h3>
<ol start="0">
<li>start：启动 Spring 容器时会把 Provider 启动。</li>
<li>register：把 Provider 相关信息注册到 Registry 里</li>
<li>subscribe：Consumer 从 Registry 中订阅 Provider 的信息</li>
<li>notify：当Provider发生改变时，Registry通知给 Consumer</li>
<li>invoke：Consumer 根据 Registry 通知的信息进行调用 Provider 中方法。</li>
<li>count:Consumer 和 Provider 把调用次数信息异步发送给 Monitor 进行统计。</li>
</ol>
<h2 id="3-dobbo支持的协议">3、Dobbo支持的协议</h2>
<h3 id="31-dubbo协议官方推荐协议">3.1 Dubbo协议（官方推荐协议）</h3>
<p>优点：<br>
采用 NIO 复用单一长连接，并使用线程池并发处理请求，减少握手和加大并发效率，性能较好（推荐使用）</p>
<p>缺点：<br>
大文件上传时,可能出现问题(不使用 Dubbo 文件上传)</p>
<h3 id="32-rmiremote-method-invocation协议">3.2  RMI(Remote Method Invocation)协议</h3>
<p>优点:<br>
JDK 自带的能力。<br>
缺点:<br>
偶尔连接失败.</p>
<h3 id="33-hessian-协议">3.3  Hessian 协议</h3>
<p>优点:<br>
可与原生 Hessian 互操作，基于 HTTP 协议<br>
缺点:<br>
需 hessian.jar 支持，http 短连接的开销大</p>
<h2 id="4-dubbo-支持的注册中心">4、Dubbo 支持的注册中心</h2>
<h3 id="41-zookeeper官方推荐">4.1 Zookeeper(官方推荐)</h3>
<ol>
<li>优点:<br>
支持分布式.很多周边产品.</li>
<li>缺点:<br>
受限于 Zookeeper 软件的稳定性。Zookeeper 是一款专门为分布式架构提供辅助型处理的软件，稳定较优。</li>
</ol>
<h3 id="42-multicast">4.2  Multicast</h3>
<ol>
<li>优点:<br>
去中心化,不需要单独安装软件.</li>
<li>缺点:<br>
Provider 和 Consumer 和 Registry 不能跨机房(路由)</li>
</ol>
<h3 id="43-redis">4.3 Redis</h3>
<ol>
<li>优点:<br>
支持集群,性能高</li>
<li>缺点:<br>
要求服务器时间同步.否则可能出现集群失败问题.</li>
</ol>
<h3 id="44-simple">4.4 Simple</h3>
<ol>
<li>
<p>优点:<br>
标准 RPC 服务.没有兼容问题</p>
</li>
<li>
<p>缺点:<br>
不支持集群.</p>
</li>
</ol>
<h2 id="5-dubbo-应用">5、Dubbo 应用</h2>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200628095739.png" alt="" loading="lazy"></figure>
<p>Dubbo 在不同的版本中对于添加的依赖也是不同的。</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200628195505.png" alt="" loading="lazy"></figure>
<h3 id="51-创建父工程">5.1 创建父工程</h3>
<ol>
<li>
<p>创建项目</p>
</li>
<li>
<p>修改POM 文件添加依赖</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.cy&lt;/groupId&gt;
    &lt;artifactId&gt;parent&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;pom&lt;/packaging&gt;

    &lt;properties&gt;
        &lt;spring.version&gt;5.2.5.RELEASE&lt;/spring.version&gt;
        &lt;dubbo.version&gt;2.7.6&lt;/dubbo.version&gt;
        &lt;curator.version&gt;4.2.0&lt;/curator.version&gt;
        &lt;registry-zookeeper.version&gt;2.7.6&lt;/registry-zookeeper.version&gt;
        &lt;servlet.version&gt;3.1.0&lt;/servlet.version&gt;
        &lt;jsp.version&gt;2.0&lt;/jsp.version&gt;
        &lt;jstl.version&gt;1.2&lt;/jstl.version&gt;
    &lt;/properties&gt;
    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;!--Spring Context Dependence--&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework&lt;/groupId&gt;
                &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
                &lt;version&gt;${spring.version}&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;!--Spring MVC Dependence--&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework&lt;/groupId&gt;
                &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
                &lt;version&gt;${spring.version}&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;!--Apache Dubbo Dependence--&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
                &lt;artifactId&gt;dubbo&lt;/artifactId&gt;
                &lt;version&gt;${dubbo.version}&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;!--Registry Zookeeper Dependence--&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
                &lt;artifactId&gt;dubbo-registry-zookeeper&lt;/artifactId&gt;
                &lt;version&gt;${registry-zookeeper.version}&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;!--Apache Curator Dependence--&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
                &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;
                &lt;version&gt;${curator.version}&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;!--Servlet Dependence--&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
                &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
                &lt;version&gt;${servlet.version}&lt;/version&gt;
                &lt;scope&gt;provided&lt;/scope&gt;
            &lt;/dependency&gt;
            &lt;!--JSP Dependence--&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
                &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;
                &lt;version&gt;${jsp.version}&lt;/version&gt;
                &lt;scope&gt;provided&lt;/scope&gt;
            &lt;/dependency&gt;
            &lt;!--JSTL Dependence--&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;javax.servlet.jsp.jstl&lt;/groupId&gt;
                &lt;artifactId&gt;jstl&lt;/artifactId&gt;
                &lt;version&gt;${jstl.version}&lt;/version&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;

    &lt;build&gt;
        &lt;pluginManagement&gt;
            &lt;plugins&gt;
                &lt;!--Tomcat Plugin--&gt;
                &lt;plugin&gt;
                    &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;
                    &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;
                    &lt;version&gt;2.2&lt;/version&gt;
                &lt;/plugin&gt;
            &lt;/plugins&gt;
        &lt;/pluginManagement&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
</li>
</ol>
<h3 id="52-创建服务接口">5.2  创建服务接口</h3>
<ol>
<li>
<p>创建项目</p>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200628102304.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>添加接口</p>
</li>
</ol>
<pre><code class="language-java">public interface DemoDubboService {
    String showMsg(String str);
}
</code></pre>
<h3 id="53-创建provider">5.3  创建Provider</h3>
<ol>
<li>
<p>创建项目</p>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200628135344.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>修改POM 文件添加依赖</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;parent&lt;/artifactId&gt;
        &lt;groupId&gt;com.cy&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;provider&lt;/artifactId&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.cy&lt;/groupId&gt;
            &lt;artifactId&gt;api&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--Spring Context Dependence--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--Apache Dubbo Dependence--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
            &lt;artifactId&gt;dubbo&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--Registry Zookeeper Dependence--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
            &lt;artifactId&gt;dubbo-registry-zookeeper&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--Apache Curator Dependence--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
            &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
</li>
<li>
<p>添加接口实现</p>
<pre><code class="language-java">public class DemoDubboServiceimpl implements DemoDubboService{
    public String showMsg(String str) {
        return &quot;Hello Dubbo &quot;+ str;
    }
}
</code></pre>
</li>
</ol>
<h3 id="54-添加dubbo-的配置文件">5.4 添加Dubbo 的配置文件</h3>
<ol>
<li>
<p>Dubbo 配置文件的存放位置</p>
<p>配置文件必须放到 resources/META-INF/spring/*.xml</p>
</li>
<li>
<p>配置文件内容</p>
<ol>
<li>
<p>使用配置bean 标签配置接口实现类</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:dubbo=&quot;http://dubbo.apache.org/schema/dubbo&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans-4.3.xsd        http://dubbo.apache.org/schema/dubbo        http://dubbo.apache.org/schema/dubbo/dubbo.xsd&quot;&gt;

    &lt;!--定义服务的名称(自定义)--&gt;
    &lt;dubbo:application name=&quot;myProvider&quot; /&gt;

    &lt;!--配置注册中心--&gt;
    &lt;dubbo:registry address=&quot;124.70.181.124:2181,124.70.181.124:2182,124.70.181.124:2183&quot; protocol=&quot;zookeeper&quot; timeout=&quot;10000&quot;/&gt;

    &lt;!--服务协议以及监听端口--&gt;
    &lt;dubbo:protocol  name=&quot;dubbo&quot; port=&quot;20880&quot; /&gt;

    &lt;!--注册接口--&gt;
	&lt;dubbo:service interface=&quot;com.bjsxt.dubbo.service.DemoDubboService&quot; ref=&quot;service&quot;/&gt;

    &lt;!--创建接口实现类--&gt;
	&lt;bean id=&quot;service&quot; class=&quot;com.bjsxt.dubbo.service.impl.DemoDubboServiceImpl&quot;/&gt;
&lt;/beans&gt;
  
</code></pre>
</li>
<li>
<p>使用注解方式开发服务接口</p>
<ol>
<li>
<p>需改配置文件</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:dubbo=&quot;http://dubbo.apache.org/schema/dubbo&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans-4.3.xsd        http://dubbo.apache.org/schema/dubbo        http://dubbo.apache.org/schema/dubbo/dubbo.xsd&quot;&gt;

    &lt;!--定义服务的名称(自定义)--&gt;
    &lt;dubbo:application name=&quot;myProvider&quot; /&gt;

    &lt;!--配置注册中心--&gt;
    &lt;dubbo:registry address=&quot;124.70.181.124:2181,124.70.181.124:2182,124.70.181.124:2183&quot; protocol=&quot;zookeeper&quot; timeout=&quot;10000&quot;/&gt;

    &lt;!--服务协议以及监听端口--&gt;
    &lt;dubbo:protocol  name=&quot;dubbo&quot; port=&quot;20880&quot; /&gt;

    &lt;!--扫描接口的位置的指定@Service：注意该注解并不是Spring的@Service--&gt;
    &lt;dubbo:annotation  package=&quot;com.cy.dubbo.service&quot;/&gt;
&lt;/beans&gt;
</code></pre>
</li>
<li>
<p>修改接口实现类</p>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200628135900.png" alt="" loading="lazy"></figure>
</li>
</ol>
<pre><code class="language-java">@Service //注意使用的是 Dubbo 的@Service 注解。
//org.apache.dubbo.config.annotation.Service
public class DemoDubboServiceimpl implements DemoDubboService{
    public String showMsg(String str) {
        return &quot;Hello Dubbo &quot;+ str;
    }
}
</code></pre>
</li>
<li>
<p>启动Provider</p>
<p>创建Dubbo 启动类</p>
<pre><code class="language-java">/**
 * Dubbo的启动类
 */
public class Start {
    public static void main(String[] args) {
        Main.main(args);
    }
}
</code></pre>
</li>
</ol>
</li>
</ol>
<h3 id="55-使用zookeeper-客户端工具查看注册信息">5.5  使用Zookeeper 客户端工具查看注册信息</h3>
<p>​	ls /dubbo/服务接口名称/providers</p>
<figure data-type="image" tabindex="8"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200628144412.png" alt="" loading="lazy"></figure>
<p>注：url信息在Zookeeper中以一个节点的名字而不是信息存储</p>
<ol>
<li>
<p>解码前</p>
<p>dubbo%3A%2F%2F192.168.92.1%3A20880%2Fcom.cy.dubbo.service.DemoDubboService%3Fanyhost%3Dtrue%26application%3DmyProvider%26deprecated%3Dfalse%26dubbo%3D2.0.2%26dynamic%3Dtrue%26generic%3Dfalse%26interface%3Dcom.cy.dubbo.service.DemoDubboService%26methods%3DshowMsg%26pid%3D36272%26release%3D2.7.6%26side%3Dprovider%26timestamp%3D1593326084675</p>
</li>
<li>
<p>解码后</p>
<p>dubbo://192.168.92.1:20880/com.cy.dubbo.service.DemoDubboService?anyhost=true&amp;application=myProvider&amp;deprecated=false&amp;dubbo=2.0.2&amp;dynamic=true&amp;generic=false&amp;interface=com.cy.dubbo.service.DemoDubboService&amp;methods=showMsg&amp;pid=36272&amp;release=2.7.6&amp;side=provider&amp;timestamp=1593326084675</p>
</li>
</ol>
<h3 id="56-创建consumer">5.6 创建Consumer</h3>
<ol>
<li>
<p>创建项目</p>
<figure data-type="image" tabindex="9"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200628145857.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>修改POM 文件添加依赖</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;parent&lt;/artifactId&gt;
        &lt;groupId&gt;com.cy&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;consumer&lt;/artifactId&gt;
    &lt;packaging&gt;war&lt;/packaging&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.cy&lt;/groupId&gt;
            &lt;artifactId&gt;api&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--Spring MVC Dependence--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--Apache Dubbo Dependence--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
            &lt;artifactId&gt;dubbo&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--Registry Zookeeper Dependence--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
            &lt;artifactId&gt;dubbo-registry-zookeeper&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--Apache Curator Dependence--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
            &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!--Servlet Dependence--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;!--JSP Dependence--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;!--JSTL Dependence--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet.jsp.jstl&lt;/groupId&gt;
            &lt;artifactId&gt;jstl&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;!--Tomcat Plugin--&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;
                &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;
                &lt;version&gt;2.2&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;port&gt;8888&lt;/port&gt;
                    &lt;path&gt;/&lt;/path&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
</li>
<li>
<p>编写配置文件</p>
<ol>
<li>
<p>Spring 配置文件</p>
<p>applicationContext-service.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
   http://www.springframework.org/schema/context
   http://www.springframework.org/schema/context/spring-context.xsd
   http://www.springframework.org/schema/aop
   http://www.springframework.org/schema/aop/spring-aop.xsd
   http://www.springframework.org/schema/util
   http://www.springframework.org/schema/util/spring-util.xsd&quot;&gt;
    &lt;context:component-scan base-package=&quot;com.cy.service&quot;/&gt;
&lt;/beans&gt;
</code></pre>
</li>
<li>
<p>SpringMVC 配置文件</p>
<p>springmvc.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
   http://www.springframework.org/schema/context
   http://www.springframework.org/schema/context/spring-context.xsd
   http://www.springframework.org/schema/aop
   http://www.springframework.org/schema/aop/spring-aop.xsd
   http://www.springframework.org/schema/util
   http://www.springframework.org/schema/util/spring-util.xsd
    http://www.springframework.org/schema/mvc
    http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;
    &lt;context:component-scan base-package=&quot;com.cy.web.controller&quot;/&gt;
    &lt;mvc:annotation-driven/&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
</li>
<li>
<p>Dubbo 配置文件</p>
<p>applicationContext-dubbo.xml</p>
<pre><code class="language-xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:dubbo=&quot;http://dubbo.apache.org/schema/dubbo&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:dubbot=&quot;http://dubbo.apache.org/schema/dubbo&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd
      http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;!--配置服务名称--&gt;
    &lt;dubbo:application name=&quot;myConsumer&quot;/&gt;
    &lt;!--配置注册中心地址以及访问协议--&gt;
    &lt;dubbo:registry address=&quot;124.70.181.124:2181,124.70.181.124:2182,124.70.181.124:2183&quot; protocol=&quot;zookeeper&quot; timeout=&quot;10000&quot;/&gt;
    &lt;!--dubbo扫描自己@Reference注解--&gt;
    &lt;dubbo:annotation package=&quot;com.cy.service.impl&quot;/&gt;
&lt;/beans&gt;
</code></pre>
</li>
<li>
<p>Web.xml 配置文件</p>
<p>web.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee
        http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;
         version=&quot;3.0&quot;&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;classpath:spring/applicationContext-*.xml&lt;/param-value&gt;
    &lt;/context-param&gt;
    &lt;listener&gt;
        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
    &lt;/listener&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:spring/springmvc.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    &lt;!--SpringMVC中的编码过滤器--&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;encodeFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;utf-8&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;encodeFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
&lt;/web-app&gt;
</code></pre>
</li>
</ol>
</li>
</ol>
<h3 id="57-实现远程调用">5.7 实现远程调用</h3>
<ol>
<li>
<p>创建业务层</p>
<p>DemoService接口:</p>
<pre><code class="language-java">public interface DemoService {
    public String showInf(String str);
}
</code></pre>
<p>DemoServiceImpl:</p>
<pre><code class="language-java">/**
 * Consumer的业务层
 */
@Service
public class DemoServiceImpl implements DemoService {
    //该注解针对DemoDubboService接口生成代理对象，通过代理对象远程调用provider中方法
    @Reference
    private DemoDubboService demoDubboService;

    public String showInf(String str) {
        return this.demoDubboService.showMsg(str);
    }
}
</code></pre>
</li>
<li>
<p>创建Controller层</p>
<p>DemoController:</p>
<pre><code class="language-java">@RestController
public class DemoController {
    @Autowired
    private DemoService demoService;

    @RequestMapping(&quot;/getMsg&quot;)
    public String getMsg(String str){
        return this.demoService.showInf(str);
    }
}
</code></pre>
</li>
<li>
<p>测试结果</p>
<figure data-type="image" tabindex="10"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200628195240.png" alt="" loading="lazy"></figure>
</li>
</ol>
<h2 id="6-spring-boot-整合dubbo">6、 Spring Boot 整合Dubbo</h2>
<figure data-type="image" tabindex="11"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200629112338.png" alt="" loading="lazy"></figure>
<h3 id="61-创建服务接口">6.1 创建服务接口</h3>
<ol>
<li>
<p>创建项目</p>
<figure data-type="image" tabindex="12"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200629013311.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>添加接口</p>
<pre><code class="language-java">public interface DemoDubboService {
    public String showMsg(String str);
}
</code></pre>
</li>
</ol>
<h3 id="62-创建provider">6.2 创建Provider</h3>
<ol>
<li>
<p>创建项目</p>
<figure data-type="image" tabindex="13"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200629013420.png" alt="" loading="lazy"></figure>
<ol start="2">
<li>
<p>修改POM 文件添加依赖</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
	xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
	&lt;parent&gt;
		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
		&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
		&lt;version&gt;2.3.1.RELEASE&lt;/version&gt;
		&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
	&lt;/parent&gt;
	&lt;groupId&gt;com.cy&lt;/groupId&gt;
	&lt;artifactId&gt;springbootdubbo_provider&lt;/artifactId&gt;
	&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
	&lt;name&gt;springbootdubbo_provider&lt;/name&gt;
	&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;

	&lt;properties&gt;
		&lt;java.version&gt;1.8&lt;/java.version&gt;
	&lt;/properties&gt;

	&lt;dependencies&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;com.cy&lt;/groupId&gt;
			&lt;artifactId&gt;springboot_api&lt;/artifactId&gt;
			&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
			&lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;
			&lt;version&gt;2.7.6&lt;/version&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
			&lt;artifactId&gt;dubbo-registry-zookeeper&lt;/artifactId&gt;
			&lt;version&gt;2.7.6&lt;/version&gt;
		&lt;/dependency&gt;

		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
			&lt;scope&gt;test&lt;/scope&gt;
			&lt;exclusions&gt;
				&lt;exclusion&gt;
					&lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;
					&lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;
				&lt;/exclusion&gt;
			&lt;/exclusions&gt;
		&lt;/dependency&gt;
	&lt;/dependencies&gt;

	&lt;build&gt;
		&lt;plugins&gt;
			&lt;plugin&gt;
				&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
				&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
			&lt;/plugin&gt;
		&lt;/plugins&gt;
	&lt;/build&gt;

&lt;/project&gt;

</code></pre>
</li>
</ol>
</li>
<li>
<p>添加接口实现</p>
<pre><code class="language-java">@Service //在Provider中使用的dubbo的@Service注解。
public class DemoDubboServiceImpl implements DemoDubboService {
    @Override
    public String showMsg(String str) {
        return &quot;Hello Dubbo &quot; + str;
    }
}
</code></pre>
</li>
<li>
<p>在配置文件中配置Dubbo</p>
<p>application.yml：</p>
<pre><code class="language-yaml"># 指定服务的名称
dubbo:
  application:
    name: MYProvider
  registry:
    address: zookeeper://124.70.181.124:2181?backup=124.70.181.124:2182,124.70.181.124:2183
    timeout: 10000
# 配置服务所使用的的协议
  protocol:
    name: dubbo
    port: 20880
  scan:
    base-packages: com.cy.springbootdubbo_provider.service.impl

</code></pre>
</li>
<li>
<p>启动Provider</p>
<ol>
<li>
<p>通过spring-boot-starter-web 启动Dubbo</p>
<p>​		如果在项目中添加的是 spring-boot-starter-web 启动器，那么在启动 dubbo 后还会监听一个端口，因为在 web 启动器中内置了一个 Tomcat，Tomcat 的启动不会影响 dubbo 的运行，但是会多占用一个端口，未来在其他的 Provider 中还需要考虑端口分配的问题，避免端口抢占。</p>
</li>
<li>
<p>通过spring-boot-starter 启动Dubbo</p>
<p>​		可以使用 spring-boot-starter 起来启动 Dubbo，在该启动器中并未包含 Tomcat 所以并不会监听端口。</p>
</li>
</ol>
</li>
</ol>
<figure data-type="image" tabindex="14"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200629014059.png" alt="" loading="lazy"></figure>
<p>解码后：dubbo://192.168.92.1:20880/com.cy.dubbo.service.DemoDubboService?anyhost=true&amp;application=MYProvider&amp;deprecated=false&amp;dubbo=2.0.2&amp;dynamic=true&amp;generic=false&amp;interface=com.cy.dubbo.service.DemoDubboService&amp;methods=showMsg&amp;pid=28764&amp;release=2.7.6&amp;side=provider&amp;timestamp=1593365445283</p>
<h3 id="63-创建consumer">6.3 创建consumer</h3>
<ol>
<li>
<p>创建项目</p>
<figure data-type="image" tabindex="15"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200629111858.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>修改POM 文件添加依赖</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
	xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
	&lt;parent&gt;
		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
		&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
		&lt;version&gt;2.3.1.RELEASE&lt;/version&gt;
		&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
	&lt;/parent&gt;
	&lt;groupId&gt;com.cy&lt;/groupId&gt;
	&lt;artifactId&gt;springbootdubbo_consumer&lt;/artifactId&gt;
	&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
	&lt;name&gt;springbootdubbo_consumer&lt;/name&gt;
	&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;

	&lt;properties&gt;
		&lt;java.version&gt;1.8&lt;/java.version&gt;
	&lt;/properties&gt;

	&lt;dependencies&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;com.cy&lt;/groupId&gt;
			&lt;artifactId&gt;springboot_api&lt;/artifactId&gt;
			&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
		&lt;/dependency&gt;

		&lt;dependency&gt;
			&lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
			&lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;
			&lt;version&gt;2.7.6&lt;/version&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
			&lt;artifactId&gt;dubbo-registry-zookeeper&lt;/artifactId&gt;
			&lt;version&gt;2.7.6&lt;/version&gt;
		&lt;/dependency&gt;

		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
			&lt;scope&gt;test&lt;/scope&gt;
			&lt;exclusions&gt;
				&lt;exclusion&gt;
					&lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;
					&lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;
				&lt;/exclusion&gt;
			&lt;/exclusions&gt;
		&lt;/dependency&gt;
	&lt;/dependencies&gt;

	&lt;build&gt;
		&lt;plugins&gt;
			&lt;plugin&gt;
				&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
				&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
			&lt;/plugin&gt;
		&lt;/plugins&gt;
	&lt;/build&gt;

&lt;/project&gt;

</code></pre>
</li>
<li>
<p>编写配置文件</p>
<p>application.yml</p>
<pre><code class="language-yaml"># 指定服务的名称
dubbo:
  application:
    name: MYConsumer
  registry:
    address: zookeeper://124.70.181.124:2181?backup=124.70.181.124:2182,124.70.181.124:2183
    timeout: 10000
  # 配置服务所使用的的协议
  protocol:
    name: dubbo

</code></pre>
</li>
<li>
<p>实现远程调用</p>
<ol>
<li>
<p>创建业务层</p>
<p>DemoService接口：</p>
<pre><code class="language-java">public interface DemoService {
    public String getMsg(String str);
}
</code></pre>
<p>DemoServiceImpl:</p>
<pre><code class="language-java">@Service
public class DemoServiceImpl implements DemoService {
    @Reference
    private DemoDubboService demoDubboService;

    @Override
    public String getMsg(String str) {
        return this.demoDubboService.showMsg(str);
    }
}
</code></pre>
</li>
<li>
<p>创建Controller 层</p>
<pre><code class="language-java">@RestController
public class DemoController {
    @Autowired
    private DemoService demoService;

    @RequestMapping(&quot;/getMsg&quot;)
    public String getMsg(String str){
        return this.demoService.getMsg(str);
    }
}
</code></pre>
</li>
</ol>
</li>
<li>
<p>测试结果：</p>
<figure data-type="image" tabindex="16"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200629113307.png" alt="" loading="lazy"></figure>
</li>
</ol>
<h2 id="7-dubbo-监控与管理">7、Dubbo 监控与管理</h2>
<h3 id="71-监控平台-dubbo-monitor">7.1  监控平台: dubbo-monitor</h3>
<ol>
<li>
<p>Dubbo Monitor 简介</p>
<p>主要用来统计服务的调用次数和调用时间，服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心，监控中心则使用数据绘制图表来显示。</p>
</li>
<li>
<p>Dubbo Monitor 的使用</p>
<p>修改 Monitor 的配置文件</p>
<figure data-type="image" tabindex="17"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200629170013.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>启动Monitor</p>
<figure data-type="image" tabindex="18"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200629170125.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>Monitor 监控界面</p>
<figure data-type="image" tabindex="19"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200629170143.png" alt="" loading="lazy"></figure>
</li>
</ol>
<h3 id="72-管理控制台dubbo-admin">7.2 管理控制台：dubbo-admin</h3>
<ol>
<li>
<p>Dubbo-Admin 简介</p>
<p>主要包含：路由规则、动态配置、服务降级、访问控制、权重调整、负载均衡等管理功能。</p>
</li>
<li>
<p>Dubbo Admin 的使用</p>
<figure data-type="image" tabindex="20"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200629170229.png" alt="" loading="lazy"></figure>
</li>
</ol>
<figure data-type="image" tabindex="21"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200629170237.png" alt="" loading="lazy"></figure>
<ol start="3">
<li>
<p>启动Admin</p>
<figure data-type="image" tabindex="22"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200629170253.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>Admin 管理界面</p>
<figure data-type="image" tabindex="23"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200629170311.png" alt="" loading="lazy"></figure>
</li>
</ol>
<h2 id="8-dubbo-中服务的负载均衡">8、Dubbo 中服务的负载均衡</h2>
<h3 id="81-什么是服务集群">8.1 什么是服务集群</h3>
<p>一个服务，部署多次，形成的整体称为服务集群。</p>
<ol>
<li>
<p>服务集群优点:</p>
<p>避免出现单点故障：如果集群中有某个服务宕机，其他服务可继续运行。</p>
<p>提高效率：在集群模式下有多个服务处理业务，相比非集群模式下可分担单个服务的压力，提高服务效率。</p>
</li>
<li>
<p>集群模式</p>
<ol>
<li>
<p>真实集群<br>
真实集群是指在集群中，每一个节点在一个独立的物理机中运行，当某个物理机出现设备故障并不会影响其他节点的运行。建议在生产环境中使用。</p>
<p>优点：单个硬件出现故障并不会影响集群中其他节点的运行。</p>
<p>缺点：加大硬件成本的开销。</p>
</li>
<li>
<p>伪集群<br>
集群中所有的服务都部署到同一台设备上，通过不同端口区分不同个体。当设备出现问题会导致整个集群不可用。学习阶段可以使用，但不建议在生产环境中使用。</p>
<p>优点：可节省硬件成本开销。</p>
<p>缺点：硬件出现故障会影响正个集群的使用。</p>
</li>
</ol>
</li>
</ol>
<h3 id="82-什么是负载均衡">8.2  什么是负载均衡</h3>
<p>​	负载均衡（Load Balance），是指将负载（工作任务，访问请求）进行平衡、分摊到多个操作单元（服务器，组件）上进行执行。</p>
<h3 id="83-负载均衡解决方案分类及特征">8.3  负载均衡解决方案分类及特征</h3>
<h4 id="831-集中式负载均衡">8.3.1 集中式负载均衡</h4>
<p>即在客户端和服务端之间使用独立的负载均衡设施(可以是硬件，如 F5, 也可以是软件，如 nginx), 由该设施负责把访问请求通过某种策略转发至服务端。</p>
<h5 id="8311-常见的集中式负载均衡方式">8.3.1.1 常见的集中式负载均衡方式</h5>
<ol>
<li>
<p>DNS 轮询<br>
大多域名注册商都支持 DNS 轮询，DNS 服务器将解析请求按照配置顺序，逐一分配到不同的 IP 上，这样就完成了简单的负载均衡。</p>
</li>
<li>
<p>反向代理负载均衡</p>
</li>
</ol>
<figure data-type="image" tabindex="24"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200629170724.png" alt="" loading="lazy"></figure>
<p>使用代理服务器，可以将请求转发给内部的服务器。Nginx 是比较常见的服务反向代理技术。在 Nginx 中是支持对代理的服务的负载均衡处理的。</p>
<ol start="3">
<li>基于硬件的负载均衡</li>
</ol>
<figure data-type="image" tabindex="25"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200629170748.png" alt="" loading="lazy"></figure>
<p>硬件负载均衡解决方案是直接在服务器和外部网络间安装负载均衡设备，这种设备我们通常称之为负载均衡器，由于专门的设备完成专门的任务，独立于操作系统，整体性能得到大量提高，加上多样化的负载均衡策略，智能化的流量管理，可达到最佳的负载均衡需求。</p>
<p>常见的主流产品：<br>
F5 BIG-IP 负载均衡器（LTM）</p>
<figure data-type="image" tabindex="26"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200629170827.png" alt="" loading="lazy"></figure>
<p>思科 IOS 路由器</p>
<figure data-type="image" tabindex="27"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200629170841.png" alt="" loading="lazy"></figure>
<p>Radware 的 AppDirector 系列</p>
<figure data-type="image" tabindex="28"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200629170850.png" alt="" loading="lazy"></figure>
<h4 id="832-进程内负载均衡">8.3.2 进程内负载均衡</h4>
<p>​		将负载均衡逻辑集成到服务组件中，服务组件从服务注册中心获知有哪些地址可用，然后根据指定的负载均衡策略选择出一个合适的服务来调用。</p>
<figure data-type="image" tabindex="29"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200629170931.png" alt="" loading="lazy"></figure>
<h3 id="84-dubbo-的内置负载均衡策略">8.4  Dubbo 的内置负载均衡策略</h3>
<h4 id="841-random">8.4.1 Random</h4>
<p>随机访问集群中节点。访问概率和权重有关。是 Dubbo 的默认负载均衡策略。<br>
权重（weight）：占有比例。集群中每个项目部署的服务器的性能可能是不同，性能好的服务器权重应该高一些。</p>
<h4 id="842-roundrobin">8.4.2 RoundRobin</h4>
<p>轮询。访问频率和权重有关。</p>
<h4 id="843-leastactive">8.4.3 LeastActive</h4>
<p>最少活跃调用数，相同活跃数的随机。</p>
<p>如果某个机器性能越差，那么接收的请求越少，越不活跃，此时就会给不活跃的性能差的机器分配更少的请求。</p>
<h4 id="844-consistenthash">8.4.4 ConsistentHash</h4>
<p>一致性 Hash 算法，相同参数的请求一定分发到同一个 Provider 如果需要某一类请求都到一个节点，那么可以使用一致性 Hash 策略。</p>
<h3 id="85-dubbo-负载均衡的使用">8.5 Dubbo 负载均衡的使用</h3>
<p>​		Dubbo 的负载均衡可以在 Consumer 或者 Provider 中通过配置文件或者注解来配置。</p>
<h4 id="851在consumer-中配置负载均衡">8.5.1在Consumer 中配置负载均衡</h4>
<p>将 Provider 启动三次，在启动时注意修改 dubbo.protocol.port 的值。</p>
<h5 id="8511-启动provider-集群">8.5.1.1 启动Provider 集群</h5>
<ol>
<li>
<p>通过创建多个启动类启动<br>
可以为 Provider 创建多个启动类来启动，通过不同的启动类来启动集群中不同的节点。</p>
</li>
<li>
<p>通过一个启动类启动多次<br>
打开配置启动项</p>
<figure data-type="image" tabindex="30"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200629171351.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="31"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200629171413.png" alt="" loading="lazy"></figure>
<p>选择需要多次运行的启动类，将 Allow parallel run 选中，开启允许并行运行。</p>
</li>
</ol>
<h5 id="8512-通过注解配置负载均衡">8.5.1.2 通过注解配置负载均衡</h5>
<p>​		在 Dubbo 中，如果没有指定负载均衡策略，那么 Dubbo 默认的使用随机策略调用Provider。</p>
<ol>
<li>
<p>指定负载均衡策略<br>
修改@Refrence 注解添加 loadbalance 属性指定负载均衡策略。</p>
<pre><code class="language-java">@Reference(loadbalance =&quot;负载均衡策略&quot;)
</code></pre>
</li>
<li>
<p>随机策略配置权重<br>
随机获取一个[0, totalWeight)之间的数， offset = offset - weight,如果 offset 小于 0，则选中，很明显 weight 大的更容易让 offset 的值小于 0。<br>
举个例子 有 4 权重分别为（1，2， 3， 4）,totalWeight = 10, 假如 offset = 6, 6 - 1 = 5,5 大于 0，继续 5 - 2 = 3 大于 0，3 - 3 = 0， 0 - 4 小于 0 ，所以选择权重为 4 的 invoker, 这里可以发现只要 offset &gt;= 6 则选择权重为 4 的 invoker, 正好是 40%。</p>
</li>
<li>
<p>通过Provider 的@Service 注解配置权重</p>
<pre><code class="language-java">@Service(weight = 权重数)
</code></pre>
</li>
<li>
<p>配置轮询策略<br>
所谓轮询是指将请求轮流分配给每台服务器。举个例子，我们有三台服务器 A、B、C。我们将第一个请求分配给服务器 A，第二个请求分配给服务器 B，第三个请求分配给服务器 C，第四个请求再次分配给服务器 A。这个过程就叫做轮询。</p>
<pre><code class="language-java">@Reference(loadbalance = &quot;roundrobin&quot;)
</code></pre>
</li>
<li>
<p>轮询策略加权<br>
如果我们将等量的请求分配给性能较差的服务器，这显然是不合理的。因此，这个时候我们需要对轮询过程进行加权，以调控每台服务器的负载。经过加权后，每台服务器能够得到的请求数比例，接近或等于他们的权重比。</p>
<pre><code class="language-java">@Service(weight = 权重数)
</code></pre>
</li>
</ol>
<h5 id="8513-通过配置文件配置配置负载均衡">8.5.1.3 通过配置文件配置配置负载均衡</h5>
<p>​	在 SpringBoot 的配置文件中可以配置全局的负载均衡。Consumer 中所有调用 Provider集群的业务层都会使用该负载均衡策略。</p>
<p>​	与注解配置方式区别：</p>
<p>​	注解配置方式：局部，只针对当前业务层生效。</p>
<p>​	配置文件方式：全局，对所有业务层生效。</p>
<p>application.yml:</p>
<pre><code class="language-yaml">dubbo:
	consumer:
		loadbalance: random
</code></pre>
<h4 id="852-在provider-中配置负载均衡">8.5.2 在Provider 中配置负载均衡</h4>
<ol>
<li>在Dubbo 的@Service 注解中配置负载均衡以及权重</li>
</ol>
<pre><code class="language-java">@Service(loadbalance = &quot;roundrobin&quot;,weight = 3)
</code></pre>
<ol start="2">
<li>通过配置文件配置负载均衡</li>
</ol>
<pre><code class="language-yaml">dubbo:
	provider:
		loadbalance: aoundrobin
</code></pre>
<h2 id="9-项目打包">9、项目打包</h2>
<h3 id="91-基于springboot-整合dubbo-的打包方式">9.1 基于SpringBoot 整合Dubbo 的打包方式</h3>
<p>​	通过 SpringBoot 打包插件打包项目</p>
<pre><code class="language-xml">&lt;plugin&gt;
	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
	&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
&lt;/plugin&gt;
</code></pre>
<h3 id="92-基于assembly-插件打包">9.2 基于Assembly 插件打包</h3>
<ol>
<li>
<p>Assembly 插件<br>
Assembly 是 Mave 的打包插件，他的作用是可以帮助我们对 <strong>jar</strong> 项目做打包处理。在 Spring整合 dubbo 的项目中，需要使用 Assembly 打包插件来对项目做打包处理。</p>
</li>
<li>
<p>使用步骤</p>
<ol>
<li>需要在项目根下创建一个目录，名称为 assembly</li>
<li>将示例中 bin,conf 目录拷贝到 assembly 的根目录中</li>
<li>删除 conf 目录中 dubbo.properties 配置文件中的内容</li>
<li>修改项目的 POM 文件添加 assembly 的打包插件</li>
<li>在 assembly 目录下添加 assembly.xml 配置文件</li>
<li>运行打包插件，对项目进行打包处理。可以使用 maven 的 install 命令，也可以使用插件的命令</li>
<li>修改 start.sh 或 start.bat 中配置信息，将启动类修改为当前 dubbo 版本的启动类</li>
</ol>
<pre><code class="language-sh">nohup java $JAVA_OPTS $JAVA_MEM_OPTS $JAVA_DEBUG_OPTS $JAVA_JMX_OPTS-classpath $CONF_DIR:$LIB_JARS org.apache.dubbo.container.Main &gt;$STDOUT_FILE 2&gt;&amp;1 &amp;
</code></pre>
</li>
</ol>
<h2 id="10-dubbo-实战案例">10、Dubbo 实战案例</h2>
<figure data-type="image" tabindex="32"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200630145113.png" alt="" loading="lazy"></figure>
<h3 id="101-案例介绍">10.1 案例介绍</h3>
<ol>
<li>
<p>需求<br>
完成对用户表的 CRUD 操作。</p>
</li>
<li>
<p>架构方式<br>
使用分布式架构方式。</p>
</li>
<li>
<p>技术选型<br>
Maven、Spring Boot、Thymeleaf、Zookeeper、Dubbo、MySql</p>
</li>
<li>
<p>项目结构设计</p>
</li>
</ol>
<figure data-type="image" tabindex="33"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200629172708.png" alt="" loading="lazy"></figure>
<h3 id="102-创建表">10.2 创建表</h3>
<pre><code class="language-mysql">CREATE TABLE `users` (
`userid` int(11) NOT NULL AUTO_INCREMENT,
`username` varchar(30) DEFAULT NULL,
`userage` int(11) DEFAULT NULL,
PRIMARY KEY (`userid`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;
</code></pre>
<h3 id="103-创建项目">10.3 创建项目</h3>
<h4 id="1031-创建dubbo_parent-父项目">10.3.1 创建dubbo_parent 父项目</h4>
<ol>
<li>
<p>创建项目</p>
<figure data-type="image" tabindex="34"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200629215828.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>修改POM 文件</p>
</li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.cy&lt;/groupId&gt;
    &lt;artifactId&gt;dubbo_parent&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;modules&gt;
        &lt;module&gt;user_api&lt;/module&gt;
        &lt;!--同时添加consumer为子模块，因为springboot默认会继承springboot启动器--&gt;
        &lt;module&gt;user_consumer&lt;/module&gt;
        &lt;module&gt;user_provider&lt;/module&gt;
    &lt;/modules&gt;
    &lt;!--pom 项目里没有java代码，也不执行任何代码，只是为了聚合工程或传递依赖用的。--&gt;
    &lt;packaging&gt;pom&lt;/packaging&gt;

    &lt;!--parent对所有非springboot依赖做集中管理--&gt;
    &lt;properties&gt;
        &lt;dubbo.spring.starter.version&gt;2.7.6&lt;/dubbo.spring.starter.version&gt;
        &lt;dubbo.registry.zookeeper.version&gt;2.7.6&lt;/dubbo.registry.zookeeper.version&gt;
        &lt;mybatis.spring.starter.version&gt;2.1.2&lt;/mybatis.spring.starter.version&gt;
        &lt;mysql.connector.version&gt;5.1.38&lt;/mysql.connector.version&gt;
        &lt;mybatis-generator.version&gt;1.3.5&lt;/mybatis-generator.version&gt;
    &lt;/properties&gt;
    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;!--Dubbo Starter Dependency Version:2.7.6--&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
                &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;
                &lt;version&gt;${dubbo.spring.starter.version}&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;!--Zookeeper Registry Dependency Version:2.7.6--&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
                &lt;artifactId&gt;dubbo-registry-zookeeper&lt;/artifactId&gt;
                &lt;version&gt;${dubbo.registry.zookeeper.version}&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;!--Mybatis Starter Dependency Version:2.1.2--&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
                &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
                &lt;version&gt;${mybatis.spring.starter.version}&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;!--MySQL Driver Dependency Version:5.1.38--&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;mysql&lt;/groupId&gt;
                &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
                &lt;version&gt;${mysql.connector.version}&lt;/version&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;
    &lt;build&gt;
        &lt;pluginManagement&gt;
            &lt;plugins&gt;
                &lt;!--MyBatis Generator Plugin--&gt;
                &lt;plugin&gt;
                    &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;
                    &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;
                    &lt;version&gt;${mybatis-generator.version}&lt;/version&gt;
                &lt;/plugin&gt;
            &lt;/plugins&gt;
        &lt;/pluginManagement&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<h4 id="1032-创建user_api">10.3.2 创建user_api</h4>
<ol>
<li>
<p>创建项目</p>
<figure data-type="image" tabindex="35"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200629220530.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>修改POM文件</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;dubbo_parent&lt;/artifactId&gt;
        &lt;groupId&gt;com.cy&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;user_api&lt;/artifactId&gt;

    &lt;dependencies&gt;
        &lt;!--Zookeeper Registry Dependency--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
            &lt;artifactId&gt;dubbo-registry-zookeeper&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--Dubbo Starter Dependency--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
            &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
</li>
</ol>
<h4 id="1033-创建user_consumer">10.3.3 创建user_consumer</h4>
<ol>
<li>
<p>创建项目</p>
<figure data-type="image" tabindex="36"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200629221041.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>修改POM 文件</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.3.1.RELEASE&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.cy&lt;/groupId&gt;
    &lt;artifactId&gt;user_consumer&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;user_consumer&lt;/name&gt;
    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;

    &lt;dependencyManagement&gt;
        &lt;!--Dependency dubbo_parent--&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.cy&lt;/groupId&gt;
                &lt;artifactId&gt;dubbo_parent&lt;/artifactId&gt;
                &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;
    &lt;properties&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;!--user_api Dependency --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.cy&lt;/groupId&gt;
            &lt;artifactId&gt;user_api&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--Spring Boot Starter Web Dependency --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--Spring Boot Starter Thymeleaf Dependency --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--Spring Boot Starter Test Dependency --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;
                    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

&lt;/project&gt;

</code></pre>
</li>
<li>
<p>修改配置文件</p>
<p>application.yml:</p>
<pre><code class="language-yaml"># 指定服务的名称
dubbo:
  application:
    name: MYConsumer
  registry:
    address: zookeeper://124.70.181.124:2181?backup=124.70.181.124:2182,124.70.181.124:2183
    timeout: 10000
  # 配置服务所使用的的协议
  protocol:
    name: dubbo
</code></pre>
</li>
</ol>
<h4 id="1034-创建user_provider-项目及模块">10.3.4 创建user_provider 项目及模块</h4>
<ol>
<li>
<p>创建项目及模块</p>
<figure data-type="image" tabindex="37"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200630010949.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>修改项目模块的POM 文件</p>
<ol>
<li>修改Mapper 项目的POM 文件</li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;user_provider&lt;/artifactId&gt;
        &lt;groupId&gt;com.cy&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;mapper&lt;/artifactId&gt;

    &lt;dependencies&gt;
        &lt;!--POJO Dependency--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.cy&lt;/groupId&gt;
            &lt;artifactId&gt;pojo&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--MyBatis Starter Dependency--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--MySQL Driver Dependency--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;!--MyBatis Generator Plugin--&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;
                &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;
                &lt;dependencies&gt;
                    &lt;dependency&gt;
                        &lt;groupId&gt;mysql&lt;/groupId&gt;
                        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
                        &lt;version&gt;5.1.38&lt;/version&gt;
                    &lt;/dependency&gt;
                &lt;/dependencies&gt;
                &lt;!--指定配置文件的路径--&gt;
                &lt;configuration&gt;

                    &lt;configurationFile&gt;${project.basedir}/src/main/resources/generatorConfig.xml&lt;/configurationFile&gt;
                    &lt;verbose&gt;true&lt;/verbose&gt;
                    &lt;overwrite&gt;true&lt;/overwrite&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
        &lt;resources&gt;
            &lt;!--Configure Resource Copy Path--&gt;
            &lt;resource&gt;
                &lt;directory&gt;src/main/java&lt;/directory&gt;
                &lt;includes&gt;
                    &lt;include&gt;**/*.xml&lt;/include&gt;
                &lt;/includes&gt;
            &lt;/resource&gt;
        &lt;/resources&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<ol start="2">
<li>
<p>修改Provider 项目的POM 文件</p>
<p>继承 Spring Boot 父工程</p>
<p>继承 dubbo_parent 工程</p>
<p>添加其他依赖</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.3.1.RELEASE&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.cy&lt;/groupId&gt;
    &lt;artifactId&gt;provider&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPASHOT&lt;/version&gt;

    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.cy&lt;/groupId&gt;
                &lt;artifactId&gt;user_provider&lt;/artifactId&gt;
                &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;
    &lt;properties&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;!--Mapper Dependency--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.cy&lt;/groupId&gt;
            &lt;artifactId&gt;mapper&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--user_api Dependency--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.cy&lt;/groupId&gt;
            &lt;artifactId&gt;user_api&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--Spring Boot Starter Dependency--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--Spring Boot Test Starter Dependency--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;
                    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
</li>
<li>
<p>配置Provider</p>
<p>因为是maven项目修改成springboot项目的，所以要手动添加application.yml和启动类</p>
<ol>
<li>添加application.yml 配置文件</li>
</ol>
<pre><code class="language-yaml">#配置数据源
spring:
  datasource:
    driver-class-name: com.mysql.jdbc.Driver
    url: jdbc:mysql://localhost:3306/test03?serverTimezone=UTC
    username: root
    password: root
#Mybatis 配置
mybatis:
  type-aliases-package: com.bjsxt.pojo
#Dubbo 配置
dubbo:
  application:
    name: MYProvider
  registry: address:zookeeper://124.70.181.124:2181?backup=124.70.181.124:2182,124.70.181.124:2183
    timeout: 10000
#配置服务协议及端口
  protocol:
    name: dubbo
    port: 20880
#配置 Dubbo 扫描包
  scan:
    base-packages: com.cy.provider.service.impl
</code></pre>
<ol start="2">
<li>需改启动类</li>
</ol>
<pre><code class="language-java">@SpringBootApplication
@MapperScan(&quot;com.cy.mapper&quot;) //指定扫描Mapper的包
public class ProviderApplication {
    public static void main(String[] args) {
        SpringApplication.run(ApplicationProvider.class,args);
    }
}
</code></pre>
</li>
</ol>
</li>
</ol>
<h4 id="1035-通过mybatis-generator-插件生成mapper-与pojo">10.3.5 通过Mybatis Generator 插件生成Mapper 与POJO</h4>
<ol>
<li>
<p>添加generatorConfig.xml 配置文件</p>
<figure data-type="image" tabindex="38"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200630012843.png" alt="" loading="lazy"></figure>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE generatorConfiguration
  PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;
  &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;

&lt;generatorConfiguration&gt;
	&lt;context id=&quot;testTables&quot; targetRuntime=&quot;MyBatis3&quot;&gt;
		&lt;!-- 生成实体类实现序列化--&gt;
		&lt;plugin type=&quot;org.mybatis.generator.plugins.SerializablePlugin&quot;  /&gt;
		&lt;!-- 实体类中包含toString() --&gt;
		&lt;plugin type=&quot;org.mybatis.generator.plugins.ToStringPlugin&quot; &gt;&lt;/plugin&gt;
		&lt;commentGenerator&gt;
			&lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;
			&lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt;
		&lt;/commentGenerator&gt;
		&lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt;
		&lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;
			connectionURL=&quot;jdbc:mysql://localhost:3306/test03&quot; userId=&quot;root&quot;
			password=&quot;root&quot;&gt;
		&lt;/jdbcConnection&gt;
		&lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和 
			NUMERIC 类型解析为java.math.BigDecimal --&gt;
		&lt;javaTypeResolver&gt;
			&lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt;
		&lt;/javaTypeResolver&gt;

		&lt;!-- targetProject:生成PO类的位置 --&gt;
		&lt;javaModelGenerator targetPackage=&quot;com.cy.pojo&quot;
			targetProject=&quot;.\src\main\java&quot;&gt;
			&lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;
			&lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;
			&lt;!-- 从数据库返回的值被清理前后的空格 --&gt;
			&lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt;
		&lt;/javaModelGenerator&gt;
        &lt;!-- targetProject:mapper映射文件生成的位置 --&gt;
		&lt;sqlMapGenerator targetPackage=&quot;com.cy.mapper&quot;
			targetProject=&quot;.\src\main\java&quot;&gt;
			&lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;
			&lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;
		&lt;/sqlMapGenerator&gt;
		&lt;!-- targetPackage：mapper接口生成的位置 --&gt;
		&lt;javaClientGenerator type=&quot;XMLMAPPER&quot;
			targetPackage=&quot;com.cy.mapper&quot;
			targetProject=&quot;.\src\main\java&quot;&gt;
			&lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;
			&lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;
		&lt;/javaClientGenerator&gt;
		&lt;!-- 指定数据库表 --&gt;
		&lt;table schema=&quot;&quot; tableName=&quot;users&quot;&gt;&lt;/table&gt;

	&lt;/context&gt;
&lt;/generatorConfiguration&gt;

</code></pre>
</li>
<li>
<p>运行Mybatis Generator 插件</p>
</li>
</ol>
<figure data-type="image" tabindex="39"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200630012929.png" alt="" loading="lazy"></figure>
<ol start="3">
<li>将实体类拷贝到pojo 项目中</li>
</ol>
<figure data-type="image" tabindex="40"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200630012953.png" alt="" loading="lazy"></figure>
<h3 id="104-修改user_api-的pom-文件添加pojo-依赖">10.4 修改user_api 的POM 文件添加pojo 依赖</h3>
<ol>
<li>
<p>在user_api中添加pojo 依赖</p>
<pre><code class="language-xml">        &lt;!--pojo Dependency--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.cy&lt;/groupId&gt;
            &lt;artifactId&gt;pojo&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>排除冲突依赖</p>
<figure data-type="image" tabindex="41"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200630013121.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="42"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200630013248.png" alt="" loading="lazy"></figure>
</li>
</ol>
<pre><code class="language-xml">        &lt;!--Zookeeper Registry Dependency--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
            &lt;artifactId&gt;dubbo-registry-zookeeper&lt;/artifactId&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
                    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
</code></pre>
<h3 id="105-实现业务">10.5 实现业务</h3>
<h4 id="1051-添加用户业务">10.5.1 添加用户业务</h4>
<ol>
<li>
<p>创建添加用户业务接口</p>
<ol>
<li>在user_api 项目中创建添加用户接口</li>
</ol>
<pre><code class="language-java">public interface AddUserService {
	void addUser(Users users);
}
</code></pre>
<ol start="2">
<li>在provider 中实现添加用户业务接口</li>
</ol>
<pre><code class="language-java">/**
 * 添加用户业务
 */
@Service
public class AddUserServiceImpl implements AddUserService {
    @Autowired
    private UsersMapper usersMapper;
    @Override
    public void addUser(Users users) {
        this.usersMapper.insert(users);
    }
}
</code></pre>
</li>
<li>
<p>在Consumer 中调用添加用户业务接口</p>
<ol>
<li>创建首页</li>
</ol>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;首页&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;a href=&quot;/addUser&quot;&gt;添加用户&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;/user/getUser&quot;&gt;查询用户&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="2">
<li>创建页面跳转Controller</li>
</ol>
<pre><code class="language-java">/**
 * 页面跳转controller
 */
@Controller
public class PageController {
    /**
     * 页面跳转方法
     */
    @RequestMapping(&quot;/{page}&quot;)
    public String showPage(@PathVariable String page){
        return page;
    }
}
</code></pre>
<ol start="3">
<li>创建添加用户页面</li>
</ol>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;添加用户&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form action=&quot;/user/addUser&quot; method=&quot;post&quot;&gt;
    用户姓名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br/&gt;
    用户性别：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br/&gt;
    &lt;input type=&quot;submit&quot; value=&quot;ok&quot;&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="5">
<li>创建Consumer 业务层</li>
</ol>
<p>UserService接口：</p>
<pre><code class="language-java">public interface UserService {
    void addUser(Users users);
}
</code></pre>
<p>UserServiceImpl:</p>
<pre><code class="language-java">/**
 * 用户操作业务层
 */
@Service
public class UserServiceImpl implements UserService {
    @Reference
    private AddUserService addUserService;

    @Override
    public void addUser(Users users) {
        this.addUserService.addUser(users);
    }
}
</code></pre>
<ol start="6">
<li>创建添加用户Controller</li>
</ol>
<pre><code class="language-java">/**
 * 处理用户操作控制器
 */
@Controller
@RequestMapping(&quot;/user&quot;)
public class UserController {

    @Autowired
    private UserService userService;

    /**
     * 处理添加用户请求
     */
    @PostMapping(&quot;/addUser&quot;)
    public String addUser(Users users){
        this.userService.addUser(users);
        return &quot;redirect:/ok&quot;;
    }
}

</code></pre>
<ol start="7">
<li>创建成功页面</li>
</ol>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;成功页面&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    操作成功，请&lt;a href=&quot;/index&quot;&gt;返回&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
</li>
</ol>
<h4 id="1052-查询用户业务">10.5.2 查询用户业务</h4>
<ol>
<li>
<p>创建查询用户业务接口</p>
<ol>
<li>在user_api 项目中添加查询用户业务接口</li>
</ol>
<pre><code class="language-java">public interface FindUserService {
    List&lt;Users&gt; findUserAll();
}
</code></pre>
<ol start="2">
<li>在provider 中实现查询用户业务接口</li>
</ol>
<pre><code class="language-java">/**
 * 查询所有用户业务层
 */
@Service
public class FindUserServiceImpl implements FindUserService {
    @Autowired
    private UsersMapper usersMapper;

    /**
     * 查询全部用户
     * @return
     */
    @Override
    public List&lt;Users&gt; findUserAll() {
        UsersExample example = new UsersExample();
        return this.usersMapper.selectByExample(example);
    }
}
</code></pre>
</li>
<li>
<p>在Consumer 中调用查询用户业务</p>
<ol>
<li>修改Consumer 业务层添加查询用户业务</li>
</ol>
<p>UserService接口:</p>
<pre><code class="language-java">public interface UserService {
    void addUser(Users users);
    List&lt;Users&gt; getUsersAll();
}
</code></pre>
<p>UserServiceImpl：</p>
<pre><code class="language-java">@Service
public class UserServiceImpl implements UserService {
    @Reference
    private AddUserService addUserService;

    @Reference
    private FindUserService findUserService;

    @Override
    public void addUser(Users users) {
        this.addUserService.addUser(users);
    }

    /**
     * 查询所有用户
     * @return
     */
    @Override
    public List&lt;Users&gt; getUsersAll() {
        return this.findUserService.findUserAll();
    }

}
</code></pre>
<ol start="2">
<li>修改Consumer 添加处理查询用户请求</li>
</ol>
<pre><code class="language-java">/**
 * 处理用户操作控制器
 */
@Controller
@RequestMapping(&quot;/user&quot;)
public class UsersController {
    @Autowired
    private UserService userService;
    /**
     * 处理添加用户请求
     */
    @RequestMapping(&quot;/addUser&quot;)
    public String addUser(Users users){
        this.userService.addUser(users);
        return &quot;redirect:/ok&quot;;
    }

    /**
     * 处理查询用户请求
     */
    @RequestMapping(&quot;/getUser&quot;)
    public String getUser(Model model){
        List&lt;Users&gt; list = this.userService.getUsersAll();
        model.addAttribute(&quot;list&quot;,list);
        return &quot;showUser&quot;;
    }

}
</code></pre>
<ol start="3">
<li>创建showUser 页面</li>
</ol>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;显示用户&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;table border=&quot;1&quot; align=&quot;center&quot;&gt;
        &lt;tr&gt;
            &lt;th&gt;用户ID&lt;/th&gt;
            &lt;th&gt;用户姓名&lt;/th&gt;
            &lt;th&gt;用户年龄&lt;/th&gt;
            &lt;th&gt;操作&lt;/th&gt;
        &lt;/tr&gt;
        &lt;tr th:each=&quot;user:${list}&quot;&gt;
            &lt;td th:text=&quot;${user.userid}&quot;&gt;&lt;/td&gt;
            &lt;td th:text=&quot;${user.username}&quot;&gt;&lt;/td&gt;
            &lt;td th:text=&quot;${user.userage}&quot;&gt;&lt;/td&gt;
            &lt;td&gt;
                &lt;a th:href=&quot;@{/user/preUpdateUser(userid=${user.userid})}&quot;&gt;修改用户&lt;/a&gt;
                &lt;a th:href=&quot;@{/user/deleteUser(userid=${user.userid})}&quot;&gt;删除用户&lt;/a&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
&lt;/body&gt;
</code></pre>
</li>
</ol>
<h4 id="1053-更新用户业务">10.5.3 更新用户业务</h4>
<ol>
<li>
<p>创建更新用户业务接口</p>
<ol>
<li>在user_api 项目中添加更新用户业务接口</li>
</ol>
<pre><code class="language-java">public interface UpdateUserService {Users preUpdateUsers(Integer userid);
	void updateUsers(Users users);
}
</code></pre>
<ol start="2">
<li>在provider 中实现更新用户业务接口</li>
</ol>
<pre><code class="language-java">/**
 * 更新用户业务
 */
@Service
public class UpdateUserServiceImpl implements UpdateUserService {

    @Autowired
    private UsersMapper usersMapper;


    /**
     * 预更新用户查询
     * @param userid
     * @return
     */
    @Override
    public Users preUpdateUsers(Integer userid) {
        return this.usersMapper.selectByPrimaryKey(userid);
    }

    /**
     * 更新用户
     * @param users
     */
    @Override
    public void updateUsers(Users users) {
        this.usersMapper.updateByPrimaryKey(users);
    }
}

</code></pre>
</li>
<li>
<p>在Consumer 中调用更新用户业务</p>
<ol>
<li>修改Consumer 业务层添加预更新查询用户业务</li>
</ol>
<p>UserService接口:</p>
<pre><code class="language-java">public interface UserService {
    void addUser(Users users);
    List&lt;Users&gt; getUsersAll();
    Users preUpdateUsers(Integer userid);
}
</code></pre>
<p>UserServiceImpl:</p>
<pre><code class="language-java">/**
 * 用户操作业务层
 */
@Service
public class UserServiceImpl implements UserService {
    @Reference
    private AddUserService addUserService;

    @Reference
    private FindUserService findUserService;

    @Reference
    private UpdateUserService updateUserService;

    @Override
    public void addUser(Users users) {
        this.addUserService.addUser(users);
    }

    /**
     * 查询所有用户
     * @return
     */
    @Override
    public List&lt;Users&gt; getUsersAll() {
        return this.findUserService.findUserAll();
    }

    /**
     * 根据用户ID查询用户
     * @param userid
     * @return
     */
    @Override
    public Users preUpdateUsers(Integer userid) {
        return this.updateUserService.preUpdateUsers(userid);
    }

}

</code></pre>
<ol start="2">
<li>修改Consumer 添加处理查询用户请求</li>
</ol>
<pre><code class="language-java">/**
 * 处理用户操作控制器
 */
@Controller
@RequestMapping(&quot;/user&quot;)
public class UsersController {
    @Autowired
    private UserService userService;
    /**
     * 处理添加用户请求
     */
    @RequestMapping(&quot;/addUser&quot;)
    public String addUser(Users users){
        this.userService.addUser(users);
        return &quot;redirect:/ok&quot;;
    }

    /**
     * 处理查询用户请求
     */
    @RequestMapping(&quot;/getUser&quot;)
    public String getUser(Model model){
        List&lt;Users&gt; list = this.userService.getUsersAll();
        model.addAttribute(&quot;list&quot;,list);
        return &quot;showUser&quot;;
    }

    /**
     * 处理预更新查询请求
     */
    @RequestMapping(&quot;/preUpdateUser&quot;)
    public String preUpdateUser(Integer userid,Model model){
        Users users = this.userService.preUpdateUsers(userid);
        model.addAttribute(&quot;users&quot;,users);
        return &quot;updateUsers&quot;;
    }
}

</code></pre>
<ol start="3">
<li>创建更新用户页面</li>
</ol>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;更新用户&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form action=&quot;/user/updateUser&quot; method=&quot;post&quot;&gt;
        &lt;input type=&quot;hidden&quot; name=&quot;userid&quot; th:value=&quot;${users.userid}&quot;/&gt;&lt;br/&gt;
       用户姓名： &lt;input type=&quot;text&quot; name=&quot;username&quot; th:value=&quot;${users.username}&quot;/&gt;&lt;br/&gt;
        用户年龄：&lt;input type=&quot;text&quot; name=&quot;userage&quot; th:value=&quot;${users.userage}&quot;/&gt;&lt;br/&gt;
        &lt;input type=&quot;submit&quot; value=&quot;Update&quot;/&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="4">
<li>修改Consumer 业务层添加更新用户业务</li>
</ol>
<p>UserService接口：</p>
<pre><code class="language-java">public interface UserService {
    void addUser(Users users);
    List&lt;Users&gt; getUsersAll();
    Users preUpdateUsers(Integer userid);
    void updateUsers(Users users);
}
</code></pre>
<p>UserServiceImpl：</p>
<pre><code class="language-java">/**
 * 用户操作业务层
 */
@Service
public class UserServiceImpl implements UserService {
    @Reference
    private AddUserService addUserService;

    @Reference
    private FindUserService findUserService;

    @Reference
    private UpdateUserService updateUserService;

    @Override
    public void addUser(Users users) {
        this.addUserService.addUser(users);
    }

    /**
     * 查询所有用户
     * @return
     */
    @Override
    public List&lt;Users&gt; getUsersAll() {
        return this.findUserService.findUserAll();
    }

    /**
     * 根据用户ID查询用户
     * @param userid
     * @return
     */
    @Override
    public Users preUpdateUsers(Integer userid) {
        return this.updateUserService.preUpdateUsers(userid);
    }

    /**
     * 更新用户
     * @param users
     */
    @Override
    public void updateUsers(Users users) {
        this.updateUserService.updateUsers(users);
    }
}
</code></pre>
<ol start="5">
<li>修改Consumer 添加处理更新用户请求</li>
</ol>
<pre><code class="language-java">/**
 * 处理用户操作控制器
 */
@Controller
@RequestMapping(&quot;/user&quot;)
public class UsersController {
    @Autowired
    private UserService userService;
    /**
     * 处理添加用户请求
     */
    @RequestMapping(&quot;/addUser&quot;)
    public String addUser(Users users){
        this.userService.addUser(users);
        return &quot;redirect:/ok&quot;;
    }

    /**
     * 处理查询用户请求
     */
    @RequestMapping(&quot;/getUser&quot;)
    public String getUser(Model model){
        List&lt;Users&gt; list = this.userService.getUsersAll();
        model.addAttribute(&quot;list&quot;,list);
        return &quot;showUser&quot;;
    }

    /**
     * 处理预更新查询请求
     */
    @RequestMapping(&quot;/preUpdateUser&quot;)
    public String preUpdateUser(Integer userid,Model model){
        Users users = this.userService.preUpdateUsers(userid);
        model.addAttribute(&quot;users&quot;,users);
        return &quot;updateUsers&quot;;
    }

    /**
     * 处理更新用户请求
     */
    @RequestMapping(&quot;/updateUser&quot;)
    public String updateUser(Users users){
        this.userService.updateUsers(users);
        return &quot;redirect:/ok&quot;;
    }

}
</code></pre>
</li>
</ol>
<h4 id="1054-删除用户业务">10.5.4 删除用户业务</h4>
<ol>
<li>
<p>创建删除用户业务接口</p>
<ol>
<li>在user_api 项目中添加删除用户业务接口</li>
</ol>
<pre><code class="language-java">public interface DeleteUserService {
	void deleteUsersById(Integer userid);
}
</code></pre>
<ol start="2">
<li>在provider 中实现删除用户业务接口</li>
</ol>
<pre><code class="language-java">/**
 * 删除用户业务
 */
@Service
public class DeleteUserServiceImpl implements DeleteUserService {
    @Autowired
    private UsersMapper usersMapper;

    /**
     * 根据用户ID删除用户
     * @param userid
     */
    @Override
    public void deleteUsersById(Integer userid) {
        this.usersMapper.deleteByPrimaryKey(userid);
    }
}
</code></pre>
</li>
<li>
<p>在Consumer 中调用删除用户业务</p>
<ol>
<li>
<p>修改Consumer 业务层添加删除用户业务</p>
<p>UserService接口：</p>
</li>
</ol>
<pre><code class="language-java">public interface UserService {
    void addUser(Users users);
    List&lt;Users&gt; getUsersAll();
    Users preUpdateUsers(Integer userid);
    void updateUsers(Users users);
    void deleteUsersById(Integer userid);
}
</code></pre>
<p>​	UserServiceImpl：</p>
<pre><code class="language-java">/**
 * 用户操作业务层
 */
@Service
public class UserServiceImpl implements UserService {
    @Reference
    private AddUserService addUserService;

    @Reference
    private FindUserService findUserService;

    @Reference
    private UpdateUserService updateUserService;

    @Reference
    private DeleteUserService deleteUserService;

    @Override
    public void addUser(Users users) {
        this.addUserService.addUser(users);
    }

    /**
     * 查询所有用户
     * @return
     */
    @Override
    public List&lt;Users&gt; getUsersAll() {
        return this.findUserService.findUserAll();
    }

    /**
     * 根据用户ID查询用户
     * @param userid
     * @return
     */
    @Override
    public Users preUpdateUsers(Integer userid) {
        return this.updateUserService.preUpdateUsers(userid);
    }

    /**
     * 更新用户
     * @param users
     */
    @Override
    public void updateUsers(Users users) {
        this.updateUserService.updateUsers(users);
    }

    /**
     * 根据用户ID删除用户
     * @param userid
     */
    @Override
    public void deleteUsersById(Integer userid) {
        this.deleteUserService.deleteUsersById(userid);
    }
}
</code></pre>
<ol start="2">
<li>修改Consumer 添加处理删除用户请求</li>
</ol>
<pre><code class="language-java">/**
 * 处理用户操作控制器
 */
@Controller
@RequestMapping(&quot;/user&quot;)
public class UsersController {
    @Autowired
    private UserService userService;
    /**
     * 处理添加用户请求
     */
    @RequestMapping(&quot;/addUser&quot;)
    public String addUser(Users users){
        this.userService.addUser(users);
        return &quot;redirect:/ok&quot;;
    }

    /**
     * 处理查询用户请求
     */
    @RequestMapping(&quot;/getUser&quot;)
    public String getUser(Model model){
        List&lt;Users&gt; list = this.userService.getUsersAll();
        model.addAttribute(&quot;list&quot;,list);
        return &quot;showUser&quot;;
    }

    /**
     * 处理预更新查询请求
     */
    @RequestMapping(&quot;/preUpdateUser&quot;)
    public String preUpdateUser(Integer userid,Model model){
        Users users = this.userService.preUpdateUsers(userid);
        model.addAttribute(&quot;users&quot;,users);
        return &quot;updateUsers&quot;;
    }

    /**
     * 处理更新用户请求
     */
    @RequestMapping(&quot;/updateUser&quot;)
    public String updateUser(Users users){
        this.userService.updateUsers(users);
        return &quot;redirect:/ok&quot;;
    }

    /**
     * 处理删除用户请求
     */
    @RequestMapping(&quot;/deleteUser&quot;)
    public String deleteUser(Integer userid){
        this.userService.deleteUsersById(userid);
        return &quot;redirect:/ok&quot;;
    }
}
</code></pre>
</li>
</ol>
<h4 id="1055-项目部署">10.5.5 项目部署</h4>
<h5 id="10551部署环境">10.5.5.1部署环境</h5>
<p>​	安装三台 Linux 操作系统，并正确安装 JDK。例如：<br>
​	192.168.233.130：部署 Zookeeper<br>
​	192.168.233.131：部署 Provider<br>
​	192.168.233.132：部署 Consumer</p>
<h5 id="10552-部署provider">10.5.5.2 部署Provider</h5>
<ol>
<li>
<p>在配置文件中修改数据库连接地址</p>
<pre><code class="language-yaml">#配置数据源
spring:
datasource:
driver-class-name: com.mysql.jdbc.Driver
url: jdbc:mysql://192.168.1.3:3306/test03?serverTimezone=UTC
username: root
password: root
</code></pre>
</li>
<li>
<p>在Linux 系统中创建Provider 目录</p>
<p>[root@localhost local]# mkdir provider</p>
</li>
<li>
<p>项目打包</p>
<figure data-type="image" tabindex="43"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200630142002.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>上传启Provider 项目与启动脚本</p>
<figure data-type="image" tabindex="44"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200630142028.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>为启动脚本分配执行权限</p>
<p>root@localhost provider]# chmod 777 server.sh</p>
</li>
<li>
<p>启动Provider</p>
<p>[root@localhost logs]# ./server.sh start</p>
</li>
</ol>
<h5 id="10553-部署consumer">10.5.5.3 部署Consumer</h5>
<ol>
<li>
<p>在Linux 系统中创建Consumer 目录</p>
<p>[root@localhost local]# mkdir consumer</p>
</li>
<li>
<p>项目打包</p>
<figure data-type="image" tabindex="45"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200630142002.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>上传启Provider 项目与启动脚本</p>
<figure data-type="image" tabindex="46"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200630142328.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>为启动脚本分配执行权限</p>
<p>root@localhost provider]# chmod 777 server.sh</p>
</li>
<li>
<p>启动Consumer</p>
<p>[root@localhost logs]# ./server.sh start</p>
</li>
</ol>
<h5 id="10554-测试">10.5.5.4 测试</h5>
<figure data-type="image" tabindex="47"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200630142421.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Zookeeper]]></title>
        <id>https://jonchan1013.github.io/post/zookeeper/</id>
        <link href="https://jonchan1013.github.io/post/zookeeper/">
        </link>
        <updated>2020-06-23T02:45:16.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="1-zookeeper简介">1、Zookeeper简介</h2>
<p>Zookeeper 官网：http://zookeeper.apache.org/<br>
Zookeeper 是 Apache 的一个分布式服务框架，是 Apache Hadoop 的一个子项目。官方文档上这么解释 Zookeeper，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。<br>
简单来说 zookeeper=文件系统+监听通知机制。</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="1-zookeeper简介">1、Zookeeper简介</h2>
<p>Zookeeper 官网：http://zookeeper.apache.org/<br>
Zookeeper 是 Apache 的一个分布式服务框架，是 Apache Hadoop 的一个子项目。官方文档上这么解释 Zookeeper，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。<br>
简单来说 zookeeper=文件系统+监听通知机制。</p>
<!-- more -->
<h2 id="2-zookeeper存储结构">2、Zookeeper存储结构</h2>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200623131938.png" alt="" loading="lazy"></figure>
<h3 id="21-znode">2.1 Znode</h3>
<p>在 Zookeeper 中，znode 是一个跟 Unix 文件系统路径相似的节点，可以向节点存储数据或者获取数据。</p>
<p>Zookeeper 底层是一套数据结构。这个存储结构是一个树形结构，其上的每一个节点，我们称之为“znode”</p>
<p>Zookeeper 中的数据是按照“树”结构进行存储的。而且 znode 节点还分为 4 中不同的类型。</p>
<p>每一个 znode 默认能够存储 1MB 的数据（对于记录状态性质的数据来说，够了）</p>
<p>可以使用 zkCli 命令，登录到 Zookeeper 上，并通过 ls、create、delete、get、set等命令操作这些 znode 节点。</p>
<h3 id="22-znode节点类型">2.2 Znode节点类型</h3>
<ol>
<li>
<p>PERSISTENT-持久化目录节点</p>
<p>客户端与 zookeeper 断开连接后，该节点依旧存在。</p>
</li>
<li>
<p>PERSISTENT_SEQUENTIAL-持久化顺序编号目录节点</p>
</li>
</ol>
<p>客户端与 zookeeper 断开连接后，该节点依旧存在，只是 Zookeeper 给该节点名称进行顺序编号。</p>
<ol start="3">
<li>
<p>EPHEMERAL-临时目录节点</p>
<p>客户端与 zookeeper 断开连接后，该节点被删除。</p>
</li>
<li>
<p>EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点</p>
<p>客户端与 zookeeper 断开连接后，该节点被删除，只是 Zookeeper 给该节点名称进行顺序编号。</p>
</li>
</ol>
<h2 id="3-监听通知机制">3、监听通知机制</h2>
<p>​		Zookeeper 是使用观察者设计模式来设计的。当客户端注册监听它关心的目录节点时，当目录节点发生变化（数据改变、被删除、子目录节点增加删除）时，Zookeeper 会通知客户端。</p>
<h2 id="4-安装-zookeeper">4、安装 zookeeper</h2>
<p>​		官方资源包可在 zookeeper.apache.com 站点中下载。本次安装版本为：3.6.0。</p>
<h3 id="41-安装单机版">4.1 安装单机版</h3>
<ol>
<li>
<p>安装 Linux</p>
</li>
<li>
<p>安装 JDK</p>
</li>
<li>
<p>上传 Zookeeper</p>
</li>
<li>
<p>解压 Zookeeper 压缩包</p>
</li>
<li>
<p>Zookeeper 目录结构</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200623132527.png" alt="" loading="lazy"></figure>
<blockquote>
<ol>
<li>bin：放置运行脚本和工具脚本，</li>
<li>conf：zookeeper 默认读取配置的目录，里面会有默认的配置文件</li>
<li>docs：zookeeper 相关的文档</li>
<li>lib：zookeeper 核心的 jar</li>
<li>logs：zookeeper 日志</li>
</ol>
</blockquote>
</li>
<li>
<p>配置 Zookeeper</p>
<p>Zookeeper 在启动时默认的去 conf 目录下查找一个名称为 zoo.cfg 的配置文件。在 zookeeper 应用目录中有子目录 conf。其中有配置文件模板：zoo_sample.cfg<br>
cp zoo_sample.cfg zoo.cfg。zookeeper 应用中的配置文件为 conf/zoo.cfg。</p>
<p>修改配置文件 zoo.cfg - 设置数据缓存路径(这里把缓存放到Zookeeper根目录下新建的data文件夹)</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200623132606.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200623132629.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200623132718.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>启动 Zookeeper</p>
<p>默认加载配置文件：./zkServer.sh start：默认的会去 conf 目录下加载 zoo.cfg 配置文件。<br>
指定加载配置文件：./zkServer.sh start 配置文件的路径。</p>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200623132950.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200623133029.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>停止 Zookeeper</p>
<p>./zkServer.sh stop</p>
</li>
<li>
<p>查看 Zookeeper 状态<br>
./zkServer.sh status</p>
<figure data-type="image" tabindex="8"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200623134226.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>使用客户端连接单机版 Zookeeper</p>
<ol>
<li>
<p>连接方式一</p>
<p>bin/zkCli.sh<br>
默认连接地址为本机地址，默认连接端口为 2181</p>
</li>
</ol>
<figure data-type="image" tabindex="9"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200623134503.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>连接方式二</p>
<p>bin/zkCli.sh -server ip:port<br>
连接指定 IP 地址与端口</p>
</li>
</ol>
<h3 id="42-安装集群版">4.2 安装集群版</h3>
<h4 id="421-zookeeper-集群说明">4.2.1 Zookeeper 集群说明</h4>
<ol>
<li>Zookeeper 集群中的角色</li>
</ol>
<p>Zookeeper 集群中的角色主要有以下三类</p>
<figure data-type="image" tabindex="10"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200623142410.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="11"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200623142420.png" alt="" loading="lazy"></figure>
<h4 id="422-集群安装">4.2.2 集群安装</h4>
<p>​	使用 3 个 Zookeeper 应用搭建一个伪集群。应用部署位置是：192.168.233.130。客户端监听端口分别为：2181、2182、2183。投票选举端口分别为 2881/3881、2882/3882、2883/3883。</p>
<p>​	tar -zxf zookeeper-3.6.0.tar.gz<br>
​	将解压后的 Zookeeper 应用目录重命名，便于管理<br>
​	mv zookeeper-3.6.0 zookeeper01</p>
<ol>
<li>提供数据缓存目录</li>
</ol>
<p>在 zookeeper01 应用目录中，创建 data 目录，用于缓存应用运行数据<br>
cd zookeeper01<br>
mkdir data</p>
<ol start="2">
<li>
<p>复制应用<br>
复制两份 Zookeeper 应用。用于模拟集群中的 3 个节点。<br>
cp -r zookeeper01 zookeeper02<br>
cp -r zookeeper01 zookeeper03</p>
</li>
<li>
<p>提供配置文件<br>
在 zookeeper 应用目录中有子目录 conf。其中有配置文件模板：zoo_sample.cfg<br>
cp zoo_sample.cfg zoo.cfg<br>
zookeeper 应用中的配置文件为 conf/zoo.cfg。</p>
</li>
<li>
<p>修改配置文件 zoo.cfg - 设置数据缓存路径<br>
dataDir 参数值为应用运行缓存数据保存目录。</p>
</li>
<li>
<p>提供应用唯一标识<br>
在 Zookeeper 集群中，每个节点需要一个唯一标识。这个唯一标识要求是自然数。且唯一标识保存位置是：数据缓存目录(dataDir=/usr/local/zookeeper/data)的 myid 文件中。其中“数据缓存目录”为配置文件 zoo.cfg 中的配置参数在 data 目录中创建文件 myid ： touch myid</p>
<p>为应用提供唯一标识。本环境中使用 1、2、3 作为每个节点的唯一标识。<br>
vi myid<br>
简化方式为： echo [唯一标识] &gt;&gt; myid。 echo 命令为回声命令，系统会将命令发送的数据返回。 '&gt;&gt;'为定位，代表系统回声数据指定发送到什么位置。 此命令代表系统回声数据发送到 myid 文件中。 如果没有文件则创建文件。</p>
</li>
</ol>
<figure data-type="image" tabindex="12"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200623142717.png" alt="" loading="lazy"></figure>
<ol start="6">
<li>
<p>修改配置文件 zoo.cfg - 设置监听客户端、投票、选举端口</p>
<p>vim zoo.cfg</p>
<p>clientPort=2181 #服务端口根据应用做对应修改,zk01-2181,zk02-2182,zk03-2183<br>
server.1=192.168.0.179:2881:3881<br>
server.2=192.168.0.179:2882:3882<br>
server.3=192.168.0.179:2883:3883</p>
<blockquote>
<p>注：192.168.0.179代表zookeeper所在的服务器的IP，2881是zookeeper内部连接的端口号，3881是投票机制的端口</p>
</blockquote>
<figure data-type="image" tabindex="13"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200623165813.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="14"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200623165851.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="15"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200623165926.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="16"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200623144201.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="17"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/1592902142716_59800662-2B29-4867-AACF-1D8BA6D57A80.png" alt="" loading="lazy"></figure>
</li>
</ol>
<h4 id="423-编写启动-关闭集群脚本">4.2.3 编写启动、关闭集群脚本</h4>
<p>在 Linux 中可以使用 chmod 命令为文件授权。<br>
chmod 777 文件名<br>
777 表示为文件分配可读，可写，可执行权限。</p>
<ol>
<li>
<p>启动 Zookeeper 集群脚本</p>
<p>zookeeper01/bin/zkServer.sh start<br>
zookeeper02/bin/zkServer.sh start<br>
zookeeper03/bin/zkServer.sh start</p>
</li>
<li>
<p>关闭 Zookeeper 集群脚本</p>
<p>zookeeper01/bin/zkServer.sh stop</p>
<p>zookeeper02/bin/zkServer.sh stop<br>
zookeeper03/bin/zkServer.sh stop</p>
</li>
</ol>
<figure data-type="image" tabindex="18"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200623165653.png" alt="" loading="lazy"></figure>
<h4 id="424-连接集群">4.2.4 连接集群</h4>
<p>可以使用任何节点中的客户端工具连接集群中的任何节点。<br>
./zkCli.sh -server 192.168.0.179:2183</p>
<h2 id="5-zookeeper-常用命令">5、Zookeeper 常用命令</h2>
<h3 id="51-ls-命令">5.1  ls 命令</h3>
<p>​	ls /path</p>
<p>​	使用 ls 命令查看 zookeeper 中的内容。在 ZooKeeper 控制台客户端中，没有默认列表功能，必须指定要列表资源的位置。 如： ls / 或者 ls /path</p>
<figure data-type="image" tabindex="19"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200624091621.png" alt="" loading="lazy"></figure>
<h3 id="52-create-命令">5.2 create 命令</h3>
<p>​		create [-e] [-s] /path [data]<br>
​		使用 create 命令创建一个新的 Znode。create [-e] [-s] path data - 创建节点，默认不加是永久节点，如： create /test 123 创建一个/test 的永久节点，节点携带数据信息 123。 create -e /test 123 创建一个临时节点/test，携带数据为 123，临时节点只在当前会话生命周期中有效，会话结束节点自动删除。</p>
<p>​		create -s /test 123 创建一个顺序节点/test，携带数据 123，创建的顺序节点由 ZooKeeper 自动为节点增加后缀信息，如-/test00000001 等。-e 和-s 参数可以联合使用。</p>
<figure data-type="image" tabindex="20"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200624095012.png" alt="" loading="lazy"></figure>
<h3 id="53-get命令">5.3 get命令</h3>
<p>get [-s] /path</p>
<p>get 命令获取 Znode 中的数据。</p>
<figure data-type="image" tabindex="21"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200624095654.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="22"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200624095710.png" alt="" loading="lazy"></figure>
<p>​		get -s /path</p>
<p>​		-s 查看 Znode 详细信息</p>
<p>​		<img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200624095840.png" alt="" loading="lazy"></p>
<p>123456:存放的数据<br>
cZxid:创建时 zxid(znode 每次改变时递增的事务 id)<br>
ctime:创建时间戳<br>
mZxid:最近一次更近的 zxid<br>
mtime:最近一次更新的时间戳<br>
pZxid:子节点的 zxid<br>
cversion:子节点更新次数<br>
dataversion:节点数据更新次数<br>
aclVersion:节点 ACL(授权信息)的更新次数<br>
ephemeralOwner: 如 果 该 节 点 为 ephemeral 节 点 ( 临 时 ， 生 命 周 期 与 session 一 样 ),<br>
ephemeralOwner 值表示与该节点绑定的 session id. 如果该节点不是<br>
ephemeral 节点, ephemeralOwner 值为 0.</p>
<p>dataLength:节点数据字节数<br>
numChildren:子节点数量</p>
<h3 id="54-set命令">5.4 set命令</h3>
<p>set /path [data]<br>
添加或修改 Znode 中的值</p>
<figure data-type="image" tabindex="23"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200624101639.png" alt="" loading="lazy"></figure>
<h3 id="55-delete-命令">5.5 delete 命令</h3>
<p>delete /path<br>
删除 Znode。</p>
<figure data-type="image" tabindex="24"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200624101730.png" alt="" loading="lazy"></figure>
<h2 id="6-使用-java-api-操作-zookeeper">6、使用 Java API 操作 Zookeeper</h2>
<h3 id="61-创建znode">6.1 创建Znode</h3>
<ol>
<li>创建项目</li>
</ol>
<figure data-type="image" tabindex="25"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200624102928.png" alt="" loading="lazy"></figure>
<ol start="2">
<li>
<p>修改 POM 文件添加依赖</p>
<p>该依赖为基于 Java 语言连接 Zookeeper 的客户端工具</p>
<pre><code class="language-xml">&lt;dependency&gt;
	&lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;
	&lt;artifactId&gt;zookeeper&lt;/artifactId&gt;
    &lt;version&gt;3.6.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>3创建 Znode 并添加数据</p>
<pre><code class="language-java">/**
 * 操作 Zookeeper 的 Znode
 */
public class ZnodeDemo implements Watcher {
    public static void main(String[] args) throws IOException, KeeperException, InterruptedException {
        //创建一个Zookeeper对象 Zookeeper(&quot;ip：端口，超时时间，回调处理器&quot;)
        ZooKeeper zooKeeper = new ZooKeeper(&quot;124.70.181.124:2181,124.70.181.124:2182,124.70.181.124:2183&quot;,150000,new ZnodeDemo());

        //创建一个znode
        String path = zooKeeper.create(&quot;/zk01/zk01-01&quot;, &quot;123&quot;.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);
        System.out.println(path);
    }

    /**
     * 事件通知回调方法
     *
     * @param watchedEvent
     */
    public void process(WatchedEvent watchedEvent) {
        //获取连接事件
        if (watchedEvent.getState() == Event.KeeperState.SyncConnected){
            System.out.println(&quot;连接成功！&quot;);
        }
    }
}
</code></pre>
<figure data-type="image" tabindex="26"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200624105903.png" alt="" loading="lazy"></figure>
</li>
</ol>
<figure data-type="image" tabindex="27"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200624105957.png" alt="" loading="lazy"></figure>
<h3 id="62-获取-znode-中的数据">6.2 获取 Znode 中的数据</h3>
<pre><code class="language-java">/**
 * 操作 Zookeeper 的 Znode
 */
public class ZnodeDemo implements Watcher {
    public static void main(String[] args) throws IOException, KeeperException, InterruptedException {
        //创建一个Zookeeper对象 Zookeeper(&quot;ip：端口，超时时间，回调处理器&quot;)
        ZooKeeper zooKeeper = new ZooKeeper(&quot;124.70.181.124:2181,124.70.181.124:2182,124.70.181.124:2183&quot;, 150000, new ZnodeDemo());

        /*//创建一个znode
        String path = zooKeeper.create(&quot;/zk01/zk01-01&quot;, &quot;123&quot;.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);
        System.out.println(path);*/

        //获取指定节点中的数据
        byte[] data = zooKeeper.getData(&quot;/zk04&quot;, new ZnodeDemo(), new Stat());
        System.out.println(new String(data));

        //获取所有子节点中的数据
        List&lt;String&gt; children = zooKeeper.getChildren(&quot;/zk04&quot;, new ZnodeDemo(), new Stat());
        for (String child : children) {
            byte[] childdata = zooKeeper.getData(&quot;/zk04/&quot; + child, new ZnodeDemo(), null);
            System.out.println(new String(childdata));
        }
    }

    /**
     * 事件通知回调方法
     *
     * @param watchedEvent
     */
    public void process(WatchedEvent watchedEvent) {
        //获取连接事件
        if (watchedEvent.getState() == Event.KeeperState.SyncConnected) {
            System.out.println(&quot;连接成功！&quot;);
        }
    }
}
</code></pre>
<figure data-type="image" tabindex="28"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200624111556.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="29"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200624111836.png" alt="" loading="lazy"></figure>
<h3 id="63-设置znode中的值">6.3 设置Znode中的值</h3>
<pre><code class="language-java">		//设置 Znode 中的值
        //-1表示匹配任何版本
        Stat stat = zooKeeper.setData(&quot;/zk04/zk04-01&quot;, &quot;456&quot;.getBytes(), -1);
        System.out.println(stat);
</code></pre>
<figure data-type="image" tabindex="30"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200624112812.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="31"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200624112829.png" alt="" loading="lazy"></figure>
<h3 id="64-删除znode">6.4 删除Znode</h3>
<pre><code class="language-java">zooKeeper.delete(&quot;/zk04/zk04-01&quot;,-1);
</code></pre>
<figure data-type="image" tabindex="32"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200624113023.png" alt="" loading="lazy"></figure>
<h2 id="7-zookeeper实战">7、Zookeeper实战</h2>
<p>​		实战案例介绍：使用 Zookeeper 与 RMI 技术实现一个 RPC 框架。<br>
​		RPC：RPC（Remote Procedure Call）远程过程调用。</p>
<h3 id="71-基于-rmi-实现远程方法调用">7.1 基于 RMI 实现远程方法调用</h3>
<h4 id="711-rmi-简-介">7.1.1 RMI 简 介</h4>
<p>RMI(Remote Method Invocation) 远程方法调用。<br>
RMI 是从 JDK1.2 推出的功能，它可以实现在一个 Java 应用中可以像调用本地方法一样调用另一个服务器中 Java 应用（JVM）中的内容。<br>
RMI 是 Java 语言的远程调用，无法实现跨语言。</p>
<h4 id="712-执行流程">7.1.2 执行流程</h4>
<figure data-type="image" tabindex="33"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200624142309.png" alt="" loading="lazy"></figure>
<p>​		Registry(注册表)是放置所有服务器对象的命名空间。 每次服务端创建一个对象时，它都会使用 bind()或 rebind()方法注册该对象。 这些是使用称为绑定名称的唯一名称注册的。<br>
​		要调用远程对象，客户端需要该对象的引用。即通过服务端绑定的名称从注册表中获取对象(lookup()方法)。</p>
<h4 id="713-rmi-的-api-介绍">7.1.3 RMI 的 API 介绍</h4>
<ol>
<li>
<p>Remote 接口<br>
java.rmi.Remote 定义了此接口为远程调用接口。如果接口被外部调用，需要继承此接口。</p>
<figure data-type="image" tabindex="34"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200624142408.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>RemoteException 类<br>
java.rmi.RemoteException<br>
继承了 Remote 接口的接口，如果方法是允许被远程调用的，需要抛出此异常。</p>
</li>
<li>
<p>UnicastRemoteObject 类<br>
java.rmi.server.UnicastRemoteObject<br>
此类实现了 Remote 接口和 Serializable 接口。<br>
自定义接口实现类除了实现自定义接口还需要继承此类。</p>
</li>
<li>
<p>LocateRegistry 类<br>
java.rmi.registry.LocateRegistry<br>
可以通过 LocateRegistry 在本机上创建 Registry ，通过特定的端口就可以访问这个<br>
Registry。</p>
</li>
<li>
<p>Naming 类<br>
java.rmi.Naming<br>
Naming 定义了发布内容可访问 RMI 名称。也是通过 Naming 获取到指定的远程方法。</p>
</li>
</ol>
<h4 id="714-创建server端">7.1.4 创建server端</h4>
<ol>
<li>
<p>创建项目</p>
<figure data-type="image" tabindex="35"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200624142724.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>创建接口</p>
<pre><code class="language-java">/**
 * 定义允许远程调用接口，这样客户端就能知道服务端里有什么方法，该接口必须要实现 Remote 接口
 * 允许被远程调用的方法必须要抛出 RemoteException
 */
public interface DemoService extends Remote {
    String demo(String str) throws RemoteException;
}
</code></pre>
</li>
<li>
<p>创建接口实现类</p>
<pre><code class="language-java">/**
 * 接口实现类必须要继承 UnicastRemoteObject。
 * 会自动添加构造方法，需要修改为 public
 */
public class DemoServiceImpl extends UnicastRemoteObject implements DemoService {
    public DemoServiceImpl() throws RemoteException {
    }

    public String demo(String str) throws RemoteException {
        return &quot;Hello RMI&quot; + str;
    }
}
</code></pre>
</li>
<li>
<p>编写主方法</p>
<pre><code class="language-java">public class DemoServer {
    public static void main(String[] args) throws RemoteException, AlreadyBoundException, MalformedURLException {
        //将对象实例化
        DemoServiceImpl demoService = new DemoServiceImpl();
        //创建本地注册表
        LocateRegistry.createRegistry(8888);
        //将对象绑定到注册表中
        Naming.bind(&quot;rmi://localhost:8888/demoService&quot;,demoService);
    }
}
</code></pre>
</li>
</ol>
<h4 id="715-创建client端">7.1.5 创建Client端</h4>
<ol>
<li>
<p>创建项目</p>
<figure data-type="image" tabindex="36"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200624143249.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>复制服务端接口</p>
<pre><code class="language-java">/**
 * 定义允许远程调用接口，这样客户端就能知道服务端里有什么方法，该接口必须要实现 Remote 接口
 * 允许被远程调用的方法必须要抛出 RemoteException
 */
public interface DemoService extends Remote {
    String demo(String str) throws RemoteException;
}

</code></pre>
</li>
<li>
<p>创建主方法</p>
</li>
</ol>
<pre><code class="language-java">public class DemoClient {
    public static void main(String[] args) throws RemoteException, NotBoundException, MalformedURLException {
        DemoService demoService = (DemoService) Naming.lookup(&quot;rmi://localhost:8888/demoService&quot;);
        String s = demoService.demo(&quot;调用成功&quot;);
        System.out.println(s);
    }
}
</code></pre>
<p>结果：<img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200624143433.png" alt="" loading="lazy"></p>
<h3 id="72-使用-zookeeper-作为注册中心实现-rpc">7.2 使用 Zookeeper 作为注册中心实现 RPC</h3>
<h4 id="721-创建服务端">7.2.1 创建服务端</h4>
<ol>
<li>
<p>创建项目</p>
<figure data-type="image" tabindex="37"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200624152139.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>修改 POM 文件添加依赖</p>
<pre><code class="language-xml"> &lt;dependency&gt;
     &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;
     &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;
     &lt;version&gt;3.6.0&lt;/version&gt;
 &lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>创建接口</p>
<pre><code class="language-java">public interface UserService extends Remote {
    String findUser(String str) throws RemoteException;
}
</code></pre>
</li>
<li>
<p>创建接口实现类</p>
<pre><code class="language-java">public class UserServiceImpl extends UnicastRemoteObject implements UserService {
    public UserServiceImpl() throws RemoteException {
    }

    public String findUser(String str) throws RemoteException {
        return &quot;Hello Zookeeper&quot;+str;
    }
}
</code></pre>
</li>
<li>
<p>编写主方法</p>
<pre><code class="language-java">public class UserServer implements Watcher {
    public static void main(String[] args) throws IOException, AlreadyBoundException, KeeperException, InterruptedException {
        UserServiceImpl userService = new UserServiceImpl();
        LocateRegistry.createRegistry(8888);
        String url = &quot;rmi://localhost:8888/userService&quot;;
        Naming.bind(url,userService);

        //将url信息放到zookeeper的节点中
        ZooKeeper zooKeeper = new ZooKeeper(&quot;124.70.181.124:2181,124.70.181.124:2182,124.70.181.124:2183&quot;,150000,new UserServer());

        //创建Znode
        zooKeeper.create(&quot;/zk01/service&quot;,url.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
        System.out.println(&quot;服务发布成功&quot;);
    }

    public void process(WatchedEvent watchedEvent) {
        if(watchedEvent.getState()==Event.KeeperState.SyncConnected){
            System.out.println(&quot;连接成功&quot;);
        }
    }
}
</code></pre>
</li>
</ol>
<figure data-type="image" tabindex="38"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200624153911.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="39"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200624154720.png" alt="" loading="lazy"></figure>
<h4 id="722-创建客户端">7.2.2 创建客户端</h4>
<ol>
<li>
<p>创建项目</p>
<figure data-type="image" tabindex="40"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200624155446.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>修改 POM 文件添加依赖</p>
<pre><code class="language-xml">&lt;dependency&gt;
	&lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;
	&lt;artifactId&gt;zookeeper&lt;/artifactId&gt;
	&lt;version&gt;3.6.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>创建接口</p>
<pre><code class="language-java">//调用方不需要继承Remote，只有被调用方才需要实现
public interface UserService {
    String findUser(String str);
}
</code></pre>
</li>
<li>
<p>编写主方法</p>
<pre><code class="language-java">public class ClientDemo implements Watcher {
    public static void main(String[] args) throws IOException, KeeperException, InterruptedException, NotBoundException {
        ZooKeeper zooKeeper = new ZooKeeper(&quot;124.70.181.124:2181,124.70.181.124:2182,124.70.181.124:2183&quot;,150000,new ClientDemo());
        byte[] bytes = zooKeeper.getData(&quot;/zk01/service&quot;, new ClientDemo(), new Stat());
        UserService userService =(UserService) Naming.lookup(new String(bytes));
        String result = userService.findUser(&quot; 调用成功&quot;);
        System.out.println(result);
    }

    public void process(WatchedEvent watchedEvent) {
        if(watchedEvent.getState()==Event.KeeperState.SyncConnected){
            System.out.println(&quot;连接成功&quot;);
        }
    }
}
</code></pre>
</li>
</ol>
<p>实现效果：<img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200624155630.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot]]></title>
        <id>https://jonchan1013.github.io/post/springboot/</id>
        <link href="https://jonchan1013.github.io/post/springboot/">
        </link>
        <updated>2020-06-17T08:14:25.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="1-springboot介绍">1、SpringBoot介绍</h2>
<h3 id="11-什么是springboot">1.1 什么是SpringBoot</h3>
<p>​		Spring Boot 是一个框架，一种全新的编程规范，他的产生简化了框架的使用，所谓简<br>
化是指简化了 Spring 众多框架中所需的大量且繁琐的配置文件，所以 Spring Boot 是一个服<br>
务于框架的框架，服务范围是简化配置文件。所以从本质上来说，Spring Boot 其实就是 Spring<br>
框架的另一种表现形式。</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="1-springboot介绍">1、SpringBoot介绍</h2>
<h3 id="11-什么是springboot">1.1 什么是SpringBoot</h3>
<p>​		Spring Boot 是一个框架，一种全新的编程规范，他的产生简化了框架的使用，所谓简<br>
化是指简化了 Spring 众多框架中所需的大量且繁琐的配置文件，所以 Spring Boot 是一个服<br>
务于框架的框架，服务范围是简化配置文件。所以从本质上来说，Spring Boot 其实就是 Spring<br>
框架的另一种表现形式。</p>
<!-- more -->
<h3 id="12-spring-boot-特征">1.2  Spring Boot 特征</h3>
<ul>
<li>使用 Spring Boot 可以创建独立的 Spring 应用程序</li>
<li>在Spring Boot中直接嵌入了Tomcat、Jetty、Undertow 等Web 容器，所以在使用SpringBoot做 Web 开发时不需要部署 WAR 文件</li>
<li>通过提供自己的启动器(Starter)依赖，简化项目构建配置</li>
<li>尽量的自动配置 Spring 和第三方库</li>
<li>提供了生产就绪特征，如：度量指标，运行状况检查和外部化配置</li>
<li>绝对没有代码生成，也不需要 XML 配置文件</li>
</ul>
<h3 id="13-spring-boot-版本介绍">1.3 Spring Boot 版本介绍</h3>
<p>SNAPSHOT：快照版，即开发版。<br>
CURRENT：最新版，但是不一定是稳定版。<br>
GA：General Availability，正式发布的版本。</p>
<h2 id="2-创建基于-spring-boot-的项目">2、创建基于 Spring Boot 的项目</h2>
<h3 id="21-通过官网创建项目">2.1 通过官网创建项目</h3>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200618115707.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200618115730.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200618115745.png" alt="" loading="lazy"></figure>
<h3 id="22-通过-idea-的脚手架工具创建">2.2 通过 IDEA 的脚手架工具创建</h3>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200618115904.png" alt="" loading="lazy"></figure>
<h3 id="23-通过-idea-的-maven-项目创建">2.3 通过 IDEA 的 Maven 项目创建</h3>
<p>maven创建好后修改pom文件</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0
http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
&lt;groupId&gt;com.bjsxt&lt;/groupId&gt;
&lt;artifactId&gt;springbootdemo3&lt;/artifactId&gt;
&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
&lt;parent&gt;
	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
	&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
	&lt;version&gt;2.2.0.RELEASE&lt;/version&gt;
	&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
&lt;/parent&gt;
&lt;properties&gt;
	&lt;java.version&gt;1.8&lt;/java.version&gt;
&lt;/properties&gt;
    &lt;dependencies&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
			&lt;scope&gt;test&lt;/scope&gt;
			&lt;exclusions&gt;
				&lt;exclusion&gt;
					&lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;
					&lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;
				&lt;/exclusion&gt;
			&lt;/exclusions&gt;
		&lt;/dependency&gt;
	&lt;/dependencies&gt;
&lt;build&gt;
	&lt;plugins&gt;
		&lt;plugin&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
		&lt;/plugin&gt;
	&lt;/plugins&gt;
&lt;/build&gt;
&lt;/project&gt;
</code></pre>
<h2 id="3-spring-boot-项目结构介绍">3、Spring Boot 项目结构介绍</h2>
<h3 id="31-pom文件">3.1 POM文件</h3>
<h4 id="311-继承">3.1.1 继承</h4>
<pre><code class="language-xml">&lt;parent&gt;
	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
	&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
	&lt;version&gt;2.2.0.RELEASE&lt;/version&gt;
	&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
&lt;/parent&gt;
</code></pre>
<p>Spring Boot 的父级依赖，只有继承它项目才是 Spring Boot 项目。<br>
spring-boot-starter-parent 是一个特殊的 starter，它用来提供相关的 Maven 默认依赖。使用它之后，常用的包依赖可以省去 version 标签。</p>
<h4 id="312-依赖">3.1.2 依赖</h4>
<pre><code class="language-xml">&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
	&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>启动器依赖</p>
<h4 id="313-插件">3.1.3 插件</h4>
<pre><code class="language-xml">&lt;build&gt;
	&lt;plugins&gt;
		&lt;plugin&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
		&lt;/plugin&gt;
	&lt;/plugins&gt;
&lt;/build&gt;
</code></pre>
<p>​		spring-boot-maven-plugin 插件是将 springboot 的应用程序打包成 jar 包的插件。将所有应用启动运行所需要的 jar 包都包含进来，从逻辑上将具备了独立运行的条件。当运行&quot;mvnpackage&quot;进行打包后，使用&quot;java -jar&quot;命令就可以直接运行。</p>
<h3 id="32-启动类">3.2 启动类</h3>
<p>Spring Boot 的启动类的作用是启动 Spring Boot 项目，是基于 Main 方法来运行的。<br>
注意：启动类在启动时会做注解扫描(@Controller、@Service、@Repository......)，扫描位置为同包或者子包下的注解，所以启动类的位置应放于包的根下。</p>
<h4 id="321-启动类与启动器区别">3.2.1 启动类与启动器区别</h4>
<ul>
<li>启动类表示项目的启动入口</li>
<li>启动器表示 jar 包的坐标</li>
</ul>
<h4 id="322-创建启动类">3.2.2 创建启动类</h4>
<pre><code class="language-java">/**
*Spring Boot 启动类
*/
@SpringBootApplication
public class SpringBootDemo3Application {
	public static void main(String[] args){
		SpringApplication.run(SpringBootDemo3Application.class,args);
	}
}
</code></pre>
<h3 id="32-启动器">3.2 启动器</h3>
<p>Spring Boot 将所有的功能场景都抽取出来，做成一个个的 starter(启动器)，只需要在项目里面引入这些 starter 相关场景的所有依赖都会导入进来，要用什么功能就导入什么场景，在 jar 包管理上非常方便，最终实现一站式开发。<br>
Spring Boot 提供了多达 44 个启动器。</p>
<p>spring-boot-starter<br>
这是 Spring Boot 的核心启动器，包含了自动配置、日志和 YAML。</p>
<p>spring-boot-starter-actuator<br>
帮助监控和管理应用。</p>
<p>spring-boot-starter-web<br>
支持全栈式 Web 开发，包括 Tomcat 和 spring-webmvc。</p>
<p>spring-boot-starter-amqp<br>
通过 spring-rabbit 来支持 AMQP 协议（Advanced Message Queuing Protocol）。</p>
<p>spring-boot-starter-aop<br>
支持面向方面的编程即 AOP，包括 spring-aop 和 AspectJ。</p>
<p>spring-boot-starter-artemis<br>
通过 Apache Artemis 支持 JMS 的 API（Java Message Service API）。</p>
<p>spring-boot-starter-batch<br>
支持 Spring Batch，包括 HSQLDB 数据库。</p>
<p>spring-boot-starter-cache<br>
支持 Spring 的 Cache 抽象。</p>
<p>spring-boot-starter-cloud-connectors<br>
支持 Spring Cloud Connectors，简化了在像 Cloud Foundry 或 Heroku 这样的云平台上连接服务。</p>
<p>spring-boot-starter-data-elasticsearch<br>
支持 ElasticSearch 搜索和分析引擎，包括 spring-data-elasticsearch。<br>
spring-boot-starter-data-gemfire<br>
支持 GemFire 分布式数据存储，包括 spring-data-gemfire。</p>
<p>spring-boot-starter-data-jpa</p>
<p>支持 JPA（Java Persistence API），包括 spring-data-jpa、spring-orm、Hibernate。</p>
<p>spring-boot-starter-data-mongodb<br>
支持 MongoDB 数据，包括 spring-data-mongodb。</p>
<p>spring-boot-starter-data-rest<br>
通过 spring-data-rest-webmvc，支持通过 REST 暴露 Spring Data 数据仓库。</p>
<p>spring-boot-starter-data-solr<br>
支持 Apache Solr 搜索平台，包括 spring-data-solr。</p>
<p>spring-boot-starter-freemarker<br>
支持 FreeMarker 模板引擎。</p>
<p>spring-boot-starter-groovy-templates<br>
支持 Groovy 模板引擎。</p>
<p>spring-boot-starter-hateoas<br>
通过 spring-hateoas 支持基于 HATEOAS 的 RESTful Web 服务。</p>
<p>spring-boot-starter-hornetq<br>
通过 HornetQ 支持 JMS。</p>
<p>spring-boot-starter-integration<br>
支持通用的 spring-integration 模块。</p>
<p>spring-boot-starter-jdbc<br>
支持 JDBC 数据库。</p>
<p>spring-boot-starter-jersey<br>
支持 Jersey RESTful Web 服务框架。</p>
<p>spring-boot-starter-jta-atomikos<br>
通过 Atomikos 支持 JTA 分布式事务处理。</p>
<p>spring-boot-starter-jta-bitronix<br>
通过 Bitronix 支持 JTA 分布式事务处理。</p>
<p>spring-boot-starter-mail<br>
支持 javax.mail 模块。</p>
<p>spring-boot-starter-mobile<br>
支持 spring-mobile。</p>
<p>spring-boot-starter-mustache<br>
支持 Mustache 模板引擎。</p>
<p>spring-boot-starter-redis<br>
支持 Redis 键值存储数据库，包括 spring-redis。</p>
<p>spring-boot-starter-security<br>
支持 spring-security。</p>
<p>spring-boot-starter-social-facebook<br>
支持 spring-social-facebook</p>
<p>spring-boot-starter-social-linkedin<br>
支持 pring-social-linkedin</p>
<p>spring-boot-starter-social-twitter<br>
支持 pring-social-twitter</p>
<p>spring-boot-starter-test<br>
支持常规的测试依赖，包括 JUnit、Hamcrest、Mockito 以及 spring-test 模块。</p>
<p>spring-boot-starter-thymeleaf<br>
支持 Thymeleaf 模板引擎，包括与 Spring 的集成。</p>
<p>spring-boot-starter-velocity<br>
支持 Velocity 模板引擎。</p>
<p>spring-boot-starter-websocket<br>
支持 WebSocket 开发。</p>
<p>spring-boot-starter-ws<br>
支持 Spring Web Services。</p>
<p>spring-boot-starter-actuator<br>
增加了面向产品上线相关的功能，比如测量和监控。</p>
<p>spring-boot-starter-remote-shell<br>
增加了远程 ssh shell 的支持。</p>
<p>spring-boot-starter-jetty</p>
<p>引入了 Jetty HTTP 引擎（用于替换 Tomcat）。</p>
<p>spring-boot-starter-log4j<br>
支持 Log4J 日志框架。</p>
<p>spring-boot-starter-logging<br>
引入了 Spring Boot 默认的日志框架 Logback。</p>
<p>spring-boot-starter-tomcat<br>
引入了 Spring Boot 默认的 HTTP 引擎 Tomcat。</p>
<p>spring-boot-starter-undertow<br>
引入了 Undertow HTTP 引擎（用于替换 Tomcat）。</p>
<h3 id="34-配置文件">3.4 配置文件</h3>
<p>​		Spring Boot 提供一个名称为 application 的全局配置文件，支持两种格式 properteis 格式与 YAML 格式。</p>
<h4 id="341-properties-格式">3.4.1 Properties 格式</h4>
<p>配置 Tomcat 监听端口</p>
<pre><code class="language-properties">server.port=8888
</code></pre>
<h4 id="342-yaml-格式">3.4.2 YAML 格式</h4>
<p>YAML 格式配置文件的扩展名可以是 yaml 或者 yml。</p>
<p><strong>基本格式要求</strong></p>
<ul>
<li>大小写敏感</li>
<li>使用缩进代表层级关系</li>
<li>相同的部分只出现一次</li>
</ul>
<p>配置 Tomcat 监听端口</p>
<pre><code class="language-yaml">server:
	port: 8888
</code></pre>
<h4 id="343-配置文件存放位置">3.4.3 配置文件存放位置</h4>
<ul>
<li>当前项目根目录中</li>
<li>当前项目根目录下的一个/config 子目录中</li>
<li>项目的 resources 即 classpath 根路径中</li>
<li>项目的 resources 即 classpath 根路径下的/config 目录中</li>
</ul>
<h4 id="344-配置文件加载顺序">3.4.4 配置文件加载顺序</h4>
<h5 id="3441-不同格式的加载顺序">3.4.4.1 不同格式的加载顺序</h5>
<p>​		如 果 同 一 个 目 录 下 ， 有 application.yml 也 有 application.properties ， 默 认 先 读 取application.properties。<br>
​		如果同一个配置属性，在多个配置文件都配置了，默认使用第 1 个读取到的，后面读取的不覆盖前面读取到的。</p>
<h5 id="3442-不同位置的加载顺序">3.4.4.2 不同位置的加载顺序</h5>
<ol>
<li>
<p>当前项目根目录下的一个/config 子目录中(最高)<br>
config/application.properties<br>
config/application.yml</p>
</li>
<li>
<p>当前项目根目录中(其次)<br>
application.properties<br>
application.yml</p>
</li>
<li>
<p>项目的 resources 即 classpath 根路径下的/config 目录中(一般)<br>
resources/config/application.properties<br>
resources/config/application.yml</p>
</li>
<li>
<p>项目的 resources 即 classpath 根路径中(最后)<br>
resources/application.properties<br>
resources/application.yml</p>
</li>
</ol>
<h4 id="345-配置文件中的占位符">3.4.5 配置文件中的占位符</h4>
<ol>
<li>
<p>占位符语法</p>
<p>语法：${}</p>
</li>
<li>
<p>占位符的作用</p>
<ul>
<li>&quot;${}&quot;中可以获取框架提供的方法中的值如：random.int 等。</li>
<li>占位符可以获取配置文件中的键的值赋给另一个键作为值。</li>
</ul>
</li>
<li>
<p>生成随机数<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>o</mi><mi>m</mi><mi mathvariant="normal">.</mi><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow><mo>−</mo><mi mathvariant="normal">类</mi><mi mathvariant="normal">似</mi><mi>u</mi><mi>u</mi><mi>i</mi><mi>d</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">随</mi><mi mathvariant="normal">机</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">没</mi><mi mathvariant="normal">有</mi><mi mathvariant="normal">&quot;</mi><mo>−</mo><mi mathvariant="normal">&quot;</mi><mi mathvariant="normal">连</mi><mi mathvariant="normal">接</mi></mrow><annotation encoding="application/x-tex">{random.value} - 类似 uuid 的随机数，没有&quot;-&quot;连接
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">o</span><span class="mord mathdefault">m</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">类</span><span class="mord cjk_fallback">似</span><span class="mord mathdefault">u</span><span class="mord mathdefault">u</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">随</span><span class="mord cjk_fallback">机</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">没</span><span class="mord cjk_fallback">有</span><span class="mord">&quot;</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">&quot;</span><span class="mord cjk_fallback">连</span><span class="mord cjk_fallback">接</span></span></span></span>{random.int} - 随机取整型范围内的一个值<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>o</mi><mi>m</mi><mi mathvariant="normal">.</mi><mi>l</mi><mi>o</mi><mi>n</mi><mi>g</mi></mrow><mo>−</mo><mi mathvariant="normal">随</mi><mi mathvariant="normal">机</mi><mi mathvariant="normal">取</mi><mi mathvariant="normal">长</mi><mi mathvariant="normal">整</mi><mi mathvariant="normal">型</mi><mi mathvariant="normal">范</mi><mi mathvariant="normal">围</mi><mi mathvariant="normal">内</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">值</mi></mrow><annotation encoding="application/x-tex">{random.long} - 随机取长整型范围内的一个值
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">o</span><span class="mord mathdefault">m</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">随</span><span class="mord cjk_fallback">机</span><span class="mord cjk_fallback">取</span><span class="mord cjk_fallback">长</span><span class="mord cjk_fallback">整</span><span class="mord cjk_fallback">型</span><span class="mord cjk_fallback">范</span><span class="mord cjk_fallback">围</span><span class="mord cjk_fallback">内</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">值</span></span></span></span>{random.long(100,200)} - 随机生成长整型 100-200 范围内的一个值<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>o</mi><mi>m</mi><mi mathvariant="normal">.</mi><mi>u</mi><mi>u</mi><mi>i</mi><mi>d</mi></mrow><mo>−</mo><mi mathvariant="normal">生</mi><mi mathvariant="normal">成</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">个</mi><mi>u</mi><mi>u</mi><mi>i</mi><mi>d</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">有</mi><mi mathvariant="normal">短</mi><mi mathvariant="normal">杠</mi><mi mathvariant="normal">连</mi><mi mathvariant="normal">接</mi></mrow><annotation encoding="application/x-tex">{random.uuid} - 生成一个 uuid，有短杠连接
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">o</span><span class="mord mathdefault">m</span><span class="mord">.</span><span class="mord mathdefault">u</span><span class="mord mathdefault">u</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord cjk_fallback">生</span><span class="mord cjk_fallback">成</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">个</span><span class="mord mathdefault">u</span><span class="mord mathdefault">u</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">短</span><span class="mord cjk_fallback">杠</span><span class="mord cjk_fallback">连</span><span class="mord cjk_fallback">接</span></span></span></span>{random.int(10)} - 随机生成一个 10 以内的数<br>
${random.int(100,200)} - 随机生成一个 100-200 范围以内的数</p>
</li>
</ol>
<h4 id="346-bootstrap-配置文件">3.4.6 bootstrap 配置文件</h4>
<h5 id="3461-bootstrap-配置文件介绍">3.4.6.1 bootstrap 配置文件介绍</h5>
<p>​		Spring Boot 中有两种上下文对象，一种是 bootstrap, 另外一种是 application, bootstrap是应用程序的父上下文，也就是说 bootstrap 加载优先于 applicaton。bootstrap 主要用于从额外的资源来加载配置信息，还可以在本地外部配置文件中解密属性。这两个上下文共用一个环境，它是任何 Spring 应用程序的外部属性的来源。bootstrap 里面的属性会优先加载，它们默认也不能被本地相同配置覆盖。</p>
<h5 id="3462-bootstrap-配置文件特征">3.4.6.2 bootstrap 配置文件特征</h5>
<ul>
<li>boostrap 由父 ApplicationContext 加载，比 applicaton 优先加载。</li>
<li>boostrap 里面的属性不能被覆盖。</li>
</ul>
<h5 id="3463-bootstrap-与-application-的应用场景">3.4.6.3 bootstrap 与 application 的应用场景</h5>
<p>application 配置文件主要用于 Spring Boot 项目的自动化配置。<br>
bootstrap 配置文件有以下几个应用场景。</p>
<ul>
<li>使用 Spring Cloud Config 配置中心时，这时需要在 bootstrap 配置文件中添加连接到配置中心的配置属性来加载外部配置中心的配置信息。</li>
<li>一些固定的不能被覆盖的属性。</li>
<li>一些加密/解密的场景。</li>
</ul>
<h3 id="35-spring-boot-的核心注解">3.5 Spring Boot 的核心注解</h3>
<ol>
<li>@SpringBootApplication<br>
是 SpringBoot 的启动类。<br>
此注解等同于@Configuration+@EnableAutoConfiguration+@ComponentScan 的组合。</li>
<li>@SpringBootConfiguration<br>
@SpringBootConfiguration 注解是@Configuration 注解的派生注解，跟@Configuration注解的功能一致，标注这个类是一个配置类，只不过@SpringBootConfiguration 是 Springboot的注解，而@Configuration 是 Spring 的注解</li>
<li>@Configuration<br>
通过对 bean 对象的操作替代 spring 中 xml 文件</li>
<li>@EnableAutoConfiguration<br>
Spring Boot 自动配置（auto-configuration）：尝试根据你添加的 jar 依赖自动配置你的Spring 应用。是@AutoConfigurationPackage 和@Import(AutoConfigurationImportSelector.class)注解的组合。</li>
<li>@AutoConfigurationPackage<br>
@AutoConfigurationPackage 注解，自动注入主类下所在包下所有的加了注解的类（@Controller，@Service 等），以及配置类（@Configuration）</li>
<li>@Import({AutoConfigurationImportSelector.class})<br>
直接导入普通的类<br>
导入实现了 ImportSelector 接口的类<br>
导入实现了 ImportBeanDefinitionRegistrar 接口的类</li>
<li>@ComponentScan<br>
组件扫描，可自动发现和装配一些 Bean。</li>
<li>@ConfigurationPropertiesScan<br>
@ConfigurationPropertiesScan 扫描配置属性。@EnableConfigurationProperties 注解的作用是使用 @ConfigurationProperties 注解的类生效。</li>
</ol>
<h2 id="4-编写helloworld">4、编写HelloWorld</h2>
<h3 id="41-创建项目">4.1 创建项目</h3>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200618133340.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200618133358.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200618133412.png" alt="" loading="lazy"></figure>
<p>通过maven方式创建SpringBoot项目</p>
<figure data-type="image" tabindex="8"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200618133522.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="9"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200618133633.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="10"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200618133713.png" alt="" loading="lazy"></figure>
<h3 id="42-修改pom文件">4.2 修改POM文件</h3>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.cy&lt;/groupId&gt;
    &lt;artifactId&gt;SpringBootHelloWorld&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.2.0.RELEASE&lt;/version&gt;
    &lt;/parent&gt;


    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;

</code></pre>
<h3 id="43-修改-tomcat-端口">4.3 修改 Tomcat 端口</h3>
<pre><code class="language-yaml">server:
	port: 8888
</code></pre>
<h3 id="44-创建启动类">4.4 创建启动类</h3>
<pre><code class="language-java">/**
* 启动类
*/
@SpringBootApplication
public class SpringBootHelloWorldApplication {
	public static void main(String[] args){
		SpringApplication.run(SpringBootHelloWorldApplication.class,args);
	}
}
</code></pre>
<h3 id="45-创建-controller">4.5 创建 Controller</h3>
<pre><code class="language-java">/**
* 处理请求 Controller
*/
@RestController // @Controller+@ResponsBody 直接返回字符串
public class HelloWorldController {
	@RequestMapping(&quot;/helloWorld&quot;)
	public String showHelloWorld(){
		return &quot;HelloWorld&quot;;
	}
}
</code></pre>
<h3 id="46-spring-boot-在-controller-中常用注解">4.6 Spring Boot 在 Controller 中常用注解</h3>
<ol>
<li>
<p>@RestController</p>
<p>@RestController 相当于@Controller+@ResponseBody 注解<br>
如果使用@RestController 注解 Controller 中的方法无法返回页面，相当于在方法上面自动 加 了 @ResponseBody 注 解 ， 所 以 没 办 法 跳 转 并 传 输 数 据 到 另 一 个 页 面 ， 所以InternalResourceViewResolver 也不起作用，返回的内容就是 Return 里的内容。</p>
</li>
<li>
<p>@GetMapping<br>
@GetMapping 注解是@RequestMapping(method = RequestMethod.GET)的缩写。</p>
</li>
<li>
<p>@PostMapping<br>
@PostMapping 注解是@RequestMapping(method = RequestMethod.POST)的缩写。</p>
</li>
<li>
<p>@PutMapping<br>
@PutMapping 注解是@RequestMapping(method = RequestMethod.PUT)的缩写。</p>
</li>
<li>
<p>@DeleteMapping<br>
@DeleteMapping 注解是@RequestMapping(method = RequestMethod.DELETE)的缩写。</p>
</li>
</ol>
<h2 id="5-spring-boot-整合-web-层技术">5. Spring Boot 整合 Web 层技术</h2>
<p>整合 Servlet</p>
<h3 id="51-整合-servlet-方式一通过注解扫描完成-servlet-组件的注册">5.1 整合 Servlet 方式一（通过注解扫描完成 Servlet 组件的注册）</h3>
<ol>
<li>创建 Servlet</li>
</ol>
<pre><code class="language-java">/**
* 整合 Servlet 方式一
*/
@WebServlet(name = &quot;FirstServlet&quot;,urlPatterns = &quot;/first&quot;)
public class FirstServlet extends HttpServlet {
	public void doGet(HttpServletRequest request,HttpServletResponse response){
		System.out.println(&quot;First Servlet........&quot;);
	}
}
</code></pre>
<ol start="2">
<li>修改启动类</li>
</ol>
<pre><code class="language-java">@SpringBootApplication
@ServletComponentScan//在 spring Boot 启动时会扫描@WebServlet注解，并将该类实例化
public class SpringbootwebApplication {
	public static void main(String[] args) {
		SpringApplication.run(SpringbootwebApplication.class,args);
	}
}
</code></pre>
<h3 id="52-整合-servlet-方式二通过方法完成-servlet-组件的注册">5.2  整合 Servlet 方式二（通过方法完成 Servlet 组件的注册）</h3>
<ol>
<li>创建servlet</li>
</ol>
<pre><code class="language-java">/**
* 整合 Servlet 方式二
*/
public class SecondServlet extends HttpServlet {
	public void doGet(HttpServletRequest request,HttpServletResponse response){
		System.out.println(&quot;Second Servlet........&quot;);
	}
}
</code></pre>
<ol start="2">
<li>创建 Servlet 配置类</li>
</ol>
<pre><code class="language-java">/**
* Servlet 配置类
*/
@Configuration
public class ServletConfig {
/**
* 完成 Servlet 组件的注册
*/
	@Bean
	public ServletRegistrationBean getServletRegistrationBean(){
		ServletRegistrationBean bean = new ServletRegistrationBean(new SecondServlet());
		bean.addUrlMappings(&quot;/second&quot;);
		return bean;
	}
}
</code></pre>
<h3 id="53-整合-filter-方式一通过注解扫描完成-filter-组件注册">5.3 整合 Filter 方式一(通过注解扫描完成 Filter 组件注册)</h3>
<ol>
<li>创建 Filter</li>
</ol>
<pre><code class="language-java">/**
* 整合 Filter 方式一
*/
//@WebFilter(filterName = &quot;FirstFilter&quot;,urlPatterns ={&quot;*.do&quot;,&quot;*.jsp&quot;})
@WebFilter(filterName = &quot;FirstFilter&quot;,urlPatterns =&quot;/first&quot;)
public class FirstFilter implements Filter{
	@Override
	public void init(FilterConfig filterConfig) throws ServletException {
	}
	@Override
	public void doFilter(ServletRequest servletRequest,ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
		System.out.println(&quot;进入 First Filter&quot;);
        //chain.doFilter将请求转发给过滤器链下一个filter , 如果没有filter那就是你请求的资源
		filterChain.doFilter(servletRequest,servletResponse);
		System.out.println(&quot;离开 First Filter&quot;);
	}
	@Override
	public void destroy() {
    }
}
</code></pre>
<ol start="2">
<li>修改启动类</li>
</ol>
<pre><code class="language-java">@SpringBootApplication
@ServletComponentScan//在 spring Boot 启动时会扫描@WebServlet,@WebFilter 注解，并将该类实例化
public class SpringbootwebApplication {
	public static void main(String[] args) {
		SpringApplication.run(SpringbootwebApplication.class,args);
	}
}
</code></pre>
<h3 id="54-整合-filter-方式二通过方法完成-filter-组件注册">5.4 整合 Filter 方式二(通过方法完成 Filter 组件注册)</h3>
<ol>
<li>创建 Filter</li>
</ol>
<pre><code class="language-java">/**
* 整合 Filter 方式二
*/
public class SecondFilter implements Filter {
	@Override
	public void init(FilterConfig filterConfig) throws ServletException {
	}
	@Override
	public void doFilter(ServletRequest servletRequest,ServletResponse servletResponse, FilterChain filterChain)throws IOException, ServletException {
		System.out.println(&quot;进入 Second Filter&quot;);
		filterChain.doFilter(servletRequest,servletResponse);
		System.out.println(&quot;离开 Second Filter&quot;);
	}
	@Override
	public void destroy() {
	}
}
</code></pre>
<ol start="2">
<li>创建 Filter 配置类</li>
</ol>
<pre><code class="language-java">/**
* Filter 配置类
*/
@Configuration
public class FilterConfig {
	@Bean
	public FilterRegistrationBean getFilterRegistrationBean(){
		FilterRegistrationBean bean = new FilterRegistrationBean(new SecondFilter());
		// bean.addUrlPatterns(new String[]{&quot;*.do&quot;,&quot;*.jsp&quot;});
		bean.addUrlPatterns(&quot;/second&quot;);
		return bean;	
	}
}
</code></pre>
<h3 id="55-整合-listener-方式一通过注解扫描完成-listener-组件注册">5.5  整合 Listener 方式一(通过注解扫描完成 Listener 组件注册)</h3>
<ol>
<li>编写 Listener</li>
</ol>
<pre><code class="language-java">/**
* 整合 Listener
*/
@WebListener
public class FirstListener implements ServletContextListener{
	public void contextDestroyed(ServletContextEvent event){
	}
	public void contextInitialized(ServletContextEvent event){
		System.out.println(&quot;Listener ...Init......&quot;);
	}
}
</code></pre>
<ol start="2">
<li>修改启动类</li>
</ol>
<pre><code class="language-java">@SpringBootApplication
@ServletComponentScan//在 spring Boot 启动时会扫描@WebServlet,@WebFilter,@WebListener 注解，并将该类实例化
public class SpringbootwebApplication {
	public static void main(String[] args) {SpringApplication.run(SpringbootwebApplication.class, args);
	}
}
</code></pre>
<h3 id="56-整合-listener-方式二通过方法完成-listener-组件注册">5.6 整合 Listener 方式二(通过方法完成 Listener 组件注册)</h3>
<ol>
<li>编写 Listener</li>
</ol>
<pre><code class="language-java">/**
* 整合 Listener 方式二
*/
public class SecondListener implementsServletContextListener {
	public void contextDestroyed(ServletContextEvent event){
	}
	public void contextInitialized(ServletContextEvent event){
		System.out.println(&quot;Second....Listener ...Init......&quot;);
	}
}
</code></pre>
<ol start="2">
<li>创建 Listener 配置类</li>
</ol>
<pre><code class="language-java">/**
* Listener 配置类
*/
@Configuration
public class ListenerConfig {
	@Bean
	public ServletListenerRegistrationBean getServletListenerRegistrationBean(){
		ServletListenerRegistrationBean bean = new ServletListenerRegistrationBean(new SecondListener());
		return bean;
	}
}
</code></pre>
<h2 id="6-spring-boot-访问静态资源">6、Spring Boot 访问静态资源</h2>
<p>​		在 SpringBoot 项目中没有我们之前常规 web 开发的 WebContent（WebApp），它只有<br>
src 目录。在 src/main/resources 下面有两个文件夹，static 和 templates。SpringBoot 默认在 static<br>
目录中存放静态页面，而 templates 中放动态页面。</p>
<ol>
<li>
<p>static 目录</p>
<p>​		Spring Boot 通过 classpath/static 目录访问静态资源。注意存放静态资源的目录名称必须<br>
是 static。</p>
</li>
<li>
<p>templates 目录</p>
<p>​		在 Spring Boot 中不推荐使用 jsp 作为视图层技术，而是默认使用 Thymeleaf 来做动态页<br>
面。Templates 目录这是存放 Thymeleaf 的页面。</p>
</li>
<li>
<p>静态资源存放其他位置</p>
<ol>
<li>
<p>Spring Boot 访问静态资源的位置</p>
<p>classpath:/META‐INF/resources/<br>
classpath:/resources/<br>
classpath:/static/<br>
classpath:/public/</p>
</li>
<li>
<p>自定义静态资源位置</p>
<pre><code class="language-properties">#配置静态资源访问路径
spring.resources.static-locations=classpath:/suibian/,classpath:/static/
</code></pre>
</li>
</ol>
</li>
</ol>
<h2 id="7-spring-boot-文件上传">7、Spring Boot 文件上传</h2>
<ol>
<li>创建项目</li>
</ol>
<figure data-type="image" tabindex="11"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200619113918.png" alt="" loading="lazy"></figure>
<ol start="2">
<li>
<p>POM 文件</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0
https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
&lt;parent&gt;
&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
&lt;version&gt;2.2.0.RELEASE&lt;/version&gt;
&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
&lt;/parent&gt;
&lt;groupId&gt;com.bjsxt&lt;/groupId&gt;
&lt;artifactId&gt;springbootfileupload&lt;/artifactId&gt;
&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;


&lt;name&gt;springbootfileupload&lt;/name&gt;
&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;
&lt;properties&gt;
&lt;java.version&gt;1.8&lt;/java.version&gt;
&lt;/properties&gt;
&lt;dependencies&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
&lt;scope&gt;test&lt;/scope&gt;
&lt;exclusions&gt;
&lt;exclusion&gt;
&lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;
&lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;
&lt;/exclusion&gt;
&lt;/exclusions&gt;
&lt;/dependency&gt;
&lt;/dependencies&gt;
&lt;build&gt;
&lt;plugins&gt;
&lt;plugin&gt;
&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
&lt;/plugin&gt;
&lt;/plugins&gt;
&lt;/build&gt;
&lt;/project&gt;
</code></pre>
<ol start="3">
<li>启动类</li>
</ol>
</li>
</ol>
<pre><code class="language-java">@SpringBootApplication
public class SpringbootfileuploadApplication {
    public static void main(String[] args) {
        SpringApplication.run(SpringbootfileuploadApplication.class, args);
	}
}
</code></pre>
<ol start="4">
<li>编写上传页面</li>
</ol>
<pre><code class="language-html">&lt;html&gt;
	&lt;head&gt;
	&lt;/head&gt;
&lt;body&gt;
	&lt;form action=&quot;/fileUploadController&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;
		&lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;
		&lt;input type=&quot;submit&quot; value=&quot;OKOK&quot;/&gt;
	&lt;/form&gt;
&lt;/body&gt;
</code></pre>
<ol start="5">
<li>编写 Controller</li>
</ol>
<pre><code class="language-java">/**
* 文件上传
*/
@RestController
public class FileUploadController {
	@PostMapping(&quot;/fileUploadController&quot;)
	public String fileUpload(MultipartFile file)throws Exception{
		System.out.println(file.getOriginalFilename());
		file.transferTo(new File(&quot;c:/&quot;+file.getOriginalFilename()));
		return &quot;OK&quot;;
	}
}
</code></pre>
<ol start="6">
<li>修改上传文件大小</li>
</ol>
<pre><code class="language-properties">#配置单个上传文件的大小的限制
spring.servlet.multipart.max-file-size=2MB
#配置在一次请求中上传文件的总容量的限制
spring.servlet.multipart.max-request-size=20MB
</code></pre>
<h2 id="8-spring-boot-整合视图层技术">8、Spring Boot 整合视图层技术</h2>
<h3 id="81-spring-boot-整合-jsp-技术">8.1 Spring Boot 整合 JSP 技术</h3>
<ol>
<li>
<p>创建项目</p>
<figure data-type="image" tabindex="12"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200619142443.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>修改 POM 文件，添加 JSP 引擎与 JSTL 标签库</p>
</li>
</ol>
<pre><code class="language-xml">&lt;!--添加 jsp 引擎，SpringBoot 内置的 Tomat 中没有此依赖--&gt;
&lt;dependency&gt;
	&lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;
	&lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;!--添加 JSTL 坐标依赖--&gt;
&lt;dependency&gt;
	&lt;groupId&gt;javax.servlet&lt;/groupId&gt;
	&lt;artifactId&gt;jstl&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="3">
<li>
<p>创建 webapp 目录</p>
<figure data-type="image" tabindex="13"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200619142557.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>标记为 web 目录</p>
</li>
<li>
<p>创建 JSP</p>
<pre><code class="language-jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot;
language=&quot;java&quot; %&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;Title&lt;/title&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;h2&gt;Hello JSP&lt;/h2&gt;
	&lt;/body&gt;
&lt;/html&gt;
</code></pre>
</li>
<li>
<p>修改配置文件，配置视图解析器</p>
</li>
</ol>
<pre><code class="language-properties">spring.mvc.view.prefix=/WEB-INF/jsp/
spring.mvc.view.suffix=.jsp
</code></pre>
<ol start="7">
<li>
<p>创建 Controller</p>
<pre><code class="language-java">/**
* 页面跳转 Controller
*/
@Controller
public class PageController {
	@GetMapping(&quot;/{page}&quot;)
	public String showPage(@PathVariable String page){
		return page;
	}
}
</code></pre>
<p>​		如果在 IDEA 中项目结构为聚合工程。那么在运行 jsp 是需要指定路径。如果项目结构为独立项目则不需要。</p>
</li>
</ol>
<figure data-type="image" tabindex="14"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200619142830.png" alt="" loading="lazy"></figure>
<h3 id="82-spring-boot-整合-freemarker">8.2 Spring Boot 整合 Freemarker</h3>
<ol>
<li>
<p>创建项目</p>
<figure data-type="image" tabindex="15"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200619143010.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>修改 POM 文件，添加 Freemarker 启动器</p>
<pre><code class="language-xml">&lt;!--Freemarker 启动器依赖--&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;
		&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>创建 User 实体</p>
<pre><code class="language-java">public class User {
    private String userName;
    private String userSex;
    private int userAge;

    public String getUserName() {
        return userName;
    }

    public void setUserName(String userName) {
        this.userName = userName;
    }

    public String getUserSex() {
        return userSex;
    }

    public void setUserSex(String userSex) {
        this.userSex = userSex;
    }

    public int getUserAge() {
        return userAge;
    }

    public void setUserAge(int userAge) {
        this.userAge = userAge;
    }

    public User(String userName, String userSex, int userAge) {
        this.userName = userName;
        this.userSex = userSex;
        this.userAge = userAge;
    }

    public User() {
    }
}
</code></pre>
</li>
<li>
<p>创建 Controller</p>
<pre><code class="language-java">@Controller
public class UserController {
    @GetMapping(&quot;/showUser&quot;)
    public String showUser(Model model) {
        List&lt;User&gt; list = new ArrayList&lt;&gt;();
        list.add(new User(&quot;张三&quot;, &quot;M&quot;, 18));
        list.add(new User(&quot;李四&quot;, &quot;M&quot;, 19));
        list.add(new User(&quot;王五&quot;, &quot;M&quot;, 20));
        model.addAttribute(&quot;list&quot;, list);
        return &quot;userList&quot;;
    }
}
</code></pre>
</li>
<li>
<p>创建视图</p>
<p>userList.ftl</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;table border=&quot;1&quot; align=&quot;center&quot; width=&quot;50%&quot;&gt;
    &lt;tr&gt;
        &lt;th&gt;Name&lt;/th&gt;
        &lt;th&gt;Sex&lt;/th&gt;
        &lt;th&gt;Age&lt;/th&gt;
    &lt;/tr&gt;
    &lt;#--#list是freemarker中迭代list的标记，相当于JSTL中的foreach；
        list as user意思是从list中每迭代一个赋给user属性，然后就可以用user取里面的元素了--&gt;
    &lt;#list list as user&gt;
        &lt;tr&gt;
            &lt;td&gt;${user.userName}&lt;/td&gt;
            &lt;td&gt;${user.userSex}&lt;/td&gt;
            &lt;td&gt;${user.userAge}&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/#list&gt;
&lt;/table&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
</li>
<li>
<p>修改配置文件添加后缀</p>
</li>
</ol>
<pre><code class="language-properties">spring.freemarker.suffix=.ftl
</code></pre>
<h3 id="83-spring-boot-整合-thymeleaf">8.3 Spring Boot 整合 Thymeleaf</h3>
<h4 id="831-thymeleaf-介绍">8.3.1 Thymeleaf 介绍</h4>
<p>​		Thymeleaf 的主要目标是将优雅的自然模板带到开发工作流程中，并将 HTML 在浏览器中正确显示，并且可以作为静态原型，让开发团队能更容易地协作。Thymeleaf 能够处理HTML，XML，JavaScript，CSS 甚至纯文本。<br>
​		长期以来,jsp 在视图领域有非常重要的地位,随着时间的变迁,出现了一位新的挑战者:Thymeleaf,Thymeleaf 是原生的,不依赖于标签库.它能够在接受原始 HTML 的地方进行编辑和渲染.因为它没有与Servelet 规范耦合,因此Thymeleaf 模板能进入jsp 所无法涉足的领域。</p>
<h4 id="832-thymeleaf-基本使用">8.3.2 Thymeleaf 基本使用</h4>
<ol>
<li>
<p>创建项目</p>
<figure data-type="image" tabindex="16"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200619174447.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>修改 POM 文件，添加 Thymeleaf 启动器依赖</p>
</li>
</ol>
<pre><code class="language-xml">&lt;!--添加 Thymeleaf 启动器依赖--&gt;
&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
	&lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="3">
<li>创建 Controller</li>
</ol>
<pre><code class="language-java">/**
* 页面跳转 Controller
*/
@Controller
public class PageController {
	/**
	* 页面跳转方法
	*/
	@GetMapping(&quot;/show&quot;)
	public String showPage(Model model){ model.addAttribute(&quot;msg&quot;,&quot;Hello Thymeleaf&quot;);
		return &quot;index&quot;;
	}
}
</code></pre>
<ol start="4">
<li>创建视图</li>
</ol>
<pre><code class="language-html">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01
Transitional//EN&quot;
&quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;首页&lt;/title&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;span th:text=&quot;标题&quot;&gt;&lt;/span&gt;
		&lt;hr/&gt;
		&lt;span th:text=&quot;${msg}&quot;&gt;&lt;/span&gt;
	&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h4 id="833-thymeleaf-语法讲解">8.3.3 Thymeleaf 语法讲解</h4>
<p>命名空间：xmlns:th=&quot;http://www.thymeleaf.org&quot;</p>
<h5 id="8331-字符串与变量输出操作">8.3.3.1 字符串与变量输出操作</h5>
<ol>
<li>th:text<br>
在页面中输出值</li>
</ol>
<pre><code class="language-html">&lt;span th:text=&quot;${msg}&quot;&gt;&lt;/span&gt;
</code></pre>
<ol start="2">
<li>
<p>th:value<br>
可以将一个值放入到 input 标签的 value 中</p>
<pre><code class="language-html">&lt;input th:value=&quot;${msg}&quot;&gt;
</code></pre>
</li>
</ol>
<h5 id="8332-字符串操作">8.3.3.2 字符串操作</h5>
<p>​		Thymeleaf 提供了一些内置对象，内置对象可直接在模板中使用。这些对象是以#引用的。</p>
<ol>
<li>
<p>使用内置对象的语法</p>
<p>1）引用内置对象需要使用#<br>
2）大部分内置对象的名称都以 s 结尾。如：strings、numbers、dates</p>
<p>${#strings.isEmpty(key)}<br>
判断字符串是否为空，如果为空返回 true，否则返回 false</p>
<p>${#strings.contains(msg,'T')}<br>
判断字符串是否包含指定的子串，如果包含返回 true，否则返回 false</p>
<p>${#strings.startsWith(msg,'a')}<br>
判断当前字符串是否以子串开头，如果是返回 true，否则返回 false</p>
<p>${#strings.endsWith(msg,'a')}<br>
判断当前字符串是否以子串结尾，如果是返回 true，否则返回 false</p>
<p>${#strings.length(msg)}<br>
返回字符串的长度</p>
<p>${#strings.indexOf(msg,'h')}<br>
查找子串的位置，并返回该子串的下标，如果没找到则返回-1</p>
<p><span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;#&#039; at position 2: {#̲strings.substri…'>{#strings.substring(msg,2)}
</span>{#strings.substring(msg,2,5)}<br>
截取子串，用户与 jdk String 类下 SubString 方法相同</p>
<p><span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;#&#039; at position 2: {#̲strings.toUpper…'>{#strings.toUpperCase(msg)}
</span>{#strings.toLowerCase(msg)}<br>
字符串转大小写。</p>
<pre><code class="language-html">	&lt;hr/&gt;
    &lt;span th:text=&quot;${#strings.isEmpty(msg)}&quot;&gt;&lt;/span&gt;
    &lt;hr/&gt;
    &lt;span th:text=&quot;${#strings.contains(msg,'s')}&quot;&gt;&lt;/span&gt;
    &lt;hr/&gt;
    &lt;span th:text=&quot;${#strings.length(msg)}&quot;&gt;&lt;/span&gt;
</code></pre>
</li>
</ol>
<h5 id="8333-日期格式化处理">8.3.3.3 日期格式化处理</h5>
<p>​	${#dates.format(key)}<br>
​	格式化日期，默认的以浏览器默认语言为格式化标准</p>
<p>​	${#dates.format(key,'yyyy/MM/dd')}<br>
​	按照自定义的格式做日期转换</p>
<p>​	${#dates.year(key)}<br>
​	${#dates.month(key)}<br>
​	${#dates.day(key)}<br>
​	Year：取年<br>
​	Month：取月<br>
​	Day：取日</p>
<p>​	```html</p>
<hr/>
```html
<span th:text="${#dates.format(date)}"></span>
<hr/>
<span th:text="${#dates.format(date,'yyyy/MM/dd')}"></span>
<hr/>
<span th:text="${#dates.year(date)}"></span>
<span th:text="${#dates.month(date)}"></span>
<span th:text="${#dates.day(date)}"></span>
<hr/>
```
##### 8.3.3.4 条件判断
<ol>
<li>
<p>th:if</p>
<p>条件判断</p>
<pre><code class="language-html">&lt;div&gt;
        &lt;span th:if=&quot;${sex} == '男'&quot;&gt;
            性别：男
        &lt;/span&gt;
        &lt;span th:if=&quot;${sex} == '女'&quot;&gt;
            性别：女
        &lt;/span&gt;
    &lt;/div&gt;
</code></pre>
</li>
<li>
<p>th:switch / th:case</p>
</li>
</ol>
<p>th:switch / th:case 与 Java 中的 switch 语句等效，有条件地显示匹配的内容。如果有多个匹配结果只选择第一个显示。<br>
th:case=&quot;<em>&quot;表示 Java 中 switch 的 default，即没有 case 的值为 true 时则显示 th:case=&quot;</em>&quot;的内容。</p>
<pre><code class="language-html">&lt;div th:switch=&quot;${id}&quot;&gt;
        &lt;span th:case=&quot;1&quot;&gt;ID为1&lt;/span&gt;
        &lt;span th:case=&quot;2&quot;&gt;ID为2&lt;/span&gt;
        &lt;span th:case=&quot;3&quot;&gt;ID为3&lt;/span&gt;
        &lt;span th:case=&quot;*&quot;&gt;ID为*&lt;/span&gt;
&lt;/div&gt;
</code></pre>
<h5 id="8335-迭代遍历">8.3.3.5 迭代遍历</h5>
<ol>
<li>
<p>th:each</p>
<p>迭代器，用于循环迭代集合</p>
<pre><code class="language-html">&lt;table border=&quot;1&quot; width=&quot;50%&quot;&gt;
        &lt;tr&gt;
            &lt;th&gt;ID&lt;/th&gt;
            &lt;th&gt;Name&lt;/th&gt;
            &lt;th&gt;Age&lt;/th&gt;
        &lt;/tr&gt;
        &lt;tr th:each=&quot;u : ${list}&quot;&gt;
            &lt;td th:text=&quot;${u.id}&quot;&gt;&lt;/td&gt;
            &lt;td th:text=&quot;${u.name}&quot;&gt;&lt;/td&gt;
            &lt;td th:text=&quot;${u.age}&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
</code></pre>
</li>
<li>
<p>th:each 状态变量</p>
<ol>
<li>index:当前迭代器的索引 从 0 开始</li>
<li>count:当前迭代对象的计数 从 1 开始</li>
<li>size:被迭代对象的长度</li>
<li>odd/even:布尔值，当前循环是否是偶数/奇数 从 0 开始</li>
<li>first:布尔值，当前循环的是否是第一条，如果是返回 true 否则返回 false</li>
<li>last:布尔值，当前循环的是否是最后一条，如果是则返回 true 否则返回 false</li>
</ol>
<pre><code class="language-html">&lt;table border=&quot;1&quot; width=&quot;50%&quot;&gt;
        &lt;tr&gt;
            &lt;th&gt;ID&lt;/th&gt;
            &lt;th&gt;Name&lt;/th&gt;
            &lt;th&gt;Age&lt;/th&gt;
            &lt;th&gt;Index&lt;/th&gt;
            &lt;th&gt;Count&lt;/th&gt;
            &lt;th&gt;Size&lt;/th&gt;
            &lt;th&gt;Odd&lt;/th&gt;
            &lt;th&gt;Even&lt;/th&gt;
            &lt;th&gt;First&lt;/th&gt;
            &lt;th&gt;Last&lt;/th&gt;
        &lt;/tr&gt;
    	&lt;!--迭代的状态变量放在第二位 --&gt;
        &lt;tr th:each=&quot;u,suibian : ${list}&quot;&gt;
            &lt;td th:text=&quot;${u.id}&quot;&gt;&lt;/td&gt;
            &lt;td th:text=&quot;${u.name}&quot;&gt;&lt;/td&gt;
            &lt;td th:text=&quot;${u.age}&quot;&gt;&lt;/td&gt;
            &lt;td th:text=&quot;${suibian.index}&quot;&gt;&lt;/td&gt;
            &lt;td th:text=&quot;${suibian.count}&quot;&gt;&lt;/td&gt;
            &lt;td th:text=&quot;${suibian.size}&quot;&gt;&lt;/td&gt;
            &lt;td th:text=&quot;${suibian.odd}&quot;&gt;&lt;/td&gt;
            &lt;td th:text=&quot;${suibian.even}&quot;&gt;&lt;/td&gt;
            &lt;td th:text=&quot;${suibian.first}&quot;&gt;&lt;/td&gt;
            &lt;td th:text=&quot;${suibian.last}&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
</code></pre>
<h5 id="8336-theach-迭代-map">8.3.3.6 th:each 迭代 Map</h5>
</li>
</ol>
<pre><code class="language-html">    &lt;table border=&quot;1&quot; width=&quot;50%&quot;&gt;
        &lt;tr&gt;
            &lt;th&gt;Value&lt;/th&gt;
        &lt;/tr&gt;
        &lt;tr th:each=&quot;m : ${map}&quot;&gt;
            &lt;!--结果是键值对形式--&gt;
            &lt;td th:text=&quot;${m}&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
    &lt;hr/&gt;
    &lt;table border=&quot;1&quot; width=&quot;50%&quot;&gt;
        &lt;tr&gt;
            &lt;th&gt;ID&lt;/th&gt;
            &lt;th&gt;Name&lt;/th&gt;
            &lt;th&gt;Age&lt;/th&gt;
            &lt;th&gt;Key&lt;/th&gt;
        &lt;/tr&gt;
        &lt;tr th:each=&quot;m : ${map}&quot;&gt;
            &lt;td th:text=&quot;${m.value.id}&quot;&gt;&lt;/td&gt;
            &lt;td th:text=&quot;${m.value.name}&quot;&gt;&lt;/td&gt;
            &lt;td th:text=&quot;${m.value.age}&quot;&gt;&lt;/td&gt;
            &lt;td th:text=&quot;${m.key}&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
</code></pre>
<h5 id="8337-操作域对象">8.3.3.7 操作域对象</h5>
<ol>
<li>HttpServletRequest</li>
</ol>
<pre><code class="language-java">request.setAttribute(&quot;req&quot;, &quot;HttpServletRequest&quot;);
</code></pre>
<pre><code class="language-html">&lt;span th:text=&quot;${#httpServletRequest.getAttribute('req')}&quot;&gt;&lt;/span&gt;
&lt;span th:text=&quot;${#request.getAttribute('req')}&quot;&gt;&lt;/span&gt;
</code></pre>
<ol start="2">
<li>HttpSession</li>
</ol>
<pre><code class="language-java">request.getSession().setAttribute(&quot;ses&quot;, &quot;HttpSession&quot;);
</code></pre>
<pre><code class="language-html">&lt;span th:text=&quot;${session.ses}&quot;&gt;&lt;/span&gt;&lt;br/&gt;
&lt;span th:text=&quot;${#session.getAttribute('ses')}&quot;&gt;&lt;/span&gt;&lt;br/&gt;
</code></pre>
<ol start="3">
<li>ServletContext</li>
</ol>
<pre><code class="language-java">request.getSession().getServletContext().setAttribute(&quot;app&quot;,
&quot;Application&quot;);
</code></pre>
<pre><code class="language-html">&lt;span th:text=&quot;${application.app}&quot;&gt;&lt;/span&gt;
&lt;span th:text=&quot;${#servletContext.getAttribute('app')}&quot;&gt;&lt;/span&gt;
</code></pre>
<h5 id="8338-url表达式">8.3.3.8 URL表达式</h5>
<ol>
<li>
<p>语法</p>
<p>在 Thymeleaf 中 URL 表达式的语法格式为@{}</p>
</li>
<li>
<p>URL 类型</p>
<ol>
<li>
<p>绝对路径</p>
<pre><code class="language-html">&lt;a th:href=&quot;@{http://www.baidu.com}&quot;&gt;打开百度&lt;/a&gt;
</code></pre>
</li>
<li>
<p>相对路径</p>
<p>相对于当前项目的根：</p>
<p>controller：</p>
<pre><code class="language-java">//所有超链接都是基于get方式请求的
@GetMapping(&quot;/show2&quot;)
    public String show2(){
        return &quot;index2&quot;;
    }
</code></pre>
<pre><code class="language-html">&lt;a th:href=&quot;@{/show2}&quot;&gt;打开index2&lt;/a&gt;
</code></pre>
<p>相对于服务器路径的根</p>
<pre><code class="language-html">&lt;a th:href=&quot;@{~/project2/resourcename}&quot;&gt;相对于服务器的根&lt;/a&gt;
</code></pre>
</li>
</ol>
</li>
<li>
<p>在 URL 中传递参数</p>
<ol>
<li>
<p>在普通格式的 URL 中传递参数</p>
<p>controller:</p>
</li>
</ol>
</li>
</ol>
<pre><code class="language-java">     model.addAttribute(&quot;id&quot;,&quot;100&quot;);
     model.addAttribute(&quot;name&quot;,&quot;cy&quot;);

   @GetMapping(&quot;/show2&quot;)
   public String show2(String id,String name){
       System.out.println(id+&quot;\t&quot;+name);
       return &quot;index2&quot;;
</code></pre>
<pre><code class="language-html">&lt;!-- url显示为：localhost:8080/show2?id=1&amp;name=admin--&gt; 
&lt;a th:href=&quot;@{/show2?id=1&amp;name=admin}&quot;&gt;普通URL传递参数方式一(参数写死)&lt;/a&gt;

&lt;!--url显示为：localhost:8080/show2?id=1&amp;name=kevin--&gt;
&lt;a th:href=&quot;@{/show2(id=2,name=kevin)}&quot;&gt;普通URL传递参数方式二（括号）&lt;/a&gt;

&lt;!--url显示为：localhost:8080/show2?id=100&amp;name=cy--&gt;
&lt;a th:href=&quot;@{'/show2?id='+${id}+'&amp;name='+${name}}&quot;&gt;普通URL传递参数方式三(拼接)&lt;/a&gt;

&lt;!--url显示为：localhost:8080/show2?id=100&amp;name=cy--&gt;
&lt;a th:href=&quot;@{/show2(id=${id},name=${name})}&quot;&gt;普通URL传递参数方式四（括号）&lt;/a&gt;
</code></pre>
<p>​		2.在 restful 格式的 URL 中传递参数</p>
<p>controller:</p>
<pre><code class="language-java">    @GetMapping(&quot;/show3/{id}/{name}&quot;)
	/*@PathVariable
	获取的是请求路径中参数的值
	@RequestParam
	获取的是请求参数，一般是url问号后面的参数值
	简单类来说@PathVariable是/get/1 @RequestParam是/get?id=1
	*/
    public String show3(@PathVariable String id,@PathVariable String name){
        System.out.println(id+&quot;\t&quot;+name);
        return &quot;index2&quot;;
    }

    @GetMapping(&quot;/show4/{id}&quot;)
    public String show4(@PathVariable String id,String name){
        System.out.println(id+&quot;\t&quot;+name);
        return &quot;index2&quot;;
    }
</code></pre>
<pre><code class="language-html">&lt;!--url显示为：localhost:8080/show3/200--&gt;
&lt;a th:href=&quot;@{/show3/{id}(id=200)}&quot;&gt;restful格式传递参数方式一&lt;/a&gt;

&lt;!--url显示为：localhost:8080/show3/200/admin--&gt;
&lt;a th:href=&quot;@{/show3/{id}/{name}(id=200,name=admin)}&quot;&gt;restful格式传递参数方式二&lt;/a&gt;

&lt;!--url显示为：localhost:8080/show4/200?name=admin--&gt;
&lt;a th:href=&quot;@{/show4/{id}(id=200,name=admin)}&quot;&gt;restful格式传递参数方式三&lt;/a&gt;

&lt;!--url显示为：localhost:8080/show4/200?name=cy--&gt;
&lt;a th:href=&quot;@{/show4/{id}(id=${id},name=${name})}&quot;&gt;restful格式传递参数方式四&lt;/a&gt;

</code></pre>
<p>总结：在（）形式里面都可以用EL表达式进行取值</p>
<h5 id="8339-在配置文件中配置thymeleaf">8.3.3.9 在配置文件中配置Thymeleaf</h5>
<pre><code class="language-properties">spring.thymeleaf.prefix=classpath:/templates/suibian/
spring.thymeleaf.suffix=.html
spring.thymeleaf.mode=HTML #配置视图模板类型，如果视图模板使用的是 html5 需要配置
spring.thymeleaf.encoding=utf-8
spring.thymeleaf.servlet.content-type=text/html #响应类型
#配置页面缓存
spring.thymeleaf.cache=false
</code></pre>
<h2 id="9-spring-boot-整合持久层技术">9、 Spring Boot 整合持久层技术</h2>
<h3 id="91-整合jdbc">9.1 整合JDBC</h3>
<h4 id="911-搭建项目环境">9.1.1 搭建项目环境</h4>
<ol>
<li>
<p>创建表</p>
<pre><code class="language-mysql">CREATE TABLE `users` (
`userid` int(11) NOT NULL AUTO_INCREMENT,
`username` varchar(30) DEFAULT NULL,
`usersex` varchar(10) DEFAULT NULL,
PRIMARY KEY (`userid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
</code></pre>
</li>
<li>
<p>创建项目</p>
</li>
</ol>
<figure data-type="image" tabindex="17"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200620152431.png" alt="" loading="lazy"></figure>
<ol start="3">
<li>
<p>修改pom文件，添加相关依赖</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
	xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
	&lt;parent&gt;
		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
		&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
		&lt;version&gt;2.2.0.RELEASE&lt;/version&gt;
		&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
	&lt;/parent&gt;
	&lt;groupId&gt;com.bjsxt&lt;/groupId&gt;
	&lt;artifactId&gt;springbootjdbc&lt;/artifactId&gt;
	&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
	&lt;name&gt;springbootjdbc&lt;/name&gt;
	&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;

	&lt;properties&gt;
		&lt;java.version&gt;1.8&lt;/java.version&gt;
	&lt;/properties&gt;

	&lt;dependencies&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
		&lt;/dependency&gt;

        &lt;!--Thymeleaf启动器坐标--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--JDBC启动器坐标--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--数据库驱动坐标--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;5.1.38&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--Druid数据源依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid&lt;/artifactId&gt;
            &lt;version&gt;1.1.12&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
			&lt;scope&gt;test&lt;/scope&gt;
			&lt;exclusions&gt;
				&lt;exclusion&gt;
					&lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;
					&lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;
				&lt;/exclusion&gt;
			&lt;/exclusions&gt;
		&lt;/dependency&gt;
	&lt;/dependencies&gt;

	&lt;build&gt;
		&lt;plugins&gt;
			&lt;plugin&gt;
				&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
				&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
			&lt;/plugin&gt;
		&lt;/plugins&gt;
	&lt;/build&gt;

&lt;/project&gt;
</code></pre>
</li>
</ol>
<h4 id="912-配置数据源">9.1.2 配置数据源</h4>
<h5 id="9121-通过自定义配置文件方式配置数据源信息">9.1.2.1 通过自定义配置文件方式配置数据源信息</h5>
<ol>
<li>通过@PropertySource 注解读取配置文件
<ol>
<li>添加 Druid 数据源依赖</li>
</ol>
</li>
</ol>
<pre><code class="language-xml">        &lt;!--Druid数据源依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid&lt;/artifactId&gt;
            &lt;version&gt;1.1.12&lt;/version&gt;
</code></pre>
<p>​		2. 创建 Properties 文件</p>
<p>​		jdbc.properties</p>
<pre><code class="language-properties">jdbc.driverClassName=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false
jdbc.username=root
jdbc.password=root
</code></pre>
<ol start="3">
<li>
<p>创建配置类</p>
<p>JdbcConfiguration类：</p>
<pre><code class="language-java">/**


* 数据源的 JDBC 配置类
*/
@Configuration
@PropertySource(&quot;classpath:/jdbc.properties&quot;) //加载指定的Properties 配置文件
public class JdbcConfiguration {
	@Value(&quot;${jdbc.driverClassName}&quot;)
	private String driverClassName;
	@Value(&quot;${jdbc.url}&quot;)
	private String url;
	@Value(&quot;${jdbc.username}&quot;)
	private String username;
	@Value(&quot;${jdbc.password}&quot;)
	private String password;
	
    /**
	* 实例化 Druid
	*/
	@Bean
	public DataSource getDataSource(){
		DruidDataSource source = new DruidDataSource();
		source.setPassword(this.password);
		source.setUsername(this.username);
		source.setUrl(this.url);
		source.setDriverClassName(this.driverClassName);
		return source;
	}
}
</code></pre>
<ol start="2">
<li>
<p>通过@ConfigurationProperties 注解读取配置信息</p>
<ol>
<li>
<p>创建配置信息实体类</p>
<p>​	JdbcProperties类：</p>
<pre><code class="language-java">/**
 * JDBC配置信息属性类
 */
@ConfigurationProperties(prefix = &quot;jdbc&quot;)//是SpringBoot的注解不能读取其他配置文件，只能读取SpringBoot的application配置文件
public class JdbcProperties {

    private String driverClassName;
    private String url;
    private String username;
    private String password;

    public String getDriverClassName() {
        return driverClassName;
    }

    public void setDriverClassName(String driverClassName) {
        this.driverClassName = driverClassName;
    }

    public String getUrl() {
        return url;
    }

    public void setUrl(String url) {
        this.url = url;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}

</code></pre>
<ol start="2">
<li>
<p>修改配置类</p>
<p>JdbcConfiguration类：</p>
</li>
</ol>
<pre><code class="language-java">/**
 * 数据源的JDBC配置类
 */
//@Configuration
//@PropertySource(&quot;classpath:/jdbc.properties&quot;)  //加载指定的Properties配置文件
@EnableConfigurationProperties(JdbcProperties.class)//指定加载哪个配置信息属性类
public class JdbcConfiguration {

    //@Autowired
   /* private JdbcProperties jdbcProperties;

    //通过构造方法来注入
    public JdbcConfiguration(JdbcProperties jdbcProperties){
        this.jdbcProperties = jdbcProperties;
    }*/

    /**
     * 实例化Druid
     */
    @Bean
    public DataSource getDataSource(JdbcProperties
jdbcProperties){
        DruidDataSource source = new DruidDataSource();
		source.setPassword(this.password);
		source.setUsername(this.username);
		source.setUrl(this.url);		source.setDriverClassName(this.driverClassName);
		return source;
    }
}

</code></pre>
<ol start="3">
<li>
<p><strong>@ConfigurationProperties 注解的优雅使用方式（重点）</strong></p>
<p>JdbcConfiguration类：</p>
</li>
</ol>
<pre><code class="language-java">/**
 * 数据源的JDBC配置类
 */
//@Configuration
//@PropertySource(&quot;classpath:/jdbc.properties&quot;)  //加载指定的Properties配置文件
//@EnableConfigurationProperties(JdbcProperties.class)//指定加载哪个配置信息属性类
public class JdbcConfiguration {

    //@Autowired
   /* private JdbcProperties jdbcProperties;

    //通过构造方法来注入
    public JdbcConfiguration(JdbcProperties jdbcProperties){
        this.jdbcProperties = jdbcProperties;
    }*/

    /**
     * 实例化Druid
     */
    @Bean
    //这个注解会将从配置文件中解析出来的内容，通过调用getDataSource方法所创建的source对象的setUsername、setPassword、setUrl、setDriverClassName这些方法，将解析出来的值直接注入到Datasource中
    @ConfigurationProperties(prefix = &quot;jdbc&quot;)
    public DataSource getDataSource(){
        DruidDataSource source = new DruidDataSource();
        return source;
    }
}

</code></pre>
<p>UserController类：</p>
<pre><code class="language-java">@controller
public class UserController{
    
    @AutoWried
    private DataSource dataSource;
    
    @GetMapping(&quot;/showInfo&quot;)
    public String showInfo(){
        return &quot;ok&quot;;
    }
}
</code></pre>
<p>这时JdbcProperties类没有任何意义了，可以删了。</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h5 id="9122-通过-spring-boot-配置文件配置数据源">9.1.2.2 通过 Spring Boot 配置文件配置数据源</h5>
<p>​		在 Spring Boot1.x 版 本 中 的 spring-boot-starter-jdbc 启 动 器 中 默 认 使 用 的 是org.apache.tomcat.jdbc.pool.DataSource 作为数据源<br>
​		在 Spring Boot2.x 版 本 中 的 spring-boot-starter-jdbc 启 动 器 中 默 认 使 用 的 是com.zaxxer.hikariDataSource 作为数据源</p>
<ol>
<li>
<p>使用 Spring Boot 默认的 HikariDataSource 数据源</p>
<pre><code class="language-properties">spring.datasource.url=jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false
spring.datasource.driver-class-name=com.mysql.jdbc.Driver
spring.datasource.username=root
spring.datasource.password=root
</code></pre>
</li>
<li>
<p>使用第三方的数据源, 如： Druid</p>
<pre><code class="language-properties">spring.datasource.url=jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false
spring.datasource.driver-class-name=com.mysql.jdbc.Driver
spring.datasource.username=root
spring.datasource.password=root
spring.datasource.type=com.alibaba.druid.pool.DruidDataSo
urce
</code></pre>
<p>总结：在SpringBoot中配置数据非常简单，只要在pom文件中加入你想使用的数据源的依赖，并且在配置文件中加入spring.datasource.type这个key，后面跟你所使用数据源value类的全名。</p>
</li>
</ol>
<h4 id="913-详细设计">9.1.3 详细设计</h4>
<figure data-type="image" tabindex="18"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200621040916.png" alt="" loading="lazy"></figure>
<ol>
<li>
<p>视图层：</p>
<p>addUser.html:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form th:action=&quot;@{/user/addUser}&quot; method=&quot;post&quot;&gt;
    username：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br/&gt;
    usersex：&lt;input type=&quot;text&quot; name=&quot;usersex&quot;&gt;&lt;br/&gt;
    &lt;input type=&quot;submit&quot; value=&quot;增加&quot;&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>ok.html:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h2&gt;操作成功！&lt;/h2&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>showUsers.html:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;table border=&quot;1&quot; align=&quot;center&quot;&gt;
    &lt;tr&gt;
        &lt;th&gt;ID&lt;/th&gt;
        &lt;th&gt;姓名&lt;/th&gt;
        &lt;th&gt;性别&lt;/th&gt;
        &lt;th&gt;操作&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr th:each=&quot;u : ${list}&quot;&gt;
        &lt;td th:text=&quot;${u.userid}&quot;&gt;&lt;/td&gt;
        &lt;td th:text=&quot;${u.username}&quot;&gt;&lt;/td&gt;
        &lt;td th:text=&quot;${u.usersex}&quot;&gt;&lt;/td&gt;
        &lt;td&gt;
            &lt;a th:href=&quot;@{/user/preUpdateUser/(id=${u.userid})}&quot;&gt;修改&lt;/a&gt;
            &lt;a th:href=&quot;@{/user/deleteUser(id=${u.userid})}&quot;&gt;删除&lt;/a&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>updateUser.html:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form th:action=&quot;@{/user/updateUser}&quot; method=&quot;post&quot;&gt;
    &lt;input type=&quot;hidden&quot; name=&quot;userid&quot; th:value=&quot;${user.userid}&quot;&gt;
    &lt;input type=&quot;text&quot; name=&quot;username&quot; th:value=&quot;${user.username}&quot;&gt;&lt;br/&gt;
    &lt;input type=&quot;text&quot; name=&quot;usersex&quot; th:value=&quot;${user.usersex}&quot;&gt;&lt;br/&gt;
    &lt;input type=&quot;submit&quot; value=&quot;修改&quot;&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
</li>
<li>
<p>controller层</p>
<p>PageController：</p>
<pre><code class="language-java">/**
 * @date 2020-06-20 17:26
 * 页面跳转
 */
@Controller
public class PageController {
    /*
     * 页面跳转方法
     * */
    @RequestMapping(&quot;/{page}&quot;)
    public String showPage(@PathVariable String page) {
        return page;
    }
}
</code></pre>
<p>UsersController:</p>
<pre><code class="language-java">@Controller
@RequestMapping(&quot;/user&quot;)
public class UsersController {
    @Autowired
    private UsersService usersService;

    /**
     * 添加用户
     *
     * @param users
     * @return
     */
    @PostMapping(&quot;/addUser&quot;)
    public String addUser(Users users) {
        try {
            usersService.addUser(users);
        } catch (Exception e) {
            e.printStackTrace();
            return &quot;error&quot;;
        }
        //重定向，防止表单重复提交
        return &quot;redirect:/ok&quot;;
    }

    /**
     * 查询所有用户
     */
    @GetMapping(&quot;/findUsersAll&quot;)
    public String findUsersAll(Model model) {
        try {
            List&lt;Users&gt; list = usersService.findUsersAll();
            model.addAttribute(&quot;list&quot;, list);
        } catch (Exception e) {
            e.printStackTrace();
            return &quot;error&quot;;
        }
        return &quot;showUsers&quot;;
    }

    /**
     * 预更新用户的查询
     */
    @GetMapping(&quot;/preUpdateUser&quot;)
    public String preUpdateUser(Integer id, Model model) {
        try {
            Users user = usersService.findUserById(id);
            model.addAttribute(&quot;user&quot;, user);
        } catch (Exception e) {
            e.printStackTrace();
            return &quot;error&quot;;
        }
        return &quot;updateUser&quot;;
    }

    /**
     * 更新用户
     */
    @PostMapping(&quot;/updateUser&quot;)
    public String updateUser(Users user){
        try {
            usersService.modifyUser(user);
        } catch (Exception e) {
            e.printStackTrace();
            return &quot;error&quot;;
        }
        return &quot;redirect:/ok&quot;;
    }

    /**
     * 删除用户
     * @param id
     * @return
     */
    @GetMapping(&quot;/deleteUser&quot;)
    public String deleteUser(Integer id){
        try {
            usersService.dropUser(id);
        } catch (Exception e) {
            e.printStackTrace();
            return &quot;error&quot;;
        }
        return &quot;redirect:/ok&quot;;
    }
}
</code></pre>
</li>
<li>
<p>service层</p>
<p>UsersService接口:</p>
<pre><code class="language-java">public interface UsersService {

    void addUser(Users users);

    List&lt;Users&gt; findUsersAll();

    Users findUserById(Integer id);

    void modifyUser(Users user);

    void dropUser(Integer id);
}
</code></pre>
<p>UsersServiceImpl:</p>
<pre><code class="language-java">/**
 * 用户管理业务层
 */
@Service
public class UsersServiceImpl implements UsersService {
    @Autowired
    private UsersDao usersDao;

    /**
     * 添加用户
     *
     * @param users
     */
    @Override
    @Transactional
    public void addUser(Users users) {
        usersDao.insertUsers(users);
    }

    /**
     * 查询所有用户
     *
     * @return
     */
    @Override
    public List&lt;Users&gt; findUsersAll() {
        List&lt;Users&gt; list = usersDao.selectUsersAll();
        return list;
    }

    /**
     * 预更新查询
     *
     * @param id
     * @return
     */
    @Override
    public Users findUserById(Integer id) {
        Users user = usersDao.selectUserById(id);
        return user;
    }

    /**
     * 更新用户
     * @param user
     */
    @Override
    @Transactional
    public void modifyUser(Users user) {
        usersDao.updateUser(user);
    }

    /**
     * 删除用户
     * @param id
     */
    @Override
    @Transactional
    public void dropUser(Integer id) {
        usersDao.delUserById(id);
    }
}

</code></pre>
</li>
<li>
<p>dao层</p>
<p>UsersDao接口：</p>
<pre><code class="language-java">public interface UsersDao {
    
    void insertUsers(Users users);

    List&lt;Users&gt; selectUsersAll();

    Users selectUserById(Integer id);

    void updateUser(Users user);

    void delUserById(Integer id);
}

</code></pre>
<p>UsersDaImpl：</p>
<pre><code class="language-java">/**
 * 持久层
 */
@Repository
public class UsersDaImpl implements UsersDao {
    @Autowired
    private JdbcTemplate jdbcTemplate;

    /**
     * 添加用户
     *
     * @param users
     */
    @Override
    public void insertUsers(Users users) {
        String sql = &quot;insert into users(username,usersex) values(?,?)&quot;;
        jdbcTemplate.update(sql, users.getUsername(), users.getUsersex());
    }

    @Override
    public List&lt;Users&gt; selectUsersAll() {
        String sql = &quot;select * from users&quot;;
        return jdbcTemplate.query(sql, new RowMapper&lt;Users&gt;() {
            /**
             * 结果集映射
             * @param resultSet
             * @param i
             * @return
             * @throws SQLException
             */
            @Override
            public Users mapRow(ResultSet resultSet, int i) throws SQLException {
                Users users = new Users();
                //自己做ORM的处理
                users.setUserid(resultSet.getInt(&quot;userid&quot;));
                users.setUsername(resultSet.getString(&quot;username&quot;));
                users.setUsersex(resultSet.getString(&quot;usersex&quot;));
                return users;
            }
        });
    }

    /**
     * 预更新用户查询
     *
     * @param id
     * @return
     */
    @Override
    public Users selectUserById(Integer id) {
        Users user = new Users();
        String sql = &quot;select * from users where userid=?&quot;;
        Object[] objects = new Object[]{id};
        jdbcTemplate.query(sql, objects, new RowCallbackHandler() {
            @Override
            public void processRow(ResultSet resultSet) throws SQLException {
                user.setUserid(resultSet.getInt(&quot;userid&quot;));
                user.setUsername(resultSet.getString(&quot;username&quot;));
                user.setUsersex(resultSet.getString(&quot;usersex&quot;));
            }
        });
        return user;
    }

    /**
     * 更新用户
     *
     * @param user
     */
    @Override
    public void updateUser(Users user) {
        String sql = &quot;update users set username=?,usersex=? where userid=?&quot;;
        jdbcTemplate.update(sql, user.getUsername(), user.getUsersex(), user.getUserid());
    }

    /**
     * 删除用户
     *
     * @param id
     */
    @Override
    public void delUserById(Integer id) {
        String sql = &quot;delete from users where userid = ? &quot;;
        jdbcTemplate.update(sql,id);
    }
}
</code></pre>
<p>实现效果：</p>
<figure data-type="image" tabindex="19"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200621040455.png" alt="" loading="lazy"></figure>
</li>
</ol>
<figure data-type="image" tabindex="20"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200621040539.png" alt="" loading="lazy"></figure>
<p>​	<img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200621040622.png" alt="" loading="lazy"></p>
<figure data-type="image" tabindex="21"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200621040708.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="22"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200621040728.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="23"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200621040803.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="24"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200621040823.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="25"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200621040839.png" alt="" loading="lazy"></figure>
<h3 id="92-整合mybatis">9.2 整合MyBatis</h3>
<h4 id="921-搭建项目环境">9.2.1 搭建项目环境</h4>
<ol>
<li>
<p>创建项目</p>
<figure data-type="image" tabindex="26"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200622005620.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>修改POM文件，添加相关依赖</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
	xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
	&lt;parent&gt;
		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
		&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
		&lt;version&gt;2.3.1.RELEASE&lt;/version&gt;
		&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
	&lt;/parent&gt;
	&lt;groupId&gt;com.cy&lt;/groupId&gt;
	&lt;artifactId&gt;springbootmybatis&lt;/artifactId&gt;
	&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
	&lt;name&gt;springbootmybatis&lt;/name&gt;
	&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;

	&lt;properties&gt;
		&lt;java.version&gt;1.8&lt;/java.version&gt;
	&lt;/properties&gt;

	&lt;dependencies&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
			&lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
			&lt;version&gt;2.1.3&lt;/version&gt;
		&lt;/dependency&gt;
		&lt;!--数据库驱动坐标--&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;mysql&lt;/groupId&gt;
			&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
			&lt;version&gt;5.1.38&lt;/version&gt;
		&lt;/dependency&gt;
		&lt;!--Druid 数据源依赖--&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;com.alibaba&lt;/groupId&gt;
			&lt;artifactId&gt;druid&lt;/artifactId&gt;
			&lt;version&gt;1.1.12&lt;/version&gt;
		&lt;/dependency&gt;

		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
			&lt;scope&gt;test&lt;/scope&gt;
			&lt;exclusions&gt;
				&lt;exclusion&gt;
					&lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;
					&lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;
				&lt;/exclusion&gt;
			&lt;/exclusions&gt;
		&lt;/dependency&gt;
	&lt;/dependencies&gt;

	&lt;build&gt;
		&lt;plugins&gt;
			&lt;plugin&gt;
				&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
				&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
			&lt;/plugin&gt;
		&lt;/plugins&gt;
	&lt;/build&gt;

&lt;/project&gt;

</code></pre>
<ol start="3">
<li>
<p>配置数据源</p>
<pre><code class="language-yaml">spring:
  datasource:
    driver-class-name: com.mysql.jdbc.Driver
    url: jdbc:mysql://localhost:3306/test02?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false
    data-username: root
    data-password: root
    type: com.alibaba.druid.pool.DruidDataSource

</code></pre>
</li>
</ol>
</li>
</ol>
<h4 id="922-配置-maven-的-generator-插件">9.2.2 配置 Maven 的 generator 插件</h4>
<ol>
<li>
<p>添加 generator 插件坐标</p>
<pre><code class="language-xml">    &lt;plugin&gt;
        &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId
        &lt;version&gt;1.3.5&lt;/version&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;mysql&lt;/groupId&gt;
                &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
                &lt;version&gt;5.1.38&lt;/version&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
        &lt;!--指定配置文件的路径--&gt;
        &lt;configuration&gt;
            &lt;configurationFile&gt;${project.basedir}/src/main/res
            &lt;/configurationFile&gt;
            &lt;verbose&gt;true&lt;/verbose&gt;
            &lt;overwrite&gt;true&lt;/overwrite&gt;
        &lt;/configuration&gt;
    &lt;/plugin&gt;
</code></pre>
</li>
<li>
<p>添加 generator 配置文件</p>
<figure data-type="image" tabindex="27"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200622010708.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>添加 generator 配置文件的 DTD 文件</p>
</li>
</ol>
<figure data-type="image" tabindex="28"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200622010812.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="29"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200622011008.png" alt="" loading="lazy"></figure>
<ol start="4">
<li>
<p>运行 generator 插件生成代码</p>
<figure data-type="image" tabindex="30"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200622011545.png" alt="" loading="lazy"></figure>
</li>
</ol>
<figure data-type="image" tabindex="31"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200622011732.png" alt="" loading="lazy"></figure>
<h4 id="923-配置资源拷贝插件">9.2.3 配置资源拷贝插件</h4>
<p>​		由于映射配置文件在自定义包中，项目运行时在resources中找不到映射配置文件，所以要配置资源拷贝插件</p>
<ol>
<li>
<p>添加资源拷贝插件坐标</p>
<pre><code class="language-xml"> &lt;!--配置资源拷贝插件--&gt;
 &lt;resources&gt;
     &lt;resource&gt;
         &lt;directory&gt;src/main/java&lt;/directory&gt;
         &lt;includes&gt;
             &lt;include&gt;**/*.xml&lt;/include&gt;
         &lt;/includes&gt;
     &lt;/resource&gt;
     &lt;!--由于前面配置了路径，这样就不到到resources目录下处理文件，所以还要配置resources目录--&gt;
     &lt;resource&gt;
         &lt;directory&gt;src/main/resources&lt;/directory&gt;
         &lt;includes&gt;
             &lt;include&gt;**/*.yml&lt;/include&gt;
             &lt;include&gt;**/*.properties&lt;/include&gt;
             &lt;!--加载模板文件--&gt;
             &lt;include&gt;**/*.html&lt;/include&gt;
             &lt;!--加载静态文件--&gt;
             &lt;include&gt;/static/&lt;/include&gt;
         &lt;/includes&gt;
     &lt;/resource&gt;
 &lt;/resources&gt;
</code></pre>
</li>
<li>
<p>修改启动类添加@MapperScan 注解</p>
<pre><code class="language-java">@SpringBootApplication
@MapperScan(&quot;com.cy.springbootmybatis.mapper&quot;)//指定扫描接口与映射配置文件的包名
public class SpringbootmybatisApplication {

	public static void main(String[] args) {
		SpringApplication.run(SpringbootmybatisApplication.class, args);
	}

}
</code></pre>
</li>
</ol>
<h4 id="924-mybatis-的其他配置项">9.2.4 MyBatis 的其他配置项</h4>
<pre><code class="language-yaml">mybatis:
#扫描 classpath 中 mapper 目录下的映射配置文件，针对于映射配置文件放到了 resources 目录下
	mapper-locations: classpath:/mapper/*.xml
#定义包别名，使用 pojo 时可以直接使用 pojo 的类型名称不用加包名
	type-aliases-package: com.bjsxt.springbootmybatis.pojo
</code></pre>
<p>由于本项目mapper目录不在resources目录下，且已经在启动类中添加了@MapperScan注解，故本项目不需要此配置</p>
<h4 id="925-详细设计">9.2.5 详细设计</h4>
<figure data-type="image" tabindex="32"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200622091922.png" alt="" loading="lazy"></figure>
<ol>
<li>
<p>视图层</p>
<p>addUser.html:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form th:action=&quot;@{/user/addUser}&quot; method=&quot;post&quot;&gt;
    username：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br/&gt;
    usersex：&lt;input type=&quot;text&quot; name=&quot;usersex&quot;&gt;&lt;br/&gt;
    &lt;input type=&quot;submit&quot; value=&quot;增加&quot;&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>ok.html:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h2&gt;成功！&lt;/h2&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>showUsers.html:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;table border=&quot;1&quot; align=&quot;center&quot;&gt;
    &lt;tr&gt;
        &lt;th&gt;ID&lt;/th&gt;
        &lt;th&gt;姓名&lt;/th&gt;
        &lt;th&gt;性别&lt;/th&gt;
        &lt;th&gt;操作&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr th:each=&quot;u : ${list}&quot;&gt;
        &lt;td th:text=&quot;${u.userid}&quot;&gt;&lt;/td&gt;
        &lt;td th:text=&quot;${u.username}&quot;&gt;&lt;/td&gt;
        &lt;td th:text=&quot;${u.usersex}&quot;&gt;&lt;/td&gt;
        &lt;td&gt;
            &lt;a th:href=&quot;@{/user/preUpdateUser(id=${u.userid})}&quot;&gt;修改&lt;/a&gt;
            &lt;a th:href=&quot;@{/user/deleteUser(id=${u.userid})}&quot;&gt;删除&lt;/a&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>updateUser.html:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form th:action=&quot;@{/user/updateUser}&quot; method=&quot;post&quot;&gt;
    &lt;input type=&quot;hidden&quot; name=&quot;userid&quot; th:value=&quot;${user.userid}&quot;&gt;
    &lt;input type=&quot;text&quot; name=&quot;username&quot; th:value=&quot;${user.username}&quot;&gt;&lt;br/&gt;
    &lt;input type=&quot;text&quot; name=&quot;usersex&quot; th:value=&quot;${user.usersex}&quot;&gt;&lt;br/&gt;
    &lt;input type=&quot;submit&quot; value=&quot;修改&quot;&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
</li>
<li>
<p>控制层</p>
<p>PageController:</p>
<pre><code class="language-java">/**
 * 页面跳转controller
 */
@Controller
public class PageController {

    /**
     * 页面跳转方法
     */
    @RequestMapping(&quot;/{page}&quot;)
    public String showPage(@PathVariable String page) {
        return page;
    }
}
</code></pre>
<p>UsersController:</p>
<pre><code class="language-java">/**
 * 用户管理controller
 */
@Controller
@RequestMapping(&quot;/user&quot;)
public class UsersController {

    @Autowired
    private UsersService usersService;
    /**
     * 添加用户
     */
    @PostMapping(&quot;/addUser&quot;)
    public String addUsers(Users users){
        try {
            usersService.addUsers(users);
        }catch (Exception e){
            e.printStackTrace();
            return &quot;error&quot;;
        }
        return &quot;redirect:/ok&quot;;
    }

    /**
     * 查询全部用户
     */
    @GetMapping(&quot;/findUsersAll&quot;)
    public String findUsersAll(Model model){
        try {
            List&lt;Users&gt; list = usersService.findUsersAll();
            model.addAttribute(&quot;list&quot;,list);
        }catch (Exception e){
            e.printStackTrace();
            return &quot;error&quot;;
        }
        return &quot;showUsers&quot;;
    }

    /**
     * 预更新用户的查询
     */
    @GetMapping(&quot;/preUpdateUser&quot;)
    public String preUpdateUser(Integer id,Model model){
        try {
            Users user = usersService.findUserById(id);
            model.addAttribute(&quot;user&quot;,user);
        }catch (Exception e){
            e.printStackTrace();
            return &quot;error&quot;;
        }
        return &quot;updateUser&quot;;
    }

    /**
     * 修改用户
     */
    @PostMapping(&quot;/updateUser&quot;)
    public String updateUser(Users user){
        try {
            usersService.updateUser(user);
        }catch (Exception e){
            e.printStackTrace();
            return &quot;error&quot;;
        }
        return &quot;redirect:/ok&quot;;
    }

    /**
     * 删除用户
     */
    @GetMapping(&quot;/deleteUser&quot;)
    public String deleteUser(Integer id){
        try {
            usersService.deleteUser(id);
        }catch (Exception e){
            e.printStackTrace();
            return &quot;error&quot;;
        }
        return &quot;redirect:/ok&quot;;
    }
}
</code></pre>
</li>
<li>
<p>service层</p>
<p>UsersService接口：</p>
<pre><code class="language-java">public interface UsersService {

    void addUsers(Users user);

    List&lt;Users&gt; findUsersAll();

    Users findUserById(Integer id);

    void updateUser(Users user);

    void deleteUser(Integer id);
}
</code></pre>
<p>UsersServiceImpl类：</p>
<pre><code class="language-java">/**
 * 用户管理业务层
 */
@Service
public class UsersServiceImpl implements UsersService {
    @Autowired
    private UsersMapper usersMapper;

    /**
     * 增加用户
     * @param users
     */
    @Override
    public void addUsers(Users users) {
        usersMapper.insert(users);
    }

    /**
     * 查询所有用户
     * @return
     */
    @Override
    public List&lt;Users&gt; findUsersAll() {
        UsersExample usersExample = new UsersExample();
        return usersMapper.selectByExample(usersExample);
    }

    /**
     * 预更新用户的查询
     * @param id
     * @return
     */
    @Override
    public Users findUserById(Integer id) {
        Users user = usersMapper.selectByPrimaryKey(id);
        return user;
    }

    /**
     * 修改用户
     */
    @Override
    public void updateUser(Users user) {
        usersMapper.updateByPrimaryKey(user);
    }

    /**
     * 删除用户
     * @param id
     */
    @Override
    public void deleteUser(Integer id) {
        usersMapper.deleteByPrimaryKey(id);
    }

}
</code></pre>
</li>
<li>
<p>mapper(generator插件自动生成)</p>
<p>UsersMapper.xml:</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.cy.springbootmybatis.mapper.UsersMapper&quot;&gt;
  &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.cy.springbootmybatis.pojo.Users&quot;&gt;
    &lt;id column=&quot;userid&quot; jdbcType=&quot;INTEGER&quot; property=&quot;userid&quot; /&gt;
    &lt;result column=&quot;username&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;username&quot; /&gt;
    &lt;result column=&quot;usersex&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;usersex&quot; /&gt;
  &lt;/resultMap&gt;
  &lt;sql id=&quot;Example_Where_Clause&quot;&gt;
    &lt;where&gt;
      &lt;foreach collection=&quot;oredCriteria&quot; item=&quot;criteria&quot; separator=&quot;or&quot;&gt;
        &lt;if test=&quot;criteria.valid&quot;&gt;
          &lt;trim prefix=&quot;(&quot; prefixOverrides=&quot;and&quot; suffix=&quot;)&quot;&gt;
            &lt;foreach collection=&quot;criteria.criteria&quot; item=&quot;criterion&quot;&gt;
              &lt;choose&gt;
                &lt;when test=&quot;criterion.noValue&quot;&gt;
                  and ${criterion.condition}
                &lt;/when&gt;
                &lt;when test=&quot;criterion.singleValue&quot;&gt;
                  and ${criterion.condition} #{criterion.value}
                &lt;/when&gt;
                &lt;when test=&quot;criterion.betweenValue&quot;&gt;
                  and ${criterion.condition} #{criterion.value} and #{criterion.secondValue}
                &lt;/when&gt;
                &lt;when test=&quot;criterion.listValue&quot;&gt;
                  and ${criterion.condition}
                  &lt;foreach close=&quot;)&quot; collection=&quot;criterion.value&quot; item=&quot;listItem&quot; open=&quot;(&quot; separator=&quot;,&quot;&gt;
                    #{listItem}
                  &lt;/foreach&gt;
                &lt;/when&gt;
              &lt;/choose&gt;
            &lt;/foreach&gt;
          &lt;/trim&gt;
        &lt;/if&gt;
      &lt;/foreach&gt;
    &lt;/where&gt;
  &lt;/sql&gt;
  &lt;sql id=&quot;Update_By_Example_Where_Clause&quot;&gt;
    &lt;where&gt;
      &lt;foreach collection=&quot;example.oredCriteria&quot; item=&quot;criteria&quot; separator=&quot;or&quot;&gt;
        &lt;if test=&quot;criteria.valid&quot;&gt;
          &lt;trim prefix=&quot;(&quot; prefixOverrides=&quot;and&quot; suffix=&quot;)&quot;&gt;
            &lt;foreach collection=&quot;criteria.criteria&quot; item=&quot;criterion&quot;&gt;
              &lt;choose&gt;
                &lt;when test=&quot;criterion.noValue&quot;&gt;
                  and ${criterion.condition}
                &lt;/when&gt;
                &lt;when test=&quot;criterion.singleValue&quot;&gt;
                  and ${criterion.condition} #{criterion.value}
                &lt;/when&gt;
                &lt;when test=&quot;criterion.betweenValue&quot;&gt;
                  and ${criterion.condition} #{criterion.value} and #{criterion.secondValue}
                &lt;/when&gt;
                &lt;when test=&quot;criterion.listValue&quot;&gt;
                  and ${criterion.condition}
                  &lt;foreach close=&quot;)&quot; collection=&quot;criterion.value&quot; item=&quot;listItem&quot; open=&quot;(&quot; separator=&quot;,&quot;&gt;
                    #{listItem}
                  &lt;/foreach&gt;
                &lt;/when&gt;
              &lt;/choose&gt;
            &lt;/foreach&gt;
          &lt;/trim&gt;
        &lt;/if&gt;
      &lt;/foreach&gt;
    &lt;/where&gt;
  &lt;/sql&gt;
  &lt;sql id=&quot;Base_Column_List&quot;&gt;
    userid, username, usersex
  &lt;/sql&gt;
  &lt;select id=&quot;selectByExample&quot; parameterType=&quot;com.cy.springbootmybatis.pojo.UsersExample&quot; resultMap=&quot;BaseResultMap&quot;&gt;
    select
    &lt;if test=&quot;distinct&quot;&gt;
      distinct
    &lt;/if&gt;
    &lt;include refid=&quot;Base_Column_List&quot; /&gt;
    from users
    &lt;if test=&quot;_parameter != null&quot;&gt;
      &lt;include refid=&quot;Example_Where_Clause&quot; /&gt;
    &lt;/if&gt;
    &lt;if test=&quot;orderByClause != null&quot;&gt;
      order by ${orderByClause}
    &lt;/if&gt;
  &lt;/select&gt;
  &lt;select id=&quot;selectByPrimaryKey&quot; parameterType=&quot;java.lang.Integer&quot; resultMap=&quot;BaseResultMap&quot;&gt;
    select 
    &lt;include refid=&quot;Base_Column_List&quot; /&gt;
    from users
    where userid = #{userid,jdbcType=INTEGER}
  &lt;/select&gt;
  &lt;delete id=&quot;deleteByPrimaryKey&quot; parameterType=&quot;java.lang.Integer&quot;&gt;
    delete from users
    where userid = #{userid,jdbcType=INTEGER}
  &lt;/delete&gt;
  &lt;delete id=&quot;deleteByExample&quot; parameterType=&quot;com.cy.springbootmybatis.pojo.UsersExample&quot;&gt;
    delete from users
    &lt;if test=&quot;_parameter != null&quot;&gt;
      &lt;include refid=&quot;Example_Where_Clause&quot; /&gt;
    &lt;/if&gt;
  &lt;/delete&gt;
  &lt;insert id=&quot;insert&quot; parameterType=&quot;com.cy.springbootmybatis.pojo.Users&quot;&gt;
    insert into users (userid, username, usersex
      )
    values (#{userid,jdbcType=INTEGER}, #{username,jdbcType=VARCHAR}, #{usersex,jdbcType=VARCHAR}
      )
  &lt;/insert&gt;
  &lt;insert id=&quot;insertSelective&quot; parameterType=&quot;com.cy.springbootmybatis.pojo.Users&quot;&gt;
    insert into users
    &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt;
      &lt;if test=&quot;userid != null&quot;&gt;
        userid,
      &lt;/if&gt;
      &lt;if test=&quot;username != null&quot;&gt;
        username,
      &lt;/if&gt;
      &lt;if test=&quot;usersex != null&quot;&gt;
        usersex,
      &lt;/if&gt;
    &lt;/trim&gt;
    &lt;trim prefix=&quot;values (&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt;
      &lt;if test=&quot;userid != null&quot;&gt;
        #{userid,jdbcType=INTEGER},
      &lt;/if&gt;
      &lt;if test=&quot;username != null&quot;&gt;
        #{username,jdbcType=VARCHAR},
      &lt;/if&gt;
      &lt;if test=&quot;usersex != null&quot;&gt;
        #{usersex,jdbcType=VARCHAR},
      &lt;/if&gt;
    &lt;/trim&gt;
  &lt;/insert&gt;
  &lt;select id=&quot;countByExample&quot; parameterType=&quot;com.cy.springbootmybatis.pojo.UsersExample&quot; resultType=&quot;java.lang.Long&quot;&gt;
    select count(*) from users
    &lt;if test=&quot;_parameter != null&quot;&gt;
      &lt;include refid=&quot;Example_Where_Clause&quot; /&gt;
    &lt;/if&gt;
  &lt;/select&gt;
  &lt;update id=&quot;updateByExampleSelective&quot; parameterType=&quot;map&quot;&gt;
    update users
    &lt;set&gt;
      &lt;if test=&quot;record.userid != null&quot;&gt;
        userid = #{record.userid,jdbcType=INTEGER},
      &lt;/if&gt;
      &lt;if test=&quot;record.username != null&quot;&gt;
        username = #{record.username,jdbcType=VARCHAR},
      &lt;/if&gt;
      &lt;if test=&quot;record.usersex != null&quot;&gt;
        usersex = #{record.usersex,jdbcType=VARCHAR},
      &lt;/if&gt;
    &lt;/set&gt;
    &lt;if test=&quot;_parameter != null&quot;&gt;
      &lt;include refid=&quot;Update_By_Example_Where_Clause&quot; /&gt;
    &lt;/if&gt;
  &lt;/update&gt;
  &lt;update id=&quot;updateByExample&quot; parameterType=&quot;map&quot;&gt;
    update users
    set userid = #{record.userid,jdbcType=INTEGER},
      username = #{record.username,jdbcType=VARCHAR},
      usersex = #{record.usersex,jdbcType=VARCHAR}
    &lt;if test=&quot;_parameter != null&quot;&gt;
      &lt;include refid=&quot;Update_By_Example_Where_Clause&quot; /&gt;
    &lt;/if&gt;
  &lt;/update&gt;
  &lt;update id=&quot;updateByPrimaryKeySelective&quot; parameterType=&quot;com.cy.springbootmybatis.pojo.Users&quot;&gt;
    update users
    &lt;set&gt;
      &lt;if test=&quot;username != null&quot;&gt;
        username = #{username,jdbcType=VARCHAR},
      &lt;/if&gt;
      &lt;if test=&quot;usersex != null&quot;&gt;
        usersex = #{usersex,jdbcType=VARCHAR},
      &lt;/if&gt;
    &lt;/set&gt;
    where userid = #{userid,jdbcType=INTEGER}
  &lt;/update&gt;
  &lt;update id=&quot;updateByPrimaryKey&quot; parameterType=&quot;com.cy.springbootmybatis.pojo.Users&quot;&gt;
    update users
    set username = #{username,jdbcType=VARCHAR},
      usersex = #{usersex,jdbcType=VARCHAR}
    where userid = #{userid,jdbcType=INTEGER}
  &lt;/update&gt;
&lt;/mapper&gt;
</code></pre>
<p>UsersMapper接口:</p>
<pre><code class="language-java">public interface UsersMapper {
    long countByExample(UsersExample example);

    int deleteByExample(UsersExample example);

    int deleteByPrimaryKey(Integer userid);

    int insert(Users record);

    int insertSelective(Users record);

    List&lt;Users&gt; selectByExample(UsersExample example);

    Users selectByPrimaryKey(Integer userid);

    int updateByExampleSelective(@Param(&quot;record&quot;) Users record, @Param(&quot;example&quot;) UsersExample example);

    int updateByExample(@Param(&quot;record&quot;) Users record, @Param(&quot;example&quot;) UsersExample example);

    int updateByPrimaryKeySelective(Users record);

    int updateByPrimaryKey(Users record);
}
</code></pre>
</li>
</ol>
<h2 id="10-springboot-中异常处理与单元测试">10、 SpringBoot 中异常处理与单元测试</h2>
<h3 id="101-异常处理">10.1 异常处理</h3>
<p>SpringBoot 中对于异常处理提供了五种处理方式</p>
<h4 id="1011-自定义错误页面">10.1.1 自定义错误页面</h4>
<p>SpringBoot 默认的处理异常的机制：SpringBoot 默认的已经提供了一套处理异常的机制。一旦程序中出现了异常 SpringBoot 会向/error 的 url 发送请求。在 SpringBoot 中提供了一个名为 BasicErrorController 来处理/error 请求，然后跳转到默认显示异常的页面来展示异常信息。<br>
如 果 我 们 需 要 将 所 有 的 异 常 同 一 跳 转 到 自 定 义 的 错 误 页 面 ， 需 要 再src/main/resources/templates 目录下创建 error.html 页面。注意：页面名称必须叫 error</p>
<h4 id="1012-通过exceptionhandler-注解处理异常">10.1.2 通过@ExceptionHandler 注解处理异常</h4>
<ol>
<li>
<p>修改 Controller</p>
<pre><code class="language-java">@Controller
public class UsersController {
    @RequestMapping(&quot;showInfo&quot;)
    public String showInfo() {
        String str = null;
        str.length();
        return &quot;ok&quot;;
    }

    @ExceptionHandler(value = {java.lang.NullPointerException.class})
    public ModelAndView nullpointExcepitonHandler(Exception e) {
        ModelAndView mv = new ModelAndView();
        mv.addObject(&quot;err&quot;, e.toString());
        mv.setViewName(&quot;error1&quot;);
        return mv;
    }
}

</code></pre>
<ol start="2">
<li>
<p>创建页面</p>
<pre><code class="language-html">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01
Transitional//EN&quot;
&quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
&lt;title&gt;error1&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
出错了。。。
&lt;span th:text=&quot;${err}&quot;/&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
</li>
</ol>
</li>
</ol>
<h4 id="1013-通过controlleradvice-与exceptionhandler-注解处理异常">10.1.3 通过@ControllerAdvice 与@ExceptionHandler 注解处理异常</h4>
<ol>
<li>
<p>创建全局异常处理类</p>
<pre><code class="language-java">/**
 * 全局异常处理类
 */
@ControllerAdvice
public class GlobalException {
    @ExceptionHandler(value = {java.lang.NullPointerException.class} )
    public ModelAndView nullpointExcepitonHandler(Exception e){
        ModelAndView mv = new ModelAndView();
        mv.addObject(&quot;err&quot;,e.toString());
        mv.setViewName(&quot;error1&quot;);
        return mv;

    }
    @ExceptionHandler(value = {java.lang.ArithmeticException.class} )
    public ModelAndView arithmeticExceptionHandler(Exception e){
        ModelAndView mv = new ModelAndView();
        mv.addObject(&quot;err&quot;, e.toString());
        mv.setViewName(&quot;error2&quot;);
        return mv;
    }
}
</code></pre>
</li>
</ol>
<h4 id="1014-通过-simplemappingexceptionresolver-对象处理异常">10.1.4 通过 SimpleMappingExceptionResolver 对象处理异常</h4>
<ol>
<li>
<p>创建全局异常处理类</p>
<pre><code class="language-java">@Configuration
public class GlobalException2 {

    /**
     * 此方法返回值必须是 SimpleMappingExceptionResolver 对象
     * @return
     */
    @Bean
    public SimpleMappingExceptionResolver getSimpleMappingExceptionResolver() {
        SimpleMappingExceptionResolver resolver = new SimpleMappingExceptionResolver();
        Properties properties = new Properties();
    /**
    * 参数一：异常类型，并且是全名
    * 参数二：视图名称
    */
        properties.put(&quot;java.lang.NullPointerException&quot;, &quot;error3&quot;);
        properties.put(&quot;java.lang.ArithmeticException&quot;, &quot;error4&quot;);

        resolver.setExceptionMappings(properties);
        return resolver;
    }
}
</code></pre>
<p>缺点：不能传递异常信息</p>
</li>
</ol>
<h4 id="1015-通过自定义-handlerexceptionresolver-对象处理异常推荐">10.1.5 通过自定义 HandlerExceptionResolver 对象处理异常（推荐）</h4>
<ol>
<li>
<p>创建全局异常处理类</p>
<pre><code class="language-java">/**
 * 自定义 HandlerExceptionResolver 对象处理异常
 * 必须要实现 HandlerExceptionResolver
 */
@Configuration
public class GlobalException3 implements HandlerExceptionResolver {
    @Override
    public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object handler, Exception e) {
        ModelAndView mv = new ModelAndView();
        //判断不同异常类型，做不同视图的跳转
        if (e instanceof NullPointerException) {
            mv.setViewName(&quot;error5&quot;);
        }
        if (e instanceof ArithmeticException) {
            mv.setViewName(&quot;error6&quot;);
        }
        mv.addObject(&quot;error&quot;, e.toString());
        return mv;
    }
}
</code></pre>
<h3 id="102-spring-boot-整合-junit-单元测试">10.2 Spring Boot 整合 Junit 单元测试</h3>
<p>SpringBoot2.x 使用 Junit5 作为测试平台</p>
<ol>
<li>
<p>修改 POM 文件添加 Test 启动器</p>
<pre><code class="language-xml">&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
	&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
	&lt;scope&gt;test&lt;/scope&gt;
	&lt;!--junit-vintage-engine 提供了 Junit3 与 Junit4 的运行平台--&gt;
	&lt;exclusions&gt;
		&lt;exclusion&gt;
			&lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;
			&lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;
		&lt;/exclusion&gt;
	&lt;/exclusions&gt;
&lt;/dependency&gt;
</code></pre>
</li>
</ol>
</li>
<li>
<p>编写测试代码</p>
<pre><code class="language-java">@SpringBootTest
class SpringbootexcepionandjunitApplicationTests {
	@Autowired
	private UsersServiceImpl usersService;
	@Test
	void suibian() {
		this.usersService.addUser();
	}
}
</code></pre>
</li>
</ol>
<h2 id="11-spring-boot-服务端数据校验">11、 Spring Boot 服务端数据校验</h2>
<h3 id="111-spring-boot-对实体对象的校验">11.1 Spring Boot 对实体对象的校验</h3>
<h4 id="1111-搭建项目环境">11.1.1 搭建项目环境</h4>
<ol>
<li>
<p>创建项目</p>
<figure data-type="image" tabindex="33"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200622113358.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>创建实体</p>
<pre><code class="language-java">
public class Users {
    private  Integer userid;
    private String username;
    private String usersex;

    public Integer getUserid() {
        return userid;
    }

    public void setUserid(Integer userid) {
        this.userid = userid;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getUsersex() {
        return usersex;
    }

    public void setUsersex(String usersex) {
        this.usersex = usersex;
    }

    @Override
    public String toString() {
        return &quot;Users{&quot; +
                &quot;userid=&quot; + userid +
                &quot;, username='&quot; + username + '\'' +
                &quot;, usersex='&quot; + usersex + '\'' +
                '}';
    }
}

</code></pre>
</li>
<li>
<p>创建Controller</p>
<pre><code class="language-java">@Controller
@RequestMapping(&quot;/user&quot;)
public class UsersController {
	/**
	* 添加用户
	*/
	@RequestMapping(&quot;/addUser&quot;)
	public String addUser(Users users){
		System.out.println(users);
		return &quot;ok&quot;;
	}
}
</code></pre>
</li>
<li>
<p>创建页面</p>
<pre><code class="language-html">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;
        &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;link rel=&quot;shortcut icon&quot; href=&quot;../resources/favicon.ico&quot; th:href=&quot;@{/static/favicon.ico}&quot;/&gt;
&lt;head&gt;
    &lt;title&gt;addUser&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

    &lt;form th:action=&quot;@{/user/addUser}&quot; method=&quot;post&quot;&gt;
        &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br/&gt;
        &lt;input type=&quot;text&quot; name=&quot;usersex&quot;&gt;&lt;br/&gt;
        &lt;input type=&quot;submit&quot; value=&quot;OK&quot;/&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
</li>
</ol>
<h4 id="1112-对实体对象做数据校验">11.1.2 对实体对象做数据校验</h4>
<ol>
<li>
<p>Spring Boot 数据校验的技术特点</p>
<p>Spring Boot 中使用了 Hibernate-validator 校验框架。</p>
</li>
<li>
<p>对实体对象数据校验步骤</p>
<ol>
<li>
<p>修改实体类添加校验规则</p>
<pre><code class="language-java">import org.hibernate.validator.constraints.Length;

import javax.validation.constraints.NotBlank;
import javax.validation.constraints.NotEmpty;
import javax.validation.constraints.NotNull;

/**
 * 以下注解是javax包下的
 * @NotNull: 对基本数据类型的对象类型做非空校验
 * @NotBlank：对字符串类型做非空校验
 * @NotEmpty：对集合类型做非空校验
 */
public class Users {
    @NotNull
    private  Integer userid;
    @NotBlank
    private String username;
    @NotBlank
    private String usersex;

    public Integer getUserid() {
        return userid;
    }

    public void setUserid(Integer userid) {
        this.userid = userid;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getUsersex() {
        return usersex;
    }

    public void setUsersex(String usersex) {
        this.usersex = usersex;
    }

    @Override
    public String toString() {
        return &quot;Users{&quot; +
                &quot;userid=&quot; + userid +
                &quot;, username='&quot; + username + '\'' +
                &quot;, usersex='&quot; + usersex + '\'' +
                '}';
    }
}

</code></pre>
<ol start="2">
<li>
<p>在 Controller 中开启校验</p>
<pre><code class="language-java">@Controller
@RequestMapping(&quot;/user&quot;)
public class UsersController {

    /**
     * 添加用户
     */
    @RequestMapping(&quot;/addUser&quot;)
    public String addUser(@Validated Users users, BindingResult result){
        if(result.hasErrors()){
            /*List&lt;ObjectError&gt; list = result.getAllErrors();
            for(ObjectError err:list){
                FieldError fieldError = (FieldError) err;
                String fieldName = fieldError.getField();
                String msg = fieldError.getDefaultMessage();
                System.out.println(fieldName+&quot;\t&quot;+msg);
            } 平时不需要 */
            return &quot;addUser&quot;;
        }
        System.out.println(users);
        return &quot;ok&quot;;
    }
</code></pre>
<ol start="3">
<li>
<p>在页面中获取提示信息</p>
<pre><code class="language-html">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;
        &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;link rel=&quot;shortcut icon&quot; href=&quot;../resources/favicon.ico&quot; th:href=&quot;@{/static/favicon.ico}&quot;/&gt;
&lt;head&gt;
    &lt;title&gt;addUser&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

    &lt;form th:action=&quot;@{/user/addUser}&quot; method=&quot;post&quot;&gt;
        &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;font color=&quot;red&quot;&gt;&lt;span th:errors=&quot;${Users.username}&quot;/&gt;&lt;/font&gt;&lt;br/&gt;
        &lt;input type=&quot;text&quot; name=&quot;usersex&quot;&gt;&lt;font color=&quot;red&quot;&gt;&lt;span th:errors=&quot;${Users.usersex}&quot;/&gt;&lt;/font&gt;&lt;br/&gt;
        &lt;input type=&quot;submit&quot; value=&quot;OK&quot;/&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p>自定义错误提示信息</p>
<ol>
<li>
<p>在注解中定义提示信息</p>
<pre><code class="language-java">@NotNull(message = &quot;用户 ID 不能为空&quot;)
private Integer userid;
@NotBlank(message = &quot;用户姓名不能为空&quot;)
private String username;
@NotBlank(message = &quot;用户性别不能为空&quot;)
private String usersex;
</code></pre>
</li>
<li>
<p>在配置文件中定义提示信息</p>
<pre><code class="language-java">	@NotNull(message =&quot;{userid.notnull}&quot; )
    private  Integer userid;
    @NotBlank(message = &quot;{username.notnull}&quot;)
    private String username;
    @NotBlank(message = &quot;{usersex.notnull}&quot;)
    private String usersex;
</code></pre>
<p>配置文件名必须是 ValidationMessages.properties</p>
<pre><code class="language-properties">userid.notnull=\u7528\u6237Id\u4e0d\u80fd\u4e3a\u7a7a-pro
username.notnull=\u7528\u6237\u59d3\u540d\u4e0d\u80fd\u4e3a\u7a7a-pro
usersex.notnull=\u7528\u6237\u6027\u522b\u4e0d\u80fd\u4e3a\u7a7a-pro
</code></pre>
</li>
</ol>
</li>
<li>
<p>解决页面跳转异常</p>
<p>​		在跳转页面的方法中注入一个对象，要求参数对象的变量名必须是对象类型名称首字母小写格式。</p>
</li>
</ol>
<pre><code class="language-java">@Controller
public class PageController {

    /**
     * 跳转页面方法
     *解决异常的方式：可以在跳转页面的方法中注入一个Users对象
     * 由于SprignMVC会将该对象放入到Model中传递，key的名称会使用该对象
     * 的驼峰命名规则来作为key
     */
    @RequestMapping(&quot;/{page}&quot;)
    public String showPage(@PathVariable String page, Users suibian){
        return page;
    }
}

</code></pre>
<pre><code class="language-html">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;
        &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;link rel=&quot;shortcut icon&quot; href=&quot;../resources/favicon.ico&quot; th:href=&quot;@{/static/favicon.ico}&quot;/&gt;
&lt;head&gt;
    &lt;title&gt;addUser&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

    &lt;form th:action=&quot;@{/user/addUser}&quot; method=&quot;post&quot;&gt;
        &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;font color=&quot;red&quot;&gt;&lt;span th:errors=&quot;${users.username}&quot;/&gt;&lt;/font&gt;&lt;br/&gt;
        &lt;input type=&quot;text&quot; name=&quot;usersex&quot;&gt;&lt;font color=&quot;red&quot;&gt;&lt;span th:errors=&quot;${users.usersex}&quot;/&gt;&lt;/font&gt;&lt;br/&gt;
        &lt;input type=&quot;submit&quot; value=&quot;OK&quot;/&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="5">
<li>
<p>修改参数 key 的名称</p>
<p>PageController:</p>
</li>
</ol>
<pre><code class="language-java">@Controller
public class PageController {

    /**
     * 跳转页面方法
     *解决异常的方式：可以在跳转页面的方法中注入一个Users对象
     * 由于SprignMVC会将该对象放入到Model中传递，key的名称会使用该对象
     * 的驼峰命名规则来作为key
     * @ModelAttribute的作用是来指定当前做数据传递时SpringMVC放到Model中的key是什么
     */
    @RequestMapping(&quot;/{page}&quot;)
    public String showPage(@PathVariable String page, @ModelAttribute(&quot;aa&quot;) Users suibian){
        return page;
    }
}

</code></pre>
<p>​	UsersController:</p>
<pre><code class="language-java">@Controller
@RequestMapping(&quot;/user&quot;)
public class UsersController {

    /**
     * 添加用户
     */
    @RequestMapping(&quot;/addUser&quot;)
    public String addUser(@ModelAttribute(&quot;aa&quot;)@Validated Users users, BindingResult result){
        if(result.hasErrors()){
            List&lt;ObjectError&gt; list = result.getAllErrors();
            for(ObjectError err:list){
                FieldError fieldError = (FieldError) err;
                String fieldName = fieldError.getField();
                String msg = fieldError.getDefaultMessage();
                System.out.println(fieldName+&quot;\t&quot;+msg);
            }
            return &quot;addUser&quot;;
        }
        System.out.println(users);
        return &quot;ok&quot;;
    }
}
</code></pre>
<pre><code class="language-html">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;
        &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;link rel=&quot;shortcut icon&quot; href=&quot;../resources/favicon.ico&quot; th:href=&quot;@{/static/favicon.ico}&quot;/&gt;
&lt;head&gt;
    &lt;title&gt;addUser&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--th:errors取自BindingResult--&gt;
    &lt;form th:action=&quot;@{/user/addUser}&quot; method=&quot;post&quot;&gt;
        &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;font color=&quot;red&quot;&gt;&lt;span th:errors=&quot;${aa.username}&quot;/&gt;&lt;/font&gt;&lt;br/&gt;
        &lt;input type=&quot;text&quot; name=&quot;usersex&quot;&gt;&lt;font color=&quot;red&quot;&gt;&lt;span th:errors=&quot;${aa.usersex}&quot;/&gt;&lt;/font&gt;&lt;br/&gt;
        &lt;input type=&quot;submit&quot; value=&quot;OK&quot;/&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="6">
<li>
<p>其他校验规则</p>
<p>@NotNull: 判断基本数据类型的对象类型是否为 null<br>
@NotBlank: 判断字符串是否为 null 或者是空串(去掉首尾空格)。<br>
@NotEmpty: 判断集合是否为空。<br>
@Length: 判断字符的长度(最大或者最小)<br>
@Min: 判断数值最小值<br>
@Max: 判断数值最大值<br>
@Email: 判断邮箱是否合法</p>
</li>
</ol>
<h3 id="112-spring-boot-对-controller-中其他参数的校验">11.2  Spring Boot 对 Controller 中其他参数的校验</h3>
<ol>
<li>编写页面</li>
</ol>
<pre><code class="language-html">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;
        &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;link rel=&quot;shortcut icon&quot; href=&quot;../resources/favicon.ico&quot; th:href=&quot;@{/static/favicon.ico}&quot;/&gt;
&lt;head&gt;
    &lt;title&gt;findUser&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
这是一个查询页面
&lt;form th:action=&quot;@{/user/findUser}&quot; method=&quot;post&quot;&gt;
    &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;font color=&quot;red&quot;&gt;&lt;span th:text=&quot;${error}&quot;/&gt;&lt;/font&gt;&lt;br/&gt;
    &lt;input type=&quot;submit&quot; value=&quot;OK&quot;/&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="2">
<li>对参数指定校验规则</li>
</ol>
<pre><code class="language-java">@PostMapping(&quot;/findUser&quot;)
public String findUser(@NotBlank(message = &quot;用户名不能为空&quot;) String username){
	System.out.println(username);
	return &quot;ok&quot;;
}
</code></pre>
<ol start="3">
<li>在 Controller 中开启校验</li>
</ol>
<pre><code class="language-java">@Controller
@RequestMapping(&quot;/user&quot;)
@Validated
public class UsersController {

    @PostMapping(&quot;/findUser&quot;)
    public String findUser(@NotBlank(message = &quot;用户名不能为空&quot;) String username){
        System.out.println(username);
        return &quot;ok&quot;;
    }
}

</code></pre>
<ol start="4">
<li>通过全局异常处理来跳转页面</li>
</ol>
<pre><code class="language-java">@Configuration
public class GlobalException implements HandlerExceptionResolver {
    @Override
    public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object handler, Exception e) {
        ModelAndView mv = new ModelAndView();
        //判断不同异常类型，做不同视图的跳转
        if(e instanceof NullPointerException){
            mv.setViewName(&quot;error5&quot;);
        }
        if(e instanceof ArithmeticException){
            mv.setViewName(&quot;error6&quot;);
        }
        if(e instanceof ConstraintViolationException){
            mv.setViewName(&quot;findUser&quot;);
        }
        mv.addObject(&quot;error&quot;,e.getMessage().split(&quot;:&quot;)[1]);
        return mv;
    }
}
</code></pre>
<h2 id="12-spring-boot-热部署">12、Spring Boot 热部署</h2>
<p>通过 DevTools 工具实现热部署：</p>
<ol>
<li>
<p>修改 POM 文件，添加 DevTools 依赖</p>
<pre><code class="language-xml">&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
	&lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
	&lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>配置 Idea</p>
<ol>
<li>
<p>设置自动编译</p>
<figure data-type="image" tabindex="34"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200622134350.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>设置 Idea 的 Registry</p>
<p>通过快捷键打开该设置项：Ctrl+Shift+Alt+/<br>
勾选 complier.automake.allow.when.app.running</p>
<figure data-type="image" tabindex="35"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200622134732.png" alt="" loading="lazy"></figure>
</li>
</ol>
</li>
</ol>
<h2 id="13-spring-boot-度量指标监控与健康检查">13、Spring Boot 度量指标监控与健康检查</h2>
<h3 id="131-使用-actuator-检查与监控">13.1 使用 Actuator 检查与监控</h3>
<ol>
<li>创建项目</li>
</ol>
<figure data-type="image" tabindex="36"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200622144536.png" alt="" loading="lazy"></figure>
<ol start="2">
<li>需改 POM 文件，添加依赖</li>
</ol>
<pre><code class="language-xml">&lt;!--Actuator 坐标依赖--&gt;
&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
	&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="3">
<li>修改配置文件</li>
</ol>
<pre><code class="language-properties">#配置访问端点的根路径
management.endpoints.web.base-path=/actuator

#配置开启其他端点的 URI
#开启所有的端点访问：*
#指定开启端点访问：如：beans,env
management.endpoints.web.exposure.include=*
</code></pre>
<ol start="4">
<li>各项监控指标接口 URL 介绍</li>
</ol>
<figure data-type="image" tabindex="37"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200622144724.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="38"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200622144737.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="39"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200622144748.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="40"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200622144756.png" alt="" loading="lazy"></figure>
<h3 id="132-使用可视化监控应用-spring-boot-admin">13.2 使用可视化监控应用 Spring Boot Admin</h3>
<p><strong>使用步骤:</strong></p>
<p>Spring Boot Admin 的使用是需要建立服务端与客户端。<br>
服务端：独立的项目，会将搜集到的数据在自己的图形界面中展示。<br>
客户端：需要监控的项目。<br>
对应关系：一个服务端可以监控多个客户端。</p>
<h4 id="1321-搭建服务端">13.2.1 搭建服务端</h4>
<ol>
<li>
<p>创建项目</p>
<figure data-type="image" tabindex="41"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200622145305.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>修改 POM 文件</p>
<p>注意：目前在 Spring Boot Admin Starter Server2.1.6 版本中不支持 Spring Boot2.2.x 版本,只支持到 2.1.X</p>
<pre><code class="language-xml">&lt;!--
https://mvnrepository.com/artifact/de.codecentric/spring-
boot-admin-starter-server --&gt;
&lt;dependency&gt;
	&lt;groupId&gt;de.codecentric&lt;/groupId&gt;
	&lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt;
	&lt;version&gt;2.1.6&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>修改配置文件</p>
<pre><code class="language-properties">server.port=9090
</code></pre>
</li>
<li>
<p>修改启动类</p>
<pre><code class="language-java">@SpringBootApplication
@EnableAdminServer //开启 Spring Boot Admin 服务端
public class SpringbootactuatorserverApplication {
	public static void main(String[] args) {
	SpringApplication.run(SpringbootactuatorserverApplication.class, args);
	}
}
</code></pre>
</li>
</ol>
<h4 id="1322-搭建客户端">13.2.2 搭建客户端</h4>
<ol>
<li>修改POM文件</li>
</ol>
<pre><code class="language-xml">&lt;!--
https://mvnrepository.com/artifact/de.codecentric/spring-
boot-admin-starter-client --&gt;
&lt;dependency&gt;
	&lt;groupId&gt;de.codecentric&lt;/groupId&gt;
	&lt;artifactId&gt;spring-boot-admin-starter-client&lt;/artifactId&gt;
	&lt;version&gt;2.1.6&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
<li>修改配置文件</li>
</ol>
<pre><code class="language-properties">#配置访问端点的根路径
management.endpoints.web.base-path=/actuator

#配置开启其他端点的 URI
#开启所有的端点访问：*
#指定开启端点访问：如：beans,env
#这里暴露的会在服务端显示
management.endpoints.web.exposure.include=*

#指定服务端的访问地址
spring.boot.admin.client.url=http://localhost:9090
</code></pre>
<ol start="3">
<li>
<p>效果图</p>
<figure data-type="image" tabindex="42"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200622150615.png" alt="" loading="lazy"></figure>
</li>
</ol>
<h2 id="14-spring-boot-的日志管理">14、Spring Boot 的日志管理</h2>
<p>​		Spring Boot 默认使用 Logback 组件作为日志管理。Logback 是由 log4j 创始人设计的一个开源日志组件。<br>
​		在 Spring Boot 项目中我们不需要额外的添加 Logback 的依赖，因为在 spring-boot-starter或者 spring-boot-starter-web 中已经包含了 Logback 的依赖。</p>
<ol>
<li>Logback 读取配置文件的步骤</li>
</ol>
<p>（1）在 classpath 下查找文件 logback-test.xml<br>
（2）如果文件不存在，则查找 logback.xml<br>
（3）如果两个文件都不存在，LogBack 用 BasicConfiguration 自动对自己进行最小化配置，这样既实现了上面我们不需要添加任何配置就可以输出到控制台日志信息。</p>
<ol start="2">
<li>添加 Logback 配置文件</li>
</ol>
<figure data-type="image" tabindex="43"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200622160355.png" alt="" loading="lazy"></figure>
<ol start="3">
<li>
<p>Logback配置文件</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
 &lt;configuration&gt;
&lt;!--定义日志文件的存储地址 勿在 LogBack 的配置中使用相对路径--&gt;  
    &lt;property name=&quot;LOG_HOME&quot; value=&quot;${catalina.base}/logs/&quot; /&gt;  
    &lt;!-- 控制台输出 --&gt;   
    &lt;appender name=&quot;Stdout&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
       &lt;!-- 日志输出编码 --&gt;  
        &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;   
             &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt; 
            &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n   
            &lt;/pattern&gt;   
        &lt;/layout&gt;   
    &lt;/appender&gt;   
    &lt;!-- 按照每天生成日志文件 --&gt;   
    &lt;appender name=&quot;RollingFile&quot;  class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;   
        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;
            &lt;!--日志文件输出的文件名--&gt;
            &lt;FileNamePattern&gt;${LOG_HOME}/server.%d{yyyy-MM-dd}.log&lt;/FileNamePattern&gt;   
            &lt;MaxHistory&gt;30&lt;/MaxHistory&gt;
        &lt;/rollingPolicy&gt;   
        &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;  
            &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt; 
            &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n   
            &lt;/pattern&gt;   
       &lt;/layout&gt; 
        &lt;!--日志文件最大的大小--&gt;
       &lt;triggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;&gt;
         &lt;MaxFileSize&gt;10MB&lt;/MaxFileSize&gt;
       &lt;/triggeringPolicy&gt;
    &lt;/appender&gt;     

    &lt;!-- 日志输出级别 --&gt;
    &lt;root level=&quot;info&quot;&gt;   
        &lt;appender-ref ref=&quot;Stdout&quot; /&gt;   
        &lt;appender-ref ref=&quot;RollingFile&quot; /&gt;   
    &lt;/root&gt; 



&lt;!--日志异步到数据库 --&gt;  
&lt;!--     &lt;appender name=&quot;DB&quot; class=&quot;ch.qos.logback.classic.db.DBAppender&quot;&gt;
        日志异步到数据库 
        &lt;connectionSource class=&quot;ch.qos.logback.core.db.DriverManagerConnectionSource&quot;&gt;
           连接池 
           &lt;dataSource class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;
              &lt;driverClass&gt;com.mysql.jdbc.Driver&lt;/driverClass&gt;
              &lt;url&gt;jdbc:mysql://127.0.0.1:3306/databaseName&lt;/url&gt;
              &lt;user&gt;root&lt;/user&gt;
              &lt;password&gt;root&lt;/password&gt;
            &lt;/dataSource&gt;
        &lt;/connectionSource&gt;
  &lt;/appender&gt; --&gt;

&lt;/configuration&gt;
</code></pre>
</li>
<li>
<p>在代码中使用 Logback</p>
</li>
</ol>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/logback&quot;)
public class HelloController {

    private final static Logger logger = LoggerFactory.getLogger(HelloController.class);

    @RequestMapping(&quot;/showInfo&quot;)
    public String showInfo(){
        logger.info(&quot;记录日志&quot;);
        return &quot;Hello Logback &quot;;
    }
}
</code></pre>
<figure data-type="image" tabindex="44"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200622161037.png" alt="" loading="lazy"></figure>
<ol start="5">
<li>
<p>在配置文件中屏蔽指定包的日志记录</p>
<pre><code class="language-properties">#屏蔽指定包中的日志输出 logging.level.包名=off
logging.level.org=off
</code></pre>
</li>
</ol>
<figure data-type="image" tabindex="45"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200622161416.png" alt="" loading="lazy"></figure>
<h2 id="15-spring-boot-项目打包与多环境配置">15、Spring Boot 项目打包与多环境配置</h2>
<h3 id="151-spring-boot-项目打包">15.1 Spring Boot 项目打包</h3>
<ol>
<li>Spring Boot 的打包插件</li>
</ol>
<pre><code class="language-xml">&lt;build&gt;
	&lt;plugins&gt;
		&lt;plugin&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-maven-lugin&lt;/artifactId&gt;
		&lt;/plugin&gt;
	&lt;/plugins&gt;
&lt;/build&gt;
</code></pre>
<ol start="2">
<li>项目打包方式</li>
</ol>
<figure data-type="image" tabindex="46"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200622162322.png" alt="" loading="lazy"></figure>
<ol start="3">
<li>
<p>运行命令</p>
<p>注意：需要正确的配置环境变量。<br>
运行命令：java -jar 项目的名称</p>
</li>
</ol>
<h3 id="152-spring-boot-的多环境配置">15.2 Spring Boot 的多环境配置</h3>
<p>语法结构：application-{profile}.properties/yml<br>
profile：代表某个配置环境的标识</p>
<p>示例：application-dev.properties/yml 开发环境<br>
application-test.properties/yml 测试环境<br>
application-prod.properties/yml 生产环境</p>
<h4 id="1521-windows-环境下启动方式">15.2.1 Windows 环境下启动方式</h4>
<p>​	java -jar xxx.jar --spring.profiles.active={profile}</p>
<h4 id="1522-在-linux-环境下启动方式">15.2.2 在 Linux 环境下启动方式</h4>
<ol>
<li>
<p>安装上传下载工具</p>
<p>安装命令：yum install lrzsz -y<br>
上传命令：rz<br>
下载命令：sz 下载文件名</p>
</li>
<li>
<p>启动脚本的使用</p>
<p>修改脚本文件中的参数值<br>
将启动脚本文件（sever.sh）上传到 Linux 中<br>
分配执行权限：chmod 777<br>
通过脚本启动命令：server.sh start<br>
通过脚本关闭命令：server.sh stop</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring]]></title>
        <id>https://jonchan1013.github.io/post/spring/</id>
        <link href="https://jonchan1013.github.io/post/spring/">
        </link>
        <updated>2020-06-17T02:15:01.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="1-spring">1、Spring</h2>
<h3 id="11-简介">1.1 简介</h3>
<p>Spring：春天—-&gt;给软件行业带来了春天！<br>
2002，首次推出了Spring框架的雏形：interface21框架！<br>
Spring框架即以interface21框架为基础，经过重新设计，并不断丰富内涵，于2004年3月24日，发布了1.0正式版。<br>
Rod Johnson，Spring Framework创始人，著名作者。很难想象其学历，真的让好多人大吃一惊，他是悉尼大学的博士，然而他的专业不是计算机，而是音乐学。<br>
spring理念：使现有的技术更加容易使用，本身是一个大杂烩，整合了现有的技术框架。</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="1-spring">1、Spring</h2>
<h3 id="11-简介">1.1 简介</h3>
<p>Spring：春天—-&gt;给软件行业带来了春天！<br>
2002，首次推出了Spring框架的雏形：interface21框架！<br>
Spring框架即以interface21框架为基础，经过重新设计，并不断丰富内涵，于2004年3月24日，发布了1.0正式版。<br>
Rod Johnson，Spring Framework创始人，著名作者。很难想象其学历，真的让好多人大吃一惊，他是悉尼大学的博士，然而他的专业不是计算机，而是音乐学。<br>
spring理念：使现有的技术更加容易使用，本身是一个大杂烩，整合了现有的技术框架。</p>
<!-- more -->
<p>SSH：Struct2+Spring+Hibernate!<br>
SSM：SpringMVC+Spring+Mybatis!​<br>
官网：https://spring.io/projects/spring-framework#overview</p>
<p>官方下载地址：https://repo.spring.io/release/org/springframework/spring/</p>
<p>Github：https://github.com/spring-projects/spring-framework</p>
<p>Maven仓库：导入webmvc包会自动导入相关依赖；jdbc用于和Mybatis整合。</p>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
    &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
    &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="12-优点">1.2 优点</h3>
<ul>
<li>
<p>Spring是一个开源的免费的框架（容器）！</p>
</li>
<li>
<p>Spring是一个轻量级的、非入侵式的框架！</p>
</li>
<li>
<p>控制反转（IOC）、面向切面编程（AOP）！</p>
</li>
<li>
<p>支持事务的处理，对框架整合的支持！</p>
<p><mark><strong>总结一句话：Spring就是一个轻量级的控制反转（IOC）和面向切面编程的框架！</strong></mark></p>
</li>
</ul>
<h3 id="13-组成">1.3 组成</h3>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200617110747.png" alt="" loading="lazy"></figure>
<h3 id="14-拓展">1.4 拓展</h3>
<p>在Spring的官网有这个介绍：现代化的java开发！说白了就是基于Spring的开发！</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200617111004.png" alt="" loading="lazy"></figure>
<ul>
<li>Spring Boot
<ul>
<li>一个快速开发的脚手架。</li>
<li>基于Spring Boot可以快速的开发单个微服务。</li>
<li>约定大于配置！</li>
</ul>
</li>
<li>Spring Cloud
<ul>
<li>SpringCloud是基于SpringBoot实现的。</li>
</ul>
</li>
</ul>
<p>因为现在大多数公司都在使用SpringBoot进行快速开发，学习SpringBoot的前提，需要完全掌握Spring以及SpringMVC！承上启下的作用。</p>
<p><strong>弊端：发展了太久之后，违背了原来的理念！配置十分繁琐，人称：“配置地狱”。</strong></p>
<h2 id="2-ioc理论推导">2、IOC理论推导</h2>
<p>1.UserDao接口</p>
<p>2.UserDaoImpl实现类</p>
<p>3.UserService业务接口</p>
<p>4.UserServiceImpl业务实现类</p>
<p>在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改源代码!如果程序代码量十分大，修改一次的成本代价十分昂贵！</p>
<p>我们使用一个Set接口实现，已经发生了革命性的变化！</p>
<pre><code class="language-java">private UserDao userDao;

//利用set进行动态实现值的注入！
public void setUserDao(UserDao userDao){
    this.userDao = userDao;
}
</code></pre>
<ul>
<li>之前，程序是主动创建对象！控制权在程序员手上！</li>
<li>使用了set注入后，程序不再具有主动性，而是变成了被动的接收对象！</li>
</ul>
<p>这种思想，从本质上解决了问题，我们程序员不用再去管理对象的创建了。系统的耦合性大大降低，可以更加专注在业务的实现上。这是IOC的原型！</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200617140229.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200617140305.png" alt="" loading="lazy"></figure>
<h3 id="21-ioc本质">2.1 IOC本质</h3>
<p>**控制反转IOC（Inversion of Control），是一种设计思想，DI（依赖注入）是实现IOC的一种方法，**也有人认为DI是IoC的另一种说法。没有IoC的程序中，我们使用面向对象编程，对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。</p>
<p>采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。</p>
<p><strong>控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方式是依赖注入（Dependency Injection,DI）</strong>。</p>
<h2 id="3-hello-spring">3、Hello Spring</h2>
<p>beans.xml官网配置文件：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

&lt;/beans&gt;
</code></pre>
<p>bean对象添加：</p>
<pre><code class="language-xml">&lt;bean id=&quot;mysqlImpl&quot; class=&quot;com.kuang.dao.UserDaoMysqlImpl&quot;&gt;&lt;/bean&gt;
&lt;bean id=&quot;oracleImpl&quot; class=&quot;com.kuang.dao.UserDaoOracleImpl&quot;&gt;&lt;/bean&gt;

&lt;bean id=&quot;UserServiceImpl&quot; class=&quot;com.kuang.service.UserServiceImpl&quot;&gt;
    &lt;!--
        ref：引用Spring容器中已经创建好的对象
        value：具体的值，基本数据类型
        --&gt;
    &lt;property name=&quot;userDao&quot; ref=&quot;mysqlImpl&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>Test方法：</p>
<pre><code class="language-java">//解析beans.xml文件，生成管理相应的Bean对象
ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
//getBean:参数即为spring配置文件中bean的id
Hello hello = (Hello) context.getBean(&quot;hello&quot;);
System.out.println(hello.toString());
</code></pre>
<h3 id="思考问题"><strong>思考问题</strong>？</h3>
<ul>
<li>
<p>Hello对象是谁创建的？</p>
<p>hello对象是由Spring创建的。</p>
</li>
<li>
<p>Hello对象的属性是怎么设置的？</p>
<p>hello对象的属性是由Spring容器设置的。</p>
</li>
</ul>
<p>这个过程就叫做控制反转：</p>
<p>控制：谁来控制对象的创建，传统应用程序的对象是由程序本身控制创建的，使用Spring后，对象是由Spring来创建的。</p>
<p>反转：程序本身不创建对象，而变成被动的接收对象。</p>
<p>依赖注入：就是利用set方法来进行注入。</p>
<p>IoC是一种编程思想，由主动的编程编程被动的接收。</p>
<p>可以通过new ClassPathXmlApplicationContext去浏览一下底层源码。</p>
<p><strong>OK，到了现在，我们彻底不用在程序中去改动了，要实现不同的操作，只需要在xml配置文件中进行修改，所谓的IoC，一句话搞定：对象由Spring来创建，管理，装配！</strong></p>
<p>IDEA快捷创建beans.xml文件，自动导入spring配置信息：</p>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200617141027.png" alt="" loading="lazy"></figure>
<h2 id="4-ioc创建对象的方式">4、IOC创建对象的方式</h2>
<ol>
<li>
<p>使用无参构造创建对象，默认方式！</p>
</li>
<li>
<p>假设我们要使用有参构造创建对象。</p>
<p>1.下标赋值：</p>
<pre><code class="language-xml">&lt;!--第一种，下标赋值！--&gt;
&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;&gt;
    &lt;constructor-arg index=&quot;0&quot; value=&quot;憨批&quot; /&gt;
&lt;/bean&gt;
</code></pre>
<p>2.类型赋值:</p>
<pre><code class="language-xml">&lt;!--第二种，通过类型创建，不建议使用，重复类型难以分辨--&gt;
&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;&gt;
    &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;大憨批&quot; /&gt;
&lt;/bean&gt;
</code></pre>
<p>3.参数名赋值:</p>
<pre><code class="language-xml">&lt;!--第三种，直接通过参数名来设置--&gt;
&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;&gt;
    &lt;constructor-arg name=&quot;name&quot; value=&quot;臭憨批&quot; /&gt;
&lt;/bean&gt;
</code></pre>
<p>总结：在配置文件加载的时候，容器中管理的对象就已经初始化了！</p>
</li>
</ol>
<h2 id="5-spring配置">5、Spring配置</h2>
<h3 id="51-别名">5.1 别名</h3>
<pre><code class="language-xml">&lt;!--别名，如果添加了别名，我们也可以使用别名获取到--&gt;
&lt;alias name=&quot;user&quot; alias=&quot;userNew&quot;&gt;&lt;/alias&gt;
</code></pre>
<h3 id="52-bean到底是什么">5.2 Bean到底是什么？</h3>
<p>bean就相当于定义一个组件，这个组件是用于具体实现某个功能的。这里的所定义的bean就相当于给了你一个简洁方便的方法来调用这个组件实现你要完成的功能。</p>
<p>1、Java面向对象，对象有方法和属性，那么就需要对象实例来调用方法和属性（即实例化）；<br>
2、凡是有方法或属性的类都需要实例化，这样才能具象化去使用这些方法和属性；<br>
3、规律：凡是子类及带有方法或属性的类都要加上注册Bean到Spring IoC的注解；（@Component , @Repository , @ Controller , @Service , @Configration）<br>
4、把Bean理解为类的代理或代言人（实际上确实是通过反射、代理来实现的），这样它就能代表类拥有该拥有的东西了<br>
5、我们都在微博上@过某某，对方会优先看到这条信息，并给你反馈，那么在Spring中，你标识一个@符号，那么Spring就会来看看，并且从这里拿到一个Bean（注册）或者给出一个Bean（使用）</p>
<h3 id="53-怎么使用bean">5.3 怎么使用bean</h3>
<p>对于我们的spring最主要的应该就是由这些bean组成的bean工厂，每个bean实现一个功能<br>
例如：你写的第一个bean</p>
<pre><code class="language-xml">&lt;bean id=&quot;userAction&quot; class=&quot;com.neusoft.gmsbs.gms.user.action.UserAction&quot;
scope=&quot;prototype&quot;&gt;
&lt;property name=&quot;userBO&quot; ref=&quot;userBO&quot; /&gt;
&lt;/bean&gt;
</code></pre>
<p>id相当于定义了你的这个bean的别名，如果你需要他的话只要关联这个别名就可以了，也就相当于下面的一样，在你的userAction中需要实现userBO这个功能，我关联它，那么在action中set注入就可以使用了！<br>
至于其他的属性看下面：<br>
Id : 标识该bean的名称，通过factory.getBean(“id”)来获得实例。<br>
Class : 该bean的类路径。<br>
Singleton : 默认为true，即单实例模式，每次getBean(“id”)时获取的都是同一个实例，如果设置为false，即原型模式，则每次获取的是新创建的实例。</p>
<h3 id="54-bean的配置">5.4 Bean的配置</h3>
<p>ID,name 或class<br>
一般情况下，转配一个Bean时，通过指定一个ID属性作为Bean的名称<br>
1.<strong>id</strong>属性在IOC容器中必须是唯一的<br>
2.如果Bean的名称中含有特殊字符，就需要使用<strong>name</strong>属性<br>
3.<strong>class</strong>用于设置一个类的完全路径名称，主要作用是ioc容器生成类的实例</p>
<pre><code class="language-xml">&lt;!--
    id:bean的唯一标识符，相当于我们学的对象名；
    class：bean对象所对应的全限定名：包名+类名；
    name：也是别名，可以同时取多个别名，逗号分割
--&gt;
&lt;bean id=&quot;userT&quot; class=&quot;com.kuang.pojo.UserT&quot; name=&quot;user2,u2&quot;&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="54-import">5.4 import</h3>
<p>这个import，一般用于团队开发使用，他可以将多个配置文件，导入合并为一个。</p>
<p>假设，现在项目中有多个人开发，这三个人负责不同的类开发，不同的类需要注册在不同的bean中，我们可以利用import将所有人的beans.xml合并为一个总的！</p>
<ul>
<li>张三</li>
<li>李四</li>
<li>王五</li>
<li>applicationContext.xml</li>
</ul>
<pre><code class="language-xml">&lt;import resource=&quot;beans.xml&quot;/&gt;
&lt;import resource=&quot;beans2.xml&quot;/&gt;
&lt;import resource=&quot;beans3.xml&quot;/&gt;

</code></pre>
<p>使用的时候，直接使用总的配置就可以了。</p>
<h2 id="6-依赖注入">6、依赖注入</h2>
<h3 id="61-构造器注入">6.1 构造器注入</h3>
<p>之前已经介绍过</p>
<h3 id="62-set方式注入重点">6.2 Set方式注入【重点】</h3>
<ul>
<li>依赖注入：Set注入！
<ul>
<li>依赖：bean对象的创建依赖于容器！</li>
<li>注入：bean对象中的所有属性，由容器来注入！</li>
</ul>
</li>
</ul>
<p>【环境搭建】</p>
<ol>
<li>复杂类型</li>
</ol>
<pre><code class="language-java">public class Address {
    private String address;

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }
}
</code></pre>
<ol start="2">
<li>真实测试对象</li>
</ol>
<pre><code class="language-java">public class Student {
    private String name;
    private Address address;
    private String[] books;
    private List&lt;String&gt; hobbies;
    private Map&lt;String,String&gt; card;
    private Set&lt;String&gt; games;
    private String wife;
    private Properties info;
}
</code></pre>
<ol start="3">
<li>beans.xml</li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;student&quot; class=&quot;com.kuang.pojo.Student&quot;&gt;
        &lt;!--第一种，普通值注入--&gt;
        &lt;property name=&quot;name&quot; value=&quot;憨批&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<ol start="4">
<li>测试类</li>
</ol>
<pre><code class="language-java">public class MyTest {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
        Student student = (Student) context.getBean(&quot;student&quot;);
        System.out.println(student.getName());
    }
}
</code></pre>
<p><mark><strong>完善注入：</strong></mark></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;address&quot; class=&quot;com.kuang.pojo.Address&quot;/&gt;

    &lt;bean id=&quot;student&quot; class=&quot;com.kuang.pojo.Student&quot;&gt;
        &lt;!--第一种，普通值注入，value--&gt;
        &lt;property name=&quot;name&quot; value=&quot;憨批&quot;/&gt;
        &lt;!--第二种，Bean注入，ref--&gt;
        &lt;property name=&quot;address&quot; ref=&quot;address&quot;/&gt;
        &lt;!--数组注入--&gt;
        &lt;property name=&quot;books&quot;&gt;
            &lt;array&gt;
                &lt;value&gt;红楼梦&lt;/value&gt;
                &lt;value&gt;西游记&lt;/value&gt;
                &lt;value&gt;水浒传&lt;/value&gt;
                &lt;value&gt;三国演义&lt;/value&gt;
            &lt;/array&gt;
        &lt;/property&gt;
        &lt;!--List注入--&gt;
        &lt;property name=&quot;hobbies&quot;&gt;
            &lt;list&gt;
                &lt;value&gt;听歌&lt;/value&gt;
                &lt;value&gt;敲代码&lt;/value&gt;
                &lt;value&gt;看电影&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;!--Map--&gt;
        &lt;property name=&quot;card&quot;&gt;
            &lt;map&gt;
                &lt;entry key=&quot;身份证&quot; value=&quot;1555555555&quot;/&gt;
                &lt;entry key=&quot;银行卡&quot; value=&quot;5555555555&quot;/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        &lt;!--Set--&gt;
        &lt;property name=&quot;games&quot;&gt;
            &lt;set&gt;
                &lt;value&gt;lol&lt;/value&gt;
                &lt;value&gt;wow&lt;/value&gt;
            &lt;/set&gt;
        &lt;/property&gt;
        &lt;!--null--&gt;
        &lt;property name=&quot;wife&quot;&gt;
            &lt;null/&gt;
        &lt;/property&gt;
        &lt;!--Properties--&gt;
        &lt;property name=&quot;info&quot;&gt;
            &lt;props&gt;
                &lt;prop key=&quot;driver&quot;&gt;com.mysql.jdbc.Driver&lt;/prop&gt;
                &lt;prop key=&quot;url&quot;&gt;jdbc:mysql://localhost:3306/news&lt;/prop&gt;
                &lt;prop key=&quot;root&quot;&gt;root&lt;/prop&gt;
                &lt;prop key=&quot;password&quot;&gt;123456&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;

    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<h3 id="63-扩展方式注入">6.3 扩展方式注入</h3>
<p>我们可以使用c和p命令空间进行注入：</p>
<p>使用：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;!--p命名空间注入，可以直接注入属性的值：property--&gt;
    &lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot; p:name=&quot;憨批&quot; p:age=&quot;18&quot;/&gt;

    &lt;!--c命名空间注入，通过构造器注入：construct-args--&gt;
    &lt;bean id=&quot;user2&quot; class=&quot;com.kuang.pojo.User&quot; c:age=&quot;18&quot; c:name=&quot;憨批&quot;/&gt;

&lt;/beans&gt;
</code></pre>
<p>测试：</p>
<pre><code class="language-java">@Test
public void test2(){
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;userBeans.xml&quot;);
    User user = context.getBean(&quot;user2&quot;, User.class);
    System.out.println(user);
}
</code></pre>
<p>注意点：p和c命名空间不能直接使用，需要导入xml约束！</p>
<pre><code class="language-xml">xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
xmlns:c=&quot;http://www.springframework.org/schema/c&quot;
</code></pre>
<h3 id="64-bean的作用域">6.4 bean的作用域</h3>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200617145745.png" alt="" loading="lazy"></figure>
<ol>
<li>代理模式（Spring默认机制）：get到的都是同一个对象！</li>
</ol>
<pre><code class="language-xml">&lt;bean id=&quot;user2&quot; class=&quot;com.kuang.pojo.User&quot; c:age=&quot;18&quot; c:name=&quot;憨批&quot; scope=&quot;singleton&quot;/&gt;

</code></pre>
<ol start="2">
<li>原型模式：每次从容器中get的时候，都会产生一个新的对象！</li>
</ol>
<pre><code class="language-xml">&lt;bean id=&quot;user2&quot; class=&quot;com.kuang.pojo.User&quot; c:age=&quot;18&quot; c:name=&quot;憨批&quot; scope=&quot;prototype&quot;/&gt;

</code></pre>
<ol start="3">
<li>其余的request、session、application、这些个只能在web开发中使用。</li>
</ol>
<p>从上面的例子也印证了我上面的总结的内容：<br>
1、凡是子类及带属性、方法的类都注册Bean到Spring中，交给它管理；<br>
2、@Bean 用在方法上，告诉Spring容器，你可以从下面这个方法中拿到一个Bean</p>
<h2 id="7-bean的自动装配">7、Bean的自动装配</h2>
<ul>
<li>自动装配是Spring满足bean依赖的一种方式！</li>
<li>Spring会在上下文中自动寻找，并自动给bean装配属性！</li>
</ul>
<p>在Spring中有三种装配的方式：</p>
<ol>
<li>在xml中显式配置；</li>
<li>在java中显式配置；</li>
<li>隐式的自动装配bean</li>
</ol>
<h3 id="71-测试">7.1 测试</h3>
<p>环境搭建：一个人有两个宠物！</p>
<h3 id="72-byname自动装配">7.2 ByName自动装配</h3>
<pre><code class="language-xml">&lt;!--
    byName:会自动在容器上下文中查找和自己对象set方法后面的值对应的beanid！
--&gt;
&lt;bean id=&quot;people&quot; class=&quot;com.kuang.pojo.People&quot; autowire=&quot;byName&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;憨批&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="73-bytype自动装配">7.3  ByType自动装配</h3>
<pre><code class="language-xml">&lt;!--
    byType:会自动在容器上下文中查找，和自己对象属性类型相同的bean！必须保证类型全局唯一。
--&gt;
&lt;bean id=&quot;people&quot; class=&quot;com.kuang.pojo.People&quot; autowire=&quot;byType&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;憨批&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>小结：</p>
<ul>
<li>byName的时候，需要保证所有bean的id唯一，并且这个bean需要和自动注入的属性的set方法的值一致！</li>
<li>byType的时候，需要保证所有bean的class唯一，并且这个bean需要和自动注入的属性的类型一致！</li>
</ul>
<h3 id="74-使用注解实现自动装配">7.4 使用注解实现自动装配</h3>
<p>jdk1.5支持注解，Spring2.5开始支持注解。</p>
<p>要使用注解须知：</p>
<ol>
<li>导入约束：context约束。</li>
<li>配置注解的支持：<a href="context:annot-config/">context:annot-config/</a></li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:annotation-config/&gt;

&lt;/beans&gt;
</code></pre>
<p><strong>@Autowired</strong></p>
<p>直接在属性上使用即可！也可以在set方式上使用！</p>
<p>使用Autowired我们可以不用编写Set方法了，前提是你这个自动装配的属性在IoC（Spring）容器中存在，且符合名字byName！</p>
<p>科普：</p>
<pre><code class="language-java">@Nullable	字段标记了这个注解，说明这个字段可以为null
    public People(@Nullable String name){
    this.name = name;
}
</code></pre>
<pre><code class="language-java">public @interface Autowired {
    boolean required() default true;
}
</code></pre>
<p>测试代码:</p>
<pre><code class="language-java">public class People {
    //如果显式定义了Autowired的required属性为false，说明这个对象可以为null，否则不允许为空
    @Autowired(required = false)
    private Dog dog;
    @Autowired
    private Cat cat;
    private String name;
}
</code></pre>
<p>如果@Autowired自动装配的环境比较复杂，自动装配无法通过一个注解@Autowired完成的时候，我们可以使用@Qualifier(value=”xxx”)去配置@Autowired的使用，指定一个唯一的bean对象注入！</p>
<pre><code class="language-java">public class People {
    @Autowired
    @Qualifier(value=&quot;dog11&quot;)
    private Dog dog;
    @Autowired
	@Qualifier(value=&quot;cat11&quot;)
    private Cat cat;
    private String name;
}
</code></pre>
<p><strong>@Resource注解</strong></p>
<pre><code class="language-java">public class People {
    @Resource(name = &quot;cat2&quot;)
    private Cat cat;
}
</code></pre>
<p>小结：</p>
<p><strong>@Resource和@Autowired的区别：</strong></p>
<ul>
<li>都是用来自动装配的，都可以放在属性字段上；</li>
<li>@Autowired通过byType的方式实现，而且必须要求这个对象存在！【常用】</li>
<li>@Resource默认通过byName的方式实现，如果找不到名字，则通过byType实现！如果两个都找不到的情况下，就报错！</li>
<li>执行顺序不同：@Autowired通过byType的方式实现，@Resource默认通过byName的方式实现。</li>
</ul>
<h2 id="8-使用注解开发">8、使用注解开发</h2>
<p>在spring4之后，要使用注解开发，必须要保证aop的包导入了。</p>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200617153338.png" alt="" loading="lazy"></figure>
<p>使用注解需要导入context约束，增加注解的支持！</p>
<pre><code class="language-xml">&lt;!--指定要扫描的包，这个包下的注解会生效--&gt;
&lt;context:component-scan base-package=&quot;com.kuang.pojo&quot;/&gt;

</code></pre>
<ol>
<li>bean</li>
<li>属性如何注入</li>
</ol>
<pre><code class="language-java">//等价于&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;/&gt;
//@Component 组件
@Component
public class User {
    //相当于&lt;property name=&quot;name&quot; value=&quot;小憨批&quot;/&gt;
    public String name;
    @Value(&quot;小憨批&quot;)
    public void setName(String name){
        this.name = name;
    }
}
</code></pre>
<ol start="3">
<li>衍生的注解</li>
</ol>
<p>@Component有几个衍生注解，我们在web开发中，会按照mvc三层架构分层！</p>
<ul>
<li>dao【@Repository】</li>
<li>service【@Service】</li>
<li>controller【@Controller】</li>
</ul>
<p>这四个注解功能都是一样的，都是代表将某个类注册到Spring中，装配Bean！</p>
<ol start="4">
<li>自动装配</li>
</ol>
<pre><code class="language-xml">-@Autowired:自动装配通过类型，名字
	如果Autowired不能唯一自动装配上属性，则需要通过@Qualifier(value=&quot;xxx&quot;)
-@Nullable:字段标记了这个注解，说明这个字段可以为null
-@Resource:自动装配通过名字，类型
</code></pre>
<ol start="5">
<li>作用域</li>
</ol>
<pre><code class="language-xml">@Scope(&quot;singleton&quot;)
public class User {
    //相当于&lt;property name=&quot;name&quot; value=&quot;小憨批&quot;/&gt;
    public String name;
    @Value(&quot;小憨批&quot;)
    public void setName(String name){
        this.name = name;
    }
}
</code></pre>
<ol start="6">
<li>
<p>小结</p>
<p><strong>xml与注解：</strong></p>
</li>
</ol>
<ul>
<li>
<p>xml更加万能，适用于任何场合！维护简单方便。</p>
</li>
<li>
<p>注解，不是自己的类使用不了，维护相对复杂！</p>
<p><strong>xml与注解最佳实践：</strong></p>
</li>
<li>
<p>xml用来管理bean；</p>
</li>
<li>
<p>注解只负责完成属性的注入；</p>
</li>
<li>
<p>我们在使用的过程中，只需要注意一个问题：必须让注解生效，就需要开启注解的支持。</p>
</li>
</ul>
<pre><code class="language-xml"> &lt;!--指定要扫描的包，这个包下的注解会生效--&gt;
&lt;context:component-scan base-package=&quot;com.kuang&quot;/&gt;
&lt;context:annotation-config/&gt;
</code></pre>
<h2 id="9-使用java的方式配置spring">9. 使用java的方式配置Spring</h2>
<p>我们现在要完全不适用Spring的xml配置了，全权交给java来做！</p>
<p>javaConfig是Spring的一个子项目，在Spring4之后，它成为了一个核心功能。</p>
<p>实体类：</p>
<pre><code class="language-java">@Component
public class User {
    private String name;

    public String getName() {
        return name;
    }

    @Value(&quot;小笨蛋&quot;)
    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return &quot;User{&quot; +
                &quot;name='&quot; + name + '\'' +
                '}';
    }
}
</code></pre>
<pre><code class="language-java">import com.kuang.pojo.User;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;

//这个也会被Spring容器托管，注册到容器中，因为本来就是一个@Component
//@Configuration代表这是一个配置类，就和我们之前看的beans.xml
@Configuration
@ComponentScan(&quot;com.kuang.pojo&quot;)
@Import(KuangConfig2.class )
public class KuangConfig {
    //注册一个bean，就相当于我们之前写的一个bean标签
    //这个方法的名字，就相当于bean标签中的id属性
    //这个方法的返回值，就相当于bean标签中的class属性
    @Bean
    public User getUser(){
        return new User();//就是返回要注入到bean的对象
    }
}
</code></pre>
<p>测试类：</p>
<pre><code class="language-java">public class MyTest {
    public static void main(String[] args) {
        //如果完全使用了配置类方式去做，我们就只能通过AnnotationConfig上下文来获取容器，通过配置类的class对象加载！
        ApplicationContext context = new AnnotationConfigApplicationContext(KuangConfig.class);
        User getUser = (User) context.getBean(&quot;getUser&quot;);
        System.out.println(getUser.getName());
    }
}
</code></pre>
<p>这种纯java的配置方式，在SpringBoot中随处可见！</p>
<h2 id="10-代理模式">10、代理模式</h2>
<p>为什么要学习代理模式？因为这就是SpringAOP的底层！【SpringAOP 和 SpringMVC 面试必问】</p>
<p>代理模式的分类：</p>
<ul>
<li>静态代理</li>
<li>动态代理</li>
</ul>
<figure data-type="image" tabindex="8"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200617154558.png" alt="" loading="lazy"></figure>
<h3 id="101-静态代理">10.1 静态代理</h3>
<p>角色分析：</p>
<ul>
<li>抽象角色：一般会使用接口或者抽象类来解决</li>
<li>真实角色：被代理的角色</li>
<li>代理角色：代理真是角色，代理真实角色后，我们一般会做一些附属操作。</li>
<li>客户：访问代理对象的人！</li>
</ul>
<p>代码步骤：</p>
<ol>
<li>
<p>接口</p>
<pre><code class="language-java">//租房
public interface Rent {
    public void rent();
}
</code></pre>
</li>
<li>
<p>真实角色</p>
<pre><code class="language-java">//房东
public class Host implements Rent {
    public void rent(){
        System.out.println(&quot;房东要出租房子！&quot;);
    }
}
</code></pre>
</li>
<li>
<p>代理角色</p>
<pre><code class="language-java">public class Proxy implements Rent {
    private Host host;

    public Proxy() {
    }
    public Proxy(Host host) {
        this.host = host;
    }

    public void rent(){
        seeHouse();
        host.rent();
        hetong();
        fee();
    }
    //看房
    public void seeHouse(){
        System.out.println(&quot;中介带你看房&quot;);
    }
    //签合同
    public void hetong(){
        System.out.println(&quot;签合同&quot;);
    }
    //收费
    public void fee(){
        System.out.println(&quot;收取中介费用&quot;);
    }
}
</code></pre>
<p>代理模式的好处：</p>
<ul>
<li>可以使真实角色的操作更加纯粹！不用去关注一些公共的业务</li>
<li>公共也就交给代理角色！实现了业务的分工！</li>
<li>公共业务发生扩展的时候，方便集中管理！</li>
</ul>
<p>缺点：</p>
<ul>
<li>一个真实角色就会产生一个代理角色，代码量会翻倍，开发效率会变低</li>
</ul>
</li>
</ol>
<h3 id="102-加深理解">10.2 加深理解</h3>
<p>聊聊AOP</p>
<figure data-type="image" tabindex="9"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200617154837.png" alt="" loading="lazy"></figure>
<h3 id="103-动态代理">10.3 动态代理</h3>
<ul>
<li>动态代理和静态代理角色一样</li>
<li>动态代理的代理类是动态生成的，不是我们直接写好的。</li>
<li>动态代理分为两大类：基于接口的动态代理，基于类的动态代理
<ul>
<li>基于接口——JDK动态代理</li>
<li>基于类：cglib</li>
<li>java字节码实现：javasisit</li>
</ul>
</li>
</ul>
<p>需要了解两个类：Proxy：代理；InvocationHandler：调用处理程序</p>
<p>动态代理的好处：</p>
<ul>
<li>可以使真实角色的操作更加纯粹！不用去关注一些公共的业务</li>
<li>公共也就交给代理角色！实现了业务的分工！</li>
<li>公共业务发生扩展的时候，方便集中管理！</li>
<li>一个动态代理类代理类代理的是一个接口，一般就是对应的一类业务</li>
<li>一个动态代理类可以代理多个类，只要是实现了同一个接口即可！</li>
</ul>
<h2 id="11-aop">11、AOP</h2>
<h3 id="111-什么是aop">11.1 什么是AOP</h3>
<p>AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生泛型，利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的频率。</p>
<figure data-type="image" tabindex="10"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200617155008.png" alt="" loading="lazy"></figure>
<h3 id="112-aop在spring中的作用">11.2 AOP在Spring中的作用</h3>
<p><mark>提供声明式事务；允许用户自定义切面</mark></p>
<ul>
<li>横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点，如日志、安全、缓存、事务等等……</li>
<li>切面（ASPECT）：横切关注点被模块化的特殊对象，即是一个类。</li>
<li>通知（Advice）：切面必须要完成的工作，即是类中的一个方法。</li>
<li>目标（Target）：被通知对象。</li>
<li>代理（Proxy）：向目标对象应用通知之后创建的对象。</li>
<li>切入点（PointCut）：切面通知执行的“地点”的定义。</li>
<li>连接点（jointPoint）：与切入点匹配的执行点。</li>
</ul>
<figure data-type="image" tabindex="11"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200617155041.png" alt="" loading="lazy"></figure>
<p>SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice：</p>
<figure data-type="image" tabindex="12"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200617155102.png" alt="" loading="lazy"></figure>
<p>即AOP在不改变原有代码的情况下，去增加新的功能。</p>
<h3 id="113-使用spring实现aop">11.3 使用Spring实现AOP</h3>
<p>【重点】使用AOP织入，需要导入一个依赖包。</p>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
    &lt;version&gt;1.9.5&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>方式一：使用Spring的API接口【主要SpringAPI接口实现】</p>
<p>方式二：自定义来实现AOP【主要是切面定义】</p>
<p>方式三：使用注解实现</p>
<h2 id="12-整合mybatis">12、整合Mybatis</h2>
<p>环境搭建：</p>
<pre><code class="language-mysql">/*
 Navicat Premium Data Transfer

 Source Server         : 本地
 Source Server Type    : MySQL
 Source Server Version : 80018
 Source Host           : localhost:3306
 Source Schema         : mybatis

 Target Server Type    : MySQL
 Target Server Version : 80018
 File Encoding         : 65001

 Date: 05/12/2019 17:56:22
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for bolg
-- ----------------------------
DROP TABLE IF EXISTS `bolg`;
CREATE TABLE `bolg` (
  `id` varchar(50) NOT NULL COMMENT '博客id',
  `title` varchar(100) NOT NULL COMMENT '博客标题',
  `author` varchar(30) NOT NULL COMMENT '博客作者',
  `creat_time` datetime NOT NULL COMMENT '创建时间',
  `views` int(30) NOT NULL COMMENT '浏览量'
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of bolg
-- ----------------------------
BEGIN;
INSERT INTO `bolg` VALUES ('1', 'Mybatis如此简单', '尹锐', '2019-12-04 20:32:07', 9999);
INSERT INTO `bolg` VALUES ('2', 'Java如此简单2', '尹锐2', '2019-12-04 20:32:07', 1000);
INSERT INTO `bolg` VALUES ('3', 'Spring如此简单', '尹锐', '2019-12-04 20:32:07', 9999);
INSERT INTO `bolg` VALUES ('4', '微服务如此简单', '尹锐', '2019-12-04 20:32:07', 9999);
COMMIT;

-- ----------------------------
-- Table structure for student
-- ----------------------------
DROP TABLE IF EXISTS `student`;
CREATE TABLE `student` (
  `id` int(10) NOT NULL,
  `name` varchar(30) DEFAULT NULL,
  `tid` int(10) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `fktid` (`tid`),
  CONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of student
-- ----------------------------
BEGIN;
INSERT INTO `student` VALUES (1, '小明', 1);
INSERT INTO `student` VALUES (2, '小红', 1);
INSERT INTO `student` VALUES (3, '小张', 1);
INSERT INTO `student` VALUES (4, '小李', 1);
INSERT INTO `student` VALUES (5, '小王', 1);
COMMIT;

-- ----------------------------
-- Table structure for teacher
-- ----------------------------
DROP TABLE IF EXISTS `teacher`;
CREATE TABLE `teacher` (
  `id` int(10) NOT NULL,
  `name` varchar(30) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of teacher
-- ----------------------------
BEGIN;
INSERT INTO `teacher` VALUES (1, '秦老师');
COMMIT;

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user` (
  `id` int(20) NOT NULL,
  `name` varchar(30) DEFAULT NULL,
  `pwd` varchar(30) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of user
-- ----------------------------
BEGIN;
INSERT INTO `user` VALUES (1, '狂神', '123456');
INSERT INTO `user` VALUES (2, '张三', '123456');
INSERT INTO `user` VALUES (3, '李四', '123890');
INSERT INTO `user` VALUES (4, '王五', '23333');
COMMIT;

SET FOREIGN_KEY_CHECKS = 1;
</code></pre>
<p>步骤：</p>
<ol>
<li>导入相关jar包
<ul>
<li>junit</li>
<li>Mybatis</li>
<li>mysql数据库</li>
<li>spring相关的</li>
<li>aop织入</li>
<li>mybatis-spring【new知识点】</li>
</ul>
</li>
<li>编写配置文件</li>
<li>测试</li>
</ol>
<h3 id="121-回忆mybatis">12.1 回忆mybatis</h3>
<ol>
<li>编写实体类</li>
<li>编写核心配置文件</li>
<li>编写接口</li>
<li>编写Mapper.xml</li>
<li>测试</li>
</ol>
<h3 id="122-mybatis-spring">12.2 Mybatis-Spring</h3>
<ol>
<li>编写数据源配置</li>
<li>sqlSessionFactory</li>
<li>sqlSessionTemplate</li>
<li>需要给接口加实现类</li>
<li>将自己写的实现类，注入到Spring中</li>
<li>测试</li>
</ol>
<h2 id="13-声明式事务">13、 声明式事务</h2>
<h3 id="131-回顾事务">13.1 回顾事务</h3>
<ul>
<li>把一组业务当成一个业务来做：要么都成功，要么都失败。</li>
<li>事务在项目开发中，十分的重要，涉及到数据的一致性问题，不能马虎。</li>
<li>确保完整性和一致性。</li>
</ul>
<p>事务ADID原则：</p>
<ul>
<li>原子性</li>
<li>一致性</li>
<li>隔离性
<ul>
<li>多个业务可能操作同一个资源，防止数据损坏</li>
</ul>
</li>
<li>持久性
<ul>
<li>事务一旦提交，无论系统发生什么问题，结果都不会再被影响，被持久化的写到存储器中。</li>
</ul>
</li>
</ul>
<p>13.2 Spring中的事务管理</p>
<ul>
<li>声明式事务：AOP</li>
<li>编程式事务：需要在代码中，进行事务的管理</li>
</ul>
<p>思考：</p>
<p>为什么需要事务？</p>
<ul>
<li>如果不配置事务，可能存在数据提交不一致的情况</li>
<li>如果我们不在Spring中去配置声明式事务，我们就需要在代码中手动配置事务</li>
<li>事务在项目的开发中十分重要，涉及到数据的一致性和完整性问题，不容马虎</li>
</ul>
]]></content>
    </entry>
</feed>