<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jonchan1013.github.io</id>
    <title>CY的学习博客</title>
    <updated>2020-06-13T18:21:51.900Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jonchan1013.github.io"/>
    <link rel="self" href="https://jonchan1013.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://jonchan1013.github.io/images/avatar.png</logo>
    <icon>https://jonchan1013.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, CY的学习博客</rights>
    <entry>
        <title type="html"><![CDATA[LeetCode刷题]]></title>
        <id>https://jonchan1013.github.io/post/leetcode-shua-ti/</id>
        <link href="https://jonchan1013.github.io/post/leetcode-shua-ti/">
        </link>
        <updated>2020-06-13T03:54:48.000Z</updated>
        <content type="html"><![CDATA[<h2 id="70-爬楼梯">70、爬楼梯</h2>
<p>题目描述：假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>**注意：**给定 <em>n</em> 是一个正整数。</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613121348.png" alt="" loading="lazy"></figure>
<p>方法1：记忆化递归：</p>
<pre><code class="language-java">class Solution {
    public int climbStairs(int n) {
        int memo[] = new int[n + 1]; //存储中间结果，避免重复计算
        return climbStairsMemo(n, memo);

    }

    public int climbStairsMemo(int n, int memo[]) {
        if (memo[n] &gt; 0) {
            return memo[n];
        }
        if (n == 1) {
            return memo[n] = 1;
        } else if (n == 2) {
            return memo[n] = 2;
        } else {
            return memo[n] = climbStairs(n - 1) + climbStairs(n - 2);
        }
    }
}
</code></pre>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<p>方法2：斐波那契数列</p>
<pre><code class="language-java">class Solution {
    public int climbStairs(int n) {
        if (n == 1) {
            return 1;
        }
        int first = 1;
        int second = 2;
        for (int i = 3; i &lt;= n; i++) {
            //滚动数组，优化空间复杂度,只记录两个状态
            int third = first + second;
            first = second;
            second = third;
        }
        return second;
    }
}
</code></pre>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Ajax]]></title>
        <id>https://jonchan1013.github.io/post/ajax/</id>
        <link href="https://jonchan1013.github.io/post/ajax/">
        </link>
        <updated>2020-06-12T10:34:35.000Z</updated>
        <summary type="html"><![CDATA[<p>✍️Ajax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式、快速动态应用的网页开发技术，无需重新加载整个网页的情况下，能够更新页面局部数据的技术。<br>
通过在后台与服务器进行少量数据交换，Ajax 可以使页面实现异步更新。这意味着可以在不重新加载整个页面的情况下，对页面的某部分进行更新。</p>
]]></summary>
        <content type="html"><![CDATA[<p>✍️Ajax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式、快速动态应用的网页开发技术，无需重新加载整个网页的情况下，能够更新页面局部数据的技术。<br>
通过在后台与服务器进行少量数据交换，Ajax 可以使页面实现异步更新。这意味着可以在不重新加载整个页面的情况下，对页面的某部分进行更新。</p>
<!-- more -->
<h2 id="1-ajax简介">1、Ajax简介</h2>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200612214538.png" alt="" loading="lazy"></figure>
<p>​		Ajax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式、快速动态应用的网页开发技术，无需重新加载整个网页的情况下，能够更新页面局部数据的技术。</p>
<p>​		通过在后台与服务器进行少量数据交换，Ajax 可以使页面实现异步更新。这意味着可以在不重新加载整个页面的情况下，对页面的某部分进行更新。</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200612214639.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200612214744.png" alt="" loading="lazy"></figure>
<h2 id="2-ajax的使用">2、Ajax的使用</h2>
<h3 id="21-xmlhttprequest-对象">2.1 XMLHttpRequest 对象</h3>
<p>​		XMLHttpRequest 是浏览器接口对象，该对象的 API 可被 JavaScript、VBScript 以及其它<br>
web 浏览器内嵌的脚本语言调用，通过 HTTP 协议在浏览器和 web 服务器之间收发 XML 或<br>
其它数据。XMLHttpRequest 可以与服务器实现异步交互，而无需让整个页面刷新，因此成<br>
为 Ajax 编程的核心对象。</p>
<h3 id="22-ajax-的使用步骤">2.2 Ajax 的使用步骤</h3>
<ol>
<li>
<p>创建 XMLHttpRequest 对象</p>
<pre><code class="language-javascript">var xhr = new XMLHttpRequest();
</code></pre>
</li>
<li>
<p>给定请求方式以及请求地址</p>
</li>
</ol>
<pre><code class="language-javascript">xhr.open(&quot;get&quot;,&quot;http://www.example.com&quot;);
</code></pre>
<ol start="3">
<li>发送请求</li>
</ol>
<pre><code class="language-javascript">xhr.send();
</code></pre>
<ol start="4">
<li>获取服务器端给客户端的响应数据</li>
</ol>
<pre><code class="language-javascript">xhr.onreadystatechange = function(){
//0:open()没有被调用
//1:open()正在被调用
//2:send()正在被调用
//3:服务端正在返回结果
//4:请求结束，并且服务端已经结束发送数据到客户端
if(xhr.readyState == 4 &amp;&amp; xhr.status == 200){
document.getElementById(&quot;span&quot;).innerHTML=xhr.responseText;
alert(xhr.responseText);
}
</code></pre>
<h3 id="23-ajax的运行原理">2.3 Ajax的运行原理</h3>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200612215857.png" alt="" loading="lazy"></figure>
<h3 id="24-示例代码">2.4 示例代码</h3>
<p>index.jsp：</p>
<pre><code class="language-js">&lt;%@ page contentType=&quot;text/html; charset=UTF-8&quot; language=&quot;java&quot;%&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;script&gt;
        function but() {
            var xhr = new XMLHttpRequest();
            xhr.open(&quot;get&quot;, &quot;ajax.do&quot;);
            xhr.send();
            xhr.onreadystatechange = function () {
                if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) {
                    alert(xhr.responseText);
                    //将数据插入到span标签中
                    document.getElementById(&quot;span&quot;).innerHTML=xhr.responseText;
                }
            }
        }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h2&gt;你好&lt;/h2&gt;
&lt;hr/&gt;
&lt;span id=&quot;span&quot;&gt;&lt;/span&gt;
&lt;input type=&quot;button&quot; value=&quot;ok&quot; onclick=&quot;but()&quot;/&gt;
&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<p>AjaxServlet:</p>
<pre><code class="language-java">@WebServlet(&quot;/ajax.do&quot;)
public class AjaxServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        PrintWriter pw=resp.getWriter();
        pw.println(&quot;hello,ajax!&quot;);
        pw.flush();
        pw.close();
    }
}
</code></pre>
<p>效果：</p>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200612234214.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200612234238.png" alt="" loading="lazy"></figure>
<h2 id="3-json详解">3、JSON详解</h2>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613002650.png" alt="" loading="lazy"></figure>
<h3 id="31-json简介">3.1 JSON简介</h3>
<p>​		JSON(JavaScript Object Notation) 是一种基于字符串的轻量级的数据交换格式。易于人阅读和编写，同时也易于机器解析和生成。JSON 是 JavaScript 数据类型的子集。</p>
<h3 id="32-为什么要使用-json">3.2 为什么要使用 JSON</h3>
<p>​		在 JSON 未出现之前在 Ajax 中对于数据传递方式，会使用 XML 作为主要数据格式来传输数据。直到 JSON 出现后逐渐放弃使用 XML 作为数据传输格式。JSON 比 XML 更小、更快，更易解析。</p>
<h3 id="33-json-格式的特征">3.3 JSON 格式的特征</h3>
<h4 id="331json-的语法规则">3.3.1JSON 的语法规则</h4>
<p>JSON 是按照特定的语法规则所生成的字符串结构。</p>
<ul>
<li>大括号表示 JSON 的字符串对象。{ }</li>
<li>属性和值用冒号分割。{&quot;属性&quot;:&quot;value&quot;}</li>
<li>属性和属性之间用逗号分割。{&quot;属性&quot;:&quot;value&quot;,&quot;属性&quot;:&quot;value&quot;,...}</li>
<li>中括号表示数组。[{&quot;属性&quot;:&quot;value&quot;...},{&quot;属性&quot;:&quot;value&quot;...}]</li>
</ul>
<p>JSON 字符串对象：<img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613002918.png" alt="" loading="lazy"></p>
<p>{&quot;userid&quot;:1,&quot;username&quot;:&quot;admin&quot;,&quot;sex&quot;:&quot;male&quot;}</p>
<p>数组：<img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613002948.png" alt="" loading="lazy"></p>
<p>[{&quot;userid&quot;:1,&quot;username&quot;:&quot;admin&quot;},{&quot;userid&quot;:2,&quot;username&quot;:&quot;oldlu&quot;}]</p>
<h4 id="332-josn-的-6-种数据类型">3.3.2 JOSN 的 6 种数据类型</h4>
<figure data-type="image" tabindex="8"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613003047.png" alt="" loading="lazy"></figure>
<ul>
<li>string：字符串，必须要用双引号引起来。</li>
<li>number：数值，与 JavaScript 的 number 一致，</li>
<li>object：JavaScript 的对象形式，{ key:value }表示方式，可嵌套。</li>
<li>array：数组，JavaScript 的 Array 表示方式[ value ]，可嵌套。</li>
<li>true/false：布尔类型，JavaScript 的 boolean 类型。</li>
<li>null：空值，JavaScript 的 null。</li>
</ul>
<h3 id="34-jackson的使用">3.4 Jackson的使用</h3>
<p>​		在 JDK 中并没有内置操作 JSON 格式数据的 API，因此使用处理 JSON 格式的数据需要借助第三方类库。<br>
几个常用的 JSON 解析类库：<br>
Gson: 谷歌开发的 JSON 库，功能十分全面。<br>
FastJson: 阿里巴巴开发的 JSON 库，性能十分优秀。<br>
Jackson: 社区十分活跃且更新速度很快。被称为“最好的 Json 解析器”</p>
<h4 id="341-jackson简介">3.4.1 Jackson简介</h4>
<p>Jackson 是一种解析 JSON 格式数据的 API，也是最流行，速度最快的 JSON API。在SpringMVC 中默认使用 Jackson API 处理 JSON 格式的数据。<br>
Jackson 下载地址：<br>
https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-annotations<br>
https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core<br>
https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind</p>
<h4 id="342-在响应中通过-json-格式传递数据">3.4.2 在响应中通过 JSON 格式传递数据</h4>
<p>在响应中使用 Jackson 处理 JSON 格式数据的步骤：</p>
<ul>
<li>添加 jackson-annotations.jar、jackson-core.jar、jackson-databind.jar</li>
<li>通过 jackson API 将 Java 对象转换 JSON 格式</li>
<li>修改响应头，响应类型为 application/json</li>
<li>将结果基于字符输出流推回客户端浏览器</li>
<li>在页面的中通过 JavaScript 的 JSON.parse()函数将 JSON 格式的数据转换为 JavaScript对象</li>
</ul>
<h5 id="3421-通过-json-格式在响应中传递单个对象">3.4.2.1 通过 JSON 格式在响应中传递单个对象</h5>
<p>需求：<br>
定义一个 User 类，包含 userid、username 属性。<br>
实例化一个 User 对象，通过 JSON 格式将 User 对象响应到客户端浏览器。<br>
将 User 对象中的数据插入到页面中。</p>
<p>User类:</p>
<pre><code class="language-java">public class User {
    private int userid;
    private String username;

    public int getUserid() {
        return userid;
    }

    public void setUserid(int userid) {
        this.userid = userid;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    @Override
    public String toString() {
        return &quot;User{&quot; +
                &quot;userid=&quot; + userid +
                &quot;, username='&quot; + username + '\'' +
                '}';
    }
}
</code></pre>
<p>SingleObjectServlet类：</p>
<pre><code class="language-java">@WebServlet(&quot;/single.do&quot;)
public class SingleObjectServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //创建User对象
        User user = new User();
        user.setUserid(10);
        user.setUsername(&quot;张三&quot;);


        //使用jackson的api将User对象转换成JSON格式的字符串对象
        ObjectMapper objectMapper = new ObjectMapper();
        //将USer对象转换为JSON格式的字符串对象
        String s = objectMapper.writeValueAsString(user);
        System.out.println(s);
        //设置响应类型为application/json
        resp.setContentType(&quot;application/json&quot;);

        PrintWriter pw = resp.getWriter();
        pw.print(s);
        pw.flush();
        pw.close();

    }
}

</code></pre>
<p>singleDemo.jsp</p>
<pre><code class="language-jsp">&lt;%@ page contentType=&quot;text/html; charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;script&gt;
        function but(){
            var xhr = new XMLHttpRequest();
            xhr.open(&quot;get&quot;,&quot;single.do&quot;);
            xhr.send();
            xhr.onreadystatechange = function(){

                if(xhr.readyState == 4 &amp;&amp; xhr.status == 200){
                    alert(xhr.responseText);
                    //通过javaScript的内置对象JSON中的parse函数将JSON格式的字符串对转换成javascript对象
                    var obj = JSON.parse(xhr.responseText);
                    alert(obj.userid+&quot; &quot;+obj.username);
                    document.getElementById(&quot;span&quot;).innerHTML=obj.userid+&quot;&lt;br/&gt;&quot;+obj.username;
                }
            }
        }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h3&gt;JSON格式的单个对象响应&lt;/h3&gt;
&lt;hr/&gt;
&lt;span id=&quot;span&quot;&gt;&lt;/span&gt;
&lt;input type=&quot;button&quot; value=&quot;OK&quot; onclick=&quot;but()&quot;/&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h5 id="3422-通过-json-格式在响应中传递多个对象">3.4.2.2 通过 JSON 格式在响应中传递多个对象</h5>
<p>需求：<br>
定义一个 User 类，包含 userid、username 属性。<br>
实例化多个 User 对象，通过 JSON 格式将 User对象响应到客户端浏览器。<br>
将 User 对象中的数据插入到页面中。</p>
<p>MultipleObjectServlet类：</p>
<pre><code class="language-java">@WebServlet(&quot;/multiple.do&quot;)
public class MultipleObjectServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        User user1 = new User();
        user1.setUserid(1);
        user1.setUsername(&quot;张三&quot;);
        User user2 = new User();
        user2.setUserid(2);
        user2.setUsername(&quot;李四&quot;);

        //将多个对象放入list中
        List&lt;User&gt; list = new ArrayList&lt;&gt;();
        list.add(user1);
        list.add(user2);

        //通过jackson将List转换成JSON格式的字符串对象
        ObjectMapper objectMapper = new ObjectMapper();
        String s = objectMapper.writeValueAsString(list);
        System.out.println(s);
        resp.setContentType(&quot;application/json&quot;);

        PrintWriter pw = resp.getWriter();
        pw.print(s);
        pw.flush();
        pw.close();
    }
}
</code></pre>
<p>multipleDemo.jsp</p>
<pre><code class="language-jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;script&gt;
        function but() {
            var xhr = new XMLHttpRequest();
            xhr.open(&quot;get&quot;, &quot;multiple.do&quot;);
            xhr.send();
            xhr.onreadystatechange = function () {

                if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) {
                    alert(xhr.responseText);
                    //通过javaScript的内置对象JSON中的parse函数将JSON格式的字符串对转换成javascript对象
                    //此时obj是数组，里面存放的是JavaScript对象
                    var obj = JSON.parse(xhr.responseText);
                    var temp = &quot;&quot;;
                    for (var i = 0; i &lt; obj.length; i++) {
                        alert(obj[i].userid + &quot; &quot; + obj[i].username);
                        temp +=obj[i].userid + &quot;&lt;br/&gt;&quot; + obj[i].username
                    }

                    document.getElementById(&quot;span&quot;).innerHTML = temp;
                }
            }
        }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h3&gt;JSON格式的多个对象响应&lt;/h3&gt;
&lt;hr/&gt;
&lt;span id=&quot;span&quot;&gt;&lt;/span&gt;
&lt;input type=&quot;button&quot; value=&quot;OK&quot; onclick=&quot;but()&quot;/&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[jQuery]]></title>
        <id>https://jonchan1013.github.io/post/jquery/</id>
        <link href="https://jonchan1013.github.io/post/jquery/">
        </link>
        <updated>2020-06-11T01:32:04.000Z</updated>
        <summary type="html"><![CDATA[<p>✍️ jQuery 是一个 JavaScript 库。 jQuery 极大地简化了 JavaScript 编程......</p>
]]></summary>
        <content type="html"><![CDATA[<p>✍️ jQuery 是一个 JavaScript 库。 jQuery 极大地简化了 JavaScript 编程......</p>
<!-- more -->
<h2 id="1-jquery的概述">1、jQuery的概述</h2>
<h3 id="11-为什么要用jquery">1.1 为什么要用jquery</h3>
<ul>
<li>选择器功能弱</li>
<li>DOM操作繁琐之极</li>
<li>浏览器兼容性不好</li>
<li>动画效果弱</li>
</ul>
<h3 id="12-什么是-jquery概念">1.2 什么是 jQuery(概念)</h3>
<p>​	jQuery （javaScriptQuery）JavaScript 代码库</p>
<p>js.js:</p>
<pre><code class="language-js">function $(id){
    var dom = document.getElementById(id);
    return dom;
}
</code></pre>
<p>jq的含义.html:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;utf-8&quot;&gt;
		&lt;title&gt;&lt;/title&gt;
		
		&lt;!--[1]引入js文件--&gt;
		
		&lt;script src=&quot;js/js.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
		
		&lt;script&gt;
			
			//js获得元素对象的方式
			var  div =document.getElementById(&quot;div1&quot;);
			
			//JQ获得元素的方式
			var  div2=$(&quot;div1&quot;);
			
		&lt;/script&gt;	
		
	&lt;/head&gt;
	&lt;body&gt;
		
		&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;
		
	&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="13-目前-jquery-有三个大版本">1.3 目前 jQuery 有三个大版本：</h3>
<ul>
<li>
<p>1.x：兼容ie678,使用最为广泛的，官方只做BUG维护，功能不再新增。因此一般项目来说，使用1.x版本就可以了，最终版本：1.12.4 (2016年5月20日)</p>
</li>
<li>
<p>2.x：不兼容ie678，很少有人使用，官方只做BUG维护，功<br>
能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x，最终版本：2.2.4 (2016年5月20日)</p>
</li>
<li>
<p>3.x：不兼容 ie678，只支持最新的浏览器。除非特殊要求一般不会使用 3.x 版本的，很多老的 jQuery 插件不支持这个版本。目前该版本是官方主要更新维护的版本。最新版本：3.4.1</p>
</li>
</ul>
<h2 id="2-jquery-中的含义">2、jQuery 中$的含义</h2>
<p>引入jQuery：</p>
<script src="js/jquery-1.9.1.js" type="text/javascript" charset="utf-8"></script>
<p>js的方式实现隔行变色的效果：</p>
<pre><code class="language-html">window.onload=function(){	  	 	
		  	 	//获得所有的tr对象  	 	
  	 	var  tr =document.getElementsByTagName(&quot;tr&quot;);
		  	 	
	 	 	for(var i =0;i&lt;tr.length;i++){ 		
  	 		 if(i%2==0){
  	 		 	tr[i].style.backgroundColor=&quot;red&quot;;	  	 		 	
		  		 }else { 	 		 	
		  		 	tr[i].style.backgroundColor=&quot;green&quot;;
	 	 		 }		  	 				  	 		
  	 	} 	 	
  	 }
</code></pre>
<p>jQuery实现隔行变色的效果：</p>
<pre><code class="language-javascript">$(function(){	
	 	  $(&quot;tr:odd&quot;).css(&quot;background-color&quot;,&quot;red&quot;);
 })
</code></pre>
<h3 id="21-作用-1function">2.1 作用 1：$(function)</h3>
<ul>
<li>相当于 window.onload=function(){}</li>
<li>功能比window.onload更强大
<ol>
<li>window onload一个页面只能写一个,但是可以写多个$() 而不冲突</li>
<li>window onload要等整个页面加载完后再执行（包括图片、超链接、音视频等），但是$的执行时间要早</li>
</ol>
</li>
<li>3.完整形式是$(document).ready(…….);</li>
</ul>
<h3 id="22-作用-2selector">2.2. 作用 2：$(selector)</h3>
<ul>
<li>选择器<br>
jQuery具有强大的选择器功能</li>
</ul>
<h2 id="3-基本选择器一">3、基本选择器（一）</h2>
<h3 id="31-对象之间的转换">3.1 对象之间的转换</h3>
<ul>
<li>DOM对象：直接使用JavaScript获取的节点对象
<ul>
<li>className  innerHTML  value</li>
</ul>
</li>
<li>jQuery对象：使用jQuery选择器获取的节点对象，它能够使用jQuery中的方法
<ul>
<li>addClass()  html()  val()</li>
</ul>
</li>
<li>DOM对象和jQuery对象分别拥有一套独立的方法，不能混用</li>
<li>DOM对象转换成jQuery对象
<ul>
<li>$(DOM对象)</li>
</ul>
</li>
<li>jQuery对象转换成DOM对象
<ul>
<li>jQuery对象[index]</li>
<li>jQuery对象.get(index)</li>
</ul>
</li>
</ul>
<h3 id="32-基本选择器">3.2 基本选择器</h3>
<ul>
<li>标签选择器 $(“a”)</li>
<li>ID选择器 $(“#id”)    $(“p#id”)</li>
<li>类选择器 $(“.class”)    $(“h2.class”)    通配选择器 $(&quot;*&quot;)</li>
</ul>
<pre><code class="language-html">&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;utf-8&quot;&gt;
		&lt;title&gt;&lt;/title&gt;
		
		&lt;script src=&quot;js/jquery-1.9.1.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
		
		&lt;script type=&quot;text/javascript&quot;&gt;
			   $(function(){		   	
			   	//js获得元素对象
			    var  zh =document.getElementById(&quot;zh&quot;);
			    //Element
			    // JS----JQ对象
			    var  zhh=$(zh);
			    alert(zh);
			    
			    //JQ获得元素的对象  *ID选择器
			    var  zh1=$(&quot;#zh&quot;);
			    //Object---[Element1,Element2,Element3]
			    //JQ----JS对象
			    alert(zh1[0]);
			    
			    //*元素选择器
			    var inp =$(&quot;input&quot;);
			    
			    alert(inp.length);

                //*类选择器
                
                var inp2=$(&quot;.inp&quot;);
                //jq先转成js再获取内容
              alert(inp2[0].value);
                //  jq获得内容操作
			    alert(inp2.eq(0).val());

                //通用选择器
                
                $(&quot;*&quot;).css(&quot;background-color&quot;,&quot;greenyellow&quot;);
                
			    //分组选择器
			   })
		
		&lt;/script&gt;
	
	&lt;/head&gt;
	&lt;body&gt;	
		&lt;p&gt;		
			账号: &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;zh&quot; value=&quot;123&quot; /&gt;		
		&lt;/p&gt;		
		&lt;p&gt;
			密码: &lt;input type=&quot;password&quot; name=&quot;&quot; id=&quot;pwd&quot; value=&quot;12366&quot;  class=&quot;inp&quot;/&gt;			
		&lt;/p&gt;
		&lt;p&gt;
			 确认密码： &lt;input type=&quot;password&quot; name=&quot;&quot; id=&quot;pwd2&quot; value=&quot;123&quot; class=&quot;inp&quot;/&gt;		
		&lt;/p&gt;	
	&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<h2 id="4-层级选择器">4、层级选择器</h2>
<ul>
<li>并集选择器$(&quot;elem1,elem2,elem3&quot;)</li>
<li>后代选择器$(ul li)</li>
<li>父子选择器 $(ul&gt;li)</li>
<li>后面第一个兄弟元素 prev + next
<ul>
<li>后面所有的兄弟元素 prev ~ next</li>
</ul>
</li>
</ul>
<pre><code class="language-html">&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;utf-8&quot;&gt;
		&lt;title&gt;&lt;/title&gt;
		&lt;style&gt;			
			div{				
				height: 200px;				
				border:  3px solid  red;				
			}
		&lt;/style&gt;
		
		&lt;script src=&quot;js/jquery-1.9.1.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
		
		&lt;script type=&quot;text/javascript&quot;&gt;
			
			   $(function(){
			   	
			   	   //  div下面包含的所有span标签
			   	   $(&quot;div span&quot;).css(&quot;background-color&quot;,&quot;red&quot;);
			   	  // div下面的直系子元素
			   	   $(&quot;div&gt;span&quot;).css(&quot;background-color&quot;,&quot;green&quot;);

                  //  紧接着的span标签
                 $(&quot;#sp1 + span&quot;).css(&quot;background-color&quot;,&quot;red&quot;);
                    
                    //获得指定元素后面同级的span标签
                   $(&quot;#sp1~span&quot;).css(&quot;background-color&quot;,&quot;aqua&quot;); 
			   	
			   })		
		&lt;/script&gt;		
	&lt;/head&gt;
	&lt;body&gt;		
	   &lt;div&gt;	   	 
	   	 &lt;span id=&quot;sp1&quot;&gt;你好&lt;/span&gt;
	   	 
	   	 &lt;span&gt;你好&lt;/span&gt;&lt;br /&gt;
	   	 
	   	 &lt;span&gt;你好&lt;/span&gt;&lt;br /&gt;
	   	 
	   	 &lt;p&gt;
	   	 	&lt;span&gt;你好&lt;/span&gt;&lt;br /&gt;
	   	 
	   	    &lt;span&gt;你好&lt;/span&gt;&lt;br /&gt;
	   	 
	   	    &lt;span&gt;你好&lt;/span&gt;&lt;br /&gt;
	   	 		   	 	
	   	 &lt;/p&gt;	   	
	   &lt;/div&gt;		
	&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<h2 id="5-基本选择器二">5、基本选择器（二)</h2>
<pre><code class="language-html">&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;utf-8&quot;&gt;
		&lt;title&gt;&lt;/title&gt;
		&lt;style&gt;
			div{
				
				height: 200px;
				
				border:  3px solid red;
				
			}
		&lt;/style&gt;
		&lt;script src=&quot;js/jquery-1.9.1.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
		
		&lt;script type=&quot;text/javascript&quot;&gt;
			
			  $(function(){
			  	    //只是第一行变颜色
			  	   $(&quot;ul li:first&quot;).css(&quot;background-color&quot;,&quot;red&quot;);
			  	   $(&quot;ul li&quot;).first().css(&quot;background-color&quot;,&quot;red&quot;);
			  	   
			  	   //最后一行变颜色
			  	   $(&quot;ul li:last&quot;).css(&quot;background-color&quot;,&quot;green&quot;);
			  	   $(&quot;ul li&quot;).last().css(&quot;background-color&quot;,&quot;green&quot;);
                   //获得索引是奇数对象  索引从0开始
             	  $(&quot;ul li:odd&quot;).css(&quot;background-color&quot;,&quot;green&quot;);
					//获得索引是偶数对象  索引从0开始
                  $(&quot;ul li:even&quot;).css(&quot;background-color&quot;,&quot;green&quot;);
			  	   //获得索引下标位3的对象
			   	  $(&quot;ul li:eq(3)&quot;).css(&quot;background-color&quot;,&quot;green&quot;);
                    //获得大于指定索引下标的对象
                  $(&quot;ul li:gt(3)&quot;).css(&quot;background-color&quot;,&quot;green&quot;);
			  	    //获得小于指定索引下标的对象
			  	   $(&quot;ul li:lt(3)&quot;).css(&quot;background-color&quot;,&quot;green&quot;);

                   /**********子选择器*************************/
                  
                  
             	 $(&quot;ul li:nth-child(1)&quot;).css(&quot;background-color&quot;,&quot;green&quot;);
                    
                 $(&quot;ul li:first-child&quot;).css(&quot;background-color&quot;,&quot;darkred&quot;);
                    
                 $(&quot;ul li:last-child&quot;).css(&quot;background-color&quot;,&quot;darkred&quot;);  
                  
                 $(&quot;ul li:only-child&quot;).css(&quot;background-color&quot;,&quot;#00A40C&quot;);
			  })		
		&lt;/script&gt;
				
	&lt;/head&gt;
	&lt;body&gt;		
		&lt;div&gt;		
			&lt;ul&gt;
				&lt;li&gt;List  Item1&lt;/li&gt;
				&lt;li&gt;List  Item2&lt;/li&gt;
				&lt;li&gt;List  Item3&lt;/li&gt;
				&lt;li&gt;List  Item4&lt;/li&gt;
			&lt;/ul&gt;	
            
			&lt;ul&gt;
				&lt;li&gt;List  Item1&lt;/li&gt;
			&lt;/ul&gt;						
		&lt;/div&gt;	
	&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<h2 id="6-属性选择器">6、属性选择器</h2>
<pre><code class="language-html">&lt;script type=&quot;text/javascript&quot;&gt;
			
			$(function(){
				//type属性等于text
				$(&quot;input[type=text]&quot;).css(&quot;background-color&quot;,&quot;#00A40C&quot;);
				// name属性用z开头的
				$(&quot;input[name^=z]&quot;).css(&quot;background-color&quot;,&quot;#FF0000&quot;);
				// name属性同d结尾的
				$(&quot;input[name$=d]&quot;).css(&quot;background-color&quot;,&quot;green&quot;);
				//name属性中包含p 的元素
				$(&quot;input[name*=p]&quot;).css(&quot;background-color&quot;,&quot;green&quot;);
               
               //复合属性选择器，需要同时满足多个条件时使用
                $(&quot;input[type=text][name^=z]&quot;).css(&quot;background-color&quot;,&quot;deeppink&quot;); 
			})
			
			
		&lt;/script&gt;
</code></pre>
<h2 id="7-表单选择器">7、表单选择器</h2>
<pre><code class="language-html">&lt;script type=&quot;text/javascript&quot;&gt;
			
			$(function(){
				
				// √ 获得form表单中的所有的表单项
				var inp= $(&quot;:input&quot;) 
				//获得标签名称是input 的所有的标签对象
				var  inp2=$(&quot;input&quot;);
				alert(inp.length+&quot;----&quot;+inp2.length);
				
				$(&quot;input[type=text]&quot;)
				//  √ input标签 type属性等于text所对应的对象
				$(&quot;:text&quot;).css(&quot;background-color&quot;,&quot;green&quot;);
				
				$(&quot;:password&quot;).css(&quot;background-color&quot;,&quot;red&quot;);
				
				
				/********表单属性选择器*****************/
				
				//获得input标签中含有disabled属性的对象
				var but=  $(&quot;input:disabled&quot;);	
				
				alert(but.val());
				//√  获得含有checked属性的对象
				var  ch =$(&quot;input:checked&quot;);
				
			})
</code></pre>
<h2 id="8-操作元素对象的样式">8、 操作元素对象的样式</h2>
<pre><code class="language-html">&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;utf-8&quot;&gt;
		&lt;title&gt;&lt;/title&gt;
		
		&lt;style&gt;
			
			#div1{
				
				width: 200px;
				
				height: 200px;
				
				border: 2px solid  green;
				
			}			
		&lt;/style&gt;		
		&lt;script src=&quot;js/jquery-1.9.1.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
		
		&lt;script type=&quot;text/javascript&quot;&gt;
			
			$(function(){
				
				
				$(&quot;#bu1&quot;).click(function(){
					
					//获得div对象
					
					var  div =$(&quot;#div1&quot;);
					
					//获得css样式
					
					var wid=div.css(&quot;width&quot;);
					
					var hi=div.css(&quot;height&quot;);
					
					console.log(wid+&quot;----&quot;+hi);
					
					//操作元素对象的css
					
					div.css(&quot;width&quot;,&quot;400px&quot;);
					
					div.css(&quot;height&quot;,&quot;500px&quot;);
					
					div.css(&quot;background-color&quot;,&quot;red&quot;);
					
					div.css(&quot;backgroundColor&quot;,&quot;red&quot;);
					
				  //以上内容的综合---{key1:value1,key2:value2}---json数据格式
					
					div.css({'width':'300px','height':'300px','background-color':'red'});
				})
				
				
			})
			
		&lt;/script&gt;
		
	&lt;/head&gt;
	&lt;body&gt;		
		&lt;input type=&quot;button&quot; value=&quot;样式的添加&quot; id=&quot;bu1&quot;&gt;		
		&lt;hr /&gt;	
		&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;	
	&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<p>如果当页面中的css样式比较多的时候可以通过添加类的方式添加样式，方法如下：两种：</p>
<pre><code class="language-html">&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;utf-8&quot;&gt;
		&lt;title&gt;&lt;/title&gt;
		&lt;style&gt;
			#div1{
				
				width: 300px;
				
				height: 300px;
				
				border:  3px solid red;
				
			}
			
			.div{
				
				width: 500px;
				
				height: 500px;
				
				
				background-image: url(img/1.jpg);
				
				background-repeat: no-repeat;
				
				background-position: center;
				
				background-color: greenyellow;
				
			}
			
		&lt;/style&gt;
		
		&lt;script src=&quot;js/jquery-1.9.1.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
		
		&lt;script type=&quot;text/javascript&quot;&gt;
			
			  $(function(){
			  	 
			  	$(&quot;#bu1&quot;).click(function(){
			  		
			  		//获得div对象 --通过添加类的方式添加css样式
			  		$(&quot;#div1&quot;).attr(&quot;class&quot;,&quot;div&quot;);
			  		
			  		$(&quot;#div1&quot;).addClass(&quot;div&quot;);
			  	})			  				  	
			  })
						
		&lt;/script&gt;				
	&lt;/head&gt;
	&lt;body&gt;
		
		&lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;bu1&quot; value=&quot;元素样式操作&quot; /&gt;		
		&lt;hr /&gt;		
		&lt;div id=&quot;div1&quot;&gt;			
		&lt;/div&gt;
	&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<h2 id="9-操作元素对象的属性">9、操作元素对象的属性</h2>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;utf-8&quot;&gt;
		&lt;title&gt;&lt;/title&gt;
		&lt;script src=&quot;js/jquery-1.9.1.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
		
		&lt;script type=&quot;text/javascript&quot;&gt;
			
			 $(function(){
			 	
			 	 $(&quot;#bu1&quot;).click(function(){
			 	 	
			 	  //获得元素对象
			 	  var tex=$(&quot;#inp1&quot;);
			 	 //获得元素对象的属性	
			 	  var te=tex.attr(&quot;type&quot;);
			 	 	
			 	  var cl =tex.attr(&quot;class&quot;);
			 	 //获得元素固有的属性值
			 	 var  val =tex.attr(&quot;value&quot;);
			 	 
			 	 console.log(te+&quot;------&quot;+cl+&quot;-----&quot;+val);
			 	 //获得文本框实时输入的值
			 	 var  val2=tex.val();
			 	  alert(val2);
			 	 
			 	 /*********操作元素对象的属性******************/
                  
                  tex.attr(&quot;type&quot;,&quot;button&quot;);
                  
                  tex.attr(&quot;value&quot;,&quot;测试按钮&quot;);
			 	 
			 	 //支持json数据格式
			 	  tex.attr({&quot;type&quot;:&quot;button&quot;,&quot;value&quot;:&quot;测试按钮&quot;});
			 	  
			 	  var ch= $(&quot;#fav&quot;).attr(&quot;checked&quot;);//返回的是checked
                  var  flag=$(&quot;#fav&quot;).prop(&quot;checked&quot;);//返回值是true或false

                  var  flag=$(&quot;#fav&quot;).prop(&quot;checked&quot;,true);
			 	 
			 	 })			 	
			 	
			 })
		&lt;/script&gt;
		
	&lt;/head&gt;
	&lt;body&gt;
		
		&lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;bu1&quot; value=&quot;元素属性的获得&quot; /&gt;
		&lt;hr /&gt;
		&lt;form&gt;
			
			
			账号：&lt;input type=&quot;text&quot; class=&quot;inp&quot; id=&quot;inp1&quot; value=&quot;sxt&quot; /&gt; &lt;br /&gt;
			
			
			密码：&lt;input type=&quot;password&quot; class=&quot;pwd&quot; id=&quot;pwd1&quot; value=&quot;sxt&quot; /&gt;&lt;br /&gt;
			
			
			爱好： 抽烟：&lt;input type=&quot;checkbox&quot; /&gt;
			         
			       喝酒：&lt;input type=&quot;checkbox&quot; /&gt;
			
			       烫头：&lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot; id=&quot;fav&quot; /&gt;
		
		&lt;/form&gt;
		
	&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<h2 id="10-操作元素对象的内容和值">10、操作元素对象的内容和值</h2>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;utf-8&quot;&gt;
		&lt;title&gt;&lt;/title&gt;
      &lt;script src=&quot;js/jquery-1.9.1.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
      
      &lt;script type=&quot;text/javascript&quot;&gt;
      	
      	$(function(){
      		
      		$(&quot;#bu1&quot;).click(function(){
      			
      			 //获得div元素对象
      			 var div =$(&quot;#div1&quot;);
      			 
      			 
      			 //获得元素的内容 含有HTML的标签的
      			 var  ht=div.html();
      			 
      			 console.log(ht);
      			 //只是获得文本内容， 不含有HTML标签
      			 var te =div.text();
      			 
      			 console.log(te);
      			//获得文本框的值
      			
      			var val=$(&quot;#inp1&quot;).val();
      			
      			console.log(val);
      			
      			
      			/********操作元素对象的内容和值****************/
      			
      			//会识别这里的b标签，覆盖之前的内容
      			div.html(&quot;&lt;b&gt;我们都爱笑&lt;/b&gt;&quot;);
				
				//不会识别这里的b标签，覆盖之前的内容
      			div.text(&lt;b&gt;我们都爱笑&lt;/b&gt;&quot;);
      			
				//累加，不覆盖
      			div.text(div.text()+&quot;&lt;b&gt;我们都爱笑&lt;/b&gt;&quot;);
      			
      			
      			$(&quot;#inp1&quot;).val(&quot;123&quot;);
      			
      		})
	
      	})
      	
      	
      &lt;/script&gt;
	
	&lt;/head&gt;
	&lt;body&gt;
		
		&lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;bu1&quot; value=&quot;操作元素的内容&quot; /&gt;
		&lt;hr /&gt;
		
		&lt;div id=&quot;div1&quot;&gt;
			
			&lt;span&gt;你好&lt;/span&gt;
			
		&lt;/div&gt;
	
		&lt;input type=&quot;text&quot; name=&quot;inp1&quot;  id=&quot;inp1&quot; value=&quot;&quot; /&gt;
		
	&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<h2 id="11-操作元素对象的节点">11、操作元素对象的节点</h2>
<pre><code class="language-html">&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;utf-8&quot;&gt;
		&lt;title&gt;&lt;/title&gt;
		&lt;style&gt;	
			#div1{
				height: 300px;
				
				border: 3px solid  red;
			}
			p{
				border: 2px solid  green;
				
			}
		&lt;/style&gt;
		
		&lt;script src=&quot;js/jquery-1.9.1.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
		
		&lt;script type=&quot;text/javascript&quot;&gt;
			$(function(){
				//创建了新的元素
				var  p=$(&quot;&lt;p&gt; &lt;b&gt;List  Item0&lt;/b&gt; &lt;/p&gt;&quot;)
				//增加子元素   ---现有元素之后
				$(&quot;#div1&quot;).append(p);
                 //把p元素增加到  div里面 
                p.appendTo(&quot;#div1&quot;);
               //添加内部的子元素  ---现有元素之前
                $(&quot;#div1&quot;).prepend(p);
               
                p.prependTo(&quot;#div1&quot;);
               //平级的添加元素---现有元素之前
                p.insertBefore(&quot;#div1&quot;);
               
                $(&quot;#div1&quot;).before(p);
                
                //平级的添加元素---现有元素之后
                p.insertAfter(&quot;#div1&quot;);
                
                $(&quot;#div1&quot;).after(p);

            /***********替换指定的节点******************/
            
            $(&quot;div p:nth-child(1)&quot;).replaceWith(p);
            
            p.replaceAll(&quot;div p:nth-child(5)&quot;);
             
             /**********删除指定的节点元素***************************/
             //删除指定的元素
            $(&quot;#div1&quot;).remove();
	        //删除指定下标为3的子元素
	         $(&quot;div p:nth-child(3)&quot;).remove();
	         
	         
	         //清空内容,div1里面的内容全清空
	         $(&quot;#div1&quot;).empty();
	         
	         $(&quot;div p:nth-child(2)&quot;).empty();
	         
			})
			
		&lt;/script&gt;
		
	&lt;/head&gt;
	&lt;body&gt;
		
		&lt;div id=&quot;div1&quot;&gt;
			
			&lt;p&gt;List Item1&lt;/p&gt;
			
			&lt;p&gt;List Item2&lt;/p&gt;
			
			&lt;p&gt;List Item3&lt;/p&gt;
			
			&lt;p&gt;List Item4&lt;/p&gt;
			
			&lt;p&gt;List Item5&lt;/p&gt;	
		&lt;/div&gt;
		
	&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<pre><code class="language-html">&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;utf-8&quot;&gt;
		&lt;title&gt;&lt;/title&gt;
		&lt;script src=&quot;js/jquery-1.9.1.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
		
		&lt;script type=&quot;text/javascript&quot;&gt;
			
			 function insertNode(){
			 	
			 	//创建节点对象
			 	var  p =$('&lt;p&gt;'+
				'照片:&lt;input type=&quot;file&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;&quot; /&gt;'+
				'&lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;删除&quot; onclick=&quot;removeNode(this)&quot; /&gt;'+
			    '&lt;/p&gt;');
			 	
			 	$(&quot;#last&quot;).before(p);
			 	
			 }
			 function removeNode(obj){
			 	
			 	$(obj).parent().remove();
			 }
						
		&lt;/script&gt;
				
	&lt;/head&gt;
	&lt;body&gt;
		
		&lt;form&gt;
			
			&lt;p&gt;
				
				用户名:&lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;&quot; /&gt;
				
			&lt;/p&gt;
			
			&lt;p&gt;
				照片:&lt;input type=&quot;file&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;&quot; /&gt;
				
				&lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;添加&quot; onclick=&quot;insertNode()&quot; /&gt;
			&lt;/p&gt;
			
			&lt;p id=&quot;last&quot;&gt;
				&lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;提交&quot; /&gt;
				
				&lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;清空&quot; /&gt;
			&lt;/p&gt;
			
		&lt;/form&gt;	
	&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<h2 id="12-事件处理">12、事件处理</h2>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;utf-8&quot;&gt;
		&lt;title&gt;&lt;/title&gt;
		&lt;script src=&quot;http://apps.bdimg.com/libs/jquery/1.7.0/jquery.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
		
		&lt;script type=&quot;text/javascript&quot;&gt;
			/*页面加载完执行的操作*/
//			$(function(){})
			
//			jQuery(function(){})
			
//			$(document).ready(function(){})
			
			$(function(){
				/*******事件的基础绑定*************/
				$(&quot;#bu1&quot;).click(function(){
				
				alert(&quot;单击事件&quot;);
				
			  })
			  
			 $(&quot;#bu1&quot;).dblclick(function(){
			  	
			  	alert(&quot;双击事件&quot;);
			  })
			 
			  /*******bind事件绑定**************/
			  $(&quot;#bu2&quot;).bind('click',function(){
			  	
			  	alert(&quot;单击事件绑定&quot;);
			  	
			  })*/
			  //内容还支持json数据格式
			  $(&quot;#bu2&quot;).bind({
			  	 'click':function(){},
			  	 'dblclick':function(){},
			  	 'blur':function(){}
			  	})
			  
			  /*********one一次事件绑定*************/
			  
				$(&quot;#bu3&quot;).one('click',function(){
					
					alert(&quot;一次事件绑定&quot;);
				})			
				
				/*********trigger事件操作****************/
				
				$(&quot;#bu4&quot;).click(function(){
						
					$(&quot;#bu1&quot;).trigger('dblclick');
					
					$(&quot;#bu3&quot;).trigger('click');
					
				})
				
				/********事件的解绑***********/
				
				$(&quot;#bu5&quot;).click(function(){
					
					//事件的解绑
					//解绑指定对象上的所有事件
					$(&quot;#bu1&quot;).unbind();
					//解绑指定的事件
					$(&quot;#bu1&quot;).unbind(&quot;dblclick&quot;);
					
				})
				
				$(&quot;.bu6&quot;).click(function(){
					
					alert(&quot;单击事件的绑定&quot;);
					
				})
				
				$(&quot;.bu6&quot;).live('click',function(){
					
					alert(&quot;单击事件绑定&quot;);
					
				})
				
				
				$(&quot;body&quot;).append('&lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; class=&quot;bu6&quot; value=&quot;事件操作2&quot; /&gt;');
				
			})
		
		&lt;/script&gt;
	
	&lt;/head&gt;
	&lt;body&gt;
	
		&lt;input type=&quot;button&quot; name=&quot;bu1&quot; id=&quot;bu1&quot; value=&quot;事件绑定&quot; /&gt;
		
		&lt;input type=&quot;button&quot; name=&quot;bu2&quot; id=&quot;bu2&quot; value=&quot;bind事件绑定&quot; /&gt;
		
		&lt;input type=&quot;button&quot; name=&quot;bu3&quot; id=&quot;bu3&quot; value=&quot;one事件绑定&quot; /&gt;
		
		&lt;input type=&quot;button&quot; name=&quot;bu4&quot; id=&quot;bu4&quot; value=&quot;tigger事件学习&quot; /&gt;
		
		&lt;input type=&quot;button&quot; name=&quot;bu5&quot; id=&quot;bu5&quot; value=&quot;事件解绑&quot; /&gt;
	
		&lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; class=&quot;bu6&quot; value=&quot;事件操作&quot; /&gt;
	
	&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<h2 id="13-动画功能">13、动画功能</h2>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;utf-8&quot;&gt;
		&lt;title&gt;&lt;/title&gt;
		&lt;style&gt;
			#div1{		
				height: 300px;
				background-color: green;
			}
			
			#div2{
				
				height: 300px;
				
				background-color: yellow;
		}
		&lt;/style&gt;
		
		&lt;script src=&quot;js/jquery-1.9.1.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
		
		&lt;script type=&quot;text/javascript&quot;&gt;
			
			  $(function(){
			  	  $(&quot;#bu1&quot;).click(function(){
			  	  	
			  	  	  //获得div对象
			  	  	  var  div1 =$(&quot;#div1&quot;);
			  	  	  
			  	  	  //3s隐藏动画
			  	  	  div1.hide(3000);
			  	  	  
			  	  	  div1.show(3000);
                      //隐藏的显示 ---显示的隐藏
                      $(&quot;div&quot;).toggle(3000);
                     //滑动上
                   div1.slideUp(3000);
                     //滑动下
                   div1.slideDown(3000);
                     //滑动上--滑动下    滑动下---滑动上
                   $(&quot;div&quot;).slideToggle(3000);
                   
                     //淡出
                     div1.fadeOut(3000);
                     //淡入
                     div1.fadeIn(3000);
			  	  	
			  	  })
	  	
			  })
			
		&lt;/script&gt;
		
	&lt;/head&gt;
	&lt;body&gt;
		
		&lt;input type=&quot;button&quot; id=&quot;bu1&quot; value='动画触发'&gt;
		
		&lt;hr /&gt;
		
		&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;
		
		&lt;div id=&quot;div2&quot;&gt;&lt;/div&gt;	
	&lt;/body&gt;
&lt;/html&gt;

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础-面向对象]]></title>
        <id>https://jonchan1013.github.io/post/java-ji-chu-mian-xiang-dui-xiang/</id>
        <link href="https://jonchan1013.github.io/post/java-ji-chu-mian-xiang-dui-xiang/">
        </link>
        <updated>2020-06-10T07:42:29.000Z</updated>
        <summary type="html"><![CDATA[<p>✍️面向对象的基本思想是，从现实世界中客观存在的事物出发来构造软件系统，并在系统的构造中尽可能运用人类的自然思维方式。<br>
面向对象更加强调运用人类在日常生活的逻辑思维中经常采用的思想方法与原则，如抽象、分类，继承、聚合、多态等。</p>
]]></summary>
        <content type="html"><![CDATA[<p>✍️面向对象的基本思想是，从现实世界中客观存在的事物出发来构造软件系统，并在系统的构造中尽可能运用人类的自然思维方式。<br>
面向对象更加强调运用人类在日常生活的逻辑思维中经常采用的思想方法与原则，如抽象、分类，继承、聚合、多态等。</p>
<!-- more -->
<h2 id="1-面向对象一">1、面向对象（一）</h2>
<h3 id="11-面向过程的思想和面向对象的思想">1.1 面向过程的思想和面向对象的思想</h3>
<p>​		面向对象和面向过程的思想有着本质上的区别, <strong>作为面向对象的思维来说，当你拿到一个问题时，你分析这个问题不再是第一步先做什么，第二步再做什么，这是面向过程的思维，你应该分析这个问题里面有哪些类和对象，这是第一点，然后再分析这些类和对象应该具有哪些属性和方法。这是第二点。最后分析类和类之间具体有什么关系，这是第三点。</strong></p>
<p>​		<strong>面向对象有一个非常重要的设计思维：合适的方法应该出现在合适的类里面。</strong></p>
<h3 id="12-简单理解面向对象">1.2 简单理解面向对象</h3>
<p>​		就是在程序里面首先分解出来的应该是注意不再是一步一步的过程了，而是首先考虑在这个问题域里面或者程序里面应该具有有哪些对象，所以从现在开始考虑任何问题脑子里不要再想着我实现这件事我第一步应该干什么，第二步应该干什么，如果这样想，那就是面向过程的思维了。面向对象的思维是，当我碰到这个问题域的时候，碰到这个程序的时候，我首先应该把这个问题里有哪些对象，对象与对象之间有什么关系抽象出来。</p>
<h3 id="13-面向对象的设计思想">1.3 面向对象的设计思想</h3>
<ul>
<li>面向对象的基本思想是，从现实世界中客观存在的事物出发来构造软件系统，并在系统的构造中尽可能运用人类的自然思维方式。</li>
<li>面向对象更加强调运用人类在日常生活的逻辑思维中经常采用的思想方法与原则，如抽象、分类，继承、聚合、多态等。</li>
<li>人在思考的时候，首先眼睛里看到的是一个一个的对象。</li>
</ul>
<h3 id="14-对象和类的概念">1.4  对象和类的概念</h3>
<p>​		对象是用于计算机语言对问题域中事物的描述，<strong>对象通过“属性（attribute）”和“方法（method）”来分别对应事物所具有的静态属性和动态属性</strong>。</p>
<p>​		<strong>类是用于描述同一类的对象的一个抽象的概念，类中定义了这一类对象所具有的静态属性和动态属性</strong></p>
<p>​		<strong>类可以看成一类对象的模板，对象可以看成该类的一个具体实例</strong>。</p>
<p>​		<strong>eg.什么叫瓶子？</strong></p>
<p>​		瓶子的定义：具有某些类特征的东西就是瓶子，比分说什么样的形状，比方说有个口，能倒水，能装水，一般有个盖等等。给瓶子下定义的过程，其实就是把瓶子里的某些东西抽象出来了，所以瓶子在这里是叫做一类事物的一个抽象，在你脑子里有瓶子的概念，可瓶子的概念在你脑子里到底是什么呢？瓶子的概念在你脑子里叫做一类事物的一个抽象。怎么抽象的呢？你往往抽象的是这两个方面：第一个方面我们叫它静态的属性，瓶子应该具有哪些特征，比分说瓶子应有个口，这是它的具有的一个静态属性，瓶子一般有一个盖，这也是它的具有一个静态属性，除此之外，你还可能给它总结动态的属性，什么动态的属性呢？比放说瓶子能倒水，这是它的动态属性。瓶子这个概念在你脑子里如果你细细的思维的话，其实你给它做了两方面的总结，一方面是静态的，一方面是动态的。反映到JAVA的类上，一个就是成员变量（静态属性），一个就是方法（动态属性）方法是可以执行的，可以动的。成员变量是某一个类的静态属性。所以你脑子里瓶子的概念实际上是一类事物的一个抽象，这种东西我们叫它类，椅子是类，桌子是类，学生是类。什么是对象呢？这一类事物的具体的某个实例就叫做对象。所以<strong>一类事物的具体的某一个东西，符合这类事物具体的特征的某个东西就叫做对象</strong>。瓶子是一个类，某个瓶子就是瓶子这个类里面的一个对象。</p>
<h3 id="15-如何抽象出一个类">1.5 如何抽象出一个类？</h3>
<p>​		有两个方面，一方面是它的静态属性，另一方面是它的动态属性。反映到JAVA里面的类怎么包装它呢？一方面成员变量，另一方面是方法。</p>
<p>​		eg.职员这个类该怎么抽象出来？也是从两个方面，一方面是它的静态属性，另一方面它的动态属性</p>
<p>​		职员有哪些属性呢？有姓名，年龄，目前工资数额等属性，他有哪些方法呢？让这个职员来显示姓名，显示年龄，修改姓名，领取工资。当然显示姓名，显示年龄，修改姓名，领取工资这些也可以让别人来做，但<strong>面向对象的设计思维是最合适的方法应该出现在最合适的类里面</strong>。显示姓名，显示年龄，修改姓名，领取工资由谁来做更合适呢，那就是职员自己最合适。所以这些方法应该出现在职员这个类里面。</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610155239.png" alt="" loading="lazy"></figure>
<p>​		对于类来说，它有一些属性或者称为成员变量，以后说属性或者成员变量指的是同一回事。具体的对象他有没有相关的一些属性或者叫成员变量呢？有，每一个人都有一份，只不过是取值不同而已。如从职员这个类实例化出来的两个职员：职员A和职员B，他们都有姓名，年龄，目前工资数额这些属性，但他们的名字，年龄，领取的工资数额都不一样。这样就能把职员A和职员B区分开来了，正是因为他们的属性值不一样，所以这个对象才能和另外的对象区分开来，<strong>所以通过属性是可以区分两个对象的</strong>。猫是一个类，这只猫是一个对象，这只猫和另外一只猫该怎么区分开来呢？那就得看你的猫这个类是怎么定义的了，猫有猫毛，毛有颜色。OK，这只猫是黑猫，另一只猫是白猫，这样通过猫毛的颜色区分开来了。如果只定义一个，如捉老鼠，白猫也能捉，黑猫也能捉，这样就没办法区分出黑猫和白猫了，所以<strong>根据方法是没办法区分两个对象的</strong>。所以<strong>每个对象都有自己的属性，属性值和另外一个对象一般是不一样的</strong>。</p>
<p>​		一定要区分类和对象，什么叫做类？什么叫做对象？类是一类事物的一个抽象，具有共同特征的一类事物的一个抽象。对象是这个类具体的某一个实例，所以以后说实例（instance）或者说对象（object）指的是同一回事。</p>
<h3 id="16-类对象之间的关系">1.6 类（对象）之间的关系</h3>
<h4 id="161-关联关系最弱的一种关系">1.6.1 关联关系(最弱的一种关系)</h4>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610155402.png" alt="" loading="lazy"></figure>
<p>​		类和类之间是有关系的，如学生和老师这两个类，老师可以教学生，学生可以向老师学习。这就是他们之间的关系。关系和关系之间是不同的，你和你老婆的关系和你和你其他女朋友的关系是不能混为一谈的。关系最弱的一种关系叫关联关系。关联关系反应到代码上往往是一个类的方法里面的参数是另一个类的具体的某一个对象，比如教授教研究生，教哪个研究生，教是教授这个类里面的一个方法，某个研究生是研究生这个类里面的一个具体的对象。<strong>关联关系是最弱的一种关系</strong>，咱们两个类之间有关系，或者两个对象之间有关系，但关系不是很紧密。</p>
<h4 id="162-继承关系比较强的一种关系">1.6.2 继承关系（比较强的一种关系）</h4>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610155535.png" alt="" loading="lazy"></figure>
<p>​		<strong>继承关系封装了这样一种逻辑：“XX是一种XX”，只要这东西能说通了，就可以考虑用继承关系来封装它</strong>。如：游泳运动员从运动员继承，游泳运动员是一种运动员，这能说得通，所以游泳运动员就是从运动员继承过来的，游泳运动员和运动员就是一种继承关系。学生是一个人，学生从人继承，老师是一个人，老师也从人继承，学生是一种老师，这说不通，所以学生和老师就不存在继承关系。所以将来做设计的时候要分清继承关系很简单，你只要说通这么一句话：“XX是一种XX”。OK，那他们之间就是继承关系。篮球运动员是一种球类运动员，这说得通，所以篮球运动员从球类运动员继承，这样继承很有可能会产生一棵继承树，运动员派生出来，派生出来的意思是游泳运动员这个类、球类运动员这个类、射击运动员类从它继承，相当于运动员派生出来了这些个不同的运动员，包括游泳的，球类的，射击的。球类的再派生足球的，篮球的，排球的。这就是一棵继承树，不过这棵树是比较理想化的情况，只有一个根节点。但实际当中，我们真实世界当中的继承关系不一定只从一个类继承，一个类可能从多个类继承过来，比如说：金丝猴从动物这个类继承，这很正常，但我还有另外一个专门的类：“应该受到保护的东西”，这也是一个类，金丝猴应该受到保护，所以金丝猴是一种应该受到保护的东西。所以金丝猴从“应该受到保护的东西”这个类继承过来。所以在现实情况当中，一个类完完全全有可能从多个不同的类继承，C++正是因为想封装这种继承关系，所以C++存在多重继承。</p>
<h4 id="163-聚合关系整体和部分比较强的一种关系">1.6.3 聚合关系（整体和部分）（比较强的一种关系）</h4>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610155626.png" alt="" loading="lazy"></figure>
<p>​		什么是聚合？<strong>聚合就是一个整体与部分的关系</strong>。我们说**“XX是XX的一部分”，只要说得通，那么他们之间的关系就是聚合关系**，队长是球队的一部分，队员是球队的一部分。所以队长和球队是聚合关系，队员和球队也是聚合关系。脑袋是人的以部分，身体和胳膊也是人的一部分，因此脑袋，身体和胳膊与人都是聚合关系。<strong>聚合关系分得再细一点的话就可以分成聚集关系和组合关系</strong>，比如球队、队长，队员，这三者是聚集关系，假如这个队长既是足球的队长，同时也是篮球的队长，一个人分属两个不同的球队，这是可以的，球队与队长之间没有我离不了你，你离不了我这种情况，所以如果分得更细的话，这种就叫做聚集关系。还有一种情况叫组合，组合说的是咱们俩密不可分，我是你必不可少的一部分。一个人的脑袋不可能既属于你又属于别人，身体也一样，不可能既属于你又属于别人。所以你的身体，脑袋和你是密不可分的，这是一种更加严格的聚合关系，专门给它取了个名字叫组合。</p>
<h4 id="164-实现关系">1.6.4 实现关系</h4>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610155715.png" alt="" loading="lazy"></figure>
<p>​		**作为父类来说，我觉得我应该具有这样一个方法，但我不知道怎么去实现，谁去实现，我的子类去实现，这就是实现关系。**和实现关系息息相关的还有一种关系叫多态。</p>
<h4 id="165-多态">1.6.5 多态</h4>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610155757.png" alt="" loading="lazy"></figure>
<h3 id="17-java与面向对象">1.7 Java与面向对象</h3>
<pre><code>	对象和类是分不开的，必须首先定义类才能有对象。首先定义方法才能调用。对象是JAVA里面的核心，做任何东西你首先都得给我造出一个对象才能做。静态属性简称属性，也叫成员变量，以后说属性或者说成员变量它们指的都是同一回事。
</code></pre>
<p>整个类可以看作是静态的属性还有方法他们之间的一个综合。怎么抽象出一个类的概念，还是那句话，你必须抽象出两个方面来，第一方面是看他们的静态属性，他们有哪些成员变量，第二方面是看他们的有哪些方法。</p>
<p>写JAVA程序时，我们一上来写的就是public class（声明一个类），在这个class里面我们写的是成员变量和方法。</p>
<p><strong>每一个JAVA里面的class（类）都对应了我们现实生活中某一类事物的一个抽象</strong>。比如说要在JAVA里面封装一只狗，具体怎么封装，如何写代码，代码如下：</p>
<pre><code class="language-java">/**
 * 一类事物封装到JAVA里面首先得写class，定义这个类，类名是什么可以自己取。
 * 这里把类名叫做Dog
 */
public class Dog {
    /**
     * 接下来就是写这个狗这个类的属性或者叫成员变量，
     * 比如说狗这个类的毛的颜色，怎么定义这个属性呢，
     * 首先得定义毛的一个类型,如使用int来定义毛的颜色类型
     */
    int furcolor; //定义属性：毛的颜色
    float height; //定义属性：狗的高度
    float weight; //定义属性：狗的体重

    /**
     * 狗的颜色，高度，体重这些属性定义完了，接下来要定义的就是方法了。
     * 如写一个CatchMouse（）方法，捉老鼠的方法。
     * CatchMouse这个方法里面有一个对象类型的参数，捉哪一只老鼠，这个对象参数是属于Mouse这个类的
     * @param m
     */
    void CatchMouse(Mouse m){
            //在方法体内写捉老鼠这个过程，怎么捉，跑着捉，走着捉
            System.out.println(&quot;我捉到老鼠了，汪汪！，老鼠要尖叫了！&quot;);
            /**
             * 老鼠尖叫一声，表示被狗咬到了，咬到了能不叫吗，很自然而然地想到，
             * 尖叫（scream()）这个方法是属于Mouse这个类里面的某一个方法。
             * 老鼠自己调用它，让它自己尖叫。这就是面向对象的思维。
             */
            m.scream();
    }

    public static void main(String[] args) {
        Dog  d = new Dog();//首先用new关键字创建一只狗
        Mouse m=new Mouse();//造出一只老鼠。
        d.CatchMouse(m);//然后用这只狗去抓老鼠，让狗调用CatchMouse()方法去捉某只老鼠。
    }
}
</code></pre>
<p>​		从这个意义上来讲，JAVA里面的每定义一个类实际上就相当于一种新的数据类型。就跟int ，float， String等一样，不过是一种新定义的类型而已。</p>
<h3 id="18-为什么使用面向对象编程">1.8 为什么使用面向对象编程？</h3>
<p>​		面向对象编程：一组对象互相配合通过沟通完成特定功能</p>
<p>做软件苦苦追求的一种境界是可重用性（reusable），可扩展性。如果是面向过程，一般情况是属性和方法它们是分开的，他们不是聚合的关系，不是合在一起的，这样要复用起来比较麻烦，复用的层次只是局限于方法这个层次上，而面向对象则不同，它是把属性和方法综合在一个里面。综合在一起复用的时候是整个对象进行复用。所以面向对象和面向过程相比，前者更加容易让我们达到可重用性。</p>
<h2 id="2-java面向对象二">2、Java面向对象（二）</h2>
<h3 id="21-java类的定义">2.1 Java类的定义</h3>
<pre><code class="language-java">//用class关键字定义一个类
class Person{
    private int id;
    private int age = 20;
    //方法的定义
    public int getAge(){
        return age;
    }
    public void setAge(int i){
        age = i;
    }
    public int getId(){
        return id;
    }
}
</code></pre>
<ul>
<li>
<p>类的定义主要有两方面组成一成员变量和方法。</p>
</li>
<li>
<p>声明成员变量的格式为: [&lt; modifiers&gt;] type &lt; attr_name&gt;[=defaultValue] ;<br>
例如:  private int id;    private int age = 20;</p>
</li>
<li>
<p>声明方法的格式为:<br>
[&lt; modifiers&gt;)] &lt; modifiers&gt; &lt;return_ type&gt; <name>([&lt; argu list&gt;]) {<br>
[&lt; statements&gt;]<br>
}    例如: public int getAge() {return age;}</p>
<p>​		JAVA里面有<strong>class</strong>关键字定义一个类，后面加上自定义的类名即可。如这里定义的person类，使用class person定义了一个person类，然后在person这个类的类体里面定义person这个类应该具有的成员变量（即属性）和方法，如这里定义的int id和int age这个两个成员变量，或者叫属性，这个id表示人的身份证号码，人应该具有这个属性，age表示人的年龄，这也是人应该具有的。这样就在person这个类里面定义了两个人应该有的属性，接下来就是定义方法了，这里定义了三个方法，分别是getAge()、setAge(int i)和getId()，分别用来获取人的年龄，设置人的年龄，获取人的id，getAge()方法获取了人的年龄后，将获取到的值返回，所以使用了return age语句，getId()方法也使用了return id语句用于返回获取到的id的值。</p>
</li>
</ul>
<h3 id="22-成员变量">2.2 成员变量</h3>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610160936.png" alt="" loading="lazy"></figure>
<p>**在JAVA里面的任何变量首先应该要声明，然后再赋值，然后再使用。**成员变量和局部变量有一个重要区别：<strong>成员变量在类里面声明时如果不进行初始化，那么JAVA会默认给它初始化，而局部变量JAVA不会默认给它初始化，所以在方法里面声明一个局部变量如果不给它初始化时就会出错</strong>。默认初始化大多数都是0，boolean类型的为false，引用类型的为null，如过不记得JAVA对成员变量默认的初始化是多少的话，那就这样做，定义一个成员变量，不给它初始化，然后直接打印这个成员变量，打印出来的结果就是JAVA默认的初始化的值。</p>
<h3 id="23-java面向对象的基本概念引用">2.3 Java面向对象的基本概念——引用</h3>
<figure data-type="image" tabindex="8"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610161110.png" alt="" loading="lazy"></figure>
<p>​		<strong>引用类型和基本类型有着巨大的区别</strong>，当声明一个int i=0时，系统会马上给这个i分配一个内存空间（在栈内存里面分配一小块区域用来装数字0），里面装着一个值为0，以后使用i这个名字马上就可以访问这个内存空间里面的值，这就是基本数据类型，所以<strong>基础类型就只占一块内存</strong>。基础类型之外的类型全都叫引用类型，我们定义一个Mouse m，这个m就是一个引用类型的数据。引用类型有什么重要的特征——<strong>引用类型占<strong><strong>2</strong></strong>块内存</strong>。我们定义好这个类之后，需要使用new关键字把这个类的对象实例化出来，也就是真真正正造出一个对象出来才能使用这个对象。</p>
<p><strong>如何在内存中区分类和对象</strong></p>
<p>类是静态的概念，是位于代码区里面。对象是new出来的，它是位于堆内存，为什么对象要位于堆内存？因为堆内存是用来动态分配内存的，只有在运行当中才会new一个对象放堆内存里面，那这个对象到底有多大个，这个东西你不知道，你没有办法提前知道，所以你没有办法提前分配内存给这个对象，你只有在运行期间才能去分配它。什么叫运行期间？敲JAVAC这个命令那是在编译期间，编译完成后再敲JAVA命令，那就是运行期间了。只有在运行期间，才能够明白这个对象到底要分配多大的空间给它，所以把它放在堆内存里面，堆内存比较大，动态分配内存用它。如果这个对象不用了，那它就是垃圾，那么就等着垃圾收集器把它收集回去，释放掉占用的内存。</p>
<p>​		记住，<strong>以后一提到引用，脑子里马上浮现引用那就是一小块内存指向一大块内存。</strong></p>
<h3 id="24-对象的创建和使用">2.4 对象的创建和使用</h3>
<ul>
<li>必须使用new关键字创建对象。</li>
<li>使用对象(引用) .成员变量或来引用对象的成员变量。</li>
<li>使用对象(引用) .方法(参数列表)来调用对象的方法。</li>
<li>同一类的每个对象有不同的成员变量存储空间。</li>
<li>同一类的每个对象共享该类的方法。</li>
</ul>
<h3 id="25-类和对象的关系">2.5 类和对象的关系</h3>
<figure data-type="image" tabindex="9"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610162714.png" alt="" loading="lazy"></figure>
<p><strong>在内存中分析类和对象的关系</strong></p>
<p>假设这里有一个类C，我们定义了一个类class C，然后在这个类里面定义了两个成员变量: int i和int j。定义好了这两个成员变量以后，我们写了一个main()方法（public static void main(Strng[] args)），程序开始执行。第一句我们写了 C c1 = new C()，这句的代码是我们相当于在堆内存里创建了一个对象，同时也创建了这个对象的一个引用对象c1，c1位于栈内存中，c1这个引用对象指向堆中一大块内存，这一大块内存里面装着new出来的那个对象。这里面我们一般来说是new出来两个对象c1和c2，当然，实际上，严格来讲，c1和c2叫做对象的引用，有时候，简称new出来了两个对象，c1和c2。你脑子里马上要浮现出两块内存，c1指向一块，c2指向一块。局部变量是分配在栈内存里面的，main方法里面的c1和c2都是局部变量，所以在栈里面分配了两小块内存出来，一块是c1的，一块是c2的，c1这块内存里面装着一个值，或者叫装着一个地址，这个地址是什么，我们不知道，我们只知道根据这个值就能找到new出来的C这个类里面的一个对象，而在这个对象里面有它自己的成员变量i和j，里面的两小块内存是分别用来装i和j的值的，因为每一个对象都有自己不同的成员变量的值，所以c1指向的那块对内存里面又分成一小块一小块内存，每一个小块的内存都装着这个对象的成员变量（或者叫属性）。如这里的第一小块装着i的值，第二小块装着j的值，所以当我们去访问第一小块里面装着的成员变量时，我们应该这样写：c1.i，这样就拿到了i的值，c1.j，这样就拿到了j的值。同理，c2这个对象也指向了一个new出来的C这个类里面的另一个对象，这个对象也有成员变量i和j，只不过和c1指向的那个对象里的i和j的值不同而已。要访问这个这个对象的成员变量时 ，也是要c2.i，c2.j这样去访问。</p>
<h3 id="26-构造方法">2.6 构造方法</h3>
<ul>
<li>
<p>使用new+构造方法创建-一个新的对象。</p>
</li>
<li>
<p>构造函数是定义在Java类中的一个用来初始化对象的函数。</p>
</li>
<li>
<p>构造函数与类同名且没有返回值。</p>
</li>
<li>
<p>例如: Person 类的构造函数:</p>
<pre><code class="language-java">public class Person(){
    int id;
    int age;
    Person(int n,int i){
        id = n;
        age = i;
    }
}
</code></pre>
<p>在面向对象里面有一个特殊的方法，叫构造方法。</p>
<p>构造方法是用来创建一个新的对象的，与new组合在一起用，使用new+构造方法创建一个新的对象。你new一个东西的时候，实际上你调用的是一个构造方法，构造方法就是把自己构造成一个新的对象，所以叫构造方法，构造一个新对象用的方法叫构造方法。</p>
<p>构造方法比较特殊，构造方法的名字必须和类的名字完全一模一样，包括大小写，并且没有返回值。如原来定义的一个person类，在类里面声明了两个成员变量id与age，这时候你可以再为这个person类定义一个它的构造方法person(int n，int i)，这个方法的名字和类名完全相同，并且没有返回值，也就是在这个方法前面不能写任何的方法的返回类型修饰符，连void都不可以写。</p>
</li>
<li>
<p>构造方法范例：</p>
<pre><code class="language-java">public class Person {
    int id;  //在person这类里面定义两个成员变量id和age,
    int age=20;  //给成员变量age赋了初值为20

    /**这里就是person这个类的一个构造方法
     * 构造方法的规则很简单，和类名要完全一样，一点都不能错，包括大小写。
     * 并且没有返回值，不能写void在它前面修饰
     * @param _id
     * @param _age
     */
    public Person(int _id,int _age ) {
        id = _id;
        age = _age;
    }
}
</code></pre>
<p>​		构造方法写好后就和new组合在一起使用，new的作用是构建一个新对象，创造一个新对象，所以new的时候实际当中调用的是构造方法。只有调用了这个构造方法才能构造出一个新的对象。例如：</p>
<pre><code class="language-java">public static void main(String[] args) {
    Person tom = new Person(1, 25); // 调用person这个构造方法创建一个新的对象，并给这个对象的成员变量赋初始值
}
</code></pre>
</li>
</ul>
<figure data-type="image" tabindex="10"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610161822.png" alt="" loading="lazy"></figure>
<p>​	<strong>下面是在main方法里面调用person构造方法时的内存分析情况：</strong></p>
<figure data-type="image" tabindex="11"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610161855.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610161922.png" alt="" loading="lazy"></figure>
<p>​		<strong>当方法调用完成之后，栈里面为它分配的空间全部都要消失，即把这个方法调用时分配给它的内存空间释放出来</strong>，所以这个构造方法person调用完成之后，栈内存里面分配的两小块内存_id和_age自动消失了。这样就把它们所占的空间让了出来，让其他的方法去占用。而new出来的对象则永远留在了堆内存里面。</p>
<figure data-type="image" tabindex="13"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610162016.png" alt="" loading="lazy"></figure>
<p>​		<strong>声明一个类，若没有在类中指定其构造方法（构造函数）时，编译器会为这个类自动添加形如类名( ){ }的构造函数。</strong></p>
<p><strong>如：</strong></p>
<pre><code class="language-java">class  point{//这里声明一个类时并没有给它指定其构造方法。
     int  x;
     int  y;
}
</code></pre>
<p>​		但在main方法里面我们却可以这样使用：</p>
<pre><code class="language-java">public static void main(String[] args){
     point  p = new  point();
}
</code></pre>
<p>​		这里这样写是可以的，当没有给这个类指明构造方法时，系统会默认地给这个类加上point ( ) { }这样一个空的构造方法。所以才可以在main方法中使用point p = new point(); 实际上你调用的就是编译器默认给它加上的point ( ) { }这个构造方法，在这个构造方法当中，默认地把类里面的成员变量x和y初始值设为0。正是因为系统给它默认加上这么一个构造方法，所以才能在main方法里面调用。但<strong>要记住一点，一旦给这个类里面指定了构造方法，那么系统就不会再给这个类添加构造方法了</strong>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础-基础语法]]></title>
        <id>https://jonchan1013.github.io/post/java-ji-chu-ji-chu-yu-fa/</id>
        <link href="https://jonchan1013.github.io/post/java-ji-chu-ji-chu-yu-fa/">
        </link>
        <updated>2020-06-10T03:16:11.000Z</updated>
        <summary type="html"><![CDATA[<p>✍️JavaSE是Java Standard Edtion的缩写，译成中文就是Java标准版，也是Java的核心。无论是JavaEE(Java企业版)还是JavaME(Java微型版)都是以JavaSE为基础。</p>
]]></summary>
        <content type="html"><![CDATA[<p>✍️JavaSE是Java Standard Edtion的缩写，译成中文就是Java标准版，也是Java的核心。无论是JavaEE(Java企业版)还是JavaME(Java微型版)都是以JavaSE为基础。</p>
<!-- more -->
<h2 id="1-标识符">1、标识符</h2>
<ul>
<li>Java对各种变量、方法和类等要素命名时使用的字符序列称为标识符。
<ul>
<li>凡是自己可以起名字的地方都叫标识符，都遵守标识符的规则</li>
</ul>
</li>
<li>Java标识符命名规则:
<ul>
<li>标识符应以字母、下划线、美元符开头。</li>
<li>Java 标识符大小写敏感，长度无限制。</li>
<li>Java 标识符大小写敏感，长度无限制。</li>
</ul>
</li>
<li>约定俗成: Java标识符选取因注意&quot;见名知意&quot;且不能与Java语言的关键字重名。</li>
</ul>
<h2 id="2-关键字">2、关键字</h2>
<ul>
<li>
<p>Java中一些赋以特定的含义，用做专门用途的字符串称为关键字( keyword)。大多数编辑器会将关键字用特殊方式标出</p>
</li>
<li>
<p>所有Java关键字都是小写英文。</p>
</li>
<li>
<p>所有Java关键字都是小写英文。</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610115950.png" alt="" loading="lazy"></figure>
</li>
</ul>
<h2 id="3-java基础数据类型">3、Java基础数据类型</h2>
<h3 id="31-java常量">3.1 Java常量</h3>
<ul>
<li>
<p>Java 的常量值用字符串表示，区分为不同的数据类型。</p>
<ul>
<li>如整型常量123</li>
<li>实型常量3.14</li>
<li>字符常量'a'</li>
<li>逻辑常量true. false</li>
<li>字符串常量&quot;helloworld&quot;</li>
</ul>
</li>
<li>
<p>注意:区分字符常量和字符串常量</p>
</li>
<li>
<p>注意:“常量”这个名词还会用在另外其它语境中表示值不可变的变量</p>
</li>
</ul>
<h3 id="32-java变量">3.2 Java变量</h3>
<ul>
<li>
<p>Java变量是程序中最基本的存储单元，其要素包括变量名，变量类型和作用域。</p>
</li>
<li>
<p>Java程序中每一个变量都属于特定的数据类型，在使用前必须对其声明，声明格式为:</p>
<ul>
<li>
<p>例如：int i=100;<br>
float f=12.3f;</p>
<p>​			double d1, d2, d3 = 0.123;<br>
​			String s=&quot;hello&quot;;</p>
</li>
</ul>
</li>
<li>
<p>从本质上讲，变量其实是内存中的一-小块区域，使用变量名来访问这块区域，因此，每一个变量使用前必须要先申请(声明)，然后必须进行赋值(填充内容)，才能使用</p>
</li>
<li>
<p>一个程序在运行的时候，实际上这个程序是位于内存里面，然后才开始运行。一个.exe文件存放在硬盘上是无法运行的，在硬盘上看到的.exe文件无非就是一个文件而已，当我们双击这个.exe文件时，运行起来的时候实际上是整个.exe文件被放在了在内存里面，然后操作系统找到main方法，也就是程序的入口，然后就开始执行了。执行的过程之中，会不断地在内存里面分配一些区域，变量在内存里面就是一小块区域，变量有两个概念，一个是变量的名字，另一个是变量的值，即这一小块区域是有名字的，里面装着一个值，因此以后要想访问这小块区域里面的内容就可以根据这小块区域的名字来访问了。因此，变量的本质就是一小块内存区域。就变量来说，该在内存里面分配多大的存储空间呢？不同的变量类型分配不同大小的存储空间，每一个变量都是属于特定的数据类型的，声明成不同的数据类型，它就在内存里面分配不同的存储空间。</p>
</li>
<li>
<p>变量作用域：变量的作用域只在“{ }”有效，出了这个“{ }”就没有作用了</p>
</li>
</ul>
<h3 id="33-java变量分类">3.3 Java变量分类</h3>
<ul>
<li>
<p>按被声明的位置划分:</p>
<ul>
<li>局部变量:方法或语句块内部定义的变量</li>
<li>成员变量:方法外部、类的内部定义的变量</li>
<li>注意:类外面(与类对应的大括号外面)不能有变量的声明</li>
</ul>
</li>
<li>
<p>按所属的数据类型划分:</p>
<ul>
<li>基本数据类型变量</li>
<li>引用数据类型变量</li>
</ul>
</li>
</ul>
<h3 id="34-java局部变量和成员变量">3.4 Java局部变量和成员变量</h3>
<ul>
<li>
<p>方法体内部声明的变量(包括形参)称为局部变量:</p>
</li>
<li>
<p>方法体内部是指与方法对应的大括号内部</p>
</li>
<li>
<p>在方法体外，类体内声明的变量成为成员变量</p>
<pre><code class="language-java">public void method(){
int i;
int j= i+5://编译出错，变量i还未被初始化
double d= 3.14;
Dog dog;
dog = new Dog(22,7,1964);
}
</code></pre>
</li>
</ul>
<h3 id="35-java数据类型划分">3.5 Java数据类型划分</h3>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610124522.png" alt="" loading="lazy"></figure>
<ul>
<li>Java中定义了4类8种基本数据类型。
<ul>
<li>逻辑型一boolean</li>
<li>文本型一char</li>
<li>整数型一byte, short, int, long</li>
<li>浮点数型一float, double</li>
</ul>
</li>
</ul>
<h2 id="4-java数据类型讲解">4、Java数据类型讲解</h2>
<h3 id="41-boolean-布尔型">4.1 boolean--布尔型</h3>
<ul>
<li>
<p>boolean类型适于逻辑运算，一般用于程序流程控制。</p>
</li>
<li>
<p>boolean类型数据只允许取值true或false，不可以0或非0的整数替代true和false，这点和C语言不同。</p>
</li>
<li>
<p>用法举例:</p>
<pre><code class="language-java">boolean flag;
flag = true;
if(f1ag) {
    //do something
}
</code></pre>
</li>
</ul>
<h3 id="42-char-字符型">4.2 char--字符型</h3>
<ul>
<li>
<p>char型数据用来表示通常意义上字符”</p>
</li>
<li>
<p>字符常量为用单引号括起来的单个字符，例如:</p>
<ul>
<li>char eChar = 'a'; char cChar ='中‘；</li>
</ul>
</li>
<li>
<p>Java字符采用Unicode编码，每个字符占两个字节，因而可用十六进制编码形式表示，例如:</p>
<ul>
<li>char c1 =’\u0061';</li>
<li>注: Unicode是全球语言统一编码</li>
</ul>
</li>
<li>
<p>Java语言中还允许使用转义字符\来将其后的字符转变为其它的含义，例如:</p>
<ul>
<li>@ char c2= '\n';
<ul>
<li>'\n'代表换行符</li>
</ul>
</li>
</ul>
</li>
<li>
<p>全球的文字放到计算机里面表示全是0和1，Unicode是统一了全世界国家文字的一种编码方式，用这样的编码可以把全世界国家的文字连接在一起。Unicode编码又分为两种，一种是Utf-8，另一种是Utf-16。JAVA所采用的是Utf-16，每一个字符占2个字节，任何国家的文字放到Unicode里面都是占2个字节。</p>
</li>
</ul>
<h3 id="43-整数类型">4.3 整数类型</h3>
<ul>
<li>
<p>Java各整数类型有固定的表数范围和字段长度，其不受具体操作系统的影响，以保证Java程序的可移植性。</p>
</li>
<li>
<p>Java语言整型常量的:三种表示形式:</p>
<ul>
<li>十进制整数，如: 12, -314, 0。</li>
<li>八进制整数，要求以0开头，如: 012。</li>
<li>十六进制数，要求0x或0X开头，如: 0x12。</li>
</ul>
</li>
<li>
<p>Java语言的整型常量默认为int型，声明long型常 量可以后加工或L’，如1:</p>
<ul>
<li>int i1= 600; //正确 long l1 = 888888888L; l1必须加否则会出错</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610125719.png" alt="" loading="lazy"></figure>
<ul>
<li>C语言编译好的程序为什么不能移植，如把.exe文件放到Linux下是执行不了的，一个很大很大的原因在于C语言定义的变量在不同的操作系统上所占的大小是不一样的，声明一个int类型的变量，在Windows下面占32位，但放到Linux下面就有可能只占16位，那么这时候很可能表示的大小就不一样了，在Windows下声明一个很大的数，在Linux下面很可能就会溢出。因此这就是C语言为什么在编译完成之后不能移植的原因。</li>
</ul>
<h3 id="44-浮点类型">4.4 浮点类型</h3>
<ul>
<li>
<p>与整数类型类似，Java浮 点类型有固定的表数范围和字段长度，不受平台影响。</p>
</li>
<li>
<p>Java浮点类型常量有两种表示形式</p>
<ul>
<li>十进制数形式，例如:3.14</li>
<li>⑥科学记数法形式，如3.14e2  3.14E2  100E2</li>
</ul>
</li>
<li>
<p>Java浮点型常量默认为double型，如要声明一个常量为float型，则需在数字后面加f或F，如:</p>
<ul>
<li>double d= 12345.6; //正确 float f= 12.3f; //必须加f否则会出错</li>
</ul>
</li>
<li>
<p>下面列出Java的各种浮点类型</p>
</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610130037.png" alt="" loading="lazy"></figure>
<h3 id="45-基本数据类型的转换">4.5 基本数据类型的转换</h3>
<ul>
<li>
<p>boolean类型不可以转换为其他的数据类型。</p>
</li>
<li>
<p>整型，字符型，浮点型的数据在混合运算中相互转换，转换时遵循以下原则:</p>
<ul>
<li>容量小的类型自动转换为容量大的数据类型:数据类型按容量大小排序为:
<ul>
<li>byte,short,char-&gt;int-&gt;long-&gt;float-&gt;double</li>
<li>byte,short,char之间不会互相转换， 他们三者在计算时首先回转换为int类型</li>
</ul>
</li>
<li>容量大的数据类型转换为容量小的数据类型时，要加上强制转换符，但可能造成精度降低或溢出:使用时要格外注意。</li>
<li>有多种类型的数据混合运算时，系统首先自动的将所有数据转换成容量最大的那一:种数据类型，然后再进行计算。</li>
<li>实数常量(如: 1.2)默认为double。</li>
<li>整数常量(如: 123) 默认为int。</li>
</ul>
</li>
<li>
<p>类型转换测试</p>
<pre><code class="language-java">public class TestConvert {
    public static void main(String arg[]) {
        int i1 = 123;
        int i2 = 456;
        double d1 = (i1+i2)*1.2;//系统将转换为double型运算
        float f1 = (float)((i1+i2)*1.2);//需要加强制转换符
        byte b1 = 67;
        byte b2 = 89;
        byte b3 = (byte)(b1+b2);//系统将转换为int型运算，需要强制转换符
        System.out.println(b3);
        double d2 = 1e200;
        float f2 = (float)d2;//会产生溢出
        System.out.println(f2);
        float f3 = 1.23f;//必须加f
        long l1 = 123;
        long l2 = 30000000000L;//必须加l
        float f = l1+l2+f3;//系统将转换为float型计算
        long l = (long)f;//强制转换会舍去小数部分（不是四舍五入）
    }
}
</code></pre>
</li>
</ul>
<h2 id="5-运算符">5、运算符</h2>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610130557.png" alt="" loading="lazy"></figure>
<h3 id="51-算数运算符自加和自减运算符">5.1 算数运算符（自加和自减运算符)</h3>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610130722.png" alt="" loading="lazy"></figure>
<h3 id="52-逻辑运算符">5.2 逻辑运算符</h3>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610130816.png" alt="" loading="lazy"></figure>
<h3 id="53-赋值运算符">5.3 赋值运算符</h3>
<figure data-type="image" tabindex="8"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610131019.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p>赋值运算符，就是将符号右边的值，赋给左边的变量。</p>
<pre><code class="language-java">public static void main(String[] args){ 
    int i = 5; 
    i+=5;//计算方式 i=i+5 变量i先加5，再赋值变量i 
    System.out.println(i); //输出结果是10 
}
</code></pre>
</li>
</ul>
<h3 id="54-比较运算符">5.4 比较运算符</h3>
<figure data-type="image" tabindex="9"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610131143.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p>比较运算符，是两个数据之间进行比较的运算，运算结果都是布尔值 true 或者 false 。</p>
<pre><code class="language-java">public static void main(String[] args) { 
    System.out.println(1==1);//true 
    System.out.println(1&lt;2);//true 
    System.out.println(3&gt;4);//false 
    System.out.println(3&lt;=4);//true 
    System.out.println(3&gt;=4);//false 
    System.out.println(3!=4);//true 
}
</code></pre>
</li>
</ul>
<h3 id="55-逻辑运算符">5.5 逻辑运算符</h3>
<figure data-type="image" tabindex="10"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610152457.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p>逻辑运算符，是用来连接两个布尔类型结果的运算符，运算结果都是布尔值 true 或者 false</p>
<pre><code class="language-java">public static void main(String[] args) { 
    System.out.println(true &amp;&amp; true);//true 
    System.out.println(true &amp;&amp; false);//false 
    System.out.println(false &amp;&amp; true);//false，右边不计算 
    System.out.println(false || false);//falase 
    System.out.println(false || true);//true 
    System.out.println(true || false);//true，右边不计算				
    System.out.println(!false);//true 
}
</code></pre>
</li>
</ul>
<h3 id="56-三元运算符">5.6 三元运算符</h3>
<ul>
<li>三元运算符格式：<br>
数据类型 变量名 = 布尔类型表达式？结果1：结果2</li>
<li>三元运算符计算方式：
<ul>
<li>布尔类型表达式结果是true，三元运算符整体结果为结果1，赋值给变量。</li>
<li>布尔类型表达式结果是false，三元运算符整体结果为结果2，赋值给变量。</li>
</ul>
</li>
</ul>
<pre><code class="language-java">public static void main(String[] args) { 
	int i = (1==2 ? 100 : 200); 
    System.out.println(i);//200 
    int j = (3&lt;=4 ? 500 : 600); 
    System.out.println(j);//500 
}
</code></pre>
<h2 id="6-语句">6、语句</h2>
<figure data-type="image" tabindex="11"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610151654.png" alt="" loading="lazy"></figure>
<h3 id="61-条件语句">6.1 条件语句</h3>
<ol>
<li>
<p>if语句</p>
<figure data-type="image" tabindex="12"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610151746.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>分支语句(switch语句)</p>
<figure data-type="image" tabindex="13"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610151816.png" alt="" loading="lazy"></figure>
</li>
</ol>
<figure data-type="image" tabindex="14"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610151831.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="15"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610152413.png" alt="" loading="lazy"></figure>
<h3 id="62-循环语句">6.2 循环语句</h3>
<h4 id="621-for循环语句">6.2.1 for循环语句<img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610151930.png" alt="" loading="lazy"></h4>
<p>学会画内存分析图分析别人写的程序，这样就很容易分析出规律，分析出规律也就明白了别人的算法，也就很容易读懂别人的程序。</p>
<h4 id="622-while循环和do-while循环">6.2.2 while循环和do while循环</h4>
<figure data-type="image" tabindex="16"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610152239.png" alt="" loading="lazy"></figure>
<h4 id="623-break和continue语句">6.2.3 break和continue语句</h4>
<figure data-type="image" tabindex="17"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610152202.png" alt="" loading="lazy"></figure>
<h2 id="7-方法">7、方法</h2>
<ul>
<li>
<p>Java的方法类似于其它语言的函数，是一段用来完成特定功能的代码片段</p>
</li>
<li>
<p>形式参数:在方法被调用时用 于接收外界输入的数据。</p>
</li>
<li>
<p>实参:调用方法时实际传给方法的数据。</p>
</li>
<li>
<p>返回值:方法在执行完毕后返还给调用它的环境的数据。</p>
</li>
<li>
<p>返回值类型:事先约定的返回值的数据类型，如无返回值，必须给出返回值类型void.</p>
</li>
<li>
<p>Java语言中使用下述形式调用方法:对象名方法名(实参列表)</p>
</li>
<li>
<p>实参的数目、数据类型和次序必须和所调用方法声明的形参列表匹配，</p>
</li>
<li>
<p>retun语句终止方法的运行并指定要返回的数据。</p>
</li>
<li>
<p>Java中进行函数调用中传递参数时，遵循值传递的原则:基本类型传递的是该数据值本身。引用类型传递的是对对象的引用，而不是对象本身。</p>
</li>
<li>
<p>方法执行到return语句后，这个方法的执行就结束了，<strong>方法可以有返回值，但可以不用这个返回值</strong>。方法首先要定义，然后才能调用。</p>
<pre><code class="language-java">public class TestMethod{
    public static void main(String args[]){
        m();
        m1(3);
        m2(2,3);
        int i = m3(4,5);
        System.out.println(i);
    }
    //以下定义的都是静态方法，静态方法可以在main()方法里面直接调用
    public static void m(){
            System.out.println(&quot;Hello!&quot;);
            System.out.println(&quot;World!&quot;);
        }

    public static void m1(int i){
            if(i==5){
                    return;
                }
            System.out.println(i);
        }

    public static void m2(int i,int j){
            System.out.println(i+j);
        }

    public static int m3(int i,int j){
            return i+j;
        }
}
</code></pre>
</li>
</ul>
<h2 id="8-变量的作用域">8、变量的作用域</h2>
<ul>
<li>变量的作用域只在“{ }”有效，出了这个“{ }”就没有作用了</li>
</ul>
<h2 id="9-递归调用">9、递归调用</h2>
<ul>
<li>递归：在一个方法内部对自身的调用就称为递归</li>
</ul>
<figure data-type="image" tabindex="18"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610153500.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="19"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610153511.png" alt="" loading="lazy"></figure>
<ul>
<li>范例：使用递归计算第5个斐波那契数列数</li>
</ul>
<pre><code class="language-java">/*计算第5个斐波那契数列数*/
/*
斐波那契数列特点：f(1)=1,f(2)=1,f(3)=f(1)+f(2),f(4)=(f2)+(f3)……依次类推。
即后一个数都是等于前两个数的和，这样的数列就是斐波那契数列。
*/
/*
使用递归调用的方法计算
*/
public class Fab{
    public static void main(String args[]){
        System.out.println(f(5));
    }

    public static int f(int n){
            if(n==1||n==2){
                    return 1;
                }else{
                        return f(n-1)+f(n-2);
                    }
        }
}
</code></pre>
<p>​	整个在内存中执行过程如下图所示</p>
<figure data-type="image" tabindex="20"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610153613.png" alt="" loading="lazy"></figure>
<h2 id="10-程序的执行过程">10、程序的执行过程</h2>
<figure data-type="image" tabindex="21"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610153705.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaWeb]]></title>
        <id>https://jonchan1013.github.io/post/javaweb/</id>
        <link href="https://jonchan1013.github.io/post/javaweb/">
        </link>
        <updated>2019-09-14T17:34:28.000Z</updated>
        <summary type="html"><![CDATA[<p>✍️JAVAEE的核心内容：Servlet和JSP、Tomcat服务器等。此外Maven的配置、Servlet的原理、Cookie和Session、JSP、监听器和过滤器、JDBC......</p>
]]></summary>
        <content type="html"><![CDATA[<p>✍️JAVAEE的核心内容：Servlet和JSP、Tomcat服务器等。此外Maven的配置、Servlet的原理、Cookie和Session、JSP、监听器和过滤器、JDBC......</p>
<!-- more -->
<h2 id="1-基本概念">1、基本概念</h2>
<h3 id="11-前言">1.1、前言</h3>
<p>web开发：</p>
<ul>
<li>web，网页的意思  ， www.baidu.com</li>
<li>静态web
<ul>
<li>html，css</li>
<li>提供给所有人看的数据始终不会发生变化！</li>
</ul>
</li>
<li>动态web
<ul>
<li>淘宝，几乎是所有的网站；</li>
<li>提供给所有人看的数据始终会发生变化，每个人在不同的时间，不同的地点看到的信息各不相同！</li>
<li>技术栈：Servlet/JSP，ASP，PHP</li>
</ul>
</li>
</ul>
<p>在Java中，动态web资源开发的技术统称为JavaWeb；</p>
<h3 id="12-web应用程序">1.2、web应用程序</h3>
<p>web应用程序：可以提供浏览器访问的程序；</p>
<ul>
<li>a.html、b.html......多个web资源，这些web资源可以被外界访问，对外界提供服务；</li>
<li>你们能访问到的任何一个页面或者资源，都存在于这个世界的某一个角落的计算机上。</li>
<li>URL</li>
<li>这个统一的web资源会被放在同一个文件夹下，web应用程序--&gt;Tomcat：服务器</li>
<li>一个web应用由多部分组成 （静态web，动态web）
<ul>
<li>html，css，js</li>
<li>jsp，servlet</li>
<li>Java程序</li>
<li>jar包</li>
<li>配置文件 （Properties）</li>
</ul>
</li>
</ul>
<p>web应用程序编写完毕后，若想提供给外界访问：需要一个服务器来统一管理；</p>
<h3 id="13-静态web">1.3、静态web</h3>
<ul>
<li>*.htm, *.html,这些都是网页的后缀，如果服务器上一直存在这些东西，我们就可以直接进行读取。通络；</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613005453.png" alt="" loading="lazy"></figure>
<ul>
<li>静态web存在的缺点
<ul>
<li>Web页面无法动态更新，所有用户看到都是同一个页面
<ul>
<li>轮播图，点击特效：伪动态</li>
<li>JavaScript [实际开发中，它用的最多]</li>
<li>VBScript</li>
</ul>
</li>
<li>它无法和数据库交互（数据无法持久化，用户无法交互）</li>
</ul>
</li>
</ul>
<h3 id="14-动态web">1.4、动态web</h3>
<p>页面会动态展示： “Web的页面展示的效果因人而异”；</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613005517.png" alt="" loading="lazy"></figure>
<p>缺点：</p>
<ul>
<li>加入服务器的动态web资源出现了错误，我们需要重新编写我们的<strong>后台程序</strong>,重新发布；
<ul>
<li>停机维护</li>
</ul>
</li>
</ul>
<p>优点：</p>
<ul>
<li>Web页面可以动态更新，所有用户看到都不是同一个页面</li>
<li>它可以与数据库交互 （数据持久化：注册，商品信息，用户信息........）</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613005534.png" alt="" loading="lazy"></figure>
<p>新手村：--魔鬼训练（分析原理，看源码）--&gt; PK场</p>
<h2 id="2-web服务器">2、web服务器</h2>
<h3 id="21-技术讲解">2.1、技术讲解</h3>
<p><strong>ASP:</strong></p>
<ul>
<li>
<p>微软：国内最早流行的就是ASP；</p>
</li>
<li>
<p>在HTML中嵌入了VB的脚本，  ASP + COM；</p>
</li>
<li>
<p>在ASP开发中，基本一个页面都有几千行的业务代码，页面极其换乱</p>
</li>
<li>
<p>维护成本高！</p>
</li>
<li>
<p>C#</p>
</li>
<li>
<p>IIS</p>
<pre><code class="language-html">&lt;h1&gt;
    &lt;h1&gt;&lt;h1&gt;
        &lt;h1&gt;
            &lt;h1&gt;
                &lt;h1&gt;
        &lt;h1&gt;
            &lt;%
            System.out.println(&quot;hello&quot;)
            %&gt;
            &lt;h1&gt;
                &lt;h1&gt;
   &lt;h1&gt;&lt;h1&gt;
&lt;h1&gt;
</code></pre>
</li>
</ul>
<p><strong>php：</strong></p>
<ul>
<li>PHP开发速度很快，功能很强大，跨平台，代码很简单 （70% , WP）</li>
<li>无法承载大访问量的情况（局限性）</li>
</ul>
<p>**JSP/Servlet : **</p>
<p>B/S：浏览和服务器</p>
<p>C/S:  客户端和服务器</p>
<ul>
<li>sun公司主推的B/S架构</li>
<li>基于Java语言的 (所有的大公司，或者一些开源的组件，都是用Java写的)</li>
<li>可以承载三高问题带来的影响；</li>
<li>语法像ASP ， ASP--&gt;JSP , 加强市场强度；</li>
</ul>
<p>.....</p>
<h3 id="22-web服务器">2.2、web服务器</h3>
<p>服务器是一种被动的操作，用来处理用户的一些请求和给用户一些响应信息；</p>
<p><strong>IIS</strong></p>
<p>微软的； ASP...,Windows中自带的</p>
<p><strong>Tomcat</strong></p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613005712.png" alt="" loading="lazy"></figure>
<p>面向百度编程；</p>
<p>Tomcat是Apache 软件基金会（Apache Software Foundation）的Jakarta 项目中的一个核心项目，最新的Servlet 和JSP 规范总是能在Tomcat 中得到体现，因为Tomcat 技术先进、性能稳定，而且<strong>免费</strong>，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。</p>
<p>Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用<a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8">服务器</a>，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。对于一个Java初学web的人来说，它是最佳的选择</p>
<p>Tomcat 实际上运行JSP 页面和Servlet。Tomcat最新版本为<strong>9.0。</strong></p>
<p>....</p>
<p><strong>工作3-5年之后，可以尝试手写Tomcat服务器；</strong></p>
<p>下载tomcat：</p>
<ol>
<li>安装 or  解压</li>
<li>了解配置文件及目录结构</li>
<li>这个东西的作用</li>
</ol>
<h2 id="3-tomcat">3、Tomcat</h2>
<h3 id="31-安装tomcat">3.1、 安装tomcat</h3>
<p>tomcat官网：http://tomcat.apache.org/</p>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613005728.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613005741.png" alt="" loading="lazy"></figure>
<h3 id="32-tomcat启动和配置">3.2、Tomcat启动和配置</h3>
<p>文件夹作用：</p>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613005759.png" alt="" loading="lazy"></figure>
<p><strong>启动。关闭Tomcat</strong></p>
<figure data-type="image" tabindex="8"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613005814.png" alt="" loading="lazy"></figure>
<p>访问测试：http://localhost:8080/</p>
<p>可能遇到的问题：</p>
<ol>
<li>Java环境变量没有配置</li>
<li>闪退问题：需要配置兼容性</li>
<li>乱码问题：配置文件中设置</li>
</ol>
<h3 id="33-配置">3.3、配置</h3>
<figure data-type="image" tabindex="9"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613005836.png" alt="" loading="lazy"></figure>
<p>可以配置启动的端口号</p>
<ul>
<li>tomcat的默认端口号为：8080</li>
<li>mysql：3306</li>
<li>http：80</li>
<li>https：443</li>
</ul>
<pre><code class="language-xml">&lt;Connector port=&quot;8081&quot; protocol=&quot;HTTP/1.1&quot;
           connectionTimeout=&quot;20000&quot;
           redirectPort=&quot;8443&quot; /&gt;
</code></pre>
<p>可以配置主机的名称</p>
<ul>
<li>默认的主机名为：localhost-&gt;127.0.0.1</li>
<li>默认网站应用存放的位置为：webapps</li>
</ul>
<pre><code class="language-xml">  &lt;Host name=&quot;www.cy.com&quot;  appBase=&quot;webapps&quot;
        unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;
</code></pre>
<h4 id="高难度面试题">高难度面试题：</h4>
<p>请你谈谈网站是如何进行访问的！</p>
<ol>
<li>
<p>输入一个域名；回车</p>
</li>
<li>
<p>检查本机的 C:\Windows\System32\drivers\etc\hosts配置文件下有没有这个域名映射；</p>
<ol>
<li>
<p>有：直接返回对应的ip地址，这个地址中，有我们需要访问的web程序，可以直接访问</p>
<pre><code class="language-java">127.0.0.1       www.qinjiang.com
</code></pre>
</li>
<li>
<p>没有：去DNS服务器找，找到的话就返回，找不到就返回找不到；</p>
</li>
</ol>
<figure data-type="image" tabindex="10"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613005939.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>可以配置一下环境变量（可选性）</p>
</li>
</ol>
<h3 id="34-发布一个web网站">3.4、发布一个web网站</h3>
<p>不会就先模仿</p>
<ul>
<li>将自己写的网站，放到服务器(Tomcat)中指定的web应用的文件夹（webapps）下，就可以访问了</li>
</ul>
<p>网站应该有的结构</p>
<pre><code class="language-java">--webapps ：Tomcat服务器的web目录
	-ROOT
	-kuangstudy ：网站的目录名
		- WEB-INF
			-classes : java程序
			-lib：web应用所依赖的jar包
			-web.xml ：网站配置文件
		- index.html 默认的首页
		- static 
            -css
            	-style.css
            -js
            -img
         -.....
</code></pre>
<p>HTTP协议 ： 面试</p>
<p>Maven：构建工具</p>
<ul>
<li>Maven安装包</li>
</ul>
<p>Servlet 入门</p>
<ul>
<li>HelloWorld！</li>
<li>Servlet配置</li>
<li>原理</li>
</ul>
<h2 id="4-http">4、Http</h2>
<h3 id="41-什么是http">4.1、什么是HTTP</h3>
<p>HTTP（超文本传输协议）是一个简单的请求-响应协议，它通常运行在TCP之上。</p>
<ul>
<li>文本：html，字符串，~ ….</li>
<li>超文本：图片，音乐，视频，定位，地图…….</li>
<li>80</li>
</ul>
<p>Https：安全的</p>
<ul>
<li>443</li>
</ul>
<h3 id="42-两个时代">4.2、两个时代</h3>
<ul>
<li>
<p>http1.0</p>
<ul>
<li>HTTP/1.0：客户端可以与web服务器连接后，只能获得一个web资源，断开连接</li>
</ul>
</li>
<li>
<p>http2.0</p>
<ul>
<li>HTTP/1.1：客户端可以与web服务器连接后，可以获得多个web资源。‘</li>
</ul>
</li>
</ul>
<h3 id="43-http请求">4.3、Http请求</h3>
<ul>
<li>客户端---发请求（Request）---服务器</li>
</ul>
<p>百度：</p>
<pre><code class="language-java">Request URL:https://www.baidu.com/   请求地址
Request Method:GET    get方法/post方法
Status Code:200 OK    状态码：200
Remote（远程） Address:14.215.177.39:443
</code></pre>
<pre><code class="language-java">Accept:text/html  
Accept-Encoding:gzip, deflate, br
Accept-Language:zh-CN,zh;q=0.9    语言
Cache-Control:max-age=0
Connection:keep-alive
</code></pre>
<h4 id="1-请求行">1、请求行</h4>
<ul>
<li>请求行中的请求方式：GET</li>
<li>请求方式：<strong>Get，Post</strong>，HEAD,DELETE,PUT,TRACT…
<ul>
<li>get：请求能够携带的参数比较少，大小有限制，会在浏览器的URL地址栏显示数据内容，不安全，但高效</li>
<li>post：请求能够携带的参数没有限制，大小没有限制，不会在浏览器的URL地址栏显示数据内容，安全，但不高效。</li>
</ul>
</li>
</ul>
<h4 id="2-消息头">2、消息头</h4>
<pre><code class="language-java">Accept：告诉浏览器，它所支持的数据类型
Accept-Encoding：支持哪种编码格式  GBK   UTF-8   GB2312  ISO8859-1
Accept-Language：告诉浏览器，它的语言环境
Cache-Control：缓存控制
Connection：告诉浏览器，请求完成是断开还是保持连接
HOST：主机..../.
</code></pre>
<h3 id="44-http响应">4.4、Http响应</h3>
<ul>
<li>服务器---响应-----客户端</li>
</ul>
<p>百度：</p>
<pre><code class="language-java">Cache-Control:private    缓存控制
Connection:Keep-Alive    连接
Content-Encoding:gzip    编码
Content-Type:text/html   类型
</code></pre>
<h4 id="1响应体">1.响应体</h4>
<pre><code class="language-java">Accept：告诉浏览器，它所支持的数据类型
Accept-Encoding：支持哪种编码格式  GBK   UTF-8   GB2312  ISO8859-1
Accept-Language：告诉浏览器，它的语言环境
Cache-Control：缓存控制
Connection：告诉浏览器，请求完成是断开还是保持连接
HOST：主机..../.
Refresh：告诉客户端，多久刷新一次；
Location：让网页重新定位；
</code></pre>
<h4 id="2-响应状态码">2、响应状态码</h4>
<p>200：请求响应成功  200</p>
<p>3xx：请求重定向</p>
<ul>
<li>重定向：你重新到我给你新位置去；</li>
</ul>
<p>4xx：找不到资源   404</p>
<ul>
<li>资源不存在；</li>
</ul>
<p>5xx：服务器代码错误   500       502:网关错误</p>
<p><strong>常见面试题：</strong></p>
<p>当你的浏览器中地址栏输入地址并回车的一瞬间到页面能够展示回来，经历了什么？</p>
<h2 id="5-maven">5、Maven</h2>
<p><strong>我为什么要学习这个技术？</strong></p>
<ol>
<li>
<p>在Javaweb开发中，需要使用大量的jar包，我们手动去导入；</p>
</li>
<li>
<p>如何能够让一个东西自动帮我导入和配置这个jar包。</p>
<p>由此，Maven诞生了！</p>
</li>
</ol>
<h3 id="51-maven项目架构管理工具">5.1 Maven项目架构管理工具</h3>
<p>我们目前用来就是方便导入jar包的！</p>
<p>Maven的核心思想：<strong>约定大于配置</strong></p>
<ul>
<li>有约束，不要去违反。</li>
</ul>
<p>Maven会规定好你该如何去编写我们的Java代码，必须要按照这个规范来；</p>
<h3 id="52-下载安装maven">5.2 下载安装Maven</h3>
<p>官网;https://maven.apache.org/</p>
<figure data-type="image" tabindex="11"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613010043.png" alt="" loading="lazy"></figure>
<p>下载完成后，解压即可；</p>
<h3 id="53-配置环境变量">5.3 配置环境变量</h3>
<p>在我们的系统环境变量中</p>
<p>配置如下配置：</p>
<ul>
<li>M2_HOME     maven目录下的bin目录</li>
<li>MAVEN_HOME      maven的目录</li>
<li>在系统的path中配置  %MAVEN_HOME%\bin</li>
</ul>
<figure data-type="image" tabindex="12"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613010116.png" alt="" loading="lazy"></figure>
<p>测试Maven是否安装成功，保证必须配置完毕！</p>
<h3 id="54-阿里云镜像">5.4 阿里云镜像</h3>
<figure data-type="image" tabindex="13"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613010134.png" alt="" loading="lazy"></figure>
<ul>
<li>镜像：mirrors
<ul>
<li>作用：加速我们的下载</li>
</ul>
</li>
<li>国内建议使用阿里云的镜像</li>
</ul>
<pre><code class="language-xml">&lt;mirror&gt;
    &lt;id&gt;nexus-aliyun&lt;/id&gt;  
    &lt;mirrorOf&gt;*,!jeecg,!jeecg-snapshots&lt;/mirrorOf&gt;  
    &lt;name&gt;Nexus aliyun&lt;/name&gt;  
    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; 
&lt;/mirror&gt;
</code></pre>
<h3 id="55-本地仓库">5.5 本地仓库</h3>
<p>在本地的仓库，远程仓库；</p>
<p>**建立一个本地仓库：**localRepository</p>
<pre><code class="language-xml">&lt;localRepository&gt;D:\Environment\apache-maven-3.6.2\maven-repo&lt;/localRepository&gt;
</code></pre>
<h3 id="56-在idea中使用maven">5.6、在IDEA中使用Maven</h3>
<ol>
<li>
<p>启动IDEA</p>
</li>
<li>
<p>创建一个MavenWeb项目</p>
<figure data-type="image" tabindex="14"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613010155.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="15"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613010224.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="16"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613010243.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="17"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613010308.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="18"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613010344.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>等待项目初始化完毕</p>
<figure data-type="image" tabindex="19"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613010438.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="20"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613010525.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>观察maven仓库中多了什么东西？</p>
</li>
<li>
<p>IDEA中的Maven设置</p>
<p>注意：IDEA项目创建成功后，看一眼Maven的配置</p>
<figure data-type="image" tabindex="21"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613010556.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="22"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613010613.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>到这里，Maven在IDEA中的配置和使用就OK了!</p>
</li>
</ol>
<h3 id="57-创建一个普通的maven项目">5.7、创建一个普通的Maven项目</h3>
<figure data-type="image" tabindex="23"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613010651.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="24"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613010711.png" alt="" loading="lazy"></figure>
<p>这个只有在Web应用下才会有！</p>
<figure data-type="image" tabindex="25"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613010738.png" alt="" loading="lazy"></figure>
<h3 id="58-标记文件夹功能">5.8  标记文件夹功能</h3>
<figure data-type="image" tabindex="26"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613010816.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="27"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613010846.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="28"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613010926.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="29"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613010954.png" alt="" loading="lazy"></figure>
<h3 id="59-在-idea中配置tomcat">5.9 在 IDEA中配置Tomcat</h3>
<figure data-type="image" tabindex="30"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613011016.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="31"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613011032.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="32"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613011049.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="33"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613011103.png" alt="" loading="lazy"></figure>
<p>解决警告问题</p>
<p>必须要的配置：<strong>为什么会有这个问题：我们访问一个网站，需要指定一个文件夹名字；</strong></p>
<figure data-type="image" tabindex="34"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613011122.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="35"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613011156.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="36"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613011214.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="37"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613011230.png" alt="" loading="lazy"></figure>
<h3 id="510-pom文件">5.10 pom文件</h3>
<p>pom.xml 是Maven的核心配置文件</p>
<figure data-type="image" tabindex="38"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613011251.png" alt="" loading="lazy"></figure>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;!--Maven版本和头文件--&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

  &lt;!--这里就是我们刚才配置的GAV--&gt;
  &lt;groupId&gt;com.kuang&lt;/groupId&gt;
  &lt;artifactId&gt;javaweb-01-maven&lt;/artifactId&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;!--Package：项目的打包方式
  jar：java应用
  war：JavaWeb应用
  --&gt;
  &lt;packaging&gt;war&lt;/packaging&gt;


  &lt;!--配置--&gt;
  &lt;properties&gt;
    &lt;!--项目的默认构建编码--&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;!--编码版本--&gt;
    &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
    &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
  &lt;/properties&gt;

  &lt;!--项目依赖--&gt;
  &lt;dependencies&gt;
    &lt;!--具体依赖的jar包配置文件--&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;4.11&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;

  &lt;!--项目构建用的东西--&gt;
  &lt;build&gt;
    &lt;finalName&gt;javaweb-01-maven&lt;/finalName&gt;
    &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;
      &lt;plugins&gt;
        &lt;plugin&gt;
          &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;
          &lt;version&gt;3.1.0&lt;/version&gt;
        &lt;/plugin&gt;
        &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt;
        &lt;plugin&gt;
          &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;
          &lt;version&gt;3.0.2&lt;/version&gt;
        &lt;/plugin&gt;
        &lt;plugin&gt;
          &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
          &lt;version&gt;3.8.0&lt;/version&gt;
        &lt;/plugin&gt;
        &lt;plugin&gt;
          &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
          &lt;version&gt;2.22.1&lt;/version&gt;
        &lt;/plugin&gt;
        &lt;plugin&gt;
          &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;
          &lt;version&gt;3.2.2&lt;/version&gt;
        &lt;/plugin&gt;
        &lt;plugin&gt;
          &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt;
          &lt;version&gt;2.5.2&lt;/version&gt;
        &lt;/plugin&gt;
        &lt;plugin&gt;
          &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt;
          &lt;version&gt;2.8.2&lt;/version&gt;
        &lt;/plugin&gt;
      &lt;/plugins&gt;
    &lt;/pluginManagement&gt;
  &lt;/build&gt;
&lt;/project&gt;

</code></pre>
<figure data-type="image" tabindex="39"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613011335.png" alt="" loading="lazy"></figure>
<p>maven由于他的约定大于配置，我们之后可以能遇到我们写的配置文件，无法被导出或者生效的问题，解决方案：</p>
<pre><code class="language-xml">&lt;!--在build中配置resources，来防止我们资源导出失败的问题--&gt;
&lt;build&gt;
    &lt;resources&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/resources&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.properties&lt;/include&gt;
                &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
            &lt;filtering&gt;true&lt;/filtering&gt;
        &lt;/resource&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/java&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.properties&lt;/include&gt;
                &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
            &lt;filtering&gt;true&lt;/filtering&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
&lt;/build&gt;
</code></pre>
<h3 id="512-idea操作">5.12 IDEA操作</h3>
<figure data-type="image" tabindex="40"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613011355.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="41"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613011409.png" alt="" loading="lazy"></figure>
<h3 id="513-解决遇到的问题">5.13 解决遇到的问题</h3>
<ol>
<li>
<p>Maven 3.6.2</p>
<p>解决方法：降级为3.6.1</p>
<figure data-type="image" tabindex="42"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613011426.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>Tomcat闪退</p>
</li>
<li>
<p>IDEA中每次都要重复配置Maven<br>
在IDEA中的全局默认配置中去配置</p>
<figure data-type="image" tabindex="43"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613011443.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="44"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613011501.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>Maven项目中Tomcat无法配置</p>
</li>
<li>
<p>maven默认web项目中的web.xml版本问题</p>
<figure data-type="image" tabindex="45"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613011524.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>替换为webapp4.0版本和tomcat一致</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee
                      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;
         metadata-complete=&quot;true&quot;&gt;



&lt;/web-app&gt;
</code></pre>
</li>
<li>
<p>Maven仓库的使用</p>
<p>地址：https://mvnrepository.com/</p>
<figure data-type="image" tabindex="46"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613011542.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="47"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613011612.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="48"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613011624.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="49"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613011643.png" alt="" loading="lazy"></figure>
</li>
</ol>
<h2 id="6-servlet">6、Servlet</h2>
<h3 id="61-servlet简介">6.1、Servlet简介</h3>
<ul>
<li>Servlet就是sun公司开发动态web的一门技术</li>
<li>Sun在这些API中提供一个接口叫做：Servlet，如果你想开发一个Servlet程序，只需要完成两个小步骤：
<ul>
<li>编写一个类，实现Servlet接口</li>
<li>把开发好的Java类部署到web服务器中。</li>
</ul>
</li>
</ul>
<p><strong>把实现了Servlet接口的Java程序叫做，Servlet</strong></p>
<h3 id="62-helloservlet">6.2、HelloServlet</h3>
<p>Serlvet接口Sun公司有两个默认的实现类：HttpServlet，GenericServlet</p>
<ol>
<li>
<p>构建一个普通的Maven项目，删掉里面的src目录，以后我们的学习就在这个项目里面建立Moudel；这个空的工程就是Maven主工程；</p>
</li>
<li>
<p>关于Maven父子工程的理解：</p>
<p>父项目中会有</p>
<pre><code class="language-xml">    &lt;modules&gt;
        &lt;module&gt;servlet-01&lt;/module&gt;
    &lt;/modules&gt;
</code></pre>
<p>子项目会有</p>
<pre><code class="language-xml">    &lt;parent&gt;
        &lt;artifactId&gt;javaweb-02-servlet&lt;/artifactId&gt;
        &lt;groupId&gt;com.kuang&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
</code></pre>
<p>父项目中的java子项目可以直接使用</p>
<pre><code class="language-java">son extends father
</code></pre>
</li>
<li>
<p>Maven环境优化</p>
<ol>
<li>修改web.xml为最新的</li>
<li>将maven的结构搭建完整</li>
</ol>
</li>
<li>
<p>编写一个Servlet程序</p>
<figure data-type="image" tabindex="50"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613011708.png" alt="" loading="lazy"></figure>
<ol>
<li>
<p>编写一个普通类</p>
</li>
<li>
<p>实现Servlet接口，这里我们直接继承HttpServlet</p>
<pre><code class="language-java">public class HelloServlet extends HttpServlet {
    
    //由于get或者post只是请求实现的不同的方式，可以相互调用，业务逻辑都一样；
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //ServletOutputStream outputStream = resp.getOutputStream();
        PrintWriter writer = resp.getWriter(); //响应流
        writer.print(&quot;Hello,Serlvet&quot;);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}

</code></pre>
</li>
</ol>
</li>
<li>
<p>编写Servlet的映射</p>
<p>为什么需要映射：我们写的是JAVA程序，但是要通过浏览器访问，而浏览器需要连接web服务器，所以我们需要再web服务中注册我们写的Servlet，还需给他一个浏览器能够访问的路径；</p>
<pre><code class="language-xml">
    &lt;!--注册Servlet--&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
        &lt;servlet-class&gt;com.cy.servlet.HelloServlet&lt;/servlet-class&gt;
    &lt;/servlet&gt;
    &lt;!--Servlet的请求路径--&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

</code></pre>
</li>
<li>
<p>配置Tomcat</p>
<p>注意：配置项目发布的路径就可以了</p>
</li>
<li>
<p>启动测试，OK！</p>
</li>
</ol>
<h3 id="63-servlet原理">6.3、Servlet原理</h3>
<p>Servlet是由Web服务器调用，web服务器在收到浏览器请求之后，会：</p>
<figure data-type="image" tabindex="51"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613011737.png" alt="" loading="lazy"></figure>
<h3 id="64-mapping问题">6.4、Mapping问题</h3>
<ol>
<li>
<p>一个Servlet可以指定一个映射路径</p>
<pre><code class="language-xml">    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
</code></pre>
</li>
<li>
<p>一个Servlet可以指定多个映射路径</p>
<pre><code class="language-xml">    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/hello2&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/hello3&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/hello4&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/hello5&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

</code></pre>
</li>
<li>
<p>一个Servlet可以指定通用映射路径</p>
<pre><code class="language-xml">    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/hello/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
</code></pre>
</li>
<li>
<p>默认请求路径</p>
<pre><code class="language-xml">    &lt;!--默认请求路径--&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
</code></pre>
</li>
<li>
<p>指定一些后缀或者前缀等等….</p>
<pre><code class="language-xml">
&lt;!--可以自定义后缀实现请求映射
    注意点，*前面不能加项目映射的路径
    hello/sajdlkajda.qinjiang
    --&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
    &lt;url-pattern&gt;*.cy&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
</li>
<li>
<p>优先级问题<br>
指定了固有的映射路径优先级最高，如果找不到就会走默认的处理请求；</p>
<pre><code class="language-xml">&lt;!--404--&gt;
&lt;servlet&gt;
    &lt;servlet-name&gt;error&lt;/servlet-name&gt;
    &lt;servlet-class&gt;com.cy.servlet.ErrorServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;error&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

</code></pre>
</li>
</ol>
<h3 id="65-servletcontext">6.5、ServletContext</h3>
<p>web容器在启动的时候，它会为每个web程序都创建一个对应的ServletContext对象，它代表了当前的web应用；</p>
<h4 id="1-共享数据">1、共享数据</h4>
<p>我在这个Servlet中保存的数据，可以在另外一个servlet中拿到；</p>
<pre><code class="language-java">public class HelloServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        
        //this.getInitParameter()   初始化参数
        //this.getServletConfig()   Servlet配置
        //this.getServletContext()  Servlet上下文
        ServletContext context = this.getServletContext();

        String username = &quot;CY&quot;; //数据
        context.setAttribute(&quot;username&quot;,username); //将一个数据保存在了ServletContext中，名字为：username 。值 username

    }

}

</code></pre>
<pre><code class="language-java">public class GetServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        ServletContext context = this.getServletContext();
        String username = (String) context.getAttribute(&quot;username&quot;);

        resp.setContentType(&quot;text/html&quot;);
        resp.setCharacterEncoding(&quot;utf-8&quot;);
        resp.getWriter().print(&quot;名字&quot;+username);

    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}

</code></pre>
<pre><code class="language-XML">    &lt;servlet&gt;
        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
        &lt;servlet-class&gt;com.cy.servlet.HelloServlet&lt;/servlet-class&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;


    &lt;servlet&gt;
        &lt;servlet-name&gt;getc&lt;/servlet-name&gt;
        &lt;servlet-class&gt;com.cy.servlet.GetServlet&lt;/servlet-class&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;getc&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/getc&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
</code></pre>
<p>测试访问结果；</p>
<h4 id="2-获取初始化参数">2、获取初始化参数</h4>
<pre><code class="language-xml">    &lt;!--配置一些web应用初始化参数--&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;url&lt;/param-name&gt;
        &lt;param-value&gt;jdbc:mysql://localhost:3306/mybatis&lt;/param-value&gt;
    &lt;/context-param&gt;
</code></pre>
<pre><code class="language-java">protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    ServletContext context = this.getServletContext();
    String url = context.getInitParameter(&quot;url&quot;);
    resp.getWriter().print(url);
}
</code></pre>
<h4 id="3-请求转发">3、请求转发</h4>
<pre><code class="language-java">@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    ServletContext context = this.getServletContext();
    System.out.println(&quot;进入了ServletDemo04&quot;);
    //RequestDispatcher requestDispatcher = context.getRequestDispatcher(&quot;/gp&quot;); //转发的请求路径
    //requestDispatcher.forward(req,resp); //调用forward实现请求转发；
    context.getRequestDispatcher(&quot;/gp&quot;).forward(req,resp);
}
</code></pre>
<figure data-type="image" tabindex="52"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613011803.png" alt="" loading="lazy"></figure>
<h4 id="4-读取资源文件">4、读取资源文件</h4>
<p>Properties</p>
<ul>
<li>在java目录下新建properties</li>
<li>在resources目录下新建properties</li>
</ul>
<p>发现：都被打包到了同一个路径下：classes，我们俗称这个路径为classpath:</p>
<p>思路：需要一个文件流；</p>
<pre><code class="language-properties">username=root12312
password=zxczxczxc
</code></pre>
<pre><code class="language-java">public class ServletDemo05 extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

        InputStream is = this.getServletContext().getResourceAsStream(&quot;/WEB-INF/classes/com/kuang/servlet/aa.properties&quot;);

        Properties prop = new Properties();
        prop.load(is);
        String user = prop.getProperty(&quot;username&quot;);
        String pwd = prop.getProperty(&quot;password&quot;);

        resp.getWriter().print(user+&quot;:&quot;+pwd);

    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}

</code></pre>
<p>访问测试即可ok；</p>
<h3 id="66-httpservletresponse">6.6、HttpServletResponse</h3>
<p>web服务器接收到客户端的http请求，针对这个请求，分别创建一个代表请求的HttpServletRequest对象，代表响应的一个HttpServletResponse；</p>
<ul>
<li>如果要获取客户端请求过来的参数：找HttpServletRequest</li>
<li>如果要给客户端响应一些信息：找HttpServletResponse</li>
</ul>
<h4 id="1-简单分类">1、简单分类</h4>
<p>负责向浏览器发送数据的方法</p>
<pre><code class="language-java">ServletOutputStream getOutputStream() throws IOException;
PrintWriter getWriter() throws IOException;
</code></pre>
<p>负责向浏览器发送响应头的方法</p>
<pre><code class="language-java">    void setCharacterEncoding(String var1);

    void setContentLength(int var1);

    void setContentLengthLong(long var1);

    void setContentType(String var1);

    void setDateHeader(String var1, long var2);

    void addDateHeader(String var1, long var2);

    void setHeader(String var1, String var2);

    void addHeader(String var1, String var2);

    void setIntHeader(String var1, int var2);

    void addIntHeader(String var1, int var2);
</code></pre>
<p>响应的状态码</p>
<pre><code class="language-java">    int SC_CONTINUE = 100;
    int SC_SWITCHING_PROTOCOLS = 101;
    int SC_OK = 200;
    int SC_CREATED = 201;
    int SC_ACCEPTED = 202;
    int SC_NON_AUTHORITATIVE_INFORMATION = 203;
    int SC_NO_CONTENT = 204;
    int SC_RESET_CONTENT = 205;
    int SC_PARTIAL_CONTENT = 206;
    int SC_MULTIPLE_CHOICES = 300;
    int SC_MOVED_PERMANENTLY = 301;
    int SC_MOVED_TEMPORARILY = 302;
    int SC_FOUND = 302;
    int SC_SEE_OTHER = 303;
    int SC_NOT_MODIFIED = 304;
    int SC_USE_PROXY = 305;
    int SC_TEMPORARY_REDIRECT = 307;
    int SC_BAD_REQUEST = 400;
    int SC_UNAUTHORIZED = 401;
    int SC_PAYMENT_REQUIRED = 402;
    int SC_FORBIDDEN = 403;
    int SC_NOT_FOUND = 404;
    int SC_METHOD_NOT_ALLOWED = 405;
    int SC_NOT_ACCEPTABLE = 406;
    int SC_PROXY_AUTHENTICATION_REQUIRED = 407;
    int SC_REQUEST_TIMEOUT = 408;
    int SC_CONFLICT = 409;
    int SC_GONE = 410;
    int SC_LENGTH_REQUIRED = 411;
    int SC_PRECONDITION_FAILED = 412;
    int SC_REQUEST_ENTITY_TOO_LARGE = 413;
    int SC_REQUEST_URI_TOO_LONG = 414;
    int SC_UNSUPPORTED_MEDIA_TYPE = 415;
    int SC_REQUESTED_RANGE_NOT_SATISFIABLE = 416;
    int SC_EXPECTATION_FAILED = 417;
    int SC_INTERNAL_SERVER_ERROR = 500;
    int SC_NOT_IMPLEMENTED = 501;
    int SC_BAD_GATEWAY = 502;
    int SC_SERVICE_UNAVAILABLE = 503;
    int SC_GATEWAY_TIMEOUT = 504;
    int SC_HTTP_VERSION_NOT_SUPPORTED = 505;
</code></pre>
<h4 id="2-下载文件">2、下载文件</h4>
<ol>
<li>向浏览器输出消息</li>
<li>下载文件
<ol>
<li>要获取下载文件的路径</li>
<li>下载的文件名是啥？</li>
<li>设置想办法让浏览器能够支持下载我们需要的东西</li>
<li>获取下载文件的输入流</li>
<li>创建缓冲区</li>
<li>获取OutputStream对象</li>
<li>将FileOutputStream流写入到buffer缓冲区</li>
<li>使用OutputStream将缓冲区中的数据输出到客户端！</li>
</ol>
</li>
</ol>
<pre><code class="language-java">@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    // 1. 要获取下载文件的路径
    String realPath = &quot;F:代码\\JavaWeb\\javaweb-02-servlet\\response\\target\\classes\\123.png&quot;;
    System.out.println(&quot;下载文件的路径：&quot;+realPath);
    // 2. 下载的文件名是啥？
    String fileName = realPath.substring(realPath.lastIndexOf(&quot;\\&quot;) + 1);
    // 3. 设置想办法让浏览器能够支持(Content-Disposition)下载我们需要的东西,中文文件名URLEncoder.encode编码，否则有可能乱码
    resp.setHeader(&quot;Content-Disposition&quot;,&quot;attachment;filename=&quot;+URLEncoder.encode(fileName,&quot;UTF-8&quot;));
    // 4. 获取下载文件的输入流
    FileInputStream in = new FileInputStream(realPath);
    // 5. 创建缓冲区
    int len = 0;
    byte[] buffer = new byte[1024];
    // 6. 获取OutputStream对象
    ServletOutputStream out = resp.getOutputStream();
    // 7. 将FileOutputStream流写入到buffer缓冲区,使用OutputStream将缓冲区中的数据输出到客户端！
    while ((len=in.read(buffer))&gt;0){
        out.write(buffer,0,len);
    }

    in.close();
    out.close();
}
</code></pre>
<h4 id="3-验证码功能">3、验证码功能</h4>
<p>验证怎么来的？</p>
<ul>
<li>前端实现</li>
<li>后端实现，需要用到 Java 的图片类，生产一个图片</li>
</ul>
<pre><code class="language-java">package com.kuang.servlet;

import javax.imageio.ImageIO;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.Random;

public class ImageServlet extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

        //如何让浏览器3秒自动刷新一次;
        resp.setHeader(&quot;refresh&quot;,&quot;3&quot;);
        
        //在内存中创建一个图片
        BufferedImage image = new BufferedImage(80,20,BufferedImage.TYPE_INT_RGB);
        //得到图片
        Graphics2D g = (Graphics2D) image.getGraphics(); //笔
        //设置图片的背景颜色
        g.setColor(Color.white);
        g.fillRect(0,0,80,20);
        //给图片写数据
        g.setColor(Color.BLUE);
        g.setFont(new Font(null,Font.BOLD,20));
        g.drawString(makeNum(),0,20);

        //告诉浏览器，这个请求用图片的方式打开
        resp.setContentType(&quot;image/jpeg&quot;);
        //网站存在缓存，不让浏览器缓存
        resp.setDateHeader(&quot;expires&quot;,-1);
        resp.setHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;);
        resp.setHeader(&quot;Pragma&quot;,&quot;no-cache&quot;);

        //把图片写给浏览器
        ImageIO.write(image,&quot;jpg&quot;, resp.getOutputStream());

    }

    //生成随机数
    private String makeNum(){
        Random random = new Random();
        String num = random.nextInt(9999999) + &quot;&quot;;
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i &lt; 7-num.length() ; i++) {
            sb.append(&quot;0&quot;);
        }
        num = sb.toString() + num;
        return num;
    }


    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}

</code></pre>
<h4 id="4-实现重定向">4、实现重定向</h4>
<figure data-type="image" tabindex="53"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613012114.png" alt="" loading="lazy"></figure>
<p>B一个web资源收到客户端A请求后，B他会通知A客户端去访问另外一个web资源C，这个过程叫重定向</p>
<p>常见场景：</p>
<ul>
<li>用户登录</li>
</ul>
<pre><code class="language-java">void sendRedirect(String var1) throws IOException;
</code></pre>
<p>测试：</p>
<pre><code class="language-java">@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

    /*
        resp.setHeader(&quot;Location&quot;,&quot;/r/img&quot;);
        resp.setStatus(302);
         */
    resp.sendRedirect(&quot;/r/img&quot;);//重定向
}
</code></pre>
<p>面试题：请你聊聊重定向和转发的区别？</p>
<p>相同点</p>
<ul>
<li>页面都会实现跳转</li>
</ul>
<p>不同点</p>
<ul>
<li>请求转发的时候，url不会产生变化</li>
<li>重定向时候，url地址栏会发生变化；</li>
</ul>
<figure data-type="image" tabindex="54"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613012129.png" alt="" loading="lazy"></figure>
<h4 id="5-简单实现登录重定向">5、简单实现登录重定向</h4>
<pre><code class="language-jsp">&lt;%--这里提交的路径，需要寻找到项目的路径--%&gt;
&lt;%--${pageContext.request.contextPath}代表当前的项目--%&gt;

&lt;form action=&quot;${pageContext.request.contextPath}/login&quot; method=&quot;get&quot;&gt;
    用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;br&gt;
    密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;br&gt;
    &lt;input type=&quot;submit&quot;&gt;
&lt;/form&gt;

</code></pre>
<pre><code class="language-JAVA">
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //处理请求
        String username = req.getParameter(&quot;username&quot;);
        String password = req.getParameter(&quot;password&quot;);

        System.out.println(username+&quot;:&quot;+password);

        //重定向时候一定要注意，路径问题，否则404；
        resp.sendRedirect(&quot;/r/success.jsp&quot;);
    }

</code></pre>
<pre><code class="language-xml">  &lt;servlet&gt;
    &lt;servlet-name&gt;requset&lt;/servlet-name&gt;
    &lt;servlet-class&gt;com.cy.servlet.RequestTest&lt;/servlet-class&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;requset&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/login&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
</code></pre>
<pre><code class="language-jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1&gt;Success&lt;/h1&gt;

&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<h3 id="67-httpservletrequest">6.7、HttpServletRequest</h3>
<p>HttpServletRequest代表客户端的请求，用户通过Http协议访问服务器，HTTP请求中的所有信息会被封装到HttpServletRequest，通过这个HttpServletRequest的方法，获得客户端的所有信息；</p>
<figure data-type="image" tabindex="55"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613012206.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="56"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613012223.png" alt="" loading="lazy"></figure>
<h4 id="获取参数请求转发">获取参数，请求转发</h4>
<figure data-type="image" tabindex="57"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613012235.png" alt="" loading="lazy"></figure>
<pre><code class="language-java">@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

    req.setCharacterEncoding(&quot;utf-8&quot;);
    resp.setCharacterEncoding(&quot;utf-8&quot;);

    String username = req.getParameter(&quot;username&quot;);
    String password = req.getParameter(&quot;password&quot;);
    String[] hobbys = req.getParameterValues(&quot;hobbys&quot;);
    System.out.println(&quot;=============================&quot;);
    //后台接收中文乱码问题
    System.out.println(username);
    System.out.println(password);
    System.out.println(Arrays.toString(hobbys));
    System.out.println(&quot;=============================&quot;);


    System.out.println(req.getContextPath());
    //通过请求转发
    //这里的 / 代表当前的web应用
    req.getRequestDispatcher(&quot;/success.jsp&quot;).forward(req,resp);

}
</code></pre>
<p><strong>面试题：请你聊聊重定向和转发的区别？</strong></p>
<p>相同点</p>
<ul>
<li>页面都会实现跳转</li>
</ul>
<p>不同点</p>
<ul>
<li>请求转发的时候，url不会产生变化   307</li>
<li>重定向时候，url地址栏会发生变化； 302</li>
</ul>
<h2 id="7-cookie-session">7、Cookie、Session</h2>
<h3 id="71-会话">7.1、会话</h3>
<p><strong>会话</strong>：用户打开一个浏览器，点击了很多超链接，访问多个web资源，关闭浏览器，这个过程可以称之为会话；</p>
<p><strong>有状态会话</strong>：一个同学来过教室，下次再来教室，我们会知道这个同学，曾经来过，称之为有状态会话；</p>
<p><strong>你能怎么证明你是清华的学生？</strong></p>
<p>你              清华</p>
<ol>
<li>发票                清华给你发票</li>
<li>学校登记        清华标记你来过了</li>
</ol>
<p><strong>一个网站，怎么证明你来过？</strong></p>
<p>客户端              服务端</p>
<ol>
<li>服务端给客户端一个 信件，客户端下次访问服务端带上信件就可以了； cookie</li>
<li>服务器登记你来过了，下次你来的时候我来匹配你； seesion</li>
</ol>
<h3 id="72-保存会话的两种技术">7.2、保存会话的两种技术</h3>
<p><strong>cookie</strong></p>
<ul>
<li>客户端技术   （响应，请求）</li>
</ul>
<p><strong>session</strong></p>
<ul>
<li>服务器技术，利用这个技术，可以保存用户的会话信息？ 我们可以把信息或者数据放在Session中！</li>
</ul>
<p>常见常见：网站登录之后，你下次不用再登录了，第二次访问直接就上去了！</p>
<h3 id="73-cookie">7.3、Cookie</h3>
<figure data-type="image" tabindex="58"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613012332.png" alt="" loading="lazy"></figure>
<ol>
<li>从请求中拿到cookie信息</li>
<li>服务器响应给客户端cookie</li>
</ol>
<pre><code class="language-java">Cookie[] cookies = req.getCookies(); //获得Cookie
cookie.getName(); //获得cookie中的key
cookie.getValue(); //获得cookie中的vlaue
new Cookie(&quot;lastLoginTime&quot;, System.currentTimeMillis()+&quot;&quot;); //新建一个cookie
cookie.setMaxAge(24*60*60); //设置cookie的有效期
resp.addCookie(cookie); //响应给客户端一个cookie
</code></pre>
<p><strong>cookie：一般会保存在本地的 用户目录下 appdata；</strong></p>
<p>一个网站cookie是否存在上限！<strong>聊聊细节问题</strong></p>
<ul>
<li>一个Cookie只能保存一个信息；</li>
<li>一个web站点可以给浏览器发送多个cookie，最多存放20个cookie；</li>
<li>Cookie大小有限制4kb；</li>
<li>300个cookie浏览器上限</li>
</ul>
<p><strong>删除Cookie；</strong></p>
<ul>
<li>不设置有效期，关闭浏览器，自动失效；</li>
<li>设置有效期时间为 0 ；</li>
</ul>
<p><strong>编码解码：</strong></p>
<pre><code class="language-java">URLEncoder.encode(&quot;CY&quot;,&quot;utf-8&quot;)
URLDecoder.decode(cookie.getValue(),&quot;UTF-8&quot;)
</code></pre>
<h3 id="74-session重点">7.4、Session（重点）</h3>
<figure data-type="image" tabindex="59"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613012402.png" alt="" loading="lazy"></figure>
<p>什么是Session：</p>
<ul>
<li>服务器会给每一个用户（浏览器）创建一个Seesion对象；</li>
<li>一个Seesion独占一个浏览器，只要浏览器没有关闭，这个Session就存在；</li>
<li>用户登录之后，整个网站它都可以访问！--&gt; 保存用户的信息；保存购物车的信息…..</li>
</ul>
<figure data-type="image" tabindex="60"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613012415.png" alt="" loading="lazy"></figure>
<p>Session和cookie的区别：</p>
<ul>
<li>Cookie是把用户的数据写给用户的浏览器，浏览器保存 （可以保存多个）</li>
<li>Session把用户的数据写到用户独占Session中，服务器端保存  （保存重要的信息，减少服务器资源的浪费）</li>
<li>Session对象由服务创建；</li>
</ul>
<p>使用场景：</p>
<ul>
<li>保存一个登录用户的信息；</li>
<li>购物车信息；</li>
<li>在整个网站中经常会使用的数据，我们将它保存在Session中；</li>
</ul>
<p>使用Session：</p>
<pre><code class="language-java">package com.cy.servlet;

import com.kuang.pojo.Person;

import javax.servlet.ServletException;
import javax.servlet.http.*;
import java.io.IOException;

public class SessionDemo01 extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        
        //解决乱码问题
        req.setCharacterEncoding(&quot;UTF-8&quot;);
        resp.setCharacterEncoding(&quot;UTF-8&quot;);
        resp.setContentType(&quot;text/html;charset=utf-8&quot;);
        
        //得到Session
        HttpSession session = req.getSession();
        //给Session中存东西
        session.setAttribute(&quot;name&quot;,new Person(&quot;秦疆&quot;,1));
        //获取Session的ID
        String sessionId = session.getId();

        //判断Session是不是新创建
        if (session.isNew()){
            resp.getWriter().write(&quot;session创建成功,ID:&quot;+sessionId);
        }else {
            resp.getWriter().write(&quot;session以及在服务器中存在了,ID:&quot;+sessionId);
        }

        //Session创建的时候做了什么事情；
//        Cookie cookie = new Cookie(&quot;JSESSIONID&quot;,sessionId);
//        resp.addCookie(cookie);

    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}

//得到Session
HttpSession session = req.getSession();

Person person = (Person) session.getAttribute(&quot;name&quot;);

System.out.println(person.toString());

HttpSession session = req.getSession();
session.removeAttribute(&quot;name&quot;);
//手动注销Session
session.invalidate();
</code></pre>
<p><strong>会话自动过期：web.xml配置</strong></p>
<pre><code class="language-xml">&lt;!--设置Session默认的失效时间--&gt;
&lt;session-config&gt;
    &lt;!--15分钟后Session自动失效，以分钟为单位--&gt;
    &lt;session-timeout&gt;15&lt;/session-timeout&gt;
&lt;/session-config&gt;
</code></pre>
<figure data-type="image" tabindex="61"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613012454.png" alt="" loading="lazy"></figure>
<h2 id="8-jsp">8、JSP</h2>
<h3 id="81-什么是jsp">8.1、什么是JSP</h3>
<p>Java Server Pages ： Java服务器端页面，也和Servlet一样，用于动态Web技术！</p>
<p>最大的特点：</p>
<ul>
<li>写JSP就像在写HTML</li>
<li>区别：
<ul>
<li>HTML只给用户提供静态的数据</li>
<li>JSP页面中可以嵌入JAVA代码，为用户提供动态数据；</li>
</ul>
</li>
</ul>
<h3 id="82-jsp原理">8.2、JSP原理</h3>
<p>思路：JSP到底怎么执行的！</p>
<ul>
<li>
<p>代码层面没有任何问题</p>
</li>
<li>
<p>服务器内部工作</p>
<p>tomcat中有一个work目录；</p>
<p>IDEA中使用Tomcat的会在IDEA的tomcat中生产一个work目录</p>
<figure data-type="image" tabindex="62"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613012516.png" alt="" loading="lazy"></figure>
<p>我电脑的地址：</p>
<pre><code class="language-java">C:\Users\Administrator\.IntelliJIdea2018.1\system\tomcat\Unnamed_javaweb-session-cookie\work\Catalina\localhost\ROOT\org\apache\jsp
</code></pre>
<p>发现页面转变成了Java程序！</p>
<figure data-type="image" tabindex="63"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613012553.png" alt="" loading="lazy"></figure>
</li>
</ul>
<p><strong>浏览器向服务器发送请求，不管访问什么资源，其实都是在访问Servlet！</strong></p>
<p>JSP最终也会被转换成为一个Java类！</p>
<p><strong>JSP 本质上就是一个Servlet</strong></p>
<pre><code class="language-java">//初始化
  public void _jspInit() {
      
  }
//销毁
  public void _jspDestroy() {
  }
//JSPService
  public void _jspService(.HttpServletRequest request,HttpServletResponse response)
      
</code></pre>
<ol>
<li>
<p>判断请求</p>
</li>
<li>
<p>内置一些对象</p>
<pre><code class="language-java">final javax.servlet.jsp.PageContext pageContext;  //页面上下文
javax.servlet.http.HttpSession session = null;    //session
final javax.servlet.ServletContext application;   //applicationContext
final javax.servlet.ServletConfig config;         //config
javax.servlet.jsp.JspWriter out = null;           //out
final java.lang.Object page = this;               //page：当前
HttpServletRequest request                        //请求
HttpServletResponse response                      //响应
</code></pre>
</li>
<li>
<p>输出页面前增加的代码</p>
<pre><code class="language-java">response.setContentType(&quot;text/html&quot;);       //设置响应的页面类型
pageContext = _jspxFactory.getPageContext(this, request, response,
                                          null, true, 8192, true);
_jspx_page_context = pageContext;
application = pageContext.getServletContext();
config = pageContext.getServletConfig();
session = pageContext.getSession();
out = pageContext.getOut();
_jspx_out = out;
</code></pre>
</li>
<li>
<p>以上的这些个对象我们可以在JSP页面中直接使用！</p>
</li>
</ol>
<figure data-type="image" tabindex="64"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613012856.png" alt="" loading="lazy"></figure>
<p>在JSP页面中；</p>
<p>只要是 JAVA代码就会原封不动的输出；</p>
<p>如果是HTML代码，就会被转换为：</p>
<pre><code class="language-java">out.write(&quot;&lt;html&gt;\r\n&quot;);
</code></pre>
<p>这样的格式，输出到前端！</p>
<h3 id="83-jsp基础语法">8.3、JSP基础语法</h3>
<p>任何语言都有自己的语法，JAVA中有,。 JSP 作为java技术的一种应用，它拥有一些自己扩充的语法（了解，知道即可！），Java所有语法都支持！</p>
<h4 id="jsp表达式"><strong>JSP表达式</strong></h4>
<pre><code class="language-jsp">  &lt;%--JSP表达式
  作用：用来将程序的输出，输出到客户端
  &lt;%= 变量或者表达式%&gt;
  --%&gt;
  &lt;%= new java.util.Date()%&gt;
</code></pre>
<h4 id="jsp脚本片段"><strong>jsp脚本片段</strong></h4>
<pre><code class="language-jsp">
  &lt;%--jsp脚本片段--%&gt;
  &lt;%
    int sum = 0;
    for (int i = 1; i &lt;=100 ; i++) {
      sum+=i;
    }
    out.println(&quot;&lt;h1&gt;Sum=&quot;+sum+&quot;&lt;/h1&gt;&quot;);
  %&gt;

</code></pre>
<p><strong>脚本片段的再实现</strong></p>
<pre><code class="language-jsp">  &lt;%
    int x = 10;
    out.println(x);
  %&gt;
  &lt;p&gt;这是一个JSP文档&lt;/p&gt;
  &lt;%
    int y = 2;
    out.println(y);
  %&gt;

  &lt;hr&gt;


  &lt;%--在代码嵌入HTML元素--%&gt;
  &lt;%
    for (int i = 0; i &lt; 5; i++) {
  %&gt;
    &lt;h1&gt;Hello,World  &lt;%=i%&gt; &lt;/h1&gt;
  &lt;%
    }
  %&gt;
</code></pre>
<h4 id="jsp声明">JSP声明</h4>
<pre><code class="language-jsp">  &lt;%!
    static {
      System.out.println(&quot;Loading Servlet!&quot;);
    }

    private int globalVar = 0;

    public void kuang(){
      System.out.println(&quot;进入了方法Kuang！&quot;);
    }
  %&gt;
</code></pre>
<p>JSP声明：会被编译到JSP生成Java的类中！其他的，就会被生成到_jspService方法中！</p>
<p>在JSP，嵌入Java代码即可！</p>
<pre><code class="language-jsp">&lt;%%&gt;
&lt;%=%&gt;
&lt;%!%&gt;

&lt;%--注释--%&gt;
</code></pre>
<p>JSP的注释，不会在客户端显示，HTML就会！</p>
<h3 id="84-jsp指令">8.4、JSP指令</h3>
<pre><code class="language-jsp">&lt;%@page args.... %&gt;
&lt;%@include file=&quot;&quot;%&gt;

&lt;%--@include会将两个页面合二为一--%&gt;

&lt;%@include file=&quot;common/header.jsp&quot;%&gt;
&lt;h1&gt;网页主体&lt;/h1&gt;

&lt;%@include file=&quot;common/footer.jsp&quot;%&gt;

&lt;hr&gt;


&lt;%--jSP标签
    jsp:include：拼接页面，本质还是三个
    --%&gt;
&lt;jsp:include page=&quot;/common/header.jsp&quot;/&gt;
&lt;h1&gt;网页主体&lt;/h1&gt;
&lt;jsp:include page=&quot;/common/footer.jsp&quot;/&gt;

</code></pre>
<h3 id="85-9大内置对象">8.5、9大内置对象</h3>
<ul>
<li>PageContext    存东西</li>
<li>Request     存东西</li>
<li>Response</li>
<li>Session      存东西</li>
<li>Application   【SerlvetContext】   存东西</li>
<li>config    【SerlvetConfig】</li>
<li>out</li>
<li>page ，不用了解</li>
<li>exception</li>
</ul>
<pre><code class="language-java">pageContext.setAttribute(&quot;name1&quot;,&quot;1号&quot;); //保存的数据只在一个页面中有效
request.setAttribute(&quot;name2&quot;,&quot;2号&quot;); //保存的数据只在一次请求中有效，请求转发会携带这个数据
session.setAttribute(&quot;name3&quot;,&quot;3号&quot;); //保存的数据只在一次会话中有效，从打开浏览器到关闭浏览器
application.setAttribute(&quot;name4&quot;,&quot;4号&quot;);  //保存的数据只在服务器中有效，从打开服务器到关闭服务器
</code></pre>
<p>request：客户端向服务器发送请求，产生的数据，用户看完就没用了，比如：新闻，用户看完没用的！</p>
<p>session：客户端向服务器发送请求，产生的数据，用户用完一会还有用，比如：购物车；</p>
<p>application：客户端向服务器发送请求，产生的数据，一个用户用完了，其他用户还可能使用，比如：聊天数据；</p>
<h3 id="86-jsp标签-jstl标签-el表达式">8.6、JSP标签、JSTL标签、EL表达式</h3>
<pre><code class="language-xml">&lt;!-- JSTL表达式的依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet.jsp.jstl&lt;/groupId&gt;
    &lt;artifactId&gt;jstl-api&lt;/artifactId&gt;
    &lt;version&gt;1.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- standard标签库 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;taglibs&lt;/groupId&gt;
    &lt;artifactId&gt;standard&lt;/artifactId&gt;
    &lt;version&gt;1.1.2&lt;/version&gt;
&lt;/dependency&gt;

</code></pre>
<p>EL表达式：  ${ }</p>
<ul>
<li><strong>获取数据</strong></li>
<li><strong>执行运算</strong></li>
<li><strong>获取web开发的常用对象</strong></li>
</ul>
<p><strong>JSP标签</strong></p>
<pre><code class="language-jsp">&lt;%--jsp:include--%&gt;

&lt;%--
http://localhost:8080/jsptag.jsp?name=kuangshen&amp;age=12
--%&gt;

&lt;jsp:forward page=&quot;/jsptag2.jsp&quot;&gt;
    &lt;jsp:param name=&quot;name&quot; value=&quot;kuangshen&quot;&gt;&lt;/jsp:param&gt;
    &lt;jsp:param name=&quot;age&quot; value=&quot;12&quot;&gt;&lt;/jsp:param&gt;
&lt;/jsp:forward&gt;
</code></pre>
<p><strong>JSTL表达式</strong></p>
<p>JSTL标签库的使用就是为了弥补HTML标签的不足；它自定义许多标签，可以供我们使用，标签的功能和Java代码一样！</p>
<p><strong>格式化标签</strong></p>
<p><strong>SQL标签</strong></p>
<p><strong>XML 标签</strong></p>
<p><strong>核心标签</strong> （掌握部分）</p>
<figure data-type="image" tabindex="65"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613013014.png" alt="" loading="lazy"></figure>
<p><strong>JSTL标签库使用步骤</strong></p>
<ul>
<li>引入对应的 taglib</li>
<li>使用其中的方法</li>
<li><strong>在Tomcat 也需要引入 jstl的包，否则会报错：JSTL解析错误</strong></li>
</ul>
<p>c：if</p>
<pre><code class="language-jsp">&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;


&lt;h4&gt;if测试&lt;/h4&gt;

&lt;hr&gt;

&lt;form action=&quot;coreif.jsp&quot; method=&quot;get&quot;&gt;
    &lt;%--
    EL表达式获取表单中的数据
    ${param.参数名}
    --%&gt;
    &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;${param.username}&quot;&gt;
    &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;
&lt;/form&gt;

&lt;%--判断如果提交的用户名是管理员，则登录成功--%&gt;
&lt;c:if test=&quot;${param.username=='admin'}&quot; var=&quot;isAdmin&quot;&gt;
    &lt;c:out value=&quot;管理员欢迎您！&quot;/&gt;
&lt;/c:if&gt;

&lt;%--自闭合标签--%&gt;
&lt;c:out value=&quot;${isAdmin}&quot;/&gt;

&lt;/body&gt;
</code></pre>
<p>c:choose   c:when</p>
<pre><code class="language-jsp">&lt;body&gt;

&lt;%--定义一个变量score，值为85--%&gt;
&lt;c:set var=&quot;score&quot; value=&quot;55&quot;/&gt;

&lt;c:choose&gt;
    &lt;c:when test=&quot;${score&gt;=90}&quot;&gt;
        你的成绩为优秀
    &lt;/c:when&gt;
    &lt;c:when test=&quot;${score&gt;=80}&quot;&gt;
        你的成绩为一般
    &lt;/c:when&gt;
    &lt;c:when test=&quot;${score&gt;=70}&quot;&gt;
        你的成绩为良好
    &lt;/c:when&gt;
    &lt;c:when test=&quot;${score&lt;=60}&quot;&gt;
        你的成绩为不及格
    &lt;/c:when&gt;
&lt;/c:choose&gt;

&lt;/body&gt;
</code></pre>
<p>c:forEach</p>
<pre><code class="language-jsp">&lt;%

    ArrayList&lt;String&gt; people = new ArrayList&lt;&gt;();
    people.add(0,&quot;张三&quot;);
    people.add(1,&quot;李四&quot;);
    people.add(2,&quot;王五&quot;);
    people.add(3,&quot;赵六&quot;);
    people.add(4,&quot;田六&quot;);
    request.setAttribute(&quot;list&quot;,people);
%&gt;


&lt;%--
var , 每一次遍历出来的变量
items, 要遍历的对象
begin,   哪里开始
end,     到哪里
step,   步长
--%&gt;
&lt;c:forEach var=&quot;people&quot; items=&quot;${list}&quot;&gt;
    &lt;c:out value=&quot;${people}&quot;/&gt; &lt;br&gt;
&lt;/c:forEach&gt;

&lt;hr&gt;

&lt;c:forEach var=&quot;people&quot; items=&quot;${list}&quot; begin=&quot;1&quot; end=&quot;3&quot; step=&quot;1&quot; &gt;
    &lt;c:out value=&quot;${people}&quot;/&gt; &lt;br&gt;
&lt;/c:forEach&gt;

</code></pre>
<h2 id="9-javabean">9、JavaBean</h2>
<p>实体类</p>
<p>JavaBean有特定的写法：</p>
<ul>
<li>必须要有一个无参构造</li>
<li>属性必须私有化</li>
<li>必须有对应的get/set方法；</li>
</ul>
<p>一般用来和数据库的字段做映射  ORM；</p>
<p>ORM ：对象关系映射</p>
<ul>
<li>表---&gt;类</li>
<li>字段--&gt;属性</li>
<li>行记录----&gt;对象</li>
</ul>
<p><strong>people表</strong></p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>age</th>
<th>address</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1号</td>
<td>3</td>
<td>西安</td>
</tr>
<tr>
<td>2</td>
<td>2号</td>
<td>18</td>
<td>西安</td>
</tr>
<tr>
<td>3</td>
<td>3号</td>
<td>100</td>
<td>西安</td>
</tr>
</tbody>
</table>
<pre><code class="language-java">class People{
    private int id;
    private String name;
    private int id;
    private String address;
}

class A{
    new People(1,&quot;1号&quot;,3，&quot;西安&quot;);
    new People(2,&quot;2号&quot;,3，&quot;西安&quot;);
    new People(3,&quot;3号&quot;,3，&quot;西安&quot;);
}
</code></pre>
<ul>
<li>过滤器</li>
<li>文件上传</li>
<li>邮件发送</li>
<li>JDBC 复习 ： 如何使用JDBC ,  JDBC crud， jdbc 事务</li>
</ul>
<h2 id="10-mvc三层架构">10、MVC三层架构</h2>
<p>什么是MVC：  Model     view     Controller  模型、视图、控制器</p>
<h3 id="101-早些年">10.1、早些年</h3>
<figure data-type="image" tabindex="66"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613013052.png" alt="" loading="lazy"></figure>
<p>用户直接访问控制层，控制层就可以直接操作数据库；</p>
<pre><code class="language-java">servlet--CRUD--&gt;数据库
弊端：程序十分臃肿，不利于维护  
servlet的代码中：处理请求、响应、视图跳转、处理JDBC、处理业务代码、处理逻辑代码

架构：没有什么是加一层解决不了的！
程序猿调用
|
JDBC
|
Mysql Oracle SqlServer ....
</code></pre>
<h3 id="102-mvc三层架构">10.2、MVC三层架构</h3>
<figure data-type="image" tabindex="67"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613013122.png" alt="" loading="lazy"></figure>
<p>Model</p>
<ul>
<li>业务处理 ：业务逻辑（Service）</li>
<li>数据持久层：CRUD   （Dao）</li>
</ul>
<p>View</p>
<ul>
<li>展示数据</li>
<li>提供链接发起Servlet请求 （a，form，img…）</li>
</ul>
<p>Controller  （Servlet）</p>
<ul>
<li>
<p>接收用户的请求 ：（req：请求参数、Session信息….）</p>
</li>
<li>
<p>交给业务层处理对应的代码</p>
</li>
<li>
<p>控制视图的跳转</p>
<pre><code class="language-java">登录---&gt;接收用户的登录请求---&gt;处理用户的请求（获取用户登录的参数，username，password）----&gt;交给业务层处理登录业务（判断用户名密码是否正确：事务）---&gt;Dao层查询用户名和密码是否正确--&gt;数据库
</code></pre>
</li>
</ul>
<h2 id="11-filter-重点">11、Filter （重点）</h2>
<p>Filter：过滤器 ，用来过滤网站的数据；</p>
<ul>
<li>处理中文乱码</li>
<li>登录验证….</li>
</ul>
<figure data-type="image" tabindex="68"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613013144.png" alt="" loading="lazy"></figure>
<p>Filter开发步骤：</p>
<ol>
<li>
<p>导包</p>
</li>
<li>
<p>编写过滤器</p>
<ol>
<li>
<p>导包不要错</p>
<figure data-type="image" tabindex="69"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613013158.png" alt="" loading="lazy"></figure>
<p>实现Filter接口，重写对应的方法即可</p>
<pre><code class="language-java">public class CharacterEncodingFilter implements Filter {

    //初始化：web服务器启动，就以及初始化了，随时等待过滤对象出现！
    public void init(FilterConfig filterConfig) throws ServletException {
        System.out.println(&quot;CharacterEncodingFilter初始化&quot;);
    }

    //Chain : 链
    /*
    1. 过滤中的所有代码，在过滤特定请求的时候都会执行
    2. 必须要让过滤器继续同行
        chain.doFilter(request,response);
     */
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        request.setCharacterEncoding(&quot;utf-8&quot;);
        response.setCharacterEncoding(&quot;utf-8&quot;);
        response.setContentType(&quot;text/html;charset=UTF-8&quot;);

        System.out.println(&quot;CharacterEncodingFilter执行前....&quot;);
        chain.doFilter(request,response); //让我们的请求继续走，如果不写，程序到这里就被拦截停止！
        System.out.println(&quot;CharacterEncodingFilter执行后....&quot;);
    }

    //销毁：web服务器关闭的时候，过滤会销毁
    public void destroy() {
        System.out.println(&quot;CharacterEncodingFilter销毁&quot;);
    }
}

</code></pre>
</li>
</ol>
</li>
<li>
<p>在web.xml中配置 Filter</p>
<pre><code class="language-xml">&lt;filter&gt;
    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;com.cy.filter.CharacterEncodingFilter&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
    &lt;!--只要是 /servlet的任何请求，会经过这个过滤器--&gt;
    &lt;url-pattern&gt;/servlet/*&lt;/url-pattern&gt;
    &lt;!--&lt;url-pattern&gt;/*&lt;/url-pattern&gt;--&gt;
&lt;/filter-mapping&gt;
</code></pre>
</li>
</ol>
<h2 id="12-监听器">12、监听器</h2>
<p>实现一个监听器的接口；（有N种）</p>
<ol>
<li>
<p>编写一个监听器</p>
<p>实现监听器的接口…</p>
<pre><code class="language-java">//统计网站在线人数 ： 统计session
public class OnlineCountListener implements HttpSessionListener {

    //创建session监听： 看你的一举一动
    //一旦创建Session就会触发一次这个事件！
    public void sessionCreated(HttpSessionEvent se) {
        ServletContext ctx = se.getSession().getServletContext();

        System.out.println(se.getSession().getId());

        Integer onlineCount = (Integer) ctx.getAttribute(&quot;OnlineCount&quot;);

        if (onlineCount==null){
            onlineCount = new Integer(1);
        }else {
            int count = onlineCount.intValue();
            onlineCount = new Integer(count+1);
        }

        ctx.setAttribute(&quot;OnlineCount&quot;,onlineCount);

    }

    //销毁session监听
    //一旦销毁Session就会触发一次这个事件！
    public void sessionDestroyed(HttpSessionEvent se) {
        ServletContext ctx = se.getSession().getServletContext();

        Integer onlineCount = (Integer) ctx.getAttribute(&quot;OnlineCount&quot;);

        if (onlineCount==null){
            onlineCount = new Integer(0);
        }else {
            int count = onlineCount.intValue();
            onlineCount = new Integer(count-1);
        }

        ctx.setAttribute(&quot;OnlineCount&quot;,onlineCount);

    }


    /*
    Session销毁：
    1. 手动销毁  getSession().invalidate();
    2. 自动销毁
     */
}

</code></pre>
</li>
<li>
<p>web.xml中注册监听器</p>
<pre><code class="language-xml">&lt;!--注册监听器--&gt;
&lt;listener&gt;
    &lt;listener-class&gt;com.kuang.listener.OnlineCountListener&lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre>
</li>
<li>
<p>看情况是否使用！</p>
</li>
</ol>
<h2 id="13-过滤器-监听器常见应用">13、过滤器、监听器常见应用</h2>
<p><strong>监听器：GUI编程中经常使用；</strong></p>
<pre><code class="language-java">public class TestPanel {
    public static void main(String[] args) {
        Frame frame = new Frame(&quot;中秋节快乐&quot;);  //新建一个窗体
        Panel panel = new Panel(null); //面板
        frame.setLayout(null); //设置窗体的布局

        frame.setBounds(300,300,500,500);
        frame.setBackground(new Color(0,0,255)); //设置背景颜色

        panel.setBounds(50,50,300,300);
        panel.setBackground(new Color(0,255,0)); //设置背景颜色

        frame.add(panel);

        frame.setVisible(true);

        //监听事件，监听关闭事件
        frame.addWindowListener(new WindowAdapter() {
            @Override
            public void windowClosing(WindowEvent e) {
                super.windowClosing(e);
            }
        });


    }
}
</code></pre>
<p>用户登录之后才能进入主页！用户注销后就不能进入主页了！</p>
<ol>
<li>
<p>用户登录之后，向Sesison中放入用户的数据</p>
</li>
<li>
<p>进入主页的时候要判断用户是否已经登录；要求：在过滤器中实现！</p>
<pre><code class="language-java">HttpServletRequest request = (HttpServletRequest) req;
HttpServletResponse response = (HttpServletResponse) resp;

if (request.getSession().getAttribute(Constant.USER_SESSION)==null){
    response.sendRedirect(&quot;/error.jsp&quot;);
}

chain.doFilter(request,response);
</code></pre>
</li>
</ol>
<h2 id="14-jdbc">14、JDBC</h2>
<p>什么是JDBC ： Java连接数据库！</p>
<figure data-type="image" tabindex="70"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613013240.png" alt="" loading="lazy"></figure>
<p>需要jar包的支持：</p>
<ul>
<li>java.sql</li>
<li>javax.sql</li>
<li>mysql-conneter-java…  连接驱动（必须要导入）</li>
</ul>
<p><strong>实验环境搭建</strong></p>
<pre><code class="language-sql">
CREATE TABLE users(
    id INT PRIMARY KEY,
    `name` VARCHAR(40),
    `password` VARCHAR(40),
    email VARCHAR(60),
    birthday DATE
);

INSERT INTO users(id,`name`,`password`,email,birthday)
VALUES(1,'张三','123456','zs@qq.com','2000-01-01');
INSERT INTO users(id,`name`,`password`,email,birthday)
VALUES(2,'李四','123456','ls@qq.com','2000-01-01');
INSERT INTO users(id,`name`,`password`,email,birthday)
VALUES(3,'王五','123456','ww@qq.com','2000-01-01');


SELECT	* FROM users;

</code></pre>
<p>导入数据库依赖</p>
<pre><code class="language-xml">&lt;!--mysql的驱动--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;version&gt;5.1.47&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>IDEA中连接数据库：</p>
<figure data-type="image" tabindex="71"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613013255.png" alt="" loading="lazy"></figure>
<p><strong>JDBC 固定步骤：</strong></p>
<ol>
<li>加载驱动</li>
<li>连接数据库,代表数据库</li>
<li>向数据库发送SQL的对象Statement : CRUD</li>
<li>编写SQL （根据业务，不同的SQL）</li>
<li>执行SQL</li>
<li>关闭连接</li>
</ol>
<pre><code class="language-java">public class TestJdbc {
    public static void main(String[] args) throws ClassNotFoundException, SQLException {
        //配置信息
        //useUnicode=true&amp;characterEncoding=utf-8 解决中文乱码
        String url=&quot;jdbc:mysql://localhost:3306/jdbc?useUnicode=true&amp;characterEncoding=utf-8&quot;;
        String username = &quot;root&quot;;
        String password = &quot;123456&quot;;

        //1.加载驱动
        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
        //2.连接数据库,代表数据库
        Connection connection = DriverManager.getConnection(url, username, password);

        //3.向数据库发送SQL的对象Statement,PreparedStatement : CRUD
        Statement statement = connection.createStatement();

        //4.编写SQL
        String sql = &quot;select * from users&quot;;

        //5.执行查询SQL，返回一个 ResultSet  ： 结果集
        ResultSet rs = statement.executeQuery(sql);

        while (rs.next()){
            System.out.println(&quot;id=&quot;+rs.getObject(&quot;id&quot;));
            System.out.println(&quot;name=&quot;+rs.getObject(&quot;name&quot;));
            System.out.println(&quot;password=&quot;+rs.getObject(&quot;password&quot;));
            System.out.println(&quot;email=&quot;+rs.getObject(&quot;email&quot;));
            System.out.println(&quot;birthday=&quot;+rs.getObject(&quot;birthday&quot;));
        }

        //6.关闭连接，释放资源（一定要做） 先开后关
        rs.close();
        statement.close();
        connection.close();
    }
}

</code></pre>
<p><strong>预编译SQL</strong></p>
<pre><code class="language-java">public class TestJDBC2 {
    public static void main(String[] args) throws Exception {
        //配置信息
        //useUnicode=true&amp;characterEncoding=utf-8 解决中文乱码
        String url=&quot;jdbc:mysql://localhost:3306/jdbc?useUnicode=true&amp;characterEncoding=utf-8&quot;;
        String username = &quot;root&quot;;
        String password = &quot;123456&quot;;

        //1.加载驱动
        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
        //2.连接数据库,代表数据库
        Connection connection = DriverManager.getConnection(url, username, password);

        //3.编写SQL
        String sql = &quot;insert into  users(id, name, password, email, birthday) values (?,?,?,?,?);&quot;;

        //4.预编译
        PreparedStatement preparedStatement = connection.prepareStatement(sql);

        preparedStatement.setInt(1,2);//给第一个占位符？ 的值赋值为1；
        preparedStatement.setString(2,&quot;Java&quot;);//给第二个占位符？ 的值赋值为狂神说Java；
        preparedStatement.setString(3,&quot;123456&quot;);//给第三个占位符？ 的值赋值为123456；
        preparedStatement.setString(4,&quot;24736743@qq.com&quot;);//给第四个占位符？ 的值赋值为1；
        preparedStatement.setDate(5,new Date(new java.util.Date().getTime()));//给第五个占位符？ 的值赋值为new Date(new java.util.Date().getTime())；

        //5.执行SQL
        int i = preparedStatement.executeUpdate();

        if (i&gt;0){
            System.out.println(&quot;插入成功@&quot;);
        }

        //6.关闭连接，释放资源（一定要做） 先开后关
        preparedStatement.close();
        connection.close();
    }
}

</code></pre>
<p><strong>事务</strong></p>
<p>要么都成功，要么都失败！</p>
<p>ACID原则：保证数据的安全。</p>
<pre><code class="language-java">开启事务
事务提交  commit()
事务回滚  rollback()
关闭事务

转账：
A:1000
B:1000
    
A(900)   --100--&gt;   B(1100) 
</code></pre>
<p><strong>Junit单元测试</strong></p>
<p>依赖</p>
<pre><code class="language-xml">&lt;!--单元测试--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;junit&lt;/groupId&gt;
    &lt;artifactId&gt;junit&lt;/artifactId&gt;
    &lt;version&gt;4.12&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>简单使用</p>
<p>@Test注解只有在方法上有效，只要加了这个注解的方法，就可以直接运行！</p>
<pre><code class="language-java">@Test
public void test(){
    System.out.println(&quot;Hello&quot;);
}
</code></pre>
<figure data-type="image" tabindex="72"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613013348.png" alt="" loading="lazy"></figure>
<p>失败的时候是红色：</p>
<figure data-type="image" tabindex="73"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200613013404.png" alt="" loading="lazy"></figure>
<p><strong>搭建一个环境</strong></p>
<pre><code class="language-sql">CREATE TABLE account(
   id INT PRIMARY KEY AUTO_INCREMENT,
   `name` VARCHAR(40),
   money FLOAT
);

INSERT INTO account(`name`,money) VALUES('A',1000);
INSERT INTO account(`name`,money) VALUES('B',1000);
INSERT INTO account(`name`,money) VALUES('C',1000);
</code></pre>
<pre><code class="language-java">    @Test
    public void test() {
        //配置信息
        //useUnicode=true&amp;characterEncoding=utf-8 解决中文乱码
        String url=&quot;jdbc:mysql://localhost:3306/jdbc?useUnicode=true&amp;characterEncoding=utf-8&quot;;
        String username = &quot;root&quot;;
        String password = &quot;123456&quot;;

        Connection connection = null;

        //1.加载驱动
        try {
            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
            //2.连接数据库,代表数据库
             connection = DriverManager.getConnection(url, username, password);

            //3.通知数据库开启事务,false 开启
            connection.setAutoCommit(false);

            String sql = &quot;update account set money = money-100 where name = 'A'&quot;;
            connection.prepareStatement(sql).executeUpdate();

            //制造错误
            //int i = 1/0;

            String sql2 = &quot;update account set money = money+100 where name = 'B'&quot;;
            connection.prepareStatement(sql2).executeUpdate();

            connection.commit();//以上两条SQL都执行成功了，就提交事务！
            System.out.println(&quot;success&quot;);
        } catch (Exception e) {
            try {
                //如果出现异常，就通知数据库回滚事务
                connection.rollback();
            } catch (SQLException e1) {
                e1.printStackTrace();
            }
            e.printStackTrace();
        }finally {
            try {
                connection.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Intellij IDEA常用快捷键]]></title>
        <id>https://jonchan1013.github.io/post/intellij-idea-chang-yong-kuai-jie-jian/</id>
        <link href="https://jonchan1013.github.io/post/intellij-idea-chang-yong-kuai-jie-jian/">
        </link>
        <updated>2019-01-03T07:17:39.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="️最常用快捷键">✍️最常用快捷键</h3>
<ol>
<li>Alt+回车 导入包,自动修正</li>
<li>Ctrl+N  查找类</li>
</ol>
]]></summary>
        <content type="html"><![CDATA[<h3 id="️最常用快捷键">✍️最常用快捷键</h3>
<ol>
<li>Alt+回车 导入包,自动修正</li>
<li>Ctrl+N  查找类<!-- more -->
</li>
<li>Ctrl+Shift+N 查找文件</li>
<li>Ctrl+Alt+L  格式化代码</li>
<li>Ctrl+Alt+O 优化导入的类和包</li>
<li>Alt+Insert 生成代码(如get,set方法,构造函数等)</li>
<li>Ctrl+E或者Alt+Shift+C  最近更改的代码</li>
<li>Ctrl+R 替换文本</li>
<li>Ctrl+F 查找文本</li>
<li>Ctrl+Shift+Space 自动补全代码</li>
<li>Ctrl+空格 代码提示</li>
<li>Ctrl+Alt+Space 类名或接口名提示</li>
<li>Ctrl+P 方法参数提示</li>
<li>Ctrl+Shift+Alt+N 查找类中的方法或变量</li>
<li>Alt+Shift+C 对比最近修改的代码</li>
<li>Shift+F6  重构-重命名</li>
<li>Ctrl+Shift+先上键</li>
<li>Ctrl+X 删除行</li>
<li>Ctrl+D 复制行</li>
<li>Ctrl+/ 或 Ctrl+Shift+/  注释（// 或者/<em>...</em>/ ）</li>
<li>Ctrl+J  自动代码</li>
<li>Ctrl+E 最近打开的文件</li>
<li>Ctrl+H 显示类结构图</li>
<li>Ctrl+Q 显示注释文档</li>
<li>Alt+F1 查找代码所在位置</li>
<li>Alt+1 快速打开或隐藏工程面板</li>
<li>Ctrl+Alt+ left/right 返回至上次浏览的位置</li>
<li>Alt+ left/right 切换代码视图</li>
<li>Alt+ Up/Down 在方法间快速移动定位</li>
<li>Ctrl+Shift+Up/Down 代码向上/下移动。</li>
<li>F2 或Shift+F2 高亮错误或警告快速定位</li>
<li>代码标签输入完成后，按Tab，生成代码。</li>
<li>选中文本，按Ctrl+Shift+F7 ，高亮显示所有该文本，按Esc高亮消失。</li>
<li>Ctrl+W 选中代码，连续按会有其他效果</li>
<li>选中文本，按Alt+F3 ，逐个往下查找相同文本，并高亮显示。</li>
<li>Ctrl+Up/Down 光标跳转到第一行或最后一行下</li>
<li>Ctrl+B 快速打开光标处的类或方法</li>
<li>Ctrl＋E，可以显示最近编辑的文件列表</li>
<li>Shift＋Click可以关闭文件</li>
<li>Ctrl＋[或]可以跳到大括号的开头结尾</li>
<li>Ctrl＋Shift＋Backspace可以跳转到上次编辑的地方</li>
<li>Ctrl＋F12，可以显示当前文件的结构</li>
<li>Ctrl＋F7可以查询当前元素在当前文件中的引用，然后按F3可以选择</li>
<li>Ctrl＋Shift＋N，可以快速打开文件</li>
<li>Alt＋Q可以看到当前方法的声明</li>
<li>Ctrl＋W可以选择单词继而语句继而行继而函数</li>
<li>Alt＋F1可以将正在编辑的元素在各个面板中定位</li>
<li>Ctrl＋Shift＋Insert可以选择剪贴板内容并插入</li>
<li>Alt＋Insert可以生成构造器/Getter/Setter等</li>
<li>Ctrl＋Alt＋V 可以引入变量。例如把括号内的SQL赋成一个变量</li>
<li>Ctrl＋Alt＋T可以把代码包在一块内，例如try/catch</li>
<li>Alt＋Up and Alt＋Down可在方法间快速移动</li>
</ol>
<p>👨‍💻👨‍💻👨‍💻👨‍💻👨‍💻</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java环境变量配置]]></title>
        <id>https://jonchan1013.github.io/post/java-ji-chu/</id>
        <link href="https://jonchan1013.github.io/post/java-ji-chu/">
        </link>
        <updated>2018-02-05T01:04:05.000Z</updated>
        <summary type="html"><![CDATA[<p>✍️学习java的第一步就要搭建java的学习环境，首先是要安装JDK，JDK安装好之后，还需要在电脑上配置&quot;JAVA_HOME”、&quot;path”、&quot;classpath&quot;这三个环境变量才能够把java的开发环境搭建好。在没安装过jdk的环境下，path环境变量是系统变量，本来存在的，而JAVA_HOME和classpath是不存在的。</p>
]]></summary>
        <content type="html"><![CDATA[<p>✍️学习java的第一步就要搭建java的学习环境，首先是要安装JDK，JDK安装好之后，还需要在电脑上配置&quot;JAVA_HOME”、&quot;path”、&quot;classpath&quot;这三个环境变量才能够把java的开发环境搭建好。在没安装过jdk的环境下，path环境变量是系统变量，本来存在的，而JAVA_HOME和classpath是不存在的。</p>
<!-- more -->
<ol>
<li>
<p>配置JAVA_HOME变量<br>
操作步骤：计算机→右键“属性”→高级系统设置→高级→环境变量，如下图所示：<br>
<img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610095005.png" alt="" loading="lazy"><br>
<img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610095133.png" alt="" loading="lazy"><br>
<img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610095235.png" alt="" loading="lazy"><br>
点击系统变量下面的“【新建】”，弹出一个新建系统变量对话框，首先在变量名写上JAVA_HOME，顾名思义，JAVA_HOME的含义就是JDK的安装路径，，然后在变量值写JDK的安装路径，如这里设置的变量值是&quot;C:\Program Files (x86)\Java\jdk1.8.0&quot;，设置好变量值之后，点击【确定】按钮，JAVA_HOME环境变量就设置完成，如下图所示：系统变量中多了一个&quot;JAVA_HOME&quot;变量</p>
</li>
<li>
<p>配置path环境变量<br>
操作步骤：计算机→右键“属性”→高级系统设置→高级→环境变量<br>
找到系统变量中的Path变量，点击【编辑】按钮，弹出编辑系统变量的对话框，可以看到，Path变量中设置有很多的目录，每个目录之间使用;(分号)隔开,将%JAVA_HOME%\bin;添加到Path变量的变量值中，点击【确定】按钮，Path环境变量的就设置完成了，如下图所示：<br>
<img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610095552.png" alt="" loading="lazy"></p>
</li>
<li>
<p>配置ClassPath变量<br>
设置Classpath的目的，在于告诉Java执行环境，在哪些目录下可以找到您所要执行的Java程序(.class文件)，关于这个ClassPath变量，其实可以不用配置了<br>
<img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610095445.png" alt="" loading="lazy"></p>
</li>
<li>
<p>JAVA_HOME变量、Path变量、ClassPath变量的说明</p>
<ol>
<li>设置JAVA_HOME变量的目的
<ol>
<li>为了方便引用，比如，JDK安装在C:\Program Files (x86)\Java\jdk1.8.0目录里，则设置JAVA_HOME为该目录路径, 那么以后要使用这个路径的时候, 只需输入%JAVA_HOME%即可, 避免每次引用都输入很长的路径串;</li>
<li>归一原则, 当JDK路径被迫改变的时候, 仅需更改JAVA_HOME的变量值即可。</li>
<li>第三方软件会引用约定好的JAVA_HOME变量, 典型的就是tomcat服务器，如果不配置JAVA_HOME变量，那么tomcat服务器根本运行不起来</li>
</ol>
</li>
<li>Path变量(重点说明)<br>
操作系统用path的路径来找可执行程序(.exe程序)，在windows下当我们敲任何一个命令时，实际上就是在执行一个可执行文件，如输入notepad命令就可以打开一个记事本<br>
<img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610100042.png" alt="" loading="lazy"><br>
实际上是执行了c:\Windows下的notepad.exe这个可执行文件，和用鼠标双击notepad.exe后能够打开一个记事本的效果是一样的<br>
<img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610100137.png" alt="" loading="lazy"><br>
当在命令窗口敲一个命令时，系统就会去自动寻找这个命令对应的可执行文件(.exe)，如果这个文件不存在，就当然无法执行这个命令了。这个可执行文件的根目录必须设置在path环境变量中。</li>
<li>在命令窗口显示path设置的环境变量<br>
直接输入“echo %path%”命令就可以显示设置的path环境变量的所有根目录了，只要是根目录里面存在相应的.exe文件，敲入命令时就能执行这个相应的.exe文件。因为notepad.exe所在的Windows目录已经添加到了Path环境变量中了，这就解释了为什么输入命令notepad就可以打开一个记事本，所以前面配置java开发环境时，将%JAVA_HOME%\bin添加到Path变量中的目的就是希望可以在命令行窗口下使用javac和java这两个命令来执行javac.exe和java.exe这两个可执行程序。</li>
<li>Classpath变量说明<br>
使用javac命令编译.java文件时，如果需要其他的类，也是通过classpath去找的，<br>
　　使用java命令执行.class文件时，执行的.class文件是通过classpath去找的。<br>
　　classpath表示的是要查找的类所在的路径。</li>
</ol>
</li>
<li>
<p>用户变量和系统变量的区别<br>
用户变量，顾名思义，是针对某一个特定的用户的，只对特定的用户有效，而系统变量，则对任何用户都有效。</p>
</li>
</ol>
]]></content>
    </entry>
</feed>