<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jonchan1013.github.io</id>
    <title>CY的学习博客</title>
    <updated>2020-06-11T13:17:44.642Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jonchan1013.github.io"/>
    <link rel="self" href="https://jonchan1013.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://jonchan1013.github.io/images/avatar.png</logo>
    <icon>https://jonchan1013.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, CY的学习博客</rights>
    <entry>
        <title type="html"><![CDATA[jQuery]]></title>
        <id>https://jonchan1013.github.io/post/jquery/</id>
        <link href="https://jonchan1013.github.io/post/jquery/">
        </link>
        <updated>2020-06-11T01:32:04.000Z</updated>
        <summary type="html"><![CDATA[<p>✍️ jQuery 是一个 JavaScript 库。 jQuery 极大地简化了 JavaScript 编程......</p>
]]></summary>
        <content type="html"><![CDATA[<p>✍️ jQuery 是一个 JavaScript 库。 jQuery 极大地简化了 JavaScript 编程......</p>
<!-- more -->
<h2 id="1-jquery的概述">1、jQuery的概述</h2>
<h3 id="11-为什么要用jquery">1.1 为什么要用jquery</h3>
<ul>
<li>选择器功能弱</li>
<li>DOM操作繁琐之极</li>
<li>浏览器兼容性不好</li>
<li>动画效果弱</li>
</ul>
<h3 id="12-什么是-jquery概念">1.2 什么是 jQuery(概念)</h3>
<p>​	jQuery （javaScriptQuery）JavaScript 代码库</p>
<p>js.js:</p>
<pre><code class="language-js">function $(id){
    var dom = document.getElementById(id);
    return dom;
}
</code></pre>
<p>jq的含义.html:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;utf-8&quot;&gt;
		&lt;title&gt;&lt;/title&gt;
		
		&lt;!--[1]引入js文件--&gt;
		
		&lt;script src=&quot;js/js.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
		
		&lt;script&gt;
			
			//js获得元素对象的方式
			var  div =document.getElementById(&quot;div1&quot;);
			
			//JQ获得元素的方式
			var  div2=$(&quot;div1&quot;);
			
		&lt;/script&gt;	
		
	&lt;/head&gt;
	&lt;body&gt;
		
		&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;
		
	&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="13-目前-jquery-有三个大版本">1.3 目前 jQuery 有三个大版本：</h3>
<ul>
<li>
<p>1.x：兼容ie678,使用最为广泛的，官方只做BUG维护，功能不再新增。因此一般项目来说，使用1.x版本就可以了，最终版本：1.12.4 (2016年5月20日)</p>
</li>
<li>
<p>2.x：不兼容ie678，很少有人使用，官方只做BUG维护，功<br>
能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x，最终版本：2.2.4 (2016年5月20日)</p>
</li>
<li>
<p>3.x：不兼容 ie678，只支持最新的浏览器。除非特殊要求一般不会使用 3.x 版本的，很多老的 jQuery 插件不支持这个版本。目前该版本是官方主要更新维护的版本。最新版本：3.4.1</p>
</li>
</ul>
<h2 id="2-jquery-中的含义">2、jQuery 中$的含义</h2>
<p>引入jQuery：</p>
<script src="js/jquery-1.9.1.js" type="text/javascript" charset="utf-8"></script>
<p>js的方式实现隔行变色的效果：</p>
<pre><code class="language-html">window.onload=function(){	  	 	
		  	 	//获得所有的tr对象  	 	
  	 	var  tr =document.getElementsByTagName(&quot;tr&quot;);
		  	 	
	 	 	for(var i =0;i&lt;tr.length;i++){ 		
  	 		 if(i%2==0){
  	 		 	tr[i].style.backgroundColor=&quot;red&quot;;	  	 		 	
		  		 }else { 	 		 	
		  		 	tr[i].style.backgroundColor=&quot;green&quot;;
	 	 		 }		  	 				  	 		
  	 	} 	 	
  	 }
</code></pre>
<p>jQuery实现隔行变色的效果：</p>
<pre><code class="language-javascript">$(function(){	
	 	  $(&quot;tr:odd&quot;).css(&quot;background-color&quot;,&quot;red&quot;);
 })
</code></pre>
<h3 id="21-作用-1function">2.1 作用 1：$(function)</h3>
<ul>
<li>相当于 window.onload=function(){}</li>
<li>功能比window.onload更强大
<ol>
<li>window onload一个页面只能写一个,但是可以写多个$() 而不冲突</li>
<li>window onload要等整个页面加载完后再执行（包括图片、超链接、音视频等），但是$的执行时间要早</li>
</ol>
</li>
<li>3.完整形式是$(document).ready(…….);</li>
</ul>
<h3 id="22-作用-2selector">2.2. 作用 2：$(selector)</h3>
<ul>
<li>选择器<br>
jQuery具有强大的选择器功能</li>
</ul>
<h2 id="3-基本选择器一">3、基本选择器（一）</h2>
<h3 id="31-对象之间的转换">3.1 对象之间的转换</h3>
<ul>
<li>DOM对象：直接使用JavaScript获取的节点对象
<ul>
<li>className  innerHTML  value</li>
</ul>
</li>
<li>jQuery对象：使用jQuery选择器获取的节点对象，它能够使用jQuery中的方法
<ul>
<li>addClass()  html()  val()</li>
</ul>
</li>
<li>DOM对象和jQuery对象分别拥有一套独立的方法，不能混用</li>
<li>DOM对象转换成jQuery对象
<ul>
<li>$(DOM对象)</li>
</ul>
</li>
<li>jQuery对象转换成DOM对象
<ul>
<li>jQuery对象[index]</li>
<li>jQuery对象.get(index)</li>
</ul>
</li>
</ul>
<h3 id="32-基本选择器">3.2 基本选择器</h3>
<ul>
<li>标签选择器 $(“a”)</li>
<li>ID选择器 $(“#id”)    $(“p#id”)</li>
<li>类选择器 $(“.class”)    $(“h2.class”)    通配选择器 $(&quot;*&quot;)</li>
</ul>
<pre><code class="language-html">&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;utf-8&quot;&gt;
		&lt;title&gt;&lt;/title&gt;
		
		&lt;script src=&quot;js/jquery-1.9.1.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
		
		&lt;script type=&quot;text/javascript&quot;&gt;
			   $(function(){		   	
			   	//js获得元素对象
			    var  zh =document.getElementById(&quot;zh&quot;);
			    //Element
			    // JS----JQ对象
			    var  zhh=$(zh);
			    alert(zh);
			    
			    //JQ获得元素的对象  *ID选择器
			    var  zh1=$(&quot;#zh&quot;);
			    //Object---[Element1,Element2,Element3]
			    //JQ----JS对象
			    alert(zh1[0]);
			    
			    //*元素选择器
			    var inp =$(&quot;input&quot;);
			    
			    alert(inp.length);

                //*类选择器
                
                var inp2=$(&quot;.inp&quot;);
                //jq先转成js再获取内容
              alert(inp2[0].value);
                //  jq获得内容操作
			    alert(inp2.eq(0).val());

                //通用选择器
                
                $(&quot;*&quot;).css(&quot;background-color&quot;,&quot;greenyellow&quot;);
                
			    //分组选择器
			   })
		
		&lt;/script&gt;
	
	&lt;/head&gt;
	&lt;body&gt;	
		&lt;p&gt;		
			账号: &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;zh&quot; value=&quot;123&quot; /&gt;		
		&lt;/p&gt;		
		&lt;p&gt;
			密码: &lt;input type=&quot;password&quot; name=&quot;&quot; id=&quot;pwd&quot; value=&quot;12366&quot;  class=&quot;inp&quot;/&gt;			
		&lt;/p&gt;
		&lt;p&gt;
			 确认密码： &lt;input type=&quot;password&quot; name=&quot;&quot; id=&quot;pwd2&quot; value=&quot;123&quot; class=&quot;inp&quot;/&gt;		
		&lt;/p&gt;	
	&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<h2 id="4-层级选择器">4、层级选择器</h2>
<ul>
<li>并集选择器$(&quot;elem1,elem2,elem3&quot;)</li>
<li>后代选择器$(ul li)</li>
<li>父子选择器 $(ul&gt;li)</li>
<li>后面第一个兄弟元素 prev + next
<ul>
<li>后面所有的兄弟元素 prev ~ next</li>
</ul>
</li>
</ul>
<pre><code class="language-html">&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;utf-8&quot;&gt;
		&lt;title&gt;&lt;/title&gt;
		&lt;style&gt;			
			div{				
				height: 200px;				
				border:  3px solid  red;				
			}
		&lt;/style&gt;
		
		&lt;script src=&quot;js/jquery-1.9.1.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
		
		&lt;script type=&quot;text/javascript&quot;&gt;
			
			   $(function(){
			   	
			   	   //  div下面包含的所有span标签
			   	   $(&quot;div span&quot;).css(&quot;background-color&quot;,&quot;red&quot;);
			   	  // div下面的直系子元素
			   	   $(&quot;div&gt;span&quot;).css(&quot;background-color&quot;,&quot;green&quot;);

                  //  紧接着的span标签
                 $(&quot;#sp1 + span&quot;).css(&quot;background-color&quot;,&quot;red&quot;);
                    
                    //获得指定元素后面同级的span标签
                   $(&quot;#sp1~span&quot;).css(&quot;background-color&quot;,&quot;aqua&quot;); 
			   	
			   })		
		&lt;/script&gt;		
	&lt;/head&gt;
	&lt;body&gt;		
	   &lt;div&gt;	   	 
	   	 &lt;span id=&quot;sp1&quot;&gt;你好&lt;/span&gt;
	   	 
	   	 &lt;span&gt;你好&lt;/span&gt;&lt;br /&gt;
	   	 
	   	 &lt;span&gt;你好&lt;/span&gt;&lt;br /&gt;
	   	 
	   	 &lt;p&gt;
	   	 	&lt;span&gt;你好&lt;/span&gt;&lt;br /&gt;
	   	 
	   	    &lt;span&gt;你好&lt;/span&gt;&lt;br /&gt;
	   	 
	   	    &lt;span&gt;你好&lt;/span&gt;&lt;br /&gt;
	   	 		   	 	
	   	 &lt;/p&gt;	   	
	   &lt;/div&gt;		
	&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<h2 id="5-基本选择器二">5、基本选择器（二)</h2>
<pre><code class="language-html">&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;utf-8&quot;&gt;
		&lt;title&gt;&lt;/title&gt;
		&lt;style&gt;
			div{
				
				height: 200px;
				
				border:  3px solid red;
				
			}
		&lt;/style&gt;
		&lt;script src=&quot;js/jquery-1.9.1.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
		
		&lt;script type=&quot;text/javascript&quot;&gt;
			
			  $(function(){
			  	    //只是第一行变颜色
			  	   $(&quot;ul li:first&quot;).css(&quot;background-color&quot;,&quot;red&quot;);
			  	   $(&quot;ul li&quot;).first().css(&quot;background-color&quot;,&quot;red&quot;);
			  	   
			  	   //最后一行变颜色
			  	   $(&quot;ul li:last&quot;).css(&quot;background-color&quot;,&quot;green&quot;);
			  	   $(&quot;ul li&quot;).last().css(&quot;background-color&quot;,&quot;green&quot;);
                   //获得索引是奇数对象  索引从0开始
             	  $(&quot;ul li:odd&quot;).css(&quot;background-color&quot;,&quot;green&quot;);
					//获得索引是偶数对象  索引从0开始
                  $(&quot;ul li:even&quot;).css(&quot;background-color&quot;,&quot;green&quot;);
			  	   //获得索引下标位3的对象
			   	  $(&quot;ul li:eq(3)&quot;).css(&quot;background-color&quot;,&quot;green&quot;);
                    //获得大于指定索引下标的对象
                  $(&quot;ul li:gt(3)&quot;).css(&quot;background-color&quot;,&quot;green&quot;);
			  	    //获得小于指定索引下标的对象
			  	   $(&quot;ul li:lt(3)&quot;).css(&quot;background-color&quot;,&quot;green&quot;);

                   /**********子选择器*************************/
                  
                  
             	 $(&quot;ul li:nth-child(1)&quot;).css(&quot;background-color&quot;,&quot;green&quot;);
                    
                 $(&quot;ul li:first-child&quot;).css(&quot;background-color&quot;,&quot;darkred&quot;);
                    
                 $(&quot;ul li:last-child&quot;).css(&quot;background-color&quot;,&quot;darkred&quot;);  
                  
                 $(&quot;ul li:only-child&quot;).css(&quot;background-color&quot;,&quot;#00A40C&quot;);
			  })		
		&lt;/script&gt;
				
	&lt;/head&gt;
	&lt;body&gt;		
		&lt;div&gt;		
			&lt;ul&gt;
				&lt;li&gt;List  Item1&lt;/li&gt;
				&lt;li&gt;List  Item2&lt;/li&gt;
				&lt;li&gt;List  Item3&lt;/li&gt;
				&lt;li&gt;List  Item4&lt;/li&gt;
			&lt;/ul&gt;	
            
			&lt;ul&gt;
				&lt;li&gt;List  Item1&lt;/li&gt;
			&lt;/ul&gt;						
		&lt;/div&gt;	
	&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<h2 id="6-属性选择器">6、属性选择器</h2>
<pre><code class="language-html">&lt;script type=&quot;text/javascript&quot;&gt;
			
			$(function(){
				//type属性等于text
				$(&quot;input[type=text]&quot;).css(&quot;background-color&quot;,&quot;#00A40C&quot;);
				// name属性用z开头的
				$(&quot;input[name^=z]&quot;).css(&quot;background-color&quot;,&quot;#FF0000&quot;);
				// name属性同d结尾的
				$(&quot;input[name$=d]&quot;).css(&quot;background-color&quot;,&quot;green&quot;);
				//name属性中包含p 的元素
				$(&quot;input[name*=p]&quot;).css(&quot;background-color&quot;,&quot;green&quot;);
               
               //复合属性选择器，需要同时满足多个条件时使用
                $(&quot;input[type=text][name^=z]&quot;).css(&quot;background-color&quot;,&quot;deeppink&quot;); 
			})
			
			
		&lt;/script&gt;
</code></pre>
<h2 id="7-表单选择器">7、表单选择器</h2>
<pre><code class="language-html">&lt;script type=&quot;text/javascript&quot;&gt;
			
			$(function(){
				
				// √ 获得form表单中的所有的表单项
				var inp= $(&quot;:input&quot;) 
				//获得标签名称是input 的所有的标签对象
				var  inp2=$(&quot;input&quot;);
				alert(inp.length+&quot;----&quot;+inp2.length);
				
				$(&quot;input[type=text]&quot;)
				//  √ input标签 type属性等于text所对应的对象
				$(&quot;:text&quot;).css(&quot;background-color&quot;,&quot;green&quot;);
				
				$(&quot;:password&quot;).css(&quot;background-color&quot;,&quot;red&quot;);
				
				
				/********表单属性选择器*****************/
				
				//获得input标签中含有disabled属性的对象
				var but=  $(&quot;input:disabled&quot;);	
				
				alert(but.val());
				//√  获得含有checked属性的对象
				var  ch =$(&quot;input:checked&quot;);
				
			})
</code></pre>
<h2 id="8-操作元素对象的样式">8、 操作元素对象的样式</h2>
<pre><code class="language-html">&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;utf-8&quot;&gt;
		&lt;title&gt;&lt;/title&gt;
		
		&lt;style&gt;
			
			#div1{
				
				width: 200px;
				
				height: 200px;
				
				border: 2px solid  green;
				
			}			
		&lt;/style&gt;		
		&lt;script src=&quot;js/jquery-1.9.1.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
		
		&lt;script type=&quot;text/javascript&quot;&gt;
			
			$(function(){
				
				
				$(&quot;#bu1&quot;).click(function(){
					
					//获得div对象
					
					var  div =$(&quot;#div1&quot;);
					
					//获得css样式
					
					var wid=div.css(&quot;width&quot;);
					
					var hi=div.css(&quot;height&quot;);
					
					console.log(wid+&quot;----&quot;+hi);
					
					//操作元素对象的css
					
					div.css(&quot;width&quot;,&quot;400px&quot;);
					
					div.css(&quot;height&quot;,&quot;500px&quot;);
					
					div.css(&quot;background-color&quot;,&quot;red&quot;);
					
					div.css(&quot;backgroundColor&quot;,&quot;red&quot;);
					
				  //以上内容的综合---{key1:value1,key2:value2}---json数据格式
					
					div.css({'width':'300px','height':'300px','background-color':'red'});
				})
				
				
			})
			
		&lt;/script&gt;
		
	&lt;/head&gt;
	&lt;body&gt;		
		&lt;input type=&quot;button&quot; value=&quot;样式的添加&quot; id=&quot;bu1&quot;&gt;		
		&lt;hr /&gt;	
		&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;	
	&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<p>如果当页面中的css样式比较多的时候可以通过添加类的方式添加样式，方法如下：两种：</p>
<pre><code class="language-html">&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;utf-8&quot;&gt;
		&lt;title&gt;&lt;/title&gt;
		&lt;style&gt;
			#div1{
				
				width: 300px;
				
				height: 300px;
				
				border:  3px solid red;
				
			}
			
			.div{
				
				width: 500px;
				
				height: 500px;
				
				
				background-image: url(img/1.jpg);
				
				background-repeat: no-repeat;
				
				background-position: center;
				
				background-color: greenyellow;
				
			}
			
		&lt;/style&gt;
		
		&lt;script src=&quot;js/jquery-1.9.1.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
		
		&lt;script type=&quot;text/javascript&quot;&gt;
			
			  $(function(){
			  	 
			  	$(&quot;#bu1&quot;).click(function(){
			  		
			  		//获得div对象 --通过添加类的方式添加css样式
			  		$(&quot;#div1&quot;).attr(&quot;class&quot;,&quot;div&quot;);
			  		
			  		$(&quot;#div1&quot;).addClass(&quot;div&quot;);
			  	})			  				  	
			  })
						
		&lt;/script&gt;				
	&lt;/head&gt;
	&lt;body&gt;
		
		&lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;bu1&quot; value=&quot;元素样式操作&quot; /&gt;		
		&lt;hr /&gt;		
		&lt;div id=&quot;div1&quot;&gt;			
		&lt;/div&gt;
	&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<h2 id="9-操作元素对象的属性">9、操作元素对象的属性</h2>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;utf-8&quot;&gt;
		&lt;title&gt;&lt;/title&gt;
		&lt;script src=&quot;js/jquery-1.9.1.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
		
		&lt;script type=&quot;text/javascript&quot;&gt;
			
			 $(function(){
			 	
			 	 $(&quot;#bu1&quot;).click(function(){
			 	 	
			 	  //获得元素对象
			 	  var tex=$(&quot;#inp1&quot;);
			 	 //获得元素对象的属性	
			 	  var te=tex.attr(&quot;type&quot;);
			 	 	
			 	  var cl =tex.attr(&quot;class&quot;);
			 	 //获得元素固有的属性值
			 	 var  val =tex.attr(&quot;value&quot;);
			 	 
			 	 console.log(te+&quot;------&quot;+cl+&quot;-----&quot;+val);
			 	 //获得文本框实时输入的值
			 	 var  val2=tex.val();
			 	  alert(val2);
			 	 
			 	 /*********操作元素对象的属性******************/
                  
                  tex.attr(&quot;type&quot;,&quot;button&quot;);
                  
                  tex.attr(&quot;value&quot;,&quot;测试按钮&quot;);
			 	 
			 	 //支持json数据格式
			 	  tex.attr({&quot;type&quot;:&quot;button&quot;,&quot;value&quot;:&quot;测试按钮&quot;});
			 	  
			 	  var ch= $(&quot;#fav&quot;).attr(&quot;checked&quot;);//返回的是checked
                  var  flag=$(&quot;#fav&quot;).prop(&quot;checked&quot;);//返回值是true或false

                  var  flag=$(&quot;#fav&quot;).prop(&quot;checked&quot;,true);
			 	 
			 	 })			 	
			 	
			 })
		&lt;/script&gt;
		
	&lt;/head&gt;
	&lt;body&gt;
		
		&lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;bu1&quot; value=&quot;元素属性的获得&quot; /&gt;
		&lt;hr /&gt;
		&lt;form&gt;
			
			
			账号：&lt;input type=&quot;text&quot; class=&quot;inp&quot; id=&quot;inp1&quot; value=&quot;sxt&quot; /&gt; &lt;br /&gt;
			
			
			密码：&lt;input type=&quot;password&quot; class=&quot;pwd&quot; id=&quot;pwd1&quot; value=&quot;sxt&quot; /&gt;&lt;br /&gt;
			
			
			爱好： 抽烟：&lt;input type=&quot;checkbox&quot; /&gt;
			         
			       喝酒：&lt;input type=&quot;checkbox&quot; /&gt;
			
			       烫头：&lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot; id=&quot;fav&quot; /&gt;
		
		&lt;/form&gt;
		
	&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<h2 id="10-操作元素对象的内容和值">10、操作元素对象的内容和值</h2>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;utf-8&quot;&gt;
		&lt;title&gt;&lt;/title&gt;
      &lt;script src=&quot;js/jquery-1.9.1.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
      
      &lt;script type=&quot;text/javascript&quot;&gt;
      	
      	$(function(){
      		
      		$(&quot;#bu1&quot;).click(function(){
      			
      			 //获得div元素对象
      			 var div =$(&quot;#div1&quot;);
      			 
      			 
      			 //获得元素的内容 含有HTML的标签的
      			 var  ht=div.html();
      			 
      			 console.log(ht);
      			 //只是获得文本内容， 不含有HTML标签
      			 var te =div.text();
      			 
      			 console.log(te);
      			//获得文本框的值
      			
      			var val=$(&quot;#inp1&quot;).val();
      			
      			console.log(val);
      			
      			
      			/********操作元素对象的内容和值****************/
      			
      			//会识别这里的b标签，覆盖之前的内容
      			div.html(&quot;&lt;b&gt;我们都爱笑&lt;/b&gt;&quot;);
				
				//不会识别这里的b标签，覆盖之前的内容
      			div.text(&lt;b&gt;我们都爱笑&lt;/b&gt;&quot;);
      			
				//累加，不覆盖
      			div.text(div.text()+&quot;&lt;b&gt;我们都爱笑&lt;/b&gt;&quot;);
      			
      			
      			$(&quot;#inp1&quot;).val(&quot;123&quot;);
      			
      		})
	
      	})
      	
      	
      &lt;/script&gt;
	
	&lt;/head&gt;
	&lt;body&gt;
		
		&lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;bu1&quot; value=&quot;操作元素的内容&quot; /&gt;
		&lt;hr /&gt;
		
		&lt;div id=&quot;div1&quot;&gt;
			
			&lt;span&gt;你好&lt;/span&gt;
			
		&lt;/div&gt;
	
		&lt;input type=&quot;text&quot; name=&quot;inp1&quot;  id=&quot;inp1&quot; value=&quot;&quot; /&gt;
		
	&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<h2 id="11-操作元素对象的节点">11、操作元素对象的节点</h2>
<pre><code class="language-html">&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;utf-8&quot;&gt;
		&lt;title&gt;&lt;/title&gt;
		&lt;style&gt;	
			#div1{
				height: 300px;
				
				border: 3px solid  red;
			}
			p{
				border: 2px solid  green;
				
			}
		&lt;/style&gt;
		
		&lt;script src=&quot;js/jquery-1.9.1.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
		
		&lt;script type=&quot;text/javascript&quot;&gt;
			$(function(){
				//创建了新的元素
				var  p=$(&quot;&lt;p&gt; &lt;b&gt;List  Item0&lt;/b&gt; &lt;/p&gt;&quot;)
				//增加子元素   ---现有元素之后
				$(&quot;#div1&quot;).append(p);
                 //把p元素增加到  div里面 
                p.appendTo(&quot;#div1&quot;);
               //添加内部的子元素  ---现有元素之前
                $(&quot;#div1&quot;).prepend(p);
               
                p.prependTo(&quot;#div1&quot;);
               //平级的添加元素---现有元素之前
                p.insertBefore(&quot;#div1&quot;);
               
                $(&quot;#div1&quot;).before(p);
                
                //平级的添加元素---现有元素之后
                p.insertAfter(&quot;#div1&quot;);
                
                $(&quot;#div1&quot;).after(p);

            /***********替换指定的节点******************/
            
            $(&quot;div p:nth-child(1)&quot;).replaceWith(p);
            
            p.replaceAll(&quot;div p:nth-child(5)&quot;);
             
             /**********删除指定的节点元素***************************/
             //删除指定的元素
            $(&quot;#div1&quot;).remove();
	        //删除指定下标为3的子元素
	         $(&quot;div p:nth-child(3)&quot;).remove();
	         
	         
	         //清空内容,div1里面的内容全清空
	         $(&quot;#div1&quot;).empty();
	         
	         $(&quot;div p:nth-child(2)&quot;).empty();
	         
			})
			
		&lt;/script&gt;
		
	&lt;/head&gt;
	&lt;body&gt;
		
		&lt;div id=&quot;div1&quot;&gt;
			
			&lt;p&gt;List Item1&lt;/p&gt;
			
			&lt;p&gt;List Item2&lt;/p&gt;
			
			&lt;p&gt;List Item3&lt;/p&gt;
			
			&lt;p&gt;List Item4&lt;/p&gt;
			
			&lt;p&gt;List Item5&lt;/p&gt;	
		&lt;/div&gt;
		
	&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<pre><code class="language-html">&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;utf-8&quot;&gt;
		&lt;title&gt;&lt;/title&gt;
		&lt;script src=&quot;js/jquery-1.9.1.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
		
		&lt;script type=&quot;text/javascript&quot;&gt;
			
			 function insertNode(){
			 	
			 	//创建节点对象
			 	var  p =$('&lt;p&gt;'+
				'照片:&lt;input type=&quot;file&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;&quot; /&gt;'+
				'&lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;删除&quot; onclick=&quot;removeNode(this)&quot; /&gt;'+
			    '&lt;/p&gt;');
			 	
			 	$(&quot;#last&quot;).before(p);
			 	
			 }
			 function removeNode(obj){
			 	
			 	$(obj).parent().remove();
			 }
						
		&lt;/script&gt;
				
	&lt;/head&gt;
	&lt;body&gt;
		
		&lt;form&gt;
			
			&lt;p&gt;
				
				用户名:&lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;&quot; /&gt;
				
			&lt;/p&gt;
			
			&lt;p&gt;
				照片:&lt;input type=&quot;file&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;&quot; /&gt;
				
				&lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;添加&quot; onclick=&quot;insertNode()&quot; /&gt;
			&lt;/p&gt;
			
			&lt;p id=&quot;last&quot;&gt;
				&lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;提交&quot; /&gt;
				
				&lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;清空&quot; /&gt;
			&lt;/p&gt;
			
		&lt;/form&gt;	
	&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<h2 id="12-事件处理">12、事件处理</h2>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;utf-8&quot;&gt;
		&lt;title&gt;&lt;/title&gt;
		&lt;script src=&quot;http://apps.bdimg.com/libs/jquery/1.7.0/jquery.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
		
		&lt;script type=&quot;text/javascript&quot;&gt;
			/*页面加载完执行的操作*/
//			$(function(){})
			
//			jQuery(function(){})
			
//			$(document).ready(function(){})
			
			$(function(){
				/*******事件的基础绑定*************/
				$(&quot;#bu1&quot;).click(function(){
				
				alert(&quot;单击事件&quot;);
				
			  })
			  
			 $(&quot;#bu1&quot;).dblclick(function(){
			  	
			  	alert(&quot;双击事件&quot;);
			  })
			 
			  /*******bind事件绑定**************/
			  $(&quot;#bu2&quot;).bind('click',function(){
			  	
			  	alert(&quot;单击事件绑定&quot;);
			  	
			  })*/
			  //内容还支持json数据格式
			  $(&quot;#bu2&quot;).bind({
			  	 'click':function(){},
			  	 'dblclick':function(){},
			  	 'blur':function(){}
			  	})
			  
			  /*********one一次事件绑定*************/
			  
				$(&quot;#bu3&quot;).one('click',function(){
					
					alert(&quot;一次事件绑定&quot;);
				})			
				
				/*********trigger事件操作****************/
				
				$(&quot;#bu4&quot;).click(function(){
						
					$(&quot;#bu1&quot;).trigger('dblclick');
					
					$(&quot;#bu3&quot;).trigger('click');
					
				})
				
				/********事件的解绑***********/
				
				$(&quot;#bu5&quot;).click(function(){
					
					//事件的解绑
					//解绑指定对象上的所有事件
					$(&quot;#bu1&quot;).unbind();
					//解绑指定的事件
					$(&quot;#bu1&quot;).unbind(&quot;dblclick&quot;);
					
				})
				
				$(&quot;.bu6&quot;).click(function(){
					
					alert(&quot;单击事件的绑定&quot;);
					
				})
				
				$(&quot;.bu6&quot;).live('click',function(){
					
					alert(&quot;单击事件绑定&quot;);
					
				})
				
				
				$(&quot;body&quot;).append('&lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; class=&quot;bu6&quot; value=&quot;事件操作2&quot; /&gt;');
				
			})
		
		&lt;/script&gt;
	
	&lt;/head&gt;
	&lt;body&gt;
	
		&lt;input type=&quot;button&quot; name=&quot;bu1&quot; id=&quot;bu1&quot; value=&quot;事件绑定&quot; /&gt;
		
		&lt;input type=&quot;button&quot; name=&quot;bu2&quot; id=&quot;bu2&quot; value=&quot;bind事件绑定&quot; /&gt;
		
		&lt;input type=&quot;button&quot; name=&quot;bu3&quot; id=&quot;bu3&quot; value=&quot;one事件绑定&quot; /&gt;
		
		&lt;input type=&quot;button&quot; name=&quot;bu4&quot; id=&quot;bu4&quot; value=&quot;tigger事件学习&quot; /&gt;
		
		&lt;input type=&quot;button&quot; name=&quot;bu5&quot; id=&quot;bu5&quot; value=&quot;事件解绑&quot; /&gt;
	
		&lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; class=&quot;bu6&quot; value=&quot;事件操作&quot; /&gt;
	
	&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<h2 id="13-动画功能">13、动画功能</h2>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;utf-8&quot;&gt;
		&lt;title&gt;&lt;/title&gt;
		&lt;style&gt;
			#div1{		
				height: 300px;
				background-color: green;
			}
			
			#div2{
				
				height: 300px;
				
				background-color: yellow;
		}
		&lt;/style&gt;
		
		&lt;script src=&quot;js/jquery-1.9.1.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
		
		&lt;script type=&quot;text/javascript&quot;&gt;
			
			  $(function(){
			  	  $(&quot;#bu1&quot;).click(function(){
			  	  	
			  	  	  //获得div对象
			  	  	  var  div1 =$(&quot;#div1&quot;);
			  	  	  
			  	  	  //3s隐藏动画
			  	  	  div1.hide(3000);
			  	  	  
			  	  	  div1.show(3000);
                      //隐藏的显示 ---显示的隐藏
                      $(&quot;div&quot;).toggle(3000);
                     //滑动上
                   div1.slideUp(3000);
                     //滑动下
                   div1.slideDown(3000);
                     //滑动上--滑动下    滑动下---滑动上
                   $(&quot;div&quot;).slideToggle(3000);
                   
                     //淡出
                     div1.fadeOut(3000);
                     //淡入
                     div1.fadeIn(3000);
			  	  	
			  	  })
	  	
			  })
			
		&lt;/script&gt;
		
	&lt;/head&gt;
	&lt;body&gt;
		
		&lt;input type=&quot;button&quot; id=&quot;bu1&quot; value='动画触发'&gt;
		
		&lt;hr /&gt;
		
		&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;
		
		&lt;div id=&quot;div2&quot;&gt;&lt;/div&gt;	
	&lt;/body&gt;
&lt;/html&gt;

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础-面向对象]]></title>
        <id>https://jonchan1013.github.io/post/java-ji-chu-mian-xiang-dui-xiang/</id>
        <link href="https://jonchan1013.github.io/post/java-ji-chu-mian-xiang-dui-xiang/">
        </link>
        <updated>2020-06-10T07:42:29.000Z</updated>
        <summary type="html"><![CDATA[<p>✍️面向对象的基本思想是，从现实世界中客观存在的事物出发来构造软件系统，并在系统的构造中尽可能运用人类的自然思维方式。<br>
面向对象更加强调运用人类在日常生活的逻辑思维中经常采用的思想方法与原则，如抽象、分类，继承、聚合、多态等。</p>
]]></summary>
        <content type="html"><![CDATA[<p>✍️面向对象的基本思想是，从现实世界中客观存在的事物出发来构造软件系统，并在系统的构造中尽可能运用人类的自然思维方式。<br>
面向对象更加强调运用人类在日常生活的逻辑思维中经常采用的思想方法与原则，如抽象、分类，继承、聚合、多态等。</p>
<!-- more -->
<h2 id="1-面向对象一">1、面向对象（一）</h2>
<h3 id="11-面向过程的思想和面向对象的思想">1.1 面向过程的思想和面向对象的思想</h3>
<p>​		面向对象和面向过程的思想有着本质上的区别, <strong>作为面向对象的思维来说，当你拿到一个问题时，你分析这个问题不再是第一步先做什么，第二步再做什么，这是面向过程的思维，你应该分析这个问题里面有哪些类和对象，这是第一点，然后再分析这些类和对象应该具有哪些属性和方法。这是第二点。最后分析类和类之间具体有什么关系，这是第三点。</strong></p>
<p>​		<strong>面向对象有一个非常重要的设计思维：合适的方法应该出现在合适的类里面。</strong></p>
<h3 id="12-简单理解面向对象">1.2 简单理解面向对象</h3>
<p>​		就是在程序里面首先分解出来的应该是注意不再是一步一步的过程了，而是首先考虑在这个问题域里面或者程序里面应该具有有哪些对象，所以从现在开始考虑任何问题脑子里不要再想着我实现这件事我第一步应该干什么，第二步应该干什么，如果这样想，那就是面向过程的思维了。面向对象的思维是，当我碰到这个问题域的时候，碰到这个程序的时候，我首先应该把这个问题里有哪些对象，对象与对象之间有什么关系抽象出来。</p>
<h3 id="13-面向对象的设计思想">1.3 面向对象的设计思想</h3>
<ul>
<li>面向对象的基本思想是，从现实世界中客观存在的事物出发来构造软件系统，并在系统的构造中尽可能运用人类的自然思维方式。</li>
<li>面向对象更加强调运用人类在日常生活的逻辑思维中经常采用的思想方法与原则，如抽象、分类，继承、聚合、多态等。</li>
<li>人在思考的时候，首先眼睛里看到的是一个一个的对象。</li>
</ul>
<h3 id="14-对象和类的概念">1.4  对象和类的概念</h3>
<p>​		对象是用于计算机语言对问题域中事物的描述，<strong>对象通过“属性（attribute）”和“方法（method）”来分别对应事物所具有的静态属性和动态属性</strong>。</p>
<p>​		<strong>类是用于描述同一类的对象的一个抽象的概念，类中定义了这一类对象所具有的静态属性和动态属性</strong></p>
<p>​		<strong>类可以看成一类对象的模板，对象可以看成该类的一个具体实例</strong>。</p>
<p>​		<strong>eg.什么叫瓶子？</strong></p>
<p>​		瓶子的定义：具有某些类特征的东西就是瓶子，比分说什么样的形状，比方说有个口，能倒水，能装水，一般有个盖等等。给瓶子下定义的过程，其实就是把瓶子里的某些东西抽象出来了，所以瓶子在这里是叫做一类事物的一个抽象，在你脑子里有瓶子的概念，可瓶子的概念在你脑子里到底是什么呢？瓶子的概念在你脑子里叫做一类事物的一个抽象。怎么抽象的呢？你往往抽象的是这两个方面：第一个方面我们叫它静态的属性，瓶子应该具有哪些特征，比分说瓶子应有个口，这是它的具有的一个静态属性，瓶子一般有一个盖，这也是它的具有一个静态属性，除此之外，你还可能给它总结动态的属性，什么动态的属性呢？比放说瓶子能倒水，这是它的动态属性。瓶子这个概念在你脑子里如果你细细的思维的话，其实你给它做了两方面的总结，一方面是静态的，一方面是动态的。反映到JAVA的类上，一个就是成员变量（静态属性），一个就是方法（动态属性）方法是可以执行的，可以动的。成员变量是某一个类的静态属性。所以你脑子里瓶子的概念实际上是一类事物的一个抽象，这种东西我们叫它类，椅子是类，桌子是类，学生是类。什么是对象呢？这一类事物的具体的某个实例就叫做对象。所以<strong>一类事物的具体的某一个东西，符合这类事物具体的特征的某个东西就叫做对象</strong>。瓶子是一个类，某个瓶子就是瓶子这个类里面的一个对象。</p>
<h3 id="15-如何抽象出一个类">1.5 如何抽象出一个类？</h3>
<p>​		有两个方面，一方面是它的静态属性，另一方面是它的动态属性。反映到JAVA里面的类怎么包装它呢？一方面成员变量，另一方面是方法。</p>
<p>​		eg.职员这个类该怎么抽象出来？也是从两个方面，一方面是它的静态属性，另一方面它的动态属性</p>
<p>​		职员有哪些属性呢？有姓名，年龄，目前工资数额等属性，他有哪些方法呢？让这个职员来显示姓名，显示年龄，修改姓名，领取工资。当然显示姓名，显示年龄，修改姓名，领取工资这些也可以让别人来做，但<strong>面向对象的设计思维是最合适的方法应该出现在最合适的类里面</strong>。显示姓名，显示年龄，修改姓名，领取工资由谁来做更合适呢，那就是职员自己最合适。所以这些方法应该出现在职员这个类里面。</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610155239.png" alt="" loading="lazy"></figure>
<p>​		对于类来说，它有一些属性或者称为成员变量，以后说属性或者成员变量指的是同一回事。具体的对象他有没有相关的一些属性或者叫成员变量呢？有，每一个人都有一份，只不过是取值不同而已。如从职员这个类实例化出来的两个职员：职员A和职员B，他们都有姓名，年龄，目前工资数额这些属性，但他们的名字，年龄，领取的工资数额都不一样。这样就能把职员A和职员B区分开来了，正是因为他们的属性值不一样，所以这个对象才能和另外的对象区分开来，<strong>所以通过属性是可以区分两个对象的</strong>。猫是一个类，这只猫是一个对象，这只猫和另外一只猫该怎么区分开来呢？那就得看你的猫这个类是怎么定义的了，猫有猫毛，毛有颜色。OK，这只猫是黑猫，另一只猫是白猫，这样通过猫毛的颜色区分开来了。如果只定义一个，如捉老鼠，白猫也能捉，黑猫也能捉，这样就没办法区分出黑猫和白猫了，所以<strong>根据方法是没办法区分两个对象的</strong>。所以<strong>每个对象都有自己的属性，属性值和另外一个对象一般是不一样的</strong>。</p>
<p>​		一定要区分类和对象，什么叫做类？什么叫做对象？类是一类事物的一个抽象，具有共同特征的一类事物的一个抽象。对象是这个类具体的某一个实例，所以以后说实例（instance）或者说对象（object）指的是同一回事。</p>
<h3 id="16-类对象之间的关系">1.6 类（对象）之间的关系</h3>
<h4 id="161-关联关系最弱的一种关系">1.6.1 关联关系(最弱的一种关系)</h4>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610155402.png" alt="" loading="lazy"></figure>
<p>​		类和类之间是有关系的，如学生和老师这两个类，老师可以教学生，学生可以向老师学习。这就是他们之间的关系。关系和关系之间是不同的，你和你老婆的关系和你和你其他女朋友的关系是不能混为一谈的。关系最弱的一种关系叫关联关系。关联关系反应到代码上往往是一个类的方法里面的参数是另一个类的具体的某一个对象，比如教授教研究生，教哪个研究生，教是教授这个类里面的一个方法，某个研究生是研究生这个类里面的一个具体的对象。<strong>关联关系是最弱的一种关系</strong>，咱们两个类之间有关系，或者两个对象之间有关系，但关系不是很紧密。</p>
<h4 id="162-继承关系比较强的一种关系">1.6.2 继承关系（比较强的一种关系）</h4>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610155535.png" alt="" loading="lazy"></figure>
<p>​		<strong>继承关系封装了这样一种逻辑：“XX是一种XX”，只要这东西能说通了，就可以考虑用继承关系来封装它</strong>。如：游泳运动员从运动员继承，游泳运动员是一种运动员，这能说得通，所以游泳运动员就是从运动员继承过来的，游泳运动员和运动员就是一种继承关系。学生是一个人，学生从人继承，老师是一个人，老师也从人继承，学生是一种老师，这说不通，所以学生和老师就不存在继承关系。所以将来做设计的时候要分清继承关系很简单，你只要说通这么一句话：“XX是一种XX”。OK，那他们之间就是继承关系。篮球运动员是一种球类运动员，这说得通，所以篮球运动员从球类运动员继承，这样继承很有可能会产生一棵继承树，运动员派生出来，派生出来的意思是游泳运动员这个类、球类运动员这个类、射击运动员类从它继承，相当于运动员派生出来了这些个不同的运动员，包括游泳的，球类的，射击的。球类的再派生足球的，篮球的，排球的。这就是一棵继承树，不过这棵树是比较理想化的情况，只有一个根节点。但实际当中，我们真实世界当中的继承关系不一定只从一个类继承，一个类可能从多个类继承过来，比如说：金丝猴从动物这个类继承，这很正常，但我还有另外一个专门的类：“应该受到保护的东西”，这也是一个类，金丝猴应该受到保护，所以金丝猴是一种应该受到保护的东西。所以金丝猴从“应该受到保护的东西”这个类继承过来。所以在现实情况当中，一个类完完全全有可能从多个不同的类继承，C++正是因为想封装这种继承关系，所以C++存在多重继承。</p>
<h4 id="163-聚合关系整体和部分比较强的一种关系">1.6.3 聚合关系（整体和部分）（比较强的一种关系）</h4>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610155626.png" alt="" loading="lazy"></figure>
<p>​		什么是聚合？<strong>聚合就是一个整体与部分的关系</strong>。我们说**“XX是XX的一部分”，只要说得通，那么他们之间的关系就是聚合关系**，队长是球队的一部分，队员是球队的一部分。所以队长和球队是聚合关系，队员和球队也是聚合关系。脑袋是人的以部分，身体和胳膊也是人的一部分，因此脑袋，身体和胳膊与人都是聚合关系。<strong>聚合关系分得再细一点的话就可以分成聚集关系和组合关系</strong>，比如球队、队长，队员，这三者是聚集关系，假如这个队长既是足球的队长，同时也是篮球的队长，一个人分属两个不同的球队，这是可以的，球队与队长之间没有我离不了你，你离不了我这种情况，所以如果分得更细的话，这种就叫做聚集关系。还有一种情况叫组合，组合说的是咱们俩密不可分，我是你必不可少的一部分。一个人的脑袋不可能既属于你又属于别人，身体也一样，不可能既属于你又属于别人。所以你的身体，脑袋和你是密不可分的，这是一种更加严格的聚合关系，专门给它取了个名字叫组合。</p>
<h4 id="164-实现关系">1.6.4 实现关系</h4>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610155715.png" alt="" loading="lazy"></figure>
<p>​		**作为父类来说，我觉得我应该具有这样一个方法，但我不知道怎么去实现，谁去实现，我的子类去实现，这就是实现关系。**和实现关系息息相关的还有一种关系叫多态。</p>
<h4 id="165-多态">1.6.5 多态</h4>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610155757.png" alt="" loading="lazy"></figure>
<h3 id="17-java与面向对象">1.7 Java与面向对象</h3>
<pre><code>	对象和类是分不开的，必须首先定义类才能有对象。首先定义方法才能调用。对象是JAVA里面的核心，做任何东西你首先都得给我造出一个对象才能做。静态属性简称属性，也叫成员变量，以后说属性或者说成员变量它们指的都是同一回事。
</code></pre>
<p>整个类可以看作是静态的属性还有方法他们之间的一个综合。怎么抽象出一个类的概念，还是那句话，你必须抽象出两个方面来，第一方面是看他们的静态属性，他们有哪些成员变量，第二方面是看他们的有哪些方法。</p>
<p>写JAVA程序时，我们一上来写的就是public class（声明一个类），在这个class里面我们写的是成员变量和方法。</p>
<p><strong>每一个JAVA里面的class（类）都对应了我们现实生活中某一类事物的一个抽象</strong>。比如说要在JAVA里面封装一只狗，具体怎么封装，如何写代码，代码如下：</p>
<pre><code class="language-java">/**
 * 一类事物封装到JAVA里面首先得写class，定义这个类，类名是什么可以自己取。
 * 这里把类名叫做Dog
 */
public class Dog {
    /**
     * 接下来就是写这个狗这个类的属性或者叫成员变量，
     * 比如说狗这个类的毛的颜色，怎么定义这个属性呢，
     * 首先得定义毛的一个类型,如使用int来定义毛的颜色类型
     */
    int furcolor; //定义属性：毛的颜色
    float height; //定义属性：狗的高度
    float weight; //定义属性：狗的体重

    /**
     * 狗的颜色，高度，体重这些属性定义完了，接下来要定义的就是方法了。
     * 如写一个CatchMouse（）方法，捉老鼠的方法。
     * CatchMouse这个方法里面有一个对象类型的参数，捉哪一只老鼠，这个对象参数是属于Mouse这个类的
     * @param m
     */
    void CatchMouse(Mouse m){
            //在方法体内写捉老鼠这个过程，怎么捉，跑着捉，走着捉
            System.out.println(&quot;我捉到老鼠了，汪汪！，老鼠要尖叫了！&quot;);
            /**
             * 老鼠尖叫一声，表示被狗咬到了，咬到了能不叫吗，很自然而然地想到，
             * 尖叫（scream()）这个方法是属于Mouse这个类里面的某一个方法。
             * 老鼠自己调用它，让它自己尖叫。这就是面向对象的思维。
             */
            m.scream();
    }

    public static void main(String[] args) {
        Dog  d = new Dog();//首先用new关键字创建一只狗
        Mouse m=new Mouse();//造出一只老鼠。
        d.CatchMouse(m);//然后用这只狗去抓老鼠，让狗调用CatchMouse()方法去捉某只老鼠。
    }
}
</code></pre>
<p>​		从这个意义上来讲，JAVA里面的每定义一个类实际上就相当于一种新的数据类型。就跟int ，float， String等一样，不过是一种新定义的类型而已。</p>
<h3 id="18-为什么使用面向对象编程">1.8 为什么使用面向对象编程？</h3>
<p>​		面向对象编程：一组对象互相配合通过沟通完成特定功能</p>
<p>做软件苦苦追求的一种境界是可重用性（reusable），可扩展性。如果是面向过程，一般情况是属性和方法它们是分开的，他们不是聚合的关系，不是合在一起的，这样要复用起来比较麻烦，复用的层次只是局限于方法这个层次上，而面向对象则不同，它是把属性和方法综合在一个里面。综合在一起复用的时候是整个对象进行复用。所以面向对象和面向过程相比，前者更加容易让我们达到可重用性。</p>
<h2 id="2-java面向对象二">2、Java面向对象（二）</h2>
<h3 id="21-java类的定义">2.1 Java类的定义</h3>
<pre><code class="language-java">//用class关键字定义一个类
class Person{
    private int id;
    private int age = 20;
    //方法的定义
    public int getAge(){
        return age;
    }
    public void setAge(int i){
        age = i;
    }
    public int getId(){
        return id;
    }
}
</code></pre>
<ul>
<li>
<p>类的定义主要有两方面组成一成员变量和方法。</p>
</li>
<li>
<p>声明成员变量的格式为: [&lt; modifiers&gt;] type &lt; attr_name&gt;[=defaultValue] ;<br>
例如:  private int id;    private int age = 20;</p>
</li>
<li>
<p>声明方法的格式为:<br>
[&lt; modifiers&gt;)] &lt; modifiers&gt; &lt;return_ type&gt; <name>([&lt; argu list&gt;]) {<br>
[&lt; statements&gt;]<br>
}    例如: public int getAge() {return age;}</p>
<p>​		JAVA里面有<strong>class</strong>关键字定义一个类，后面加上自定义的类名即可。如这里定义的person类，使用class person定义了一个person类，然后在person这个类的类体里面定义person这个类应该具有的成员变量（即属性）和方法，如这里定义的int id和int age这个两个成员变量，或者叫属性，这个id表示人的身份证号码，人应该具有这个属性，age表示人的年龄，这也是人应该具有的。这样就在person这个类里面定义了两个人应该有的属性，接下来就是定义方法了，这里定义了三个方法，分别是getAge()、setAge(int i)和getId()，分别用来获取人的年龄，设置人的年龄，获取人的id，getAge()方法获取了人的年龄后，将获取到的值返回，所以使用了return age语句，getId()方法也使用了return id语句用于返回获取到的id的值。</p>
</li>
</ul>
<h3 id="22-成员变量">2.2 成员变量</h3>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610160936.png" alt="" loading="lazy"></figure>
<p>**在JAVA里面的任何变量首先应该要声明，然后再赋值，然后再使用。**成员变量和局部变量有一个重要区别：<strong>成员变量在类里面声明时如果不进行初始化，那么JAVA会默认给它初始化，而局部变量JAVA不会默认给它初始化，所以在方法里面声明一个局部变量如果不给它初始化时就会出错</strong>。默认初始化大多数都是0，boolean类型的为false，引用类型的为null，如过不记得JAVA对成员变量默认的初始化是多少的话，那就这样做，定义一个成员变量，不给它初始化，然后直接打印这个成员变量，打印出来的结果就是JAVA默认的初始化的值。</p>
<h3 id="23-java面向对象的基本概念引用">2.3 Java面向对象的基本概念——引用</h3>
<figure data-type="image" tabindex="8"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610161110.png" alt="" loading="lazy"></figure>
<p>​		<strong>引用类型和基本类型有着巨大的区别</strong>，当声明一个int i=0时，系统会马上给这个i分配一个内存空间（在栈内存里面分配一小块区域用来装数字0），里面装着一个值为0，以后使用i这个名字马上就可以访问这个内存空间里面的值，这就是基本数据类型，所以<strong>基础类型就只占一块内存</strong>。基础类型之外的类型全都叫引用类型，我们定义一个Mouse m，这个m就是一个引用类型的数据。引用类型有什么重要的特征——<strong>引用类型占<strong><strong>2</strong></strong>块内存</strong>。我们定义好这个类之后，需要使用new关键字把这个类的对象实例化出来，也就是真真正正造出一个对象出来才能使用这个对象。</p>
<p><strong>如何在内存中区分类和对象</strong></p>
<p>类是静态的概念，是位于代码区里面。对象是new出来的，它是位于堆内存，为什么对象要位于堆内存？因为堆内存是用来动态分配内存的，只有在运行当中才会new一个对象放堆内存里面，那这个对象到底有多大个，这个东西你不知道，你没有办法提前知道，所以你没有办法提前分配内存给这个对象，你只有在运行期间才能去分配它。什么叫运行期间？敲JAVAC这个命令那是在编译期间，编译完成后再敲JAVA命令，那就是运行期间了。只有在运行期间，才能够明白这个对象到底要分配多大的空间给它，所以把它放在堆内存里面，堆内存比较大，动态分配内存用它。如果这个对象不用了，那它就是垃圾，那么就等着垃圾收集器把它收集回去，释放掉占用的内存。</p>
<p>​		记住，<strong>以后一提到引用，脑子里马上浮现引用那就是一小块内存指向一大块内存。</strong></p>
<h3 id="24-对象的创建和使用">2.4 对象的创建和使用</h3>
<ul>
<li>必须使用new关键字创建对象。</li>
<li>使用对象(引用) .成员变量或来引用对象的成员变量。</li>
<li>使用对象(引用) .方法(参数列表)来调用对象的方法。</li>
<li>同一类的每个对象有不同的成员变量存储空间。</li>
<li>同一类的每个对象共享该类的方法。</li>
</ul>
<h3 id="25-类和对象的关系">2.5 类和对象的关系</h3>
<figure data-type="image" tabindex="9"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610162714.png" alt="" loading="lazy"></figure>
<p><strong>在内存中分析类和对象的关系</strong></p>
<p>假设这里有一个类C，我们定义了一个类class C，然后在这个类里面定义了两个成员变量: int i和int j。定义好了这两个成员变量以后，我们写了一个main()方法（public static void main(Strng[] args)），程序开始执行。第一句我们写了 C c1 = new C()，这句的代码是我们相当于在堆内存里创建了一个对象，同时也创建了这个对象的一个引用对象c1，c1位于栈内存中，c1这个引用对象指向堆中一大块内存，这一大块内存里面装着new出来的那个对象。这里面我们一般来说是new出来两个对象c1和c2，当然，实际上，严格来讲，c1和c2叫做对象的引用，有时候，简称new出来了两个对象，c1和c2。你脑子里马上要浮现出两块内存，c1指向一块，c2指向一块。局部变量是分配在栈内存里面的，main方法里面的c1和c2都是局部变量，所以在栈里面分配了两小块内存出来，一块是c1的，一块是c2的，c1这块内存里面装着一个值，或者叫装着一个地址，这个地址是什么，我们不知道，我们只知道根据这个值就能找到new出来的C这个类里面的一个对象，而在这个对象里面有它自己的成员变量i和j，里面的两小块内存是分别用来装i和j的值的，因为每一个对象都有自己不同的成员变量的值，所以c1指向的那块对内存里面又分成一小块一小块内存，每一个小块的内存都装着这个对象的成员变量（或者叫属性）。如这里的第一小块装着i的值，第二小块装着j的值，所以当我们去访问第一小块里面装着的成员变量时，我们应该这样写：c1.i，这样就拿到了i的值，c1.j，这样就拿到了j的值。同理，c2这个对象也指向了一个new出来的C这个类里面的另一个对象，这个对象也有成员变量i和j，只不过和c1指向的那个对象里的i和j的值不同而已。要访问这个这个对象的成员变量时 ，也是要c2.i，c2.j这样去访问。</p>
<h3 id="26-构造方法">2.6 构造方法</h3>
<ul>
<li>
<p>使用new+构造方法创建-一个新的对象。</p>
</li>
<li>
<p>构造函数是定义在Java类中的一个用来初始化对象的函数。</p>
</li>
<li>
<p>构造函数与类同名且没有返回值。</p>
</li>
<li>
<p>例如: Person 类的构造函数:</p>
<pre><code class="language-java">public class Person(){
    int id;
    int age;
    Person(int n,int i){
        id = n;
        age = i;
    }
}
</code></pre>
<p>在面向对象里面有一个特殊的方法，叫构造方法。</p>
<p>构造方法是用来创建一个新的对象的，与new组合在一起用，使用new+构造方法创建一个新的对象。你new一个东西的时候，实际上你调用的是一个构造方法，构造方法就是把自己构造成一个新的对象，所以叫构造方法，构造一个新对象用的方法叫构造方法。</p>
<p>构造方法比较特殊，构造方法的名字必须和类的名字完全一模一样，包括大小写，并且没有返回值。如原来定义的一个person类，在类里面声明了两个成员变量id与age，这时候你可以再为这个person类定义一个它的构造方法person(int n，int i)，这个方法的名字和类名完全相同，并且没有返回值，也就是在这个方法前面不能写任何的方法的返回类型修饰符，连void都不可以写。</p>
</li>
<li>
<p>构造方法范例：</p>
<pre><code class="language-java">public class Person {
    int id;  //在person这类里面定义两个成员变量id和age,
    int age=20;  //给成员变量age赋了初值为20

    /**这里就是person这个类的一个构造方法
     * 构造方法的规则很简单，和类名要完全一样，一点都不能错，包括大小写。
     * 并且没有返回值，不能写void在它前面修饰
     * @param _id
     * @param _age
     */
    public Person(int _id,int _age ) {
        id = _id;
        age = _age;
    }
}
</code></pre>
<p>​		构造方法写好后就和new组合在一起使用，new的作用是构建一个新对象，创造一个新对象，所以new的时候实际当中调用的是构造方法。只有调用了这个构造方法才能构造出一个新的对象。例如：</p>
<pre><code class="language-java">public static void main(String[] args) {
    Person tom = new Person(1, 25); // 调用person这个构造方法创建一个新的对象，并给这个对象的成员变量赋初始值
}
</code></pre>
</li>
</ul>
<figure data-type="image" tabindex="10"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610161822.png" alt="" loading="lazy"></figure>
<p>​	<strong>下面是在main方法里面调用person构造方法时的内存分析情况：</strong></p>
<figure data-type="image" tabindex="11"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610161855.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610161922.png" alt="" loading="lazy"></figure>
<p>​		<strong>当方法调用完成之后，栈里面为它分配的空间全部都要消失，即把这个方法调用时分配给它的内存空间释放出来</strong>，所以这个构造方法person调用完成之后，栈内存里面分配的两小块内存_id和_age自动消失了。这样就把它们所占的空间让了出来，让其他的方法去占用。而new出来的对象则永远留在了堆内存里面。</p>
<figure data-type="image" tabindex="13"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610162016.png" alt="" loading="lazy"></figure>
<p>​		<strong>声明一个类，若没有在类中指定其构造方法（构造函数）时，编译器会为这个类自动添加形如类名( ){ }的构造函数。</strong></p>
<p><strong>如：</strong></p>
<pre><code class="language-java">class  point{//这里声明一个类时并没有给它指定其构造方法。
     int  x;
     int  y;
}
</code></pre>
<p>​		但在main方法里面我们却可以这样使用：</p>
<pre><code class="language-java">public static void main(String[] args){
     point  p = new  point();
}
</code></pre>
<p>​		这里这样写是可以的，当没有给这个类指明构造方法时，系统会默认地给这个类加上point ( ) { }这样一个空的构造方法。所以才可以在main方法中使用point p = new point(); 实际上你调用的就是编译器默认给它加上的point ( ) { }这个构造方法，在这个构造方法当中，默认地把类里面的成员变量x和y初始值设为0。正是因为系统给它默认加上这么一个构造方法，所以才能在main方法里面调用。但<strong>要记住一点，一旦给这个类里面指定了构造方法，那么系统就不会再给这个类添加构造方法了</strong>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础-基础语法]]></title>
        <id>https://jonchan1013.github.io/post/java-ji-chu-ji-chu-yu-fa/</id>
        <link href="https://jonchan1013.github.io/post/java-ji-chu-ji-chu-yu-fa/">
        </link>
        <updated>2020-06-10T03:16:11.000Z</updated>
        <summary type="html"><![CDATA[<p>✍️JavaSE是Java Standard Edtion的缩写，译成中文就是Java标准版，也是Java的核心。无论是JavaEE(Java企业版)还是JavaME(Java微型版)都是以JavaSE为基础。</p>
]]></summary>
        <content type="html"><![CDATA[<p>✍️JavaSE是Java Standard Edtion的缩写，译成中文就是Java标准版，也是Java的核心。无论是JavaEE(Java企业版)还是JavaME(Java微型版)都是以JavaSE为基础。</p>
<!-- more -->
<h2 id="1-标识符">1、标识符</h2>
<ul>
<li>Java对各种变量、方法和类等要素命名时使用的字符序列称为标识符。
<ul>
<li>凡是自己可以起名字的地方都叫标识符，都遵守标识符的规则</li>
</ul>
</li>
<li>Java标识符命名规则:
<ul>
<li>标识符应以字母、下划线、美元符开头。</li>
<li>Java 标识符大小写敏感，长度无限制。</li>
<li>Java 标识符大小写敏感，长度无限制。</li>
</ul>
</li>
<li>约定俗成: Java标识符选取因注意&quot;见名知意&quot;且不能与Java语言的关键字重名。</li>
</ul>
<h2 id="2-关键字">2、关键字</h2>
<ul>
<li>
<p>Java中一些赋以特定的含义，用做专门用途的字符串称为关键字( keyword)。大多数编辑器会将关键字用特殊方式标出</p>
</li>
<li>
<p>所有Java关键字都是小写英文。</p>
</li>
<li>
<p>所有Java关键字都是小写英文。</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610115950.png" alt="" loading="lazy"></figure>
</li>
</ul>
<h2 id="3-java基础数据类型">3、Java基础数据类型</h2>
<h3 id="31-java常量">3.1 Java常量</h3>
<ul>
<li>
<p>Java 的常量值用字符串表示，区分为不同的数据类型。</p>
<ul>
<li>如整型常量123</li>
<li>实型常量3.14</li>
<li>字符常量'a'</li>
<li>逻辑常量true. false</li>
<li>字符串常量&quot;helloworld&quot;</li>
</ul>
</li>
<li>
<p>注意:区分字符常量和字符串常量</p>
</li>
<li>
<p>注意:“常量”这个名词还会用在另外其它语境中表示值不可变的变量</p>
</li>
</ul>
<h3 id="32-java变量">3.2 Java变量</h3>
<ul>
<li>
<p>Java变量是程序中最基本的存储单元，其要素包括变量名，变量类型和作用域。</p>
</li>
<li>
<p>Java程序中每一个变量都属于特定的数据类型，在使用前必须对其声明，声明格式为:</p>
<ul>
<li>
<p>例如：int i=100;<br>
float f=12.3f;</p>
<p>​			double d1, d2, d3 = 0.123;<br>
​			String s=&quot;hello&quot;;</p>
</li>
</ul>
</li>
<li>
<p>从本质上讲，变量其实是内存中的一-小块区域，使用变量名来访问这块区域，因此，每一个变量使用前必须要先申请(声明)，然后必须进行赋值(填充内容)，才能使用</p>
</li>
<li>
<p>一个程序在运行的时候，实际上这个程序是位于内存里面，然后才开始运行。一个.exe文件存放在硬盘上是无法运行的，在硬盘上看到的.exe文件无非就是一个文件而已，当我们双击这个.exe文件时，运行起来的时候实际上是整个.exe文件被放在了在内存里面，然后操作系统找到main方法，也就是程序的入口，然后就开始执行了。执行的过程之中，会不断地在内存里面分配一些区域，变量在内存里面就是一小块区域，变量有两个概念，一个是变量的名字，另一个是变量的值，即这一小块区域是有名字的，里面装着一个值，因此以后要想访问这小块区域里面的内容就可以根据这小块区域的名字来访问了。因此，变量的本质就是一小块内存区域。就变量来说，该在内存里面分配多大的存储空间呢？不同的变量类型分配不同大小的存储空间，每一个变量都是属于特定的数据类型的，声明成不同的数据类型，它就在内存里面分配不同的存储空间。</p>
</li>
<li>
<p>变量作用域：变量的作用域只在“{ }”有效，出了这个“{ }”就没有作用了</p>
</li>
</ul>
<h3 id="33-java变量分类">3.3 Java变量分类</h3>
<ul>
<li>
<p>按被声明的位置划分:</p>
<ul>
<li>局部变量:方法或语句块内部定义的变量</li>
<li>成员变量:方法外部、类的内部定义的变量</li>
<li>注意:类外面(与类对应的大括号外面)不能有变量的声明</li>
</ul>
</li>
<li>
<p>按所属的数据类型划分:</p>
<ul>
<li>基本数据类型变量</li>
<li>引用数据类型变量</li>
</ul>
</li>
</ul>
<h3 id="34-java局部变量和成员变量">3.4 Java局部变量和成员变量</h3>
<ul>
<li>
<p>方法体内部声明的变量(包括形参)称为局部变量:</p>
</li>
<li>
<p>方法体内部是指与方法对应的大括号内部</p>
</li>
<li>
<p>在方法体外，类体内声明的变量成为成员变量</p>
<pre><code class="language-java">public void method(){
int i;
int j= i+5://编译出错，变量i还未被初始化
double d= 3.14;
Dog dog;
dog = new Dog(22,7,1964);
}
</code></pre>
</li>
</ul>
<h3 id="35-java数据类型划分">3.5 Java数据类型划分</h3>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610124522.png" alt="" loading="lazy"></figure>
<ul>
<li>Java中定义了4类8种基本数据类型。
<ul>
<li>逻辑型一boolean</li>
<li>文本型一char</li>
<li>整数型一byte, short, int, long</li>
<li>浮点数型一float, double</li>
</ul>
</li>
</ul>
<h2 id="4-java数据类型讲解">4、Java数据类型讲解</h2>
<h3 id="41-boolean-布尔型">4.1 boolean--布尔型</h3>
<ul>
<li>
<p>boolean类型适于逻辑运算，一般用于程序流程控制。</p>
</li>
<li>
<p>boolean类型数据只允许取值true或false，不可以0或非0的整数替代true和false，这点和C语言不同。</p>
</li>
<li>
<p>用法举例:</p>
<pre><code class="language-java">boolean flag;
flag = true;
if(f1ag) {
    //do something
}
</code></pre>
</li>
</ul>
<h3 id="42-char-字符型">4.2 char--字符型</h3>
<ul>
<li>
<p>char型数据用来表示通常意义上字符”</p>
</li>
<li>
<p>字符常量为用单引号括起来的单个字符，例如:</p>
<ul>
<li>char eChar = 'a'; char cChar ='中‘；</li>
</ul>
</li>
<li>
<p>Java字符采用Unicode编码，每个字符占两个字节，因而可用十六进制编码形式表示，例如:</p>
<ul>
<li>char c1 =’\u0061';</li>
<li>注: Unicode是全球语言统一编码</li>
</ul>
</li>
<li>
<p>Java语言中还允许使用转义字符\来将其后的字符转变为其它的含义，例如:</p>
<ul>
<li>@ char c2= '\n';
<ul>
<li>'\n'代表换行符</li>
</ul>
</li>
</ul>
</li>
<li>
<p>全球的文字放到计算机里面表示全是0和1，Unicode是统一了全世界国家文字的一种编码方式，用这样的编码可以把全世界国家的文字连接在一起。Unicode编码又分为两种，一种是Utf-8，另一种是Utf-16。JAVA所采用的是Utf-16，每一个字符占2个字节，任何国家的文字放到Unicode里面都是占2个字节。</p>
</li>
</ul>
<h3 id="43-整数类型">4.3 整数类型</h3>
<ul>
<li>
<p>Java各整数类型有固定的表数范围和字段长度，其不受具体操作系统的影响，以保证Java程序的可移植性。</p>
</li>
<li>
<p>Java语言整型常量的:三种表示形式:</p>
<ul>
<li>十进制整数，如: 12, -314, 0。</li>
<li>八进制整数，要求以0开头，如: 012。</li>
<li>十六进制数，要求0x或0X开头，如: 0x12。</li>
</ul>
</li>
<li>
<p>Java语言的整型常量默认为int型，声明long型常 量可以后加工或L’，如1:</p>
<ul>
<li>int i1= 600; //正确 long l1 = 888888888L; l1必须加否则会出错</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610125719.png" alt="" loading="lazy"></figure>
<ul>
<li>C语言编译好的程序为什么不能移植，如把.exe文件放到Linux下是执行不了的，一个很大很大的原因在于C语言定义的变量在不同的操作系统上所占的大小是不一样的，声明一个int类型的变量，在Windows下面占32位，但放到Linux下面就有可能只占16位，那么这时候很可能表示的大小就不一样了，在Windows下声明一个很大的数，在Linux下面很可能就会溢出。因此这就是C语言为什么在编译完成之后不能移植的原因。</li>
</ul>
<h3 id="44-浮点类型">4.4 浮点类型</h3>
<ul>
<li>
<p>与整数类型类似，Java浮 点类型有固定的表数范围和字段长度，不受平台影响。</p>
</li>
<li>
<p>Java浮点类型常量有两种表示形式</p>
<ul>
<li>十进制数形式，例如:3.14</li>
<li>⑥科学记数法形式，如3.14e2  3.14E2  100E2</li>
</ul>
</li>
<li>
<p>Java浮点型常量默认为double型，如要声明一个常量为float型，则需在数字后面加f或F，如:</p>
<ul>
<li>double d= 12345.6; //正确 float f= 12.3f; //必须加f否则会出错</li>
</ul>
</li>
<li>
<p>下面列出Java的各种浮点类型</p>
</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610130037.png" alt="" loading="lazy"></figure>
<h3 id="45-基本数据类型的转换">4.5 基本数据类型的转换</h3>
<ul>
<li>
<p>boolean类型不可以转换为其他的数据类型。</p>
</li>
<li>
<p>整型，字符型，浮点型的数据在混合运算中相互转换，转换时遵循以下原则:</p>
<ul>
<li>容量小的类型自动转换为容量大的数据类型:数据类型按容量大小排序为:
<ul>
<li>byte,short,char-&gt;int-&gt;long-&gt;float-&gt;double</li>
<li>byte,short,char之间不会互相转换， 他们三者在计算时首先回转换为int类型</li>
</ul>
</li>
<li>容量大的数据类型转换为容量小的数据类型时，要加上强制转换符，但可能造成精度降低或溢出:使用时要格外注意。</li>
<li>有多种类型的数据混合运算时，系统首先自动的将所有数据转换成容量最大的那一:种数据类型，然后再进行计算。</li>
<li>实数常量(如: 1.2)默认为double。</li>
<li>整数常量(如: 123) 默认为int。</li>
</ul>
</li>
<li>
<p>类型转换测试</p>
<pre><code class="language-java">public class TestConvert {
    public static void main(String arg[]) {
        int i1 = 123;
        int i2 = 456;
        double d1 = (i1+i2)*1.2;//系统将转换为double型运算
        float f1 = (float)((i1+i2)*1.2);//需要加强制转换符
        byte b1 = 67;
        byte b2 = 89;
        byte b3 = (byte)(b1+b2);//系统将转换为int型运算，需要强制转换符
        System.out.println(b3);
        double d2 = 1e200;
        float f2 = (float)d2;//会产生溢出
        System.out.println(f2);
        float f3 = 1.23f;//必须加f
        long l1 = 123;
        long l2 = 30000000000L;//必须加l
        float f = l1+l2+f3;//系统将转换为float型计算
        long l = (long)f;//强制转换会舍去小数部分（不是四舍五入）
    }
}
</code></pre>
</li>
</ul>
<h2 id="5-运算符">5、运算符</h2>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610130557.png" alt="" loading="lazy"></figure>
<h3 id="51-算数运算符自加和自减运算符">5.1 算数运算符（自加和自减运算符)</h3>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610130722.png" alt="" loading="lazy"></figure>
<h3 id="52-逻辑运算符">5.2 逻辑运算符</h3>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610130816.png" alt="" loading="lazy"></figure>
<h3 id="53-赋值运算符">5.3 赋值运算符</h3>
<figure data-type="image" tabindex="8"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610131019.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p>赋值运算符，就是将符号右边的值，赋给左边的变量。</p>
<pre><code class="language-java">public static void main(String[] args){ 
    int i = 5; 
    i+=5;//计算方式 i=i+5 变量i先加5，再赋值变量i 
    System.out.println(i); //输出结果是10 
}
</code></pre>
</li>
</ul>
<h3 id="54-比较运算符">5.4 比较运算符</h3>
<figure data-type="image" tabindex="9"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610131143.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p>比较运算符，是两个数据之间进行比较的运算，运算结果都是布尔值 true 或者 false 。</p>
<pre><code class="language-java">public static void main(String[] args) { 
    System.out.println(1==1);//true 
    System.out.println(1&lt;2);//true 
    System.out.println(3&gt;4);//false 
    System.out.println(3&lt;=4);//true 
    System.out.println(3&gt;=4);//false 
    System.out.println(3!=4);//true 
}
</code></pre>
</li>
</ul>
<h3 id="55-逻辑运算符">5.5 逻辑运算符</h3>
<figure data-type="image" tabindex="10"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610152457.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p>逻辑运算符，是用来连接两个布尔类型结果的运算符，运算结果都是布尔值 true 或者 false</p>
<pre><code class="language-java">public static void main(String[] args) { 
    System.out.println(true &amp;&amp; true);//true 
    System.out.println(true &amp;&amp; false);//false 
    System.out.println(false &amp;&amp; true);//false，右边不计算 
    System.out.println(false || false);//falase 
    System.out.println(false || true);//true 
    System.out.println(true || false);//true，右边不计算				
    System.out.println(!false);//true 
}
</code></pre>
</li>
</ul>
<h3 id="56-三元运算符">5.6 三元运算符</h3>
<ul>
<li>三元运算符格式：<br>
数据类型 变量名 = 布尔类型表达式？结果1：结果2</li>
<li>三元运算符计算方式：
<ul>
<li>布尔类型表达式结果是true，三元运算符整体结果为结果1，赋值给变量。</li>
<li>布尔类型表达式结果是false，三元运算符整体结果为结果2，赋值给变量。</li>
</ul>
</li>
</ul>
<pre><code class="language-java">public static void main(String[] args) { 
	int i = (1==2 ? 100 : 200); 
    System.out.println(i);//200 
    int j = (3&lt;=4 ? 500 : 600); 
    System.out.println(j);//500 
}
</code></pre>
<h2 id="6-语句">6、语句</h2>
<figure data-type="image" tabindex="11"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610151654.png" alt="" loading="lazy"></figure>
<h3 id="61-条件语句">6.1 条件语句</h3>
<ol>
<li>
<p>if语句</p>
<figure data-type="image" tabindex="12"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610151746.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>分支语句(switch语句)</p>
<figure data-type="image" tabindex="13"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610151816.png" alt="" loading="lazy"></figure>
</li>
</ol>
<figure data-type="image" tabindex="14"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610151831.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="15"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610152413.png" alt="" loading="lazy"></figure>
<h3 id="62-循环语句">6.2 循环语句</h3>
<h4 id="621-for循环语句">6.2.1 for循环语句<img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610151930.png" alt="" loading="lazy"></h4>
<p>学会画内存分析图分析别人写的程序，这样就很容易分析出规律，分析出规律也就明白了别人的算法，也就很容易读懂别人的程序。</p>
<h4 id="622-while循环和do-while循环">6.2.2 while循环和do while循环</h4>
<figure data-type="image" tabindex="16"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610152239.png" alt="" loading="lazy"></figure>
<h4 id="623-break和continue语句">6.2.3 break和continue语句</h4>
<figure data-type="image" tabindex="17"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610152202.png" alt="" loading="lazy"></figure>
<h2 id="7-方法">7、方法</h2>
<ul>
<li>
<p>Java的方法类似于其它语言的函数，是一段用来完成特定功能的代码片段</p>
</li>
<li>
<p>形式参数:在方法被调用时用 于接收外界输入的数据。</p>
</li>
<li>
<p>实参:调用方法时实际传给方法的数据。</p>
</li>
<li>
<p>返回值:方法在执行完毕后返还给调用它的环境的数据。</p>
</li>
<li>
<p>返回值类型:事先约定的返回值的数据类型，如无返回值，必须给出返回值类型void.</p>
</li>
<li>
<p>Java语言中使用下述形式调用方法:对象名方法名(实参列表)</p>
</li>
<li>
<p>实参的数目、数据类型和次序必须和所调用方法声明的形参列表匹配，</p>
</li>
<li>
<p>retun语句终止方法的运行并指定要返回的数据。</p>
</li>
<li>
<p>Java中进行函数调用中传递参数时，遵循值传递的原则:基本类型传递的是该数据值本身。引用类型传递的是对对象的引用，而不是对象本身。</p>
</li>
<li>
<p>方法执行到return语句后，这个方法的执行就结束了，<strong>方法可以有返回值，但可以不用这个返回值</strong>。方法首先要定义，然后才能调用。</p>
<pre><code class="language-java">public class TestMethod{
    public static void main(String args[]){
        m();
        m1(3);
        m2(2,3);
        int i = m3(4,5);
        System.out.println(i);
    }
    //以下定义的都是静态方法，静态方法可以在main()方法里面直接调用
    public static void m(){
            System.out.println(&quot;Hello!&quot;);
            System.out.println(&quot;World!&quot;);
        }

    public static void m1(int i){
            if(i==5){
                    return;
                }
            System.out.println(i);
        }

    public static void m2(int i,int j){
            System.out.println(i+j);
        }

    public static int m3(int i,int j){
            return i+j;
        }
}
</code></pre>
</li>
</ul>
<h2 id="8-变量的作用域">8、变量的作用域</h2>
<ul>
<li>变量的作用域只在“{ }”有效，出了这个“{ }”就没有作用了</li>
</ul>
<h2 id="9-递归调用">9、递归调用</h2>
<ul>
<li>递归：在一个方法内部对自身的调用就称为递归</li>
</ul>
<figure data-type="image" tabindex="18"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610153500.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="19"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610153511.png" alt="" loading="lazy"></figure>
<ul>
<li>范例：使用递归计算第5个斐波那契数列数</li>
</ul>
<pre><code class="language-java">/*计算第5个斐波那契数列数*/
/*
斐波那契数列特点：f(1)=1,f(2)=1,f(3)=f(1)+f(2),f(4)=(f2)+(f3)……依次类推。
即后一个数都是等于前两个数的和，这样的数列就是斐波那契数列。
*/
/*
使用递归调用的方法计算
*/
public class Fab{
    public static void main(String args[]){
        System.out.println(f(5));
    }

    public static int f(int n){
            if(n==1||n==2){
                    return 1;
                }else{
                        return f(n-1)+f(n-2);
                    }
        }
}
</code></pre>
<p>​	整个在内存中执行过程如下图所示</p>
<figure data-type="image" tabindex="20"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610153613.png" alt="" loading="lazy"></figure>
<h2 id="10-程序的执行过程">10、程序的执行过程</h2>
<figure data-type="image" tabindex="21"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610153705.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Intellij IDEA常用快捷键]]></title>
        <id>https://jonchan1013.github.io/post/intellij-idea-chang-yong-kuai-jie-jian/</id>
        <link href="https://jonchan1013.github.io/post/intellij-idea-chang-yong-kuai-jie-jian/">
        </link>
        <updated>2019-01-03T07:17:39.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="️最常用快捷键">✍️最常用快捷键</h3>
<ol>
<li>Alt+回车 导入包,自动修正</li>
<li>Ctrl+N  查找类</li>
</ol>
]]></summary>
        <content type="html"><![CDATA[<h3 id="️最常用快捷键">✍️最常用快捷键</h3>
<ol>
<li>Alt+回车 导入包,自动修正</li>
<li>Ctrl+N  查找类<!-- more -->
</li>
<li>Ctrl+Shift+N 查找文件</li>
<li>Ctrl+Alt+L  格式化代码</li>
<li>Ctrl+Alt+O 优化导入的类和包</li>
<li>Alt+Insert 生成代码(如get,set方法,构造函数等)</li>
<li>Ctrl+E或者Alt+Shift+C  最近更改的代码</li>
<li>Ctrl+R 替换文本</li>
<li>Ctrl+F 查找文本</li>
<li>Ctrl+Shift+Space 自动补全代码</li>
<li>Ctrl+空格 代码提示</li>
<li>Ctrl+Alt+Space 类名或接口名提示</li>
<li>Ctrl+P 方法参数提示</li>
<li>Ctrl+Shift+Alt+N 查找类中的方法或变量</li>
<li>Alt+Shift+C 对比最近修改的代码</li>
<li>Shift+F6  重构-重命名</li>
<li>Ctrl+Shift+先上键</li>
<li>Ctrl+X 删除行</li>
<li>Ctrl+D 复制行</li>
<li>Ctrl+/ 或 Ctrl+Shift+/  注释（// 或者/<em>...</em>/ ）</li>
<li>Ctrl+J  自动代码</li>
<li>Ctrl+E 最近打开的文件</li>
<li>Ctrl+H 显示类结构图</li>
<li>Ctrl+Q 显示注释文档</li>
<li>Alt+F1 查找代码所在位置</li>
<li>Alt+1 快速打开或隐藏工程面板</li>
<li>Ctrl+Alt+ left/right 返回至上次浏览的位置</li>
<li>Alt+ left/right 切换代码视图</li>
<li>Alt+ Up/Down 在方法间快速移动定位</li>
<li>Ctrl+Shift+Up/Down 代码向上/下移动。</li>
<li>F2 或Shift+F2 高亮错误或警告快速定位</li>
<li>代码标签输入完成后，按Tab，生成代码。</li>
<li>选中文本，按Ctrl+Shift+F7 ，高亮显示所有该文本，按Esc高亮消失。</li>
<li>Ctrl+W 选中代码，连续按会有其他效果</li>
<li>选中文本，按Alt+F3 ，逐个往下查找相同文本，并高亮显示。</li>
<li>Ctrl+Up/Down 光标跳转到第一行或最后一行下</li>
<li>Ctrl+B 快速打开光标处的类或方法</li>
<li>Ctrl＋E，可以显示最近编辑的文件列表</li>
<li>Shift＋Click可以关闭文件</li>
<li>Ctrl＋[或]可以跳到大括号的开头结尾</li>
<li>Ctrl＋Shift＋Backspace可以跳转到上次编辑的地方</li>
<li>Ctrl＋F12，可以显示当前文件的结构</li>
<li>Ctrl＋F7可以查询当前元素在当前文件中的引用，然后按F3可以选择</li>
<li>Ctrl＋Shift＋N，可以快速打开文件</li>
<li>Alt＋Q可以看到当前方法的声明</li>
<li>Ctrl＋W可以选择单词继而语句继而行继而函数</li>
<li>Alt＋F1可以将正在编辑的元素在各个面板中定位</li>
<li>Ctrl＋Shift＋Insert可以选择剪贴板内容并插入</li>
<li>Alt＋Insert可以生成构造器/Getter/Setter等</li>
<li>Ctrl＋Alt＋V 可以引入变量。例如把括号内的SQL赋成一个变量</li>
<li>Ctrl＋Alt＋T可以把代码包在一块内，例如try/catch</li>
<li>Alt＋Up and Alt＋Down可在方法间快速移动</li>
</ol>
<p>👨‍💻👨‍💻👨‍💻👨‍💻👨‍💻</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java环境变量配置]]></title>
        <id>https://jonchan1013.github.io/post/java-ji-chu/</id>
        <link href="https://jonchan1013.github.io/post/java-ji-chu/">
        </link>
        <updated>2018-02-05T01:04:05.000Z</updated>
        <summary type="html"><![CDATA[<p>✍️学习java的第一步就要搭建java的学习环境，首先是要安装JDK，JDK安装好之后，还需要在电脑上配置&quot;JAVA_HOME”、&quot;path”、&quot;classpath&quot;这三个环境变量才能够把java的开发环境搭建好。在没安装过jdk的环境下，path环境变量是系统变量，本来存在的，而JAVA_HOME和classpath是不存在的。</p>
]]></summary>
        <content type="html"><![CDATA[<p>✍️学习java的第一步就要搭建java的学习环境，首先是要安装JDK，JDK安装好之后，还需要在电脑上配置&quot;JAVA_HOME”、&quot;path”、&quot;classpath&quot;这三个环境变量才能够把java的开发环境搭建好。在没安装过jdk的环境下，path环境变量是系统变量，本来存在的，而JAVA_HOME和classpath是不存在的。</p>
<!-- more -->
<ol>
<li>
<p>配置JAVA_HOME变量<br>
操作步骤：计算机→右键“属性”→高级系统设置→高级→环境变量，如下图所示：<br>
<img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610095005.png" alt="" loading="lazy"><br>
<img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610095133.png" alt="" loading="lazy"><br>
<img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610095235.png" alt="" loading="lazy"><br>
点击系统变量下面的“【新建】”，弹出一个新建系统变量对话框，首先在变量名写上JAVA_HOME，顾名思义，JAVA_HOME的含义就是JDK的安装路径，，然后在变量值写JDK的安装路径，如这里设置的变量值是&quot;C:\Program Files (x86)\Java\jdk1.8.0&quot;，设置好变量值之后，点击【确定】按钮，JAVA_HOME环境变量就设置完成，如下图所示：系统变量中多了一个&quot;JAVA_HOME&quot;变量</p>
</li>
<li>
<p>配置path环境变量<br>
操作步骤：计算机→右键“属性”→高级系统设置→高级→环境变量<br>
找到系统变量中的Path变量，点击【编辑】按钮，弹出编辑系统变量的对话框，可以看到，Path变量中设置有很多的目录，每个目录之间使用;(分号)隔开,将%JAVA_HOME%\bin;添加到Path变量的变量值中，点击【确定】按钮，Path环境变量的就设置完成了，如下图所示：<br>
<img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610095552.png" alt="" loading="lazy"></p>
</li>
<li>
<p>配置ClassPath变量<br>
设置Classpath的目的，在于告诉Java执行环境，在哪些目录下可以找到您所要执行的Java程序(.class文件)，关于这个ClassPath变量，其实可以不用配置了<br>
<img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610095445.png" alt="" loading="lazy"></p>
</li>
<li>
<p>JAVA_HOME变量、Path变量、ClassPath变量的说明</p>
<ol>
<li>设置JAVA_HOME变量的目的
<ol>
<li>为了方便引用，比如，JDK安装在C:\Program Files (x86)\Java\jdk1.8.0目录里，则设置JAVA_HOME为该目录路径, 那么以后要使用这个路径的时候, 只需输入%JAVA_HOME%即可, 避免每次引用都输入很长的路径串;</li>
<li>归一原则, 当JDK路径被迫改变的时候, 仅需更改JAVA_HOME的变量值即可。</li>
<li>第三方软件会引用约定好的JAVA_HOME变量, 典型的就是tomcat服务器，如果不配置JAVA_HOME变量，那么tomcat服务器根本运行不起来</li>
</ol>
</li>
<li>Path变量(重点说明)<br>
操作系统用path的路径来找可执行程序(.exe程序)，在windows下当我们敲任何一个命令时，实际上就是在执行一个可执行文件，如输入notepad命令就可以打开一个记事本<br>
<img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610100042.png" alt="" loading="lazy"><br>
实际上是执行了c:\Windows下的notepad.exe这个可执行文件，和用鼠标双击notepad.exe后能够打开一个记事本的效果是一样的<br>
<img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610100137.png" alt="" loading="lazy"><br>
当在命令窗口敲一个命令时，系统就会去自动寻找这个命令对应的可执行文件(.exe)，如果这个文件不存在，就当然无法执行这个命令了。这个可执行文件的根目录必须设置在path环境变量中。</li>
<li>在命令窗口显示path设置的环境变量<br>
直接输入“echo %path%”命令就可以显示设置的path环境变量的所有根目录了，只要是根目录里面存在相应的.exe文件，敲入命令时就能执行这个相应的.exe文件。因为notepad.exe所在的Windows目录已经添加到了Path环境变量中了，这就解释了为什么输入命令notepad就可以打开一个记事本，所以前面配置java开发环境时，将%JAVA_HOME%\bin添加到Path变量中的目的就是希望可以在命令行窗口下使用javac和java这两个命令来执行javac.exe和java.exe这两个可执行程序。</li>
<li>Classpath变量说明<br>
使用javac命令编译.java文件时，如果需要其他的类，也是通过classpath去找的，<br>
　　使用java命令执行.class文件时，执行的.class文件是通过classpath去找的。<br>
　　classpath表示的是要查找的类所在的路径。</li>
</ol>
</li>
<li>
<p>用户变量和系统变量的区别<br>
用户变量，顾名思义，是针对某一个特定的用户的，只对特定的用户有效，而系统变量，则对任何用户都有效。</p>
</li>
</ol>
]]></content>
    </entry>
</feed>