<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>Java基础-面向对象 | CY的学习博客</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://jonchan1013.github.io/favicon.ico?v=1591881454940">
<link rel="stylesheet" href="https://jonchan1013.github.io/styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="✍️面向对象的基本思想是，从现实世界中客观存在的事物出发来构造软件系统，并在系统的构造中尽可能运用人类的自然思维方式。
面向对象更加强调运用人类在日常生活的逻辑思维中经常采用的思想方法与原则，如抽象、分类，继承、聚合、多态等。

1、面向对..." />
    <meta name="keywords" content="" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://jonchan1013.github.io">
        <img src="https://jonchan1013.github.io/images/avatar.png?v=1591881454940" class="site-logo">
        <h1 class="site-title">CY的学习博客</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      温故而知新
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://jonchan1013.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">Java基础-面向对象</h2>
            <div class="post-date">2020-06-10</div>
            
            <div class="post-content" v-pre>
              <p>✍️面向对象的基本思想是，从现实世界中客观存在的事物出发来构造软件系统，并在系统的构造中尽可能运用人类的自然思维方式。<br>
面向对象更加强调运用人类在日常生活的逻辑思维中经常采用的思想方法与原则，如抽象、分类，继承、聚合、多态等。</p>
<!-- more -->
<h2 id="1-面向对象一">1、面向对象（一）</h2>
<h3 id="11-面向过程的思想和面向对象的思想">1.1 面向过程的思想和面向对象的思想</h3>
<p>​		面向对象和面向过程的思想有着本质上的区别, <strong>作为面向对象的思维来说，当你拿到一个问题时，你分析这个问题不再是第一步先做什么，第二步再做什么，这是面向过程的思维，你应该分析这个问题里面有哪些类和对象，这是第一点，然后再分析这些类和对象应该具有哪些属性和方法。这是第二点。最后分析类和类之间具体有什么关系，这是第三点。</strong></p>
<p>​		<strong>面向对象有一个非常重要的设计思维：合适的方法应该出现在合适的类里面。</strong></p>
<h3 id="12-简单理解面向对象">1.2 简单理解面向对象</h3>
<p>​		就是在程序里面首先分解出来的应该是注意不再是一步一步的过程了，而是首先考虑在这个问题域里面或者程序里面应该具有有哪些对象，所以从现在开始考虑任何问题脑子里不要再想着我实现这件事我第一步应该干什么，第二步应该干什么，如果这样想，那就是面向过程的思维了。面向对象的思维是，当我碰到这个问题域的时候，碰到这个程序的时候，我首先应该把这个问题里有哪些对象，对象与对象之间有什么关系抽象出来。</p>
<h3 id="13-面向对象的设计思想">1.3 面向对象的设计思想</h3>
<ul>
<li>面向对象的基本思想是，从现实世界中客观存在的事物出发来构造软件系统，并在系统的构造中尽可能运用人类的自然思维方式。</li>
<li>面向对象更加强调运用人类在日常生活的逻辑思维中经常采用的思想方法与原则，如抽象、分类，继承、聚合、多态等。</li>
<li>人在思考的时候，首先眼睛里看到的是一个一个的对象。</li>
</ul>
<h3 id="14-对象和类的概念">1.4  对象和类的概念</h3>
<p>​		对象是用于计算机语言对问题域中事物的描述，<strong>对象通过“属性（attribute）”和“方法（method）”来分别对应事物所具有的静态属性和动态属性</strong>。</p>
<p>​		<strong>类是用于描述同一类的对象的一个抽象的概念，类中定义了这一类对象所具有的静态属性和动态属性</strong></p>
<p>​		<strong>类可以看成一类对象的模板，对象可以看成该类的一个具体实例</strong>。</p>
<p>​		<strong>eg.什么叫瓶子？</strong></p>
<p>​		瓶子的定义：具有某些类特征的东西就是瓶子，比分说什么样的形状，比方说有个口，能倒水，能装水，一般有个盖等等。给瓶子下定义的过程，其实就是把瓶子里的某些东西抽象出来了，所以瓶子在这里是叫做一类事物的一个抽象，在你脑子里有瓶子的概念，可瓶子的概念在你脑子里到底是什么呢？瓶子的概念在你脑子里叫做一类事物的一个抽象。怎么抽象的呢？你往往抽象的是这两个方面：第一个方面我们叫它静态的属性，瓶子应该具有哪些特征，比分说瓶子应有个口，这是它的具有的一个静态属性，瓶子一般有一个盖，这也是它的具有一个静态属性，除此之外，你还可能给它总结动态的属性，什么动态的属性呢？比放说瓶子能倒水，这是它的动态属性。瓶子这个概念在你脑子里如果你细细的思维的话，其实你给它做了两方面的总结，一方面是静态的，一方面是动态的。反映到JAVA的类上，一个就是成员变量（静态属性），一个就是方法（动态属性）方法是可以执行的，可以动的。成员变量是某一个类的静态属性。所以你脑子里瓶子的概念实际上是一类事物的一个抽象，这种东西我们叫它类，椅子是类，桌子是类，学生是类。什么是对象呢？这一类事物的具体的某个实例就叫做对象。所以<strong>一类事物的具体的某一个东西，符合这类事物具体的特征的某个东西就叫做对象</strong>。瓶子是一个类，某个瓶子就是瓶子这个类里面的一个对象。</p>
<h3 id="15-如何抽象出一个类">1.5 如何抽象出一个类？</h3>
<p>​		有两个方面，一方面是它的静态属性，另一方面是它的动态属性。反映到JAVA里面的类怎么包装它呢？一方面成员变量，另一方面是方法。</p>
<p>​		eg.职员这个类该怎么抽象出来？也是从两个方面，一方面是它的静态属性，另一方面它的动态属性</p>
<p>​		职员有哪些属性呢？有姓名，年龄，目前工资数额等属性，他有哪些方法呢？让这个职员来显示姓名，显示年龄，修改姓名，领取工资。当然显示姓名，显示年龄，修改姓名，领取工资这些也可以让别人来做，但<strong>面向对象的设计思维是最合适的方法应该出现在最合适的类里面</strong>。显示姓名，显示年龄，修改姓名，领取工资由谁来做更合适呢，那就是职员自己最合适。所以这些方法应该出现在职员这个类里面。</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610155239.png" alt="" loading="lazy"></figure>
<p>​		对于类来说，它有一些属性或者称为成员变量，以后说属性或者成员变量指的是同一回事。具体的对象他有没有相关的一些属性或者叫成员变量呢？有，每一个人都有一份，只不过是取值不同而已。如从职员这个类实例化出来的两个职员：职员A和职员B，他们都有姓名，年龄，目前工资数额这些属性，但他们的名字，年龄，领取的工资数额都不一样。这样就能把职员A和职员B区分开来了，正是因为他们的属性值不一样，所以这个对象才能和另外的对象区分开来，<strong>所以通过属性是可以区分两个对象的</strong>。猫是一个类，这只猫是一个对象，这只猫和另外一只猫该怎么区分开来呢？那就得看你的猫这个类是怎么定义的了，猫有猫毛，毛有颜色。OK，这只猫是黑猫，另一只猫是白猫，这样通过猫毛的颜色区分开来了。如果只定义一个，如捉老鼠，白猫也能捉，黑猫也能捉，这样就没办法区分出黑猫和白猫了，所以<strong>根据方法是没办法区分两个对象的</strong>。所以<strong>每个对象都有自己的属性，属性值和另外一个对象一般是不一样的</strong>。</p>
<p>​		一定要区分类和对象，什么叫做类？什么叫做对象？类是一类事物的一个抽象，具有共同特征的一类事物的一个抽象。对象是这个类具体的某一个实例，所以以后说实例（instance）或者说对象（object）指的是同一回事。</p>
<h3 id="16-类对象之间的关系">1.6 类（对象）之间的关系</h3>
<h4 id="161-关联关系最弱的一种关系">1.6.1 关联关系(最弱的一种关系)</h4>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610155402.png" alt="" loading="lazy"></figure>
<p>​		类和类之间是有关系的，如学生和老师这两个类，老师可以教学生，学生可以向老师学习。这就是他们之间的关系。关系和关系之间是不同的，你和你老婆的关系和你和你其他女朋友的关系是不能混为一谈的。关系最弱的一种关系叫关联关系。关联关系反应到代码上往往是一个类的方法里面的参数是另一个类的具体的某一个对象，比如教授教研究生，教哪个研究生，教是教授这个类里面的一个方法，某个研究生是研究生这个类里面的一个具体的对象。<strong>关联关系是最弱的一种关系</strong>，咱们两个类之间有关系，或者两个对象之间有关系，但关系不是很紧密。</p>
<h4 id="162-继承关系比较强的一种关系">1.6.2 继承关系（比较强的一种关系）</h4>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610155535.png" alt="" loading="lazy"></figure>
<p>​		<strong>继承关系封装了这样一种逻辑：“XX是一种XX”，只要这东西能说通了，就可以考虑用继承关系来封装它</strong>。如：游泳运动员从运动员继承，游泳运动员是一种运动员，这能说得通，所以游泳运动员就是从运动员继承过来的，游泳运动员和运动员就是一种继承关系。学生是一个人，学生从人继承，老师是一个人，老师也从人继承，学生是一种老师，这说不通，所以学生和老师就不存在继承关系。所以将来做设计的时候要分清继承关系很简单，你只要说通这么一句话：“XX是一种XX”。OK，那他们之间就是继承关系。篮球运动员是一种球类运动员，这说得通，所以篮球运动员从球类运动员继承，这样继承很有可能会产生一棵继承树，运动员派生出来，派生出来的意思是游泳运动员这个类、球类运动员这个类、射击运动员类从它继承，相当于运动员派生出来了这些个不同的运动员，包括游泳的，球类的，射击的。球类的再派生足球的，篮球的，排球的。这就是一棵继承树，不过这棵树是比较理想化的情况，只有一个根节点。但实际当中，我们真实世界当中的继承关系不一定只从一个类继承，一个类可能从多个类继承过来，比如说：金丝猴从动物这个类继承，这很正常，但我还有另外一个专门的类：“应该受到保护的东西”，这也是一个类，金丝猴应该受到保护，所以金丝猴是一种应该受到保护的东西。所以金丝猴从“应该受到保护的东西”这个类继承过来。所以在现实情况当中，一个类完完全全有可能从多个不同的类继承，C++正是因为想封装这种继承关系，所以C++存在多重继承。</p>
<h4 id="163-聚合关系整体和部分比较强的一种关系">1.6.3 聚合关系（整体和部分）（比较强的一种关系）</h4>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610155626.png" alt="" loading="lazy"></figure>
<p>​		什么是聚合？<strong>聚合就是一个整体与部分的关系</strong>。我们说**“XX是XX的一部分”，只要说得通，那么他们之间的关系就是聚合关系**，队长是球队的一部分，队员是球队的一部分。所以队长和球队是聚合关系，队员和球队也是聚合关系。脑袋是人的以部分，身体和胳膊也是人的一部分，因此脑袋，身体和胳膊与人都是聚合关系。<strong>聚合关系分得再细一点的话就可以分成聚集关系和组合关系</strong>，比如球队、队长，队员，这三者是聚集关系，假如这个队长既是足球的队长，同时也是篮球的队长，一个人分属两个不同的球队，这是可以的，球队与队长之间没有我离不了你，你离不了我这种情况，所以如果分得更细的话，这种就叫做聚集关系。还有一种情况叫组合，组合说的是咱们俩密不可分，我是你必不可少的一部分。一个人的脑袋不可能既属于你又属于别人，身体也一样，不可能既属于你又属于别人。所以你的身体，脑袋和你是密不可分的，这是一种更加严格的聚合关系，专门给它取了个名字叫组合。</p>
<h4 id="164-实现关系">1.6.4 实现关系</h4>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610155715.png" alt="" loading="lazy"></figure>
<p>​		**作为父类来说，我觉得我应该具有这样一个方法，但我不知道怎么去实现，谁去实现，我的子类去实现，这就是实现关系。**和实现关系息息相关的还有一种关系叫多态。</p>
<h4 id="165-多态">1.6.5 多态</h4>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610155757.png" alt="" loading="lazy"></figure>
<h3 id="17-java与面向对象">1.7 Java与面向对象</h3>
<pre><code>	对象和类是分不开的，必须首先定义类才能有对象。首先定义方法才能调用。对象是JAVA里面的核心，做任何东西你首先都得给我造出一个对象才能做。静态属性简称属性，也叫成员变量，以后说属性或者说成员变量它们指的都是同一回事。
</code></pre>
<p>整个类可以看作是静态的属性还有方法他们之间的一个综合。怎么抽象出一个类的概念，还是那句话，你必须抽象出两个方面来，第一方面是看他们的静态属性，他们有哪些成员变量，第二方面是看他们的有哪些方法。</p>
<p>写JAVA程序时，我们一上来写的就是public class（声明一个类），在这个class里面我们写的是成员变量和方法。</p>
<p><strong>每一个JAVA里面的class（类）都对应了我们现实生活中某一类事物的一个抽象</strong>。比如说要在JAVA里面封装一只狗，具体怎么封装，如何写代码，代码如下：</p>
<pre><code class="language-java">/**
 * 一类事物封装到JAVA里面首先得写class，定义这个类，类名是什么可以自己取。
 * 这里把类名叫做Dog
 */
public class Dog {
    /**
     * 接下来就是写这个狗这个类的属性或者叫成员变量，
     * 比如说狗这个类的毛的颜色，怎么定义这个属性呢，
     * 首先得定义毛的一个类型,如使用int来定义毛的颜色类型
     */
    int furcolor; //定义属性：毛的颜色
    float height; //定义属性：狗的高度
    float weight; //定义属性：狗的体重

    /**
     * 狗的颜色，高度，体重这些属性定义完了，接下来要定义的就是方法了。
     * 如写一个CatchMouse（）方法，捉老鼠的方法。
     * CatchMouse这个方法里面有一个对象类型的参数，捉哪一只老鼠，这个对象参数是属于Mouse这个类的
     * @param m
     */
    void CatchMouse(Mouse m){
            //在方法体内写捉老鼠这个过程，怎么捉，跑着捉，走着捉
            System.out.println(&quot;我捉到老鼠了，汪汪！，老鼠要尖叫了！&quot;);
            /**
             * 老鼠尖叫一声，表示被狗咬到了，咬到了能不叫吗，很自然而然地想到，
             * 尖叫（scream()）这个方法是属于Mouse这个类里面的某一个方法。
             * 老鼠自己调用它，让它自己尖叫。这就是面向对象的思维。
             */
            m.scream();
    }

    public static void main(String[] args) {
        Dog  d = new Dog();//首先用new关键字创建一只狗
        Mouse m=new Mouse();//造出一只老鼠。
        d.CatchMouse(m);//然后用这只狗去抓老鼠，让狗调用CatchMouse()方法去捉某只老鼠。
    }
}
</code></pre>
<p>​		从这个意义上来讲，JAVA里面的每定义一个类实际上就相当于一种新的数据类型。就跟int ，float， String等一样，不过是一种新定义的类型而已。</p>
<h3 id="18-为什么使用面向对象编程">1.8 为什么使用面向对象编程？</h3>
<p>​		面向对象编程：一组对象互相配合通过沟通完成特定功能</p>
<p>做软件苦苦追求的一种境界是可重用性（reusable），可扩展性。如果是面向过程，一般情况是属性和方法它们是分开的，他们不是聚合的关系，不是合在一起的，这样要复用起来比较麻烦，复用的层次只是局限于方法这个层次上，而面向对象则不同，它是把属性和方法综合在一个里面。综合在一起复用的时候是整个对象进行复用。所以面向对象和面向过程相比，前者更加容易让我们达到可重用性。</p>
<h2 id="2-java面向对象二">2、Java面向对象（二）</h2>
<h3 id="21-java类的定义">2.1 Java类的定义</h3>
<pre><code class="language-java">//用class关键字定义一个类
class Person{
    private int id;
    private int age = 20;
    //方法的定义
    public int getAge(){
        return age;
    }
    public void setAge(int i){
        age = i;
    }
    public int getId(){
        return id;
    }
}
</code></pre>
<ul>
<li>
<p>类的定义主要有两方面组成一成员变量和方法。</p>
</li>
<li>
<p>声明成员变量的格式为: [&lt; modifiers&gt;] type &lt; attr_name&gt;[=defaultValue] ;<br>
例如:  private int id;    private int age = 20;</p>
</li>
<li>
<p>声明方法的格式为:<br>
[&lt; modifiers&gt;)] &lt; modifiers&gt; &lt;return_ type&gt; <name>([&lt; argu list&gt;]) {<br>
[&lt; statements&gt;]<br>
}    例如: public int getAge() {return age;}</p>
<p>​		JAVA里面有<strong>class</strong>关键字定义一个类，后面加上自定义的类名即可。如这里定义的person类，使用class person定义了一个person类，然后在person这个类的类体里面定义person这个类应该具有的成员变量（即属性）和方法，如这里定义的int id和int age这个两个成员变量，或者叫属性，这个id表示人的身份证号码，人应该具有这个属性，age表示人的年龄，这也是人应该具有的。这样就在person这个类里面定义了两个人应该有的属性，接下来就是定义方法了，这里定义了三个方法，分别是getAge()、setAge(int i)和getId()，分别用来获取人的年龄，设置人的年龄，获取人的id，getAge()方法获取了人的年龄后，将获取到的值返回，所以使用了return age语句，getId()方法也使用了return id语句用于返回获取到的id的值。</p>
</li>
</ul>
<h3 id="22-成员变量">2.2 成员变量</h3>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610160936.png" alt="" loading="lazy"></figure>
<p>**在JAVA里面的任何变量首先应该要声明，然后再赋值，然后再使用。**成员变量和局部变量有一个重要区别：<strong>成员变量在类里面声明时如果不进行初始化，那么JAVA会默认给它初始化，而局部变量JAVA不会默认给它初始化，所以在方法里面声明一个局部变量如果不给它初始化时就会出错</strong>。默认初始化大多数都是0，boolean类型的为false，引用类型的为null，如过不记得JAVA对成员变量默认的初始化是多少的话，那就这样做，定义一个成员变量，不给它初始化，然后直接打印这个成员变量，打印出来的结果就是JAVA默认的初始化的值。</p>
<h3 id="23-java面向对象的基本概念引用">2.3 Java面向对象的基本概念——引用</h3>
<figure data-type="image" tabindex="8"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610161110.png" alt="" loading="lazy"></figure>
<p>​		<strong>引用类型和基本类型有着巨大的区别</strong>，当声明一个int i=0时，系统会马上给这个i分配一个内存空间（在栈内存里面分配一小块区域用来装数字0），里面装着一个值为0，以后使用i这个名字马上就可以访问这个内存空间里面的值，这就是基本数据类型，所以<strong>基础类型就只占一块内存</strong>。基础类型之外的类型全都叫引用类型，我们定义一个Mouse m，这个m就是一个引用类型的数据。引用类型有什么重要的特征——<strong>引用类型占<strong><strong>2</strong></strong>块内存</strong>。我们定义好这个类之后，需要使用new关键字把这个类的对象实例化出来，也就是真真正正造出一个对象出来才能使用这个对象。</p>
<p><strong>如何在内存中区分类和对象</strong></p>
<p>类是静态的概念，是位于代码区里面。对象是new出来的，它是位于堆内存，为什么对象要位于堆内存？因为堆内存是用来动态分配内存的，只有在运行当中才会new一个对象放堆内存里面，那这个对象到底有多大个，这个东西你不知道，你没有办法提前知道，所以你没有办法提前分配内存给这个对象，你只有在运行期间才能去分配它。什么叫运行期间？敲JAVAC这个命令那是在编译期间，编译完成后再敲JAVA命令，那就是运行期间了。只有在运行期间，才能够明白这个对象到底要分配多大的空间给它，所以把它放在堆内存里面，堆内存比较大，动态分配内存用它。如果这个对象不用了，那它就是垃圾，那么就等着垃圾收集器把它收集回去，释放掉占用的内存。</p>
<p>​		记住，<strong>以后一提到引用，脑子里马上浮现引用那就是一小块内存指向一大块内存。</strong></p>
<h3 id="24-对象的创建和使用">2.4 对象的创建和使用</h3>
<ul>
<li>必须使用new关键字创建对象。</li>
<li>使用对象(引用) .成员变量或来引用对象的成员变量。</li>
<li>使用对象(引用) .方法(参数列表)来调用对象的方法。</li>
<li>同一类的每个对象有不同的成员变量存储空间。</li>
<li>同一类的每个对象共享该类的方法。</li>
</ul>
<h3 id="25-类和对象的关系">2.5 类和对象的关系</h3>
<figure data-type="image" tabindex="9"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610162714.png" alt="" loading="lazy"></figure>
<p><strong>在内存中分析类和对象的关系</strong></p>
<p>假设这里有一个类C，我们定义了一个类class C，然后在这个类里面定义了两个成员变量: int i和int j。定义好了这两个成员变量以后，我们写了一个main()方法（public static void main(Strng[] args)），程序开始执行。第一句我们写了 C c1 = new C()，这句的代码是我们相当于在堆内存里创建了一个对象，同时也创建了这个对象的一个引用对象c1，c1位于栈内存中，c1这个引用对象指向堆中一大块内存，这一大块内存里面装着new出来的那个对象。这里面我们一般来说是new出来两个对象c1和c2，当然，实际上，严格来讲，c1和c2叫做对象的引用，有时候，简称new出来了两个对象，c1和c2。你脑子里马上要浮现出两块内存，c1指向一块，c2指向一块。局部变量是分配在栈内存里面的，main方法里面的c1和c2都是局部变量，所以在栈里面分配了两小块内存出来，一块是c1的，一块是c2的，c1这块内存里面装着一个值，或者叫装着一个地址，这个地址是什么，我们不知道，我们只知道根据这个值就能找到new出来的C这个类里面的一个对象，而在这个对象里面有它自己的成员变量i和j，里面的两小块内存是分别用来装i和j的值的，因为每一个对象都有自己不同的成员变量的值，所以c1指向的那块对内存里面又分成一小块一小块内存，每一个小块的内存都装着这个对象的成员变量（或者叫属性）。如这里的第一小块装着i的值，第二小块装着j的值，所以当我们去访问第一小块里面装着的成员变量时，我们应该这样写：c1.i，这样就拿到了i的值，c1.j，这样就拿到了j的值。同理，c2这个对象也指向了一个new出来的C这个类里面的另一个对象，这个对象也有成员变量i和j，只不过和c1指向的那个对象里的i和j的值不同而已。要访问这个这个对象的成员变量时 ，也是要c2.i，c2.j这样去访问。</p>
<h3 id="26-构造方法">2.6 构造方法</h3>
<ul>
<li>
<p>使用new+构造方法创建-一个新的对象。</p>
</li>
<li>
<p>构造函数是定义在Java类中的一个用来初始化对象的函数。</p>
</li>
<li>
<p>构造函数与类同名且没有返回值。</p>
</li>
<li>
<p>例如: Person 类的构造函数:</p>
<pre><code class="language-java">public class Person(){
    int id;
    int age;
    Person(int n,int i){
        id = n;
        age = i;
    }
}
</code></pre>
<p>在面向对象里面有一个特殊的方法，叫构造方法。</p>
<p>构造方法是用来创建一个新的对象的，与new组合在一起用，使用new+构造方法创建一个新的对象。你new一个东西的时候，实际上你调用的是一个构造方法，构造方法就是把自己构造成一个新的对象，所以叫构造方法，构造一个新对象用的方法叫构造方法。</p>
<p>构造方法比较特殊，构造方法的名字必须和类的名字完全一模一样，包括大小写，并且没有返回值。如原来定义的一个person类，在类里面声明了两个成员变量id与age，这时候你可以再为这个person类定义一个它的构造方法person(int n，int i)，这个方法的名字和类名完全相同，并且没有返回值，也就是在这个方法前面不能写任何的方法的返回类型修饰符，连void都不可以写。</p>
</li>
<li>
<p>构造方法范例：</p>
<pre><code class="language-java">public class Person {
    int id;  //在person这类里面定义两个成员变量id和age,
    int age=20;  //给成员变量age赋了初值为20

    /**这里就是person这个类的一个构造方法
     * 构造方法的规则很简单，和类名要完全一样，一点都不能错，包括大小写。
     * 并且没有返回值，不能写void在它前面修饰
     * @param _id
     * @param _age
     */
    public Person(int _id,int _age ) {
        id = _id;
        age = _age;
    }
}
</code></pre>
<p>​		构造方法写好后就和new组合在一起使用，new的作用是构建一个新对象，创造一个新对象，所以new的时候实际当中调用的是构造方法。只有调用了这个构造方法才能构造出一个新的对象。例如：</p>
<pre><code class="language-java">public static void main(String[] args) {
    Person tom = new Person(1, 25); // 调用person这个构造方法创建一个新的对象，并给这个对象的成员变量赋初始值
}
</code></pre>
</li>
</ul>
<figure data-type="image" tabindex="10"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610161822.png" alt="" loading="lazy"></figure>
<p>​	<strong>下面是在main方法里面调用person构造方法时的内存分析情况：</strong></p>
<figure data-type="image" tabindex="11"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610161855.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610161922.png" alt="" loading="lazy"></figure>
<p>​		<strong>当方法调用完成之后，栈里面为它分配的空间全部都要消失，即把这个方法调用时分配给它的内存空间释放出来</strong>，所以这个构造方法person调用完成之后，栈内存里面分配的两小块内存_id和_age自动消失了。这样就把它们所占的空间让了出来，让其他的方法去占用。而new出来的对象则永远留在了堆内存里面。</p>
<figure data-type="image" tabindex="13"><img src="https://gitee.com/chenyong1013/picCloud/raw/master/20200610162016.png" alt="" loading="lazy"></figure>
<p>​		<strong>声明一个类，若没有在类中指定其构造方法（构造函数）时，编译器会为这个类自动添加形如类名( ){ }的构造函数。</strong></p>
<p><strong>如：</strong></p>
<pre><code class="language-java">class  point{//这里声明一个类时并没有给它指定其构造方法。
     int  x;
     int  y;
}
</code></pre>
<p>​		但在main方法里面我们却可以这样使用：</p>
<pre><code class="language-java">public static void main(String[] args){
     point  p = new  point();
}
</code></pre>
<p>​		这里这样写是可以的，当没有给这个类指明构造方法时，系统会默认地给这个类加上point ( ) { }这样一个空的构造方法。所以才可以在main方法中使用point p = new point(); 实际上你调用的就是编译器默认给它加上的point ( ) { }这个构造方法，在这个构造方法当中，默认地把类里面的成员变量x和y初始值设为0。正是因为系统给它默认加上这么一个构造方法，所以才能在main方法里面调用。但<strong>要记住一点，一旦给这个类里面指定了构造方法，那么系统就不会再给这个类添加构造方法了</strong>。</p>

            </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://jonchan1013.github.io/post/java-ji-chu-ji-chu-yu-fa/">
                  <h3 class="post-title">
                    Java基础-基础语法
                  </h3>
                </a>
              </div>
            

            
              
                <div id="gitalk-container" data-aos="fade-in"></div>
              

              
            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>


  <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad()
  </script>




  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: '',
        owner: '',
        admin: [''],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
