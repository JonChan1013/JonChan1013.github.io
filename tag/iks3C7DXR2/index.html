<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="个人博客">
<meta name="description" content="温故而知新">
<meta name="theme-color" content="#000">
<title>CY的学习博客</title>
<link rel="shortcut icon" href="/favicon.ico?v=1598602111745">
<link rel="stylesheet" href="/media/css/gemini.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/dracula.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">

<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>




<script>
  var _hmt = _hmt || [];
  (function () {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?718cd0a1aa37be48b7f50ac936d8fdf6";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>


</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="gemini">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>CY的学习博客</span>
            </a>  
          
        </div>
        
          <p class="subtitle">精于心，简于形</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/archives/" target="_self">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/post/about/" target="_self">
                  <i class="fa fa-user"></i> 关于
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tags/" target="_self">
                  <i class="fa fa-tags"></i> 标签
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> 友情链接
                  
                </a>
              </li>
            
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout  gemini">
      <div class="section-layout-wrapper">
        <div id="sidebarMeta" class="sidebar">
    
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">CY</p>
    
    <div class="site-description right-motion">
      
        <p id="binft">昨夜西风凋碧树。独上高楼，望尽天涯路。|\n衣带渐宽终不悔，为伊消得人憔悴。|\n众里寻他千百度。蓦然回首，那人却在，灯火阑珊处。|</p>
      
    </div>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">36</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">39</span>
        <span class="site-item-stat-name language" data-lan="category">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">39</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
    
      <div class="sidebar-item">
        <span class="site-item-rss">
            <i class="fa fa-rss"></i>
            <a href="https://jonchan1013.github.io/atom.xml" target="_blank">RSS</a>
        </span>
      </div>
    
  
  
    <div class="sidebar-item sidebar-item-social">
      <div class="social-item">
        
          
            <a href="">
              <i class="fa fa-globe" title=""></i>
            </a>
          
        
        
          
            <a class="social-img" href="#">
              <img src="\media\images\custom-array-imgSocials-1592076557214-socialImg.JPG" />
              <i class="fa fa-globe" title="QQ" ></i>
            </a>
          
        
      </div>
    </div>
  



  <div style="width: 100%; position: relative;">
    <canvas id="canvasDiyBlock" style="width:100%;">当前浏览器不支持canvas，请更换浏览器后再试</canvas>
    <script src="/media/js/magic/clock.js"></script>
  </div>

</div>
</div>
<script>
  let sidebarMeta = document.querySelector('#sidebarMeta');
  let scheme = 'gemini';
  let sidebarWrapper = document.querySelector('.sidebar-wrapper');
  if (sidebarMeta && (scheme === 'pisces' || scheme === 'gemini')) {
    document.addEventListener('scroll', function(e) {
      if (document.scrollingElement.scrollTop > parseInt(sidebarMeta.style.marginTop) + 10) {
        sidebarWrapper.classList.add('home-sidebar-fixed')
      } else {
        sidebarWrapper.classList.remove('home-sidebar-fixed')
      }
    });
  }
  </script>
        <div class="section-box tag-line box-shadow-wrapper">
          <section class="section tags-section posts-expand bg-color">
            <div class="padding-wrapper">
  <div class="tag-timeline-box">
    <div class="tag-timeline-wrapper">
      <div class="tag-timeline-title">
        <h2>
          继承
          <small class="language" data-lan="tag">标签</small>
        </h2>
      </div>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <a href="https://jonchan1013.github.io/post/java-ji-chu-mian-xiang-dui-xiang/">
        <div class="motion-warpper">
          <div class="tag-post-node">
            <h1>
              06-10
              <small>Java基础总结-面向对象</small>
            </h1>
          </div>
        </div>
      </a>
      
      
      
      
      
      
      
      
      
      
      
      
      
    </div>
  </div>
</div>
          </section>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <div class="copyright">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | © 2019-2020 Theme By <a
        href="https://github.com/hsxyhao/gridea-theme-next" target="_blank">HsxyHao</a>
    </div>
    <div class="poweredby">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
  </footer>
  
  
  <div class="gemini back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
  
  
<link rel="stylesheet" href="/media/live2d/css/live2d.css" />
<div class="box-scale">
  <div id="landlord" style="left: 5px;bottom: px;"
    data-key="">
    <canvas id="live2d" width="500" height="560" class="live2d"></canvas>
    

      <div class="message" style="opacity:0"></div>
      <div class="live_talk_input_body">
        <div class="live_talk_input_name_body">
          <input name="name" type="text" class="live_talk_name white_input" id="AIuserName" autocomplete="off"
            placeholder="你的名字" />
        </div>
        <div class="live_talk_input_text_body">
          <input name="talk" type="text" class="live_talk_talk white_input" id="AIuserText" autocomplete="off"
            placeholder="要和我聊什么呀？" />
          <button type="button" class="live_talk_send_btn" id="talk_send">发送</button>
        </div>
      </div>
      <input name="live_talk" id="live_talk" value="1" type="hidden" />
      <div class="live_ico_box">
        <div class="live_ico_item type_info" id="showInfoBtn"></div>
        <div class="live_ico_item type_talk" id="showTalkBtn"></div>
        
        <div class="live_ico_item type_youdu" id="youduButton"></div>
        <div class="live_ico_item type_quit" id="hideButton"></div>
        <input name="live_statu_val" id="live_statu_val" value="0" type="hidden" />
        <audio src="" style="display:none;" id="live2d_bgm" data-bgm="0" preload="none"></audio>
        <input id="duType" value="douqilai" type="hidden">
        
      </div>
    
  </div>
</div>
<div id="open_live2d">召唤看板娘</div>
<script src="https://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>
<script>
  var message_Path = 'https://cdn.jsdelivr.net/gh/hsxyhao/live2d.github.io@master/';
  let landlord = document.querySelector('#landlord');
  var apiKey = landlord.dataset.key;
</script>
<script type="text/javascript" src="/media/live2d/js/live2d.js"></script>
<script>
	var home_Path = document.location.protocol + '//' + window.document.location.hostname + ":" + window.document.location.port + '/';
	var userAgent = window.navigator.userAgent.toLowerCase();
	var norunAI = ["android", "iphone", "ipod", "ipad", "windows phone", "mqqbrowser", "msie", "trident/7.0"];
	var norunFlag = false;

	for (var i = 0; i < norunAI.length; i++) {
		if (userAgent.indexOf(norunAI[i]) > -1) {
			norunFlag = true;
			break;
		}
	}

	if (!window.WebGLRenderingContext) {
		norunFlag = true;
	}

	if (!norunFlag) {
		var hitFlag = false;
		var AIFadeFlag = false;
		var liveTlakTimer = null;
		var sleepTimer_ = null;
		var AITalkFlag = false;
		var talkNum = 0;
		(function () {
			function renderTip(template, context) {
				var tokenReg = /(\\)?\{([^\{\}\\]+)(\\)?\}/g;
				return template.replace(tokenReg, function (word, slash1, token, slash2) {
					if (slash1 || slash2) {
						return word.replace('\\', '');
					}
					var variables = token.replace(/\s/g, '').split('.');
					var currentObject = context;
					var i, length, variable;
					for (i = 0, length = variables.length; i < length; ++i) {
						variable = variables[i];
						currentObject = currentObject[variable];
						if (currentObject === undefined || currentObject === null) return '';
					}
					return currentObject;
				});
			}

			String.prototype.renderTip = function (context) {
				return renderTip(this, context);
			};

			var re = /x/;
			re.toString = function () {
				showMessage('哈哈，你打开了控制台，是想要看看我的秘密吗？', 5000);
				return '';
			};

			$(document).on('copy', function () {
				showMessage('你都复制了些什么呀，转载要记得加上出处哦~~', 5000);
			});

			function initTips() {
				$.ajax({
					cache: true,
					url: message_Path + 'message.json',
					dataType: "json",
					success: function (result) {
						$.each(result.mouseover, function (index, tips) {
							$(tips.selector).mouseover(function () {
								var text = tips.text;
								if (Array.isArray(tips.text)) text = tips.text[Math.floor(Math.random() * tips.text.length + 1) - 1];
								text = text.renderTip({ text: $(this).text() });
								showMessage(text, 3000);
								talkValTimer();
								clearInterval(liveTlakTimer);
								liveTlakTimer = null;
							});
							$(tips.selector).mouseout(function () {
								showHitokoto();
								if (liveTlakTimer == null) {
									liveTlakTimer = window.setInterval(function () {
										showHitokoto();
									}, 15000);
								};
							});
						});
						$.each(result.click, function (index, tips) {
							$(tips.selector).click(function () {
								if (hitFlag) {
									return false
								}
								hitFlag = true;
								setTimeout(function () {
									hitFlag = false;
								}, 8000);
								var text = tips.text;
								if (Array.isArray(tips.text)) text = tips.text[Math.floor(Math.random() * tips.text.length + 1) - 1];
								text = text.renderTip({ text: $(this).text() });
								showMessage(text, 3000);
							});
							clearInterval(liveTlakTimer);
							liveTlakTimer = null;
							if (liveTlakTimer == null) {
								liveTlakTimer = window.setInterval(function () {
									showHitokoto();
								}, 15000);
							};
						});
					}
				});
			}
			initTips();

			var text;
			if (document.referrer !== '') {
				var referrer = document.createElement('a');
				referrer.href = document.referrer;
				text = '嗨！来自 <span style="color:#0099cc;">' + referrer.hostname + '</span> 的朋友！';
				var domain = referrer.hostname.split('.')[1];
				if (domain == 'baidu') {
					text = '嗨！ 来自 百度搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				} else if (domain == 'so') {
					text = '嗨！ 来自 360搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				} else if (domain == 'google') {
					text = '嗨！ 来自 谷歌搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				}
			} else {
				if (window.location.href == home_Path) { //主页URL判断，需要斜杠结尾
					var now = (new Date()).getHours();
					if (now > 23 || now <= 5) {
						text = '你是夜猫子呀？这么晚还不睡觉，明天起的来嘛？';
					} else if (now > 5 && now <= 7) {
						text = '早上好！一日之计在于晨，美好的一天就要开始了！';
					} else if (now > 7 && now <= 11) {
						text = '上午好！工作顺利嘛，不要久坐，多起来走动走动哦！';
					} else if (now > 11 && now <= 14) {
						text = '中午了，工作了一个上午，现在是午餐时间！';
					} else if (now > 14 && now <= 17) {
						text = '午后很容易犯困呢，今天的运动目标完成了吗？';
					} else if (now > 17 && now <= 19) {
						text = '傍晚了！窗外夕阳的景色很美丽呢，最美不过夕阳红~~';
					} else if (now > 19 && now <= 21) {
						text = '晚上好，今天过得怎么样？';
					} else if (now > 21 && now <= 23) {
						text = '已经这么晚了呀，早点休息吧，晚安~~';
					} else {
						text = '嗨~ 快来逗我玩吧！';
					}
				} else {
					text = '欢迎阅读<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				}
			}
			showMessage(text, 12000);
		})();

		liveTlakTimer = setInterval(function () {
			showHitokoto();
		}, 15000);

		function showHitokoto() {
			if (sessionStorage.getItem("Sleepy") !== "1") {
				if (!AITalkFlag) {
					$.getJSON('https://v1.hitokoto.cn/', function (result) {
						talkValTimer();
						showMessage(result.hitokoto, 0);
					});
				}
			} else {
				hideMessage(0);
				if (sleepTimer_ == null) {
					sleepTimer_ = setInterval(function () {
						checkSleep();
					}, 200);
				}
			}
		}

		function checkSleep() {
			var sleepStatu = sessionStorage.getItem("Sleepy");
			if (sleepStatu !== '1') {
				talkValTimer();
				showMessage('你回来啦~', 0);
				clearInterval(sleepTimer_);
				sleepTimer_ = null;
			}
		}

		function showMessage(text, timeout) {
			if (Array.isArray(text)) text = text[Math.floor(Math.random() * text.length + 1) - 1];
			$('.message').stop();
			$('.message').html(text);
			$('.message').fadeTo(200, 1);
			//if (timeout === null) timeout = 5000;
			//hideMessage(timeout);
		}
		function talkValTimer() {
			$('#live_talk').val('1');
		}

		function hideMessage(timeout) {
			//$('.message').stop().css('opacity',1);
			if (timeout === null) timeout = 5000;
			$('.message').delay(timeout).fadeTo(200, 0);
		}

		function initLive2d() {
			$('#hideButton').on('click', function () {
				if (AIFadeFlag) {
					return false;
				} else {
					AIFadeFlag = true;
					localStorage.setItem("live2dhidden", "0");
					$('#landlord').fadeOut(200);
					$('#open_live2d').delay(200).fadeIn(200);
					setTimeout(function () {
						AIFadeFlag = false;
					}, 300);
				}
			});
			$('#open_live2d').on('click', function () {
				if (AIFadeFlag) {
					return false;
				} else {
					AIFadeFlag = true;
					localStorage.setItem("live2dhidden", "1");
					$('#open_live2d').fadeOut(200);
					$('#landlord').delay(200).fadeIn(200);
					setTimeout(function () {
						AIFadeFlag = false;
					}, 300);
				}
			});
			$('#youduButton').on('click', function () {
				if ($('#youduButton').hasClass('doudong')) {
					var typeIs = $('#youduButton').attr('data-type');
					$('#youduButton').removeClass('doudong');
					$('body').removeClass(typeIs);
					$('#youduButton').attr('data-type', '');
				} else {
					var duType = $('#duType').val();
					var duArr = duType.split(",");
					var dataType = duArr[Math.floor(Math.random() * duArr.length)];

					$('#youduButton').addClass('doudong');
					$('#youduButton').attr('data-type', dataType);
					$('body').addClass(dataType);
				}
			});
			if (apiKey) {
				$('#showInfoBtn').on('click', function () {
					var live_statu = $('#live_statu_val').val();
					if (live_statu == "0") {
						return
					} else {
						$('#live_statu_val').val("0");
						$('.live_talk_input_body').fadeOut(500);
						AITalkFlag = false;
						showHitokoto();
						$('#showTalkBtn').show();
						$('#showInfoBtn').hide();
					}
				});
				$('#showTalkBtn').on('click', function () {
					var live_statu = $('#live_statu_val').val();
					if (live_statu == "1") {
						return
					} else {
						$('#live_statu_val').val("1");
						$('.live_talk_input_body').fadeIn(500);
						AITalkFlag = true;
						$('#showTalkBtn').hide();
						$('#showInfoBtn').show();

					}
				});
				$('#talk_send').on('click', function () {
					var info_ = $('#AIuserText').val();
					var userid_ = $('#AIuserName').val();
					if (info_ == "") {
						showMessage('写点什么吧！', 0);
						return;
					}
					if (userid_ == "") {
						showMessage('聊之前请告诉我你的名字吧！', 0);
						return;
					}
					showMessage('思考中~', 0);
					let protocol = window.location.protocol.indexOf("s") > 0 ? "https" : "http";
					$.ajax({
						type: "get",
						url: `${protocol}://www.tuling123.com/openapi/api?key=${apiKey}&info=${info_}`,
						dataType: "json",
						success: function (res) {
							talkValTimer();
							showMessage(res.text, 0);
							$('#AIuserText').val("");
							sessionStorage.setItem("live2duser", userid_);
						},
						error: function (e) {
							talkValTimer();
							showMessage('似乎有什么错误，请和站长联系！', 0);
						}
					});
				});
			} else {
				$('#showInfoBtn').hide();
				$('#showTalkBtn').hide();
			}
			//获取音乐信息初始化
			var bgmListInfo = $('input[name=live2dBGM]');
			if (bgmListInfo.length == 0) {
				$('#musicButton').hide();
			} else {
				var bgmPlayNow = parseInt($('#live2d_bgm').attr('data-bgm'));
				var bgmPlayTime = 0;
				var live2dBGM_Num = sessionStorage.getItem("live2dBGM_Num");
				var live2dBGM_PlayTime = sessionStorage.getItem("live2dBGM_PlayTime");
				if (live2dBGM_Num) {
					if (live2dBGM_Num <= $('input[name=live2dBGM]').length - 1) {
						bgmPlayNow = parseInt(live2dBGM_Num);
					}
				}
				if (live2dBGM_PlayTime) {
					bgmPlayTime = parseInt(live2dBGM_PlayTime);
				}
				var live2dBGMSrc = bgmListInfo.eq(bgmPlayNow).val();
				$('#live2d_bgm').attr('data-bgm', bgmPlayNow);
				$('#live2d_bgm').attr('src', live2dBGMSrc);
				$('#live2d_bgm')[0].currentTime = bgmPlayTime;
				$('#live2d_bgm')[0].volume = 0.5;
				var live2dBGM_IsPlay = sessionStorage.getItem("live2dBGM_IsPlay");
				var live2dBGM_WindowClose = sessionStorage.getItem("live2dBGM_WindowClose");
				if (live2dBGM_IsPlay == '0' && live2dBGM_WindowClose == '0') {
					$('#live2d_bgm')[0].play();
					$('#musicButton').addClass('play');
				}
				sessionStorage.setItem("live2dBGM_WindowClose", '1');
				$('#musicButton').on('click', function () {
					if ($('#musicButton').hasClass('play')) {
						$('#live2d_bgm')[0].pause();
						$('#musicButton').removeClass('play');
						sessionStorage.setItem("live2dBGM_IsPlay", '1');
					} else {
						$('#live2d_bgm')[0].play();
						$('#musicButton').addClass('play');
						sessionStorage.setItem("live2dBGM_IsPlay", '0');
					}
				});
				window.onbeforeunload = function () {
					sessionStorage.setItem("live2dBGM_WindowClose", '0');
					if ($('#musicButton').hasClass('play')) {
						sessionStorage.setItem("live2dBGM_IsPlay", '0');
					}
				}
				document.getElementById('live2d_bgm').addEventListener("timeupdate", function () {
					var live2dBgmPlayTimeNow = document.getElementById('live2d_bgm').currentTime;
					sessionStorage.setItem("live2dBGM_PlayTime", live2dBgmPlayTimeNow);
				});
				document.getElementById('live2d_bgm').addEventListener("ended", function () {
					var listNow = parseInt($('#live2d_bgm').attr('data-bgm'));
					listNow++;
					if (listNow > $('input[name=live2dBGM]').length - 1) {
						listNow = 0;
					}
					var listNewSrc = $('input[name=live2dBGM]').eq(listNow).val();
					sessionStorage.setItem("live2dBGM_Num", listNow);
					$('#live2d_bgm').attr('src', listNewSrc);
					$('#live2d_bgm')[0].play();
					$('#live2d_bgm').attr('data-bgm', listNow);
				});
				document.getElementById('live2d_bgm').addEventListener("error", function () {
					$('#live2d_bgm')[0].pause();
					$('#musicButton').removeClass('play');
					showMessage('音乐似乎加载不出来了呢！', 0);
				});
			}
			//获取用户名
			var live2dUser = sessionStorage.getItem("live2duser");
			if (live2dUser !== null) {
				$('#AIuserName').val(live2dUser);
			}
			//获取位置
			var landL = sessionStorage.getItem("historywidth");
			var landB = sessionStorage.getItem("historyheight");
			if (landL == null || landB == null) {
				landL = '5px'
				landB = '0px'
			}
			$('#landlord').css('left', landL + 'px');
			$('#landlord').css('bottom', landB + 'px');
			//移动
			function getEvent() {
				return window.event || arguments.callee.caller.arguments[0];
			}
			var smcc = document.getElementById("landlord");
			var moveX = 0;
			var moveY = 0;
			var moveBottom = 0;
			var moveLeft = 0;
			var moveable = false;
			var docMouseMoveEvent = document.onmousemove;
			var docMouseUpEvent = document.onmouseup;
			smcc.onmousedown = function () {
				var ent = getEvent();
				moveable = true;
				moveX = ent.clientX;
				moveY = ent.clientY;
				var obj = smcc;
				moveBottom = parseInt(obj.style.bottom);
				moveLeft = parseInt(obj.style.left);
				if (isFirefox = navigator.userAgent.indexOf("Firefox") > 0) {
					window.getSelection().removeAllRanges();
				}
				document.onmousemove = function () {
					if (moveable) {
						var ent = getEvent();
						var x = moveLeft + ent.clientX - moveX;
						var y = moveBottom + (moveY - ent.clientY);
						obj.style.left = x + "px";
						obj.style.bottom = y + "px";
					}
				};
				document.onmouseup = function () {
					if (moveable) {
						var historywidth = obj.style.left;
						var historyheight = obj.style.bottom;
						historywidth = historywidth.replace('px', '');
						historyheight = historyheight.replace('px', '');
						sessionStorage.setItem("historywidth", historywidth);
						sessionStorage.setItem("historyheight", historyheight);
						document.onmousemove = docMouseMoveEvent;
						document.onmouseup = docMouseUpEvent;
						moveable = false;
						moveX = 0;
						moveY = 0;
						moveBottom = 0;
						moveLeft = 0;
					}
				};
			};
		}
		$(document).ready(function () {
			var AIimgSrc = [];
			let chooseLive2d = 'aoba'
			if (chooseLive2d === 'histoire') {
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_00.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_01.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_02.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_03.png");
			} else if (chooseLive2d === 'rem') {
				AIimgSrc.push(message_Path + "model/rem/remu2048/texture_00.png");
			} else if (chooseLive2d === 'aoba') {
				AIimgSrc.push(message_Path + "model/aoba/textures/texture_00.png");
			} else if (chooseLive2d === 'hijiki') {
				AIimgSrc.push(message_Path + "model/hijiki/moc/hijiki.2048/texture_00.png");
			} else if (chooseLive2d === 'tororo') {
				AIimgSrc.push(message_Path + "model/tororo/moc/tororo.2048/texture_00.png");
			}
			var images = [];
			var imgLength = AIimgSrc.length;
			var loadingNum = 0;
			for (var i = 0; i < imgLength; i++) {
				images[i] = new Image();
				images[i].src = AIimgSrc[i];
				images[i].onload = function () {
					loadingNum++;
					if (loadingNum === imgLength) {
						var live2dhidden = localStorage.getItem("live2dhidden");
						if (live2dhidden === "0") {
							setTimeout(function () {
								$('#open_live2d').fadeIn(200);
							}, 1300);
						} else {
							setTimeout(function () {
								$('#landlord').fadeIn(200);
							}, 1300);
						}
						let model = '';
						if (chooseLive2d === 'histoire') {
							model = message_Path + "model/histoire/model.json";
						} else if (chooseLive2d === 'rem') {
							model = message_Path + "model/rem/model.json";
						} else if (chooseLive2d === 'aoba') {
							model = message_Path + "model/aoba/model.json";
						} else if (chooseLive2d === 'hijiki') {
							model = message_Path + "model/hijiki/hijiki.model.json";
						} else if (chooseLive2d === 'tororo') {
							model = message_Path + "model/tororo/tororo.model.json";
						}
						setTimeout(function () {
							loadlive2d("live2d", model);
						}, 1000);
						initLive2d();
						images = null;
					}
				}
			}
		});
	}
</script>
  
  
  
  <script src="https://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>
  <script src="https://player.lmih.cn/player/js/player.js" id="myhk" key="demo" m="1"></script>


  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
    back2TopText = document.querySelector('#back_to_top_text'),
    drawerBox = document.querySelector('#drawer_box'),
    rightSideBar = document.querySelector('.sidebar'),
    viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {

    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener('scroll', function (e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });


  let hasCacu = false;
  window.onresize = function () {
    calcuHeight();
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function () {
            window.Velocity(rightMotions, transitionDir, {});
          }
        })
        window.Velocity(viewport, openProp, {
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function () {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp, {
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 链接跳转
  let newWindow = 'false'
  if (newWindow === 'true') {
    let links = document.querySelectorAll('.post-body a')
    links.forEach(item => {
      if (!item.classList.contains('btn')) {
        item.setAttribute("target", "_blank");
      }
    })
  }

  let faSearch = document.querySelector('#fa_search');
  faSearch.addEventListener('click', function () {
    document.querySelector('#search_mask').style = ''
  })

  // 代码高亮
  hljs.initHighlightingOnLoad();
  
  // 离开当前页title变化
  var leaveTitle = '人呢，快回来！';
  if (leaveTitle) {
    document.addEventListener('visibilitychange', function () {
      if (document.visibilityState == 'hidden') {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }

</script>
  </div>
</body>

  <div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jonchan1013.github.io/post/bi-ji/"" data-c="
          &lt;p&gt;自己平时遇到的问题以及疑问&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;1-requestparam详解以及加与不加的区别&#34;&gt;1、@RequestParam详解以及加与不加的区别&lt;/h2&gt;
">笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jonchan1013.github.io/post/hadoop-ru-men/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200821150606.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;1-大数据概论&#34;&gt;1、大数据概论&lt;/h2&gt;
&lt;h3 id=&#34;11-大数据概念&#34;&gt;1.1 大数据概念&lt;/h3&gt;
&lt;p&gt;大数据（Big Data）：指无法在一定时间范围内用常规软件工具进行捕捉、管理和处理的数据集合，是需要新处理模式才能具有更强的决策力、洞察发现力和流程优化能力的海量、高增长率和多样化的信息资产。&lt;br&gt;
主要解决，海量数据的存储和海量数据的分析计算问题。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;12-大数据特点&#34;&gt;1.2 大数据特点&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Volume（大量）&lt;/p&gt;
&lt;p&gt;截至目前，人类生产的所有印刷材料的数据量是200PB，而历史上全人类总共说过的话的数据量大约是5EB。当前，典型个人计算机硬盘的容量为TB量级，而一些大企业的数据量已经接近EB量级。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Velocity（高速）&lt;/p&gt;
&lt;p&gt;这是大数据区分于传统数据挖掘的最显著特征。根据IDC的“数字宇宙”的报告，预计到2020年，全球数据使用量将达到35.2ZB。在如此海量的数据面前，处理数据的效率就是企业的生命。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Variety（多样）&lt;br&gt;
这种类型的多样性也让数据被分为结构化数据和非结构化数据。相对于以往便于存储的以数据库/文本为主的结构化数据，非结构化数据越来越多，包括网络日志、音频、视频、图片、地理位置信息等，这些多类型的数据对数据的处理能力提出了更高要求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Value（低价值密度）&lt;/p&gt;
&lt;p&gt;价值密度的高低与数据总量的大小成反比。如何快速对有价值数据“提纯”成为目前大数据背景下待解决的难题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;13-大数据应用场景&#34;&gt;1.3 大数据应用场景&lt;/h3&gt;
&lt;p&gt;1、物流仓储：大数据分析系统助力商家精细化运营、提升销量、节约成本。&lt;/p&gt;
&lt;p&gt;2、零售：分析用户消费习惯，为用户购买商品提供方便，从而提升商品销量。&lt;/p&gt;
&lt;p&gt;3、旅游：深度结合大数据能力与旅游行业需求，共建旅游产业智慧管理、智慧服务和智慧营销的未来。&lt;/p&gt;
&lt;p&gt;4、商品广告推荐：给用户推荐可能喜欢的商品&lt;/p&gt;
&lt;p&gt;5、保险：海量数据挖掘及风险预测，助力保险行业精准营销，提升精细化定价能力。&lt;/p&gt;
&lt;p&gt;6、推荐优质客户，防范欺诈风险。&lt;/p&gt;
&lt;p&gt;7、房产：大数据全面助力房地产行业，打造精准投策与营销，选出更合适的地，建造更合适的楼，卖给更合适的人。&lt;/p&gt;
&lt;p&gt;8、人工智能&lt;/p&gt;
&lt;h3 id=&#34;14-大数据部门业务流程分析&#34;&gt;1.4 大数据部门业务流程分析&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200821174208.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;15-大数据部门组织结构&#34;&gt;1.5  大数据部门组织结构&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200821174241.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;2-从-hadoop-框架讨论大数据生态&#34;&gt;2、从 Hadoop 框架讨论大数据生态&lt;/h2&gt;
&lt;h3 id=&#34;21-hadoop-是什么&#34;&gt;2.1 Hadoop 是什么&lt;/h3&gt;
&lt;p&gt;1）Hadoop是一个由Apache基金会所开发的分布式系统基础架构。&lt;br&gt;
2）主要解决，海量数据的存储和海量数据的分析计算问题。&lt;br&gt;
3）广义上来说，Hadoop通常是指一个更广泛的概念——Hadoop生态圈。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200823170613.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;22-hadoop-发展历史&#34;&gt;2.2 Hadoop 发展历史&lt;/h3&gt;
&lt;p&gt;1）Lucene框架是Doug Cutting开创的开源软件，用Java书写代码，实现与Google类似的全文搜索功能，它提供了全文检索引擎的架构，包括完整的查询引擎和索引引擎。&lt;/p&gt;
&lt;p&gt;2）2001年年底Lucene成为Apache基金会的一个子项目。&lt;br&gt;
3）对于海量数据的场景，Lucene面对与Google同样的困难，&lt;strong&gt;存储数据困难，检索速度慢。&lt;/strong&gt;&lt;br&gt;
4）学习和模仿Google解决这些问题的办法 ：微型版Nutch。&lt;br&gt;
5）可以说Google是Hadoop的思想之源(Google在大数据方面的三篇论文)&lt;br&gt;
GFS ---&amp;gt;HDFS&lt;br&gt;
Map-Reduce ---&amp;gt;MR&lt;br&gt;
BigTable ---&amp;gt;HBase&lt;/p&gt;
&lt;p&gt;6）2003-2004年，Google公开了部分GFS和Mapreduce思想的细节，以此为基础Doug Cutting等人用&lt;br&gt;
了2年业余时间实现了DFS和Mapreduce机制，使Nutch性能飙升。&lt;br&gt;
7）2005 年Hadoop 作为 Lucene的子项目 Nutch的一部分正式引入Apache基金会。&lt;br&gt;
8）2006 年 3 月份，Map-Reduce和Nutch Distributed File System (NDFS) 分别被纳入称为 Hadoop 的项&lt;br&gt;
目中。&lt;br&gt;
9）名字来源于Doug Cutting儿子的玩具大象&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200823170826.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;10）Hadoop就此诞生并迅速发展，标志着大数据时代来临。&lt;/p&gt;
&lt;h3 id=&#34;23-hadoop-三大发行版本&#34;&gt;2.3 Hadoop 三大发行版本&lt;/h3&gt;
&lt;p&gt;Hadoop 三大发行版本：Apache、Cloudera、Hortonworks。&lt;br&gt;
Apache 版本最原始（最基础）的版本，对于入门学习最好。&lt;br&gt;
Cloudera 在大型互联网企业中用的较多。&lt;br&gt;
Hortonworks 文档较好。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Apache Hadoop&lt;br&gt;
官网地址：http://hadoop.apache.org/releases.html&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下载地址：https://archive.apache.org/dist/hadoop/common/&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;Cloudera Hadoop&lt;br&gt;
官网地址：https://www.cloudera.com/downloads/cdh/5-10-0.html&lt;br&gt;
下载地址：http://archive-primary.cloudera.com/cdh5/cdh/5/&lt;br&gt;
（1）2008 年成立的 Cloudera 是最早将 Hadoop 商用的公司，为合作伙伴提供 Hadoop 的商用解决方案，主要是包括支持、咨询服务、培训。&lt;br&gt;
（2）2009 年 Hadoop 的创始人 Doug Cutting 也加盟 Cloudera 公司。Cloudera 产品主要为 CDH，Cloudera Manager，Cloudera Support&lt;br&gt;
（3）CDH 是 Cloudera 的 Hadoop 发行版，完全开源，比 Apache Hadoop 在兼容性，安全性，稳定性上有所增强。&lt;br&gt;
（4）Cloudera Manager 是集群的软件分发及管理监控平台，可以在几个小时内部署好一个 Hadoop 集群，并对集群的节点及服务进行实时监控。Cloudera Support 即是对 Hadoop 的技术支持。&lt;br&gt;
（5）Cloudera 的标价为每年每个节点 4000 美元。Cloudera 开发并贡献了可实时处理大数据的 Impala 项目。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Hortonworks Hadoop&lt;br&gt;
官网地址：https://hortonworks.com/products/data-center/hdp/&lt;br&gt;
下载地址：https://hortonworks.com/downloads/#data-platform&lt;br&gt;
（1）2011 年成立的 Hortonworks 是雅虎与硅谷风投公司 Benchmark Capital 合资组建。&lt;br&gt;
（2）公司成立之初就吸纳了大约 25 名至 30 名专门研究 Hadoop 的雅虎工程师，上述工程师均在 2005 年开始协助雅虎开发 Hadoop，贡献了 Hadoop80%的代码。&lt;br&gt;
（3）雅虎工程副总裁、雅虎 Hadoop 开发团队负责人 Eric Baldeschwieler 出任 Hortonworks的首席执行官。&lt;br&gt;
（4）Hortonworks 的主打产品是 Hortonworks Data Platform（HDP），也同样是 100%开源的产品，HDP 除常见的项目外还包括了 Ambari，一款开源的安装和管理系统。&lt;br&gt;
（5）HCatalog，一个元数据管理系统，HCatalog 现已集成到 Facebook 开源的 Hive 中。&lt;br&gt;
Hortonworks 的 Stinger 开创性的极大的优化了 Hive 项目。Hortonworks 为入门提供了一个非常好的，易于使用的沙盒。&lt;br&gt;
（6）Hortonworks 开发了很多增强特性并提交至核心主干，这使得 Apache Hadoop 能够在包括 Window Server 和 Windows Azure 在内的 Microsoft Windows 平台上本地运行。定价以集群为基础，每 10 个节点每年为 12500 美元。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;24-hadoop-的优势4-高&#34;&gt;2.4 Hadoop 的优势（4 高）&lt;/h3&gt;
&lt;p&gt;1）高可靠性：Hadoop底层维护多个数据副本，所以即使Hadoop某个计算元素或存储出现故障，也不会导致数据的丢失。&lt;br&gt;
2）高扩展性：在集群间分配任务数据，可方便的扩展数以千计的节点。&lt;/p&gt;
&lt;p&gt;3）高效性：在MapReduce的思想下，Hadoop是并行工作的，以加快任务处理速度。&lt;/p&gt;
&lt;p&gt;4）高容错性：能够自动将失败的任务重新分配。&lt;/p&gt;
&lt;h3 id=&#34;25-hadoop-组成面试重点&#34;&gt;2.5  Hadoop 组成（面试重点）&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200823171307.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;251-hdfs-架构概述&#34;&gt;2.5.1 HDFS 架构概述&lt;/h4&gt;
&lt;p&gt;1）NameNode（nn）：存储文件的元数据，如文件名，文件目录结构，文件属性（生成时间、副本数、文件权限），以及每个文件的块列表和块所在的DataNode等。&lt;/p&gt;
&lt;p&gt;2）DataNode(dn)：在本地文件系统存储文件块数据，以及块数据的校验和。&lt;/p&gt;
&lt;p&gt;3）Secondary NameNode(2nn)：用来监控HDFS状态的辅助后台程序，每隔一段时间获取HDFS元数据的快照。&lt;/p&gt;
&lt;h4 id=&#34;252-yarn-架构概述&#34;&gt;2.5.2 YARN 架构概述&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200823171505.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;253-mapreduce-架构概述&#34;&gt;2.5.3 MapReduce 架构概述&lt;/h4&gt;
&lt;p&gt;MapReduce 将计算过程分为两个阶段：Map 和 Reduce&lt;br&gt;
1）Map 阶段并行处理输入数据&lt;br&gt;
2）Reduce 阶段对 Map 结果进行汇总&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200823171738.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;26-大数据技术生态体系&#34;&gt;2.6 大数据技术生态体系&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200823171840.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;图中涉及的技术名词解释如下：&lt;br&gt;
1）Sqoop：Sqoop 是一款开源的工具，主要用于在 Hadoop、Hive 与传统的数据库(MySql)间进行数据的传递，可以将一个关系型数据库（例如 ：MySQL，Oracle 等）中的数据导进到Hadoop 的 HDFS 中，也可以将 HDFS 的数据导进到关系型数据库中。&lt;/p&gt;
&lt;p&gt;2）Flume：Flume 是 Cloudera 提供的一个高可用的，高可靠的，分布式的海量日志采集、聚合和传输的系统，Flume 支持在日志系统中定制各类数据发送方，用于收集数据；同时，Flume提供对数据进行简单处理，并写到各种数据接受方（可定制）的能力。&lt;br&gt;
3）Kafka：Kafka 是一种高吞吐量的分布式发布订阅消息系统，有如下特性：&lt;br&gt;
（1）通过 O(1)的磁盘数据结构提供消息的持久化，这种结构对于即使数以 TB 的消息存储也能够保持长时间的稳定性能。&lt;br&gt;
（2）高吞吐量：即使是非常普通的硬件 Kafka 也可以支持每秒数百万的消息。&lt;br&gt;
（3）支持通过 Kafka 服务器和消费机集群来分区消息。&lt;br&gt;
（4）支持 Hadoop 并行数据加载。&lt;br&gt;
4）Storm：Storm 用于“连续计算”，对数据流做连续查询，在计算时就将结果以流的形式输出给用户。&lt;br&gt;
5）Spark：Spark 是当前最流行的开源大数据内存计算框架。可以基于 Hadoop 上存储的大数据进行计算。&lt;br&gt;
6）Oozie：Oozie 是一个管理 Hdoop 作业（job）的工作流程调度管理系统。&lt;br&gt;
7）Hbase：HBase 是一个分布式的、面向列的开源数据库。HBase 不同于一般的关系数据库，它是一个适合于非结构化数据存储的数据库。&lt;br&gt;
8）Hive：Hive 是基于 Hadoop 的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供简单的 SQL 查询功能，可以将 SQL 语句转换为 MapReduce 任务进行运行。 其优点是学习成本低，可以通过类 SQL 语句快速实现简单的 MapReduce 统计，不必开发专门的 MapReduce 应用，十分适合数据仓库的统计分析。&lt;br&gt;
10）R 语言：R 是用于统计分析、绘图的语言和操作环境。R 是属于 GNU 系统的一个自由、免费、源代码开放的软件，它是一个用于统计计算和统计制图的优秀工具。&lt;br&gt;
11）Mahout：Apache Mahout 是个可扩展的机器学习和数据挖掘库。&lt;br&gt;
12）ZooKeeper：Zookeeper 是 Google 的 Chubby 一个开源的实现。它是一个针对大型分布式系统的可靠协调系统，提供的功能包括：配置维护、名字服务、 分布式同步、组服务等。ZooKeeper 的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。&lt;/p&gt;
&lt;h3 id=&#34;27-推荐系统框架图&#34;&gt;2.7   推荐系统框架图&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200823172042.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;3-hadoop-运行环境搭建开发重点&#34;&gt;3、Hadoop 运行环境搭建（开发重点）&lt;/h2&gt;
&lt;h3 id=&#34;31-虚拟机环境准备&#34;&gt;3.1 虚拟机环境准备&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;克隆虚拟机&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改克隆虚拟机的静态 IP&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改主机名&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关闭防火墙&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建 Hadoop 用户&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置 Hadoop 用户具有 root 权限&lt;br&gt;
7．在/opt 目录下创建文件夹&lt;br&gt;
（1）在/opt 目录下创建 module、software 文件夹&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[atguigu@hadoop101 opt]$ sudo mkdir module 
[atguigu@hadoop101 opt]$ sudo mkdir software 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（2）修改 module、software 文件夹的所有者 cd&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[atguigu@hadoop101 opt]$ sudo chown atguigu:atguigu module/ 
software/ 
[atguigu@hadoop101 opt]$ ll 
总用量 8 
drwxr-xr-x. 2 atguigu atguigu 4096 1 月 17 14:37 module 
drwxr-xr-x. 2 atguigu atguigu 4096 1 月 17 14:38 software 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;32-安装-jdk&#34;&gt;3.2 安装 JDK&lt;/h3&gt;
&lt;h3 id=&#34;33-安装hadoop&#34;&gt;3.3 安装Hadoop&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Hadoop 下载地址：&lt;br&gt;
https://archive.apache.org/dist/hadoop/common/hadoop-2.7.2/&lt;/p&gt;
&lt;p&gt;上传到/opt/software目录下&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进入到 Hadoop 安装包路径下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[atguigu@hadoop101 ~]$ cd /opt/software/ 
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解压安装文件到/opt/module 下面&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[atguigu@hadoop101 software]$ tar -zxvf hadoop-2.7.2.tar.gz -C /opt/module/ 
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看是否解压成功&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[atguigu@hadoop101 software]$ ls /opt/module/
hadoop-2.7.2 
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将 Hadoop 添加到环境变量&lt;/p&gt;
&lt;p&gt;（1）获取 Hadoop 安装路径&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[atguigu@hadoop101 hadoop-2.7.2]$ pwd 
/opt/module/hadoop-2.7.2 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;（2）打开/etc/profile 文件 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[atguigu@hadoop101 hadoop-2.7.2]$ sudo vi /etc/profile 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 profile 文件末尾添加 JDK 路径：（shitf+g）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL
export JAVA_HOME=/usr/local/jdk
export HADOOP_HOME=/opt/module/hadoop-2.7.2 
export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
export PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（3）保存后退出&lt;/p&gt;
&lt;p&gt;​		:wq&lt;/p&gt;
&lt;p&gt;（4）让修改后的文件生效&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[atguigu@ hadoop101 hadoop-2.7.2]$ source /etc/profile 
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;
&lt;p&gt;测试是否安装成功&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[atguigu@hadoop101 hadoop-2.7.2]$ hadoop version 
Hadoop 2.7.2 
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重启(如果 Hadoop 命令不能用再重启)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[atguigu@ hadoop101 hadoop-2.7.2]$ sync 
[atguigu@ hadoop101 hadoop-2.7.2]$ sudo reboot 
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;34-hadoop-目录结构&#34;&gt;3.4  Hadoop 目录结构&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;查看 Hadoop 目录结构&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[atguigu@hadoop101 hadoop-2.7.2]$ ll 
总用量 52 
drwxr-xr-x. 2 atguigu atguigu  4096 5月  22 2017 bin 
drwxr-xr-x. 3 atguigu atguigu  4096 5月  22 2017 etc 
drwxr-xr-x. 2 atguigu atguigu  4096 5月  22 2017 include 
drwxr-xr-x. 3 atguigu atguigu  4096 5月  22 2017 lib 
drwxr-xr-x. 2 atguigu atguigu  4096 5月  22 2017 libexec 
-rw-r--r--. 1 atguigu atguigu 15429 5月  22 2017 LICENSE.txt 
-rw-r--r--. 1 atguigu atguigu   101 5月  22 2017 NOTICE.txt 
-rw-r--r--. 1 atguigu atguigu  1366 5月  22 2017 README.txt 
drwxr-xr-x. 2 atguigu atguigu  4096 5月  22 2017 sbin 
drwxr-xr-x. 4 atguigu atguigu  4096 5月  22 2017 share
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重要目录&lt;/p&gt;
&lt;p&gt;（1）bin 目录：存放对 Hadoop 相关服务（HDFS,YARN）进行操作的脚本&lt;br&gt;
（2）etc 目录：Hadoop 的配置文件目录，存放 Hadoop 的配置文件&lt;br&gt;
（3）lib 目录：存放 Hadoop 的本地库（对数据进行压缩解压缩功能）&lt;br&gt;
（4）sbin 目录：存放启动或停止 Hadoop 相关服务的脚本&lt;br&gt;
（5）share 目录：存放 Hadoop 的依赖 jar 包、文档、和官方案例&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;4-hadoop-运行模式&#34;&gt;4、Hadoop 运行模式&lt;/h2&gt;
&lt;p&gt;Hadoop 运行模式包括：本地模式、伪分布式模式以及完全分布式模式。&lt;br&gt;
Hadoop 官方网站：http://hadoop.apache.org/&lt;/p&gt;
&lt;h3 id=&#34;41-本地运行模式&#34;&gt;4.1 本地运行模式&lt;/h3&gt;
&lt;h4 id=&#34;411-官方-grep-案例&#34;&gt;4.1.1 官方 Grep 案例&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;创建在 hadoop-2.7.2 文件下面创建一个 input 文件夹&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[atguigu@hadoop101 hadoop-2.7.2]$ mkdir input 
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;将 Hadoop 的 xml 配置文件复制到 input&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[atguigu@hadoop101 hadoop-2.7.2]$ cp etc/hadoop/*.xml input
&lt;/code&gt;&lt;/pre&gt;
">Hadoop入门</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jonchan1013.github.io/post/shell/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200820093425.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;1-shell概述&#34;&gt;1、Shell概述&lt;/h2&gt;
&lt;h3 id=&#34;11-shell是什么&#34;&gt;1.1 Shell是什么&lt;/h3&gt;
&lt;p&gt;Linux系统的核心是内核。内核控制着计算机系统上的所有硬件和软件，在必要时为应用程序分配硬件， 并根据需要执行程序中的代码。&lt;br&gt;
内核主要负责以下四种功能：&lt;/p&gt;
&lt;!-- more --&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;系统内存管理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;软件程序管理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;硬件设备管理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;文件系统管理&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200820094033.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;简单来说Shell是一种特殊的交互式工具，核心是命令提示符，允许输入文本命令，解释命令，并在内核中执行命令。&lt;/p&gt;
&lt;p&gt;当应用程序在执行时，需要调用计算机硬件的cpu,内存等资源！程序将指令发送给内核执行！为了防止程序发送一些恶意指令导致损坏内核，在内核和应用程序接口之间，设置一个中间层，称为shell.&lt;br&gt;
本质上来说：&lt;br&gt;
shell:   一个可以解释shell规定的语法命令的解释器。&lt;br&gt;
解释器负责将应用程序发送的指令，进行检查，合法后交给内核解释执行，返回结果。&lt;/p&gt;
&lt;p&gt;shell命令：  shell解释器要求的指定语法编写的命令！&lt;/p&gt;
&lt;p&gt;shell脚本：  多条shell命令，可以编写在一个文件中，文件中的指令，可以按照顺序执行。将这个文件称为shell脚本。&lt;/p&gt;
&lt;h3 id=&#34;12-shell中的解释器&#34;&gt;1.2 shell中的解释器&lt;/h3&gt;
&lt;p&gt;（1）Linux提供的Shell解析器有：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@hadoop101 ~]$ cat /etc/shells 
/bin/sh
/bin/bash
/sbin/nologin
/bin/dash
/bin/tcsh
/bin/csh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不同的shell解析器，功能不同，比如csh，符合c语言风格的shell解析器。Centos默认使用的是/bin/sh 和 /bin/bash作为shell解析器&lt;/p&gt;
&lt;p&gt;（2）bash和sh的关系&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@hadoop101 bin]$ ll | grep bash
-rwxr-xr-x. 1 root root 941880 5月  11 2019 bash
lrwxrwxrwx. 1 root root      4 5月  27 2019 sh -&amp;gt; bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（3）Centos默认的解析器是bash&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@hadoop102 bin]$ echo $SHELL
/bin/bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 $SHELL变量查看当前系统默认的解释器类型！&lt;/p&gt;
&lt;p&gt;shell支持多种不同风格的解释器，通过/etc/shells文件查看！&lt;/p&gt;
&lt;p&gt;默认使用 /bin/bash作为shell命令解释器！&lt;/p&gt;
&lt;p&gt;在终端中输入： cat /etc/shells&lt;br&gt;
等价于/bin/bash -c &#39;cat /etc/shells&#39;.&lt;br&gt;
默认/bin/bash必须接一个脚本，作为输入！如果是一条命令，需要加-c （command）&lt;/p&gt;
&lt;h3 id=&#34;13-linux中的常用目录&#34;&gt;1.3 linux中的常用目录&lt;/h3&gt;
&lt;p&gt;/bin:     linux用户常用的命令&lt;br&gt;
cd&lt;br&gt;
echo&lt;br&gt;
pwd&lt;br&gt;
/sbin（super user bin）: root用户(管理员)使用的常用命令！&lt;br&gt;
对整个机器的管理命令！&lt;br&gt;
开启网络服务：  service network start&lt;/p&gt;
&lt;h3 id=&#34;14-命令的执行&#34;&gt;1.4 命令的执行&lt;/h3&gt;
&lt;p&gt;-bash: faefaw: command not found ： 当前命令不在当前用户的环境变量！&lt;/p&gt;
&lt;p&gt;查看： echo $PATH&lt;/p&gt;
&lt;h3 id=&#34;15-shell脚本入门&#34;&gt;1.5 Shell脚本入门&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;脚本的编写要求:&lt;/strong&gt;&lt;br&gt;
①声明：  #!/bin/bash&lt;br&gt;
②正文：  必须是shell解释器能否解释的命令&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;脚本的执行:&lt;/strong&gt;&lt;br&gt;
① bash 或 sh + 脚本&lt;br&gt;
特点： 新开一个bash执行脚本，一旦脚本执行完毕，bash自动关闭！&lt;br&gt;
② ./脚本，前提是当前用户对脚本有执行权限，使用当前默认的解释器执行脚本&lt;br&gt;
特点： 新开一个bash执行脚本，一旦脚本执行完毕，bash自动关闭！&lt;br&gt;
③ source 或 .  +脚本  使用当前默认的解释器执行脚本，并不要求当前用户对脚本有执行权限(.就是source的简写)&lt;br&gt;
特点： 在当前bash执行脚本&lt;/p&gt;
&lt;h2 id=&#34;2-shell中的变量&#34;&gt;2、Shell中的变量&lt;/h2&gt;
&lt;h3 id=&#34;21-系统变量&#34;&gt;2.1 系统变量&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;常用系统变量&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;H&lt;/mi&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mi&gt;E&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;、&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;HOME、&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.08125em;&#34;&gt;H&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;M&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;PWD、&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;S&lt;/mi&gt;&lt;mi&gt;H&lt;/mi&gt;&lt;mi&gt;E&lt;/mi&gt;&lt;mi&gt;L&lt;/mi&gt;&lt;mi&gt;L&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;、&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;SHELL、&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.08125em;&#34;&gt;H&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;USER等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;案例实操&lt;/p&gt;
&lt;p&gt;（1）查看系统变量的值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@hadoop101 datas]$ echo $HOME
/home/root
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（2）显示当前Shell中所有变量：set&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@hadoop101 datas]$ set
BASH=/bin/bash
BASH_ALIASES=()
BASH_ARGC=()
BASH_ARGV=()
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;22-自定义变量&#34;&gt;2.2 自定义变量&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;基本语法&lt;/p&gt;
&lt;p&gt;（1）定义变量：变量=值&lt;/p&gt;
&lt;p&gt;（2）撤销变量：unset 变量&lt;/p&gt;
&lt;p&gt;（3）声明静态变量：readonly变量，注意：不能unset&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;变量定义规则&lt;/p&gt;
&lt;p&gt;（1）变量名称可以由字母、数字和下划线组成，但是不能以数字开头，&lt;strong&gt;环境变量名建议大写。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（2）&lt;strong&gt;等号两侧不能有空格&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（3）在bash中，变量默认类型都是字符串类型，无法直接进行数值运算。&lt;/p&gt;
&lt;p&gt;（4）变量的值如果有空格，需要使用双引号或单引号括起来。&lt;/p&gt;
&lt;p&gt;（5）使用双引号，可以识别空格之外的其他变量，使用单引号则会只会忽略空格！&lt;/p&gt;
&lt;p&gt;（6）使用反引号，可以将语句运行的结果作为值赋值给变量！&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;特殊关键字：&lt;br&gt;
readonly : 用来修饰一个只读(不能修改，删除)变量！&lt;br&gt;
export:    导出！将一个变量提升为全局变量！&lt;br&gt;
局部变量： 默认变量只在定义变量的bash中有效！&lt;br&gt;
如果希望在bash-a访问bash-b中定义的变量！&lt;br&gt;
要求： ①bash-b不能关闭&lt;br&gt;
②让bash-b将变量提升为全局变量，才能访问到！&lt;/p&gt;
&lt;p&gt;注意： ①变量赋值时，值全部以字符串存在，无法进行运算！&lt;br&gt;
②赋值的值中有空格，需要使用引号引起来&lt;br&gt;
单引号： 不能识别&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;等&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;特&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;殊&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;字&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;符&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;不&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;能&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;脱&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;义&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;双&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;引&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;号&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;：&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;可&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;以&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;脱&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;义&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;等特殊字符,不能脱义
			双引号：  可以脱义&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.3em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;等&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;特&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;殊&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;字&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;符&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;不&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;能&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;脱&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;义&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;双&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;引&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;号&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;：&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;可&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;以&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;脱&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;义&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;
③```,作用是将引号中的命令执行的结果赋值给变量&lt;br&gt;
&lt;code&gt;命令&lt;/code&gt; 等价于 $(命令)&lt;/p&gt;
&lt;p&gt;变量的生命周期：&lt;br&gt;
在第一次新增时产生&lt;br&gt;
变量在执行unset时，撤销，失效！&lt;br&gt;
关闭当前bash，所有定义的变量也不会存在！&lt;/p&gt;
&lt;h3 id=&#34;23-特殊变量n&#34;&gt;2.3 特殊变量：$n&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;基本语法&lt;/p&gt;
&lt;p&gt;$n  （功能描述：n为数字，$0代表该脚本名称，$1-&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;9&lt;/mn&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;代&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;表&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;第&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;一&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;到&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;第&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;九&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;个&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;参&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;数&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;，&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;十&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;以&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;上&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;参&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;数&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;，&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;十&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;以&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;上&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;参&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;数&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;需&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;要&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;用&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;大&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;括&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;号&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;包&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;含&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;，&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;如&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;9代表第一到第九个参数，十以上的参数，十以上的参数需要用大括号包含，如&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;9&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;代&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;表&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;第&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;一&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;到&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;第&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;九&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;个&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;参&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;数&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;十&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;以&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;上&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;的&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;参&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;数&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;十&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;以&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;上&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;的&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;参&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;数&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;需&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;要&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;用&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;大&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;括&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;号&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;包&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;含&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;如&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;{10}）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;案例实操&lt;/p&gt;
&lt;p&gt;输出该脚本文件名称、输入参数1和输入参数2 的值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@hadoop101 datas]$ touch parameter.sh 
[root@hadoop101 datas]$ vim parameter.sh

#!/bin/bash
echo &amp;quot;$0  $1   $2&amp;quot;

[root@hadoop101 datas]$ chmod 777 parameter.sh

[root@hadoop101 datas]$ ./parameter.sh cls  xz
./parameter.sh  cls   xz

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;24-特殊变量&#34;&gt;2.4 特殊变量：$#&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;基本语法&lt;/p&gt;
&lt;p&gt;$#  （功能描述：获取所有输入参数个数，常用于循环）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;案例实操&lt;/p&gt;
&lt;p&gt;获取输入参数的个数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@hadoop101 datas]$ vim parameter.sh

#!/bin/bash
echo &amp;quot;$0  $1   $2&amp;quot;
echo $#

[root@hadoop101 datas]$ chmod 777 parameter.sh
[root@hadoop101 datas]$ ./parameter.sh cls  xz
parameter.sh cls xz 
2
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;25-特殊变量&#34;&gt;2.5 特殊变量：&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;、&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;*、&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.46528em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;@&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;基本语法&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;（&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;功&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;能&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;描&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;述&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;：&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;这&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;个&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;变&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;量&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;代&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;表&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;命&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;令&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;行&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;中&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;所&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;有&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;参&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;数&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;，&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;*  （功能描述：这个变量代表命令行中所有的参数，&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.46528em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;（&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;功&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;能&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;描&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;述&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;：&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;这&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;个&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;变&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;量&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;代&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;表&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;命&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;令&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;行&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;中&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;所&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;有&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;的&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;参&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;数&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;*把所有的参数看成一个整体）&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;@&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;（&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;功&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;能&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;描&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;述&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;：&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;这&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;个&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;变&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;量&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;也&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;代&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;表&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;命&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;令&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;行&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;中&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;所&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;有&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;参&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;数&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;，&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;不&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;过&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;@  （功能描述：这个变量也代表命令行中所有的参数，不过&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;（&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;功&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;能&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;描&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;述&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;：&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;这&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;个&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;变&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;量&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;也&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;代&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;表&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;命&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;令&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;行&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;中&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;所&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;有&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;的&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;参&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;数&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;不&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;过&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;@把每个参数区分对待）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;案例实操&lt;/p&gt;
&lt;p&gt;打印输入的所有参数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@hadoop101 datas]$ vim parameter.sh

#!/bin/bash
echo &amp;quot;$0  $1   $2&amp;quot;
echo $#
echo $*
echo $@

[root@hadoop101 datas]$ bash parameter.sh 1 2 3
parameter.sh  1   2
3
1 2 3
1 2 3
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;26-特殊变量&#34;&gt;2.6 特殊变量：$？&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;基本语法&lt;/p&gt;
&lt;p&gt;$？ （功能描述：最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行；如果这个变量的值为非0（具体是哪个数，由命令自己来决定），则证明上一个命令执行不正确了。）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;案例实操&lt;/p&gt;
&lt;p&gt;判断helloworld.sh脚本是否正确执行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@hadoop101 datas]$ ./helloworld.sh 
hello world
[root@hadoop101 datas]$ echo $?
0
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-运算符&#34;&gt;3、运算符&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;基本语法&lt;/p&gt;
&lt;p&gt;（1）“&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;运&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;算&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;式&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;”&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;或&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;“&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;((运算式))”或“&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;运&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;算&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;式&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;”&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;或&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;“&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;[运算式]”&lt;/p&gt;
&lt;p&gt;（2）expr + , - , *, /, %  加，减，乘，除，取余&lt;/p&gt;
&lt;p&gt;&lt;code&gt;注意：expr运算符间要有空格;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;*号需要转义为\*，否则会被视为通配符；&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;运算指的都是整数的运算，浮点运算需要借助其他的命令！&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;案例实操：&lt;/p&gt;
&lt;p&gt;（1）计算3+2的值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@hadoop101 datas]$ expr 2 + 3
5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（2）计算3-2的值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@hadoop101 datas]$ expr 3 - 2 
1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（3）计算（2+3）X4的值&lt;/p&gt;
&lt;p&gt;​     （a）expr一步完成计算&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@hadoop101 datas]$ expr `expr 2 + 3` \* 4
20
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（b）采用$[运算式]方式&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@hadoop101 datas]# S=$[(2+3)*4]
[root@hadoop101 datas]# echo $S
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;4-条件判断&#34;&gt;4、条件判断&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;基本语法&lt;/p&gt;
&lt;p&gt;[ condition ]（&lt;strong&gt;注意condition前后要有空格&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;注意：条件非空即为true，[ root ]返回true，[] 返回false。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;常用判断条件&lt;/p&gt;
&lt;p&gt;（1）两个整数之间比较&lt;/p&gt;
&lt;p&gt;= 字符串比较&lt;/p&gt;
&lt;p&gt;-lt 小于（less than）           -le 小于等于（less equal）&lt;/p&gt;
&lt;p&gt;-eq 等于（equal）                 -gt 大于（greater than）&lt;/p&gt;
&lt;p&gt;-ge 大于等于（greater equal）  -ne 不等于（Not equal）&lt;/p&gt;
&lt;p&gt;（2）按照文件权限进行判断&lt;/p&gt;
&lt;p&gt;-r 有读的权限（read）         -w 有写的权限（write）&lt;/p&gt;
&lt;p&gt;-x 有执行的权限（execute）&lt;/p&gt;
&lt;p&gt;（3）按照文件类型进行判断&lt;/p&gt;
&lt;p&gt;-f 文件存在并且是一个常规的文件（file）&lt;/p&gt;
&lt;p&gt;-e 文件存在（existence）      -d 文件存在并是一个目录（directory）&lt;/p&gt;
&lt;p&gt;-s 文件存在且不为空      -L 文件存在且是一个链接(link)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;案例实操&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;23是否大于等于22&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@hadoop101 datas]$ [ 23 -ge 22 ]
[root@hadoop101 datas]$ echo $?
0
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;helloworld.sh是否具有写权限&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@hadoop101 datas]$ [ -w helloworld.sh ]
[root@hadoop101 datas]$ echo $?
0
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/home/root/cls.txt目录中的文件是否存在&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@hadoop101 datas]$ [ -e /home/root/cls.txt ]
[root@hadoop101 datas]$ echo $?
1
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多条件判断（&amp;amp;&amp;amp; 表示前一条命令执行成功时，才执行后一条命令，|| 表示上一条命令执行失败后，才执行下一条命令）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@hadoop101 ~]$ [ condition ] &amp;amp;&amp;amp; echo OK || echo notok
OK
[root@hadoop101 datas]$ [ condition ] &amp;amp;&amp;amp; [ ] || echo notok
notok
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;5-流程控制&#34;&gt;5、流程控制&lt;/h2&gt;
&lt;h3 id=&#34;51-if-判断&#34;&gt;5.1  if 判断&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;基本语法&lt;/p&gt;
&lt;p&gt;if [ 条件判断式 ]&lt;/p&gt;
&lt;p&gt;then&lt;/p&gt;
&lt;p&gt;程序&lt;/p&gt;
&lt;p&gt;elif 条件判断式&lt;/p&gt;
&lt;p&gt;​     then 程序..&lt;/p&gt;
&lt;p&gt;else 程序..&lt;/p&gt;
&lt;p&gt;fi&lt;/p&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;p&gt;if [ 条件判断式 ] ; then&lt;/p&gt;
&lt;p&gt;​		程序..&lt;/p&gt;
&lt;p&gt;elif [条件判断式] ; then&lt;/p&gt;
&lt;p&gt;程序..&lt;/p&gt;
&lt;p&gt;else 程序&lt;/p&gt;
&lt;p&gt;fi&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​	注意事项：&lt;/p&gt;
&lt;p&gt;（1）[ 条件判断式 ]，中括号和条件判断式之间必须有空格&lt;/p&gt;
&lt;p&gt;（2）&lt;strong&gt;if后要有空格&lt;/strong&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;案例实操&lt;/p&gt;
&lt;p&gt;如果输入的数字是1，2，3则输出你输入的数字是xx，否则输出，你输入的数字不是1，2，3&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@0725pc shells]# cat test3.sh 
#! /bin/bash
if [ $1 -eq 1 ]
then
    echo &amp;quot;你输入的是1啊！&amp;quot;
elif [ $1 -eq 2 ]
then
	 echo &amp;quot;你输入的是2啊！&amp;quot;
elif [ $1 -eq 3 ]
then
         echo &amp;quot;你输入的是3啊！&amp;quot;
else  echo &amp;quot;你输入的不是1,2,3啊！&amp;quot;
fi

[root@0725pc shells]# bash test3.sh 3
你输入的是3啊！
[root@0725pc shells]# bash test3.sh 2
你输入的是2啊！
[root@0725pc shells]# bash test3.sh 1
你输入的是1啊！
[root@0725pc shells]# bash test3.sh 4
你输入的不是1,2,3啊！
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;52-case-语句&#34;&gt;5.2 case 语句&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;基本语法&lt;/p&gt;
&lt;p&gt;case $变量名 in&lt;/p&gt;
&lt;p&gt;&amp;quot;值1&amp;quot;）&lt;/p&gt;
&lt;p&gt;如果变量的值等于值1，则执行程序1&lt;/p&gt;
&lt;p&gt;;;&lt;/p&gt;
&lt;p&gt;&amp;quot;值2&amp;quot;）&lt;/p&gt;
&lt;p&gt;如果变量的值等于值2，则执行程序2&lt;/p&gt;
&lt;p&gt;;;&lt;/p&gt;
&lt;p&gt;…省略其他分支…&lt;/p&gt;
&lt;p&gt;*）&lt;/p&gt;
&lt;p&gt;如果变量的值都不是以上的值，则执行此程序&lt;/p&gt;
&lt;p&gt;;;&lt;/p&gt;
&lt;p&gt;esac&lt;/p&gt;
&lt;p&gt;注意事项：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;case行尾必须为单词“in”，每一个模式匹配必须以右括号“）”结束。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;双分号“&lt;strong&gt;;;&lt;/strong&gt;”表示命令序列结束，相当于java中的break。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最后的“*）”表示默认模式，相当于java中的default。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;案例实操&lt;/p&gt;
&lt;p&gt;输入一个数字，如果是1，则输出banzhang，如果是2，则输出cls，如果是其它，输出renyao。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@hadoop101 datas]$ touch case.sh
[root@hadoop101 datas]$ vim case.sh

!/bin/bash
case $1 in
&amp;quot;1&amp;quot;)
        echo &amp;quot;banzhang&amp;quot;
;;

&amp;quot;2&amp;quot;)
        echo &amp;quot;cls&amp;quot;
;;
*)
        echo &amp;quot;renyao&amp;quot;
;;
esac

[root@hadoop101 datas]$ chmod 777 case.sh
[root@hadoop101 datas]$ ./case.sh 1
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;53-for-循环&#34;&gt;5.3  for 循环&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;基本语法&lt;/p&gt;
&lt;p&gt;for (( 初始值;循环控制条件;变量变化 ))&lt;/p&gt;
&lt;p&gt;do&lt;/p&gt;
&lt;p&gt;程序&lt;/p&gt;
&lt;p&gt;done&lt;/p&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;p&gt;for (( 初始值;循环控制条件;变量变化 )); do 程序; done&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;案例实操&lt;/p&gt;
&lt;p&gt;从1加到100&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@hadoop101 datas]$ touch for1.sh
[root@hadoop101 datas]$ vim for1.sh

#!/bin/bash

s=0
for((i=0;i&amp;lt;=100;i++))
do
        s=$[$s+$i]
done
echo $s

[root@hadoop101 datas]$ chmod 777 for1.sh 
[root@hadoop101 datas]$ ./for1.sh 
“5050”

[root@0725pc shells]# tail -n 4 test1.sh 
SUM2=0
for((i=0;i&amp;lt;=10;i++));do SUM2=$(($SUM2+$i)); done
echo &amp;quot;从1加到100的值是：$SUM2&amp;quot;
[root@0725pc shells]# ./test1.sh 
从1加到100的值是：55
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基本语法2(foreach)&lt;/p&gt;
&lt;p&gt;for 变量 in 值1 值2 值3…&lt;/p&gt;
&lt;p&gt;do&lt;/p&gt;
&lt;p&gt;程序&lt;/p&gt;
&lt;p&gt;done&lt;/p&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;p&gt;for 变量 in 1 2 3; do 程序; done&lt;/p&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;p&gt;for 变量 in {1..3}; do 程序; done&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;案例实操&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;打印所有输入参数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@hadoop101 datas]$ touch for2.sh
[root@hadoop101 datas]$ vim for2.sh

#!/bin/bash
#打印数字

for i in $*
    do
      echo &amp;quot;ban zhang love $i &amp;quot;
    done

[root@hadoop101 datas]$ chmod 777 for2.sh 
[root@hadoop101 datas]$ bash for2.sh cls xz bd
ban zhang love cls
ban zhang love xz
ban zhang love bd

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多种写法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@0725pc shells]# cat test2.sh 
#! /bin/bash
for i in 1 2 3
do 
	echo $i
done
echo &amp;quot;--------------------&amp;quot;
for i in 1 2 3 ;do echo $i;done
echo &amp;quot;--------------------&amp;quot;
for i in {1..3};do echo $i;done
[root@0725pc shells]# ./test2.sh 
1
2
3
--------------------
1
2
3
--------------------
1
2
3
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;比较&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;和&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;*和&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.46528em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;和&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;@区别&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;和&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;*和&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.46528em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;和&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;@都表示传递给函数或脚本的所有参数，不被双引号“”包含时，都以$1 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;…&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;2 …&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;…&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;n的形式输出所有参数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@hadoop101 datas]$ touch for.sh
[root@hadoop101 datas]$ vim for.sh

#!/bin/bash 

for i in $*
do
      echo &amp;quot;ban zhang love $i &amp;quot;
done

for j in $@
do      
        echo &amp;quot;ban zhang love $j&amp;quot;
done

[root@hadoop101 datas]$ bash for.sh cls xz bd
ban zhang love cls 
ban zhang love xz 
ban zhang love bd 
ban zhang love cls
ban zhang love xz
ban zhang love bd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当它们被双引号“”包含时，“$*”会将所有的参数作为一个整体，以“$1 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;…&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;2 …&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;…&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;n”的形式输出所有参数；“$@”会将各个参数分开，以“$1” “&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;”&lt;/mi&gt;&lt;mo&gt;…&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;”&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;2”…”&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;”&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;…&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;”&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;n”的形式输出所有参数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@hadoop101 datas]$ vim for.sh

#!/bin/bash 

for i in &amp;quot;$*&amp;quot; 
#$*中的所有参数看成是一个整体，所以这个for循环只会循环一次 
        do 
                echo &amp;quot;ban zhang love $i&amp;quot;
        done 

for j in &amp;quot;$@&amp;quot; 
#$@中的每个参数都看成是独立的，所以“$@”中有几个参数，就会循环几次 
        do 
                echo &amp;quot;ban zhang love $j&amp;quot; 
done

[root@hadoop101 datas]$ chmod 777 for.sh
[root@hadoop101 datas]$ bash for.sh cls xz bd
ban zhang love cls xz bd
ban zhang love cls
ban zhang love xz
ban zhang love bd
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;54-while-循环&#34;&gt;5.4 while 循环&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;基本语法&lt;/p&gt;
&lt;p&gt;while [ 条件判断式 ]&lt;/p&gt;
&lt;p&gt;do&lt;/p&gt;
&lt;p&gt;程序&lt;/p&gt;
&lt;p&gt;done&lt;/p&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;p&gt;while((表达式))&lt;/p&gt;
&lt;p&gt;do&lt;/p&gt;
&lt;p&gt;​     程序&lt;/p&gt;
&lt;p&gt;done&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;案例实操&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;从1加到100&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@hadoop101 datas]$ touch while.sh
[root@hadoop101 datas]$ vim while.sh

#!/bin/bash
s=0
i=1
while [ $i -le 100 ]
do
        s=$[$s+$i]
        i=$[$i+1]
done

echo $s

[root@hadoop101 datas]$ chmod 777 while.sh 
[root@hadoop101 datas]$ ./while.sh 
5050
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从0开始，累加加11次&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@0725pc shells]# bash test3.sh 
11
[root@0725pc shells]# cat test3.sh 
#! /bin/bash

NUM=0
while((NUM&amp;lt;=10));do let NUM++; done
echo $NUM
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;6-read读取控制台输入&#34;&gt;6、read读取控制台输入&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;基本语法&lt;/p&gt;
&lt;p&gt;read(选项)(参数)&lt;/p&gt;
&lt;p&gt;​     选项：&lt;/p&gt;
&lt;p&gt;-p：指定读取值时的提示符；&lt;/p&gt;
&lt;p&gt;-t：指定读取值时等待的时间（秒）。&lt;/p&gt;
&lt;p&gt;参数&lt;/p&gt;
&lt;p&gt;​     变量：指定读取值的变量名&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;案例实操&lt;/p&gt;
&lt;p&gt;提示7秒内，读取控制台输入的名称&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@hadoop101 datas]$ touch read.sh
[root@hadoop101 datas]$ vim read.sh

#!/bin/bash

read -t 7 -p &amp;quot;Enter your name in 7 seconds &amp;quot; NAME
echo $NAME

[root@hadoop101 datas]$ ./read.sh 
Enter your name in 7 seconds xiaoze
xiaoze
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;7-函数&#34;&gt;7、函数&lt;/h2&gt;
&lt;h3 id=&#34;71-系统函数&#34;&gt;7.1 系统函数&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;basename基本语法&lt;/p&gt;
&lt;p&gt;basename [string / pathname] [suffix]     （功能描述：basename命令会删掉所有的前缀包括最后一个（‘/’）字符，然后将字符串显示出来。&lt;/p&gt;
&lt;p&gt;选项：&lt;/p&gt;
&lt;p&gt;suffix为后缀，如果suffix被指定了，basename会将pathname或string中的suffix去掉。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;案例实操&lt;/p&gt;
&lt;p&gt;截取该/home/root/banzhang.txt路径的文件名称&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@hadoop101 datas]$ basename /home/root/banzhang.txt 
banzhang.txt
[root@hadoop101 datas]$ basename /home/root/banzhang.txt .txt
banzhang
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;dirname基本语法&lt;/p&gt;
&lt;p&gt;dirname 文件绝对路径     （功能描述：从给定的包含绝对路径的文件名中去除文件名（非目录的部分），然后返回剩下的路径（目录的部分））&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;案例实操&lt;/p&gt;
&lt;p&gt;获取banzhang.txt文件的路径&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@hadoop101 ~]$ dirname /home/root/banzhang.txt 
/home/root
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;72-自定义函数&#34;&gt;7.2 自定义函数&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;基本语法&lt;/p&gt;
&lt;p&gt;function  funname[()]&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;​     Action;&lt;/p&gt;
&lt;p&gt;​     [return int;]&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;funname&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;经验技巧&lt;/p&gt;
&lt;p&gt;​     （1）必须在调用函数地方之前，先声明函数，shell脚本是逐行运行。不会像其它语言一样先编译。&lt;/p&gt;
&lt;p&gt;​     （2）函数返回值，只能通过$?系统变量获得，可以显示加：return返回，如果不加，将以最后一条命令运行结果，作为返回值。return后跟数值n(0-255)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;案例实操&lt;/p&gt;
&lt;p&gt;计算两个输入参数的和&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@hadoop101 datas]$ touch fun.sh
[root@hadoop101 datas]$ vim fun.sh

#!/bin/bash
function sum()
{
    s=0
    s=$[ $1 + $2 ]
    echo &amp;quot;$s&amp;quot;
}

read -p &amp;quot;Please input the number1: &amp;quot; n1;
read -p &amp;quot;Please input the number2: &amp;quot; n2;
sum $n1 $n2;
[root@hadoop101 datas]$ chmod 777 fun.sh
[root@hadoop101 datas]$ ./fun.sh 
Please input the number1: 2
Please input the number2: 5
7
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;8-shell工具重点&#34;&gt;8、Shell工具（重点）&lt;/h2&gt;
&lt;h3 id=&#34;81-wc&#34;&gt;8.1 wc&lt;/h3&gt;
&lt;p&gt;​     wc命令用来计算数字。利用wc指令我们可以计算文件的Byte数、字数或是列数，若不指定文件名称，或是所给予的文件名为“-”，则wc指令会从标准输入设备读取数据。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;基本用法&lt;/p&gt;
&lt;p&gt;​         wc [选项参数] filename&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;参数说明&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;选项参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-l&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;统计文件行数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-w&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;统计文件的单词数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-m&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;统计文件的字符数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-c&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;统计文件的字节数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;案例实操&lt;/p&gt;
&lt;p&gt;统计redis_6379.conf文件的行数、单词数、字节数！&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@0725pc myredis]# ll | grep redis_6379.conf
-rw-r--r--. 1 root root      188 10月  9 15:33 redis_6379.conf
[root@0725pc myredis]# cat -n redis_6379.conf 
     1	include /root/myredis/redis.conf
     2	pidfile &amp;quot;/var/run/redis_6379.pid&amp;quot;
     3	port 6379
     4	dbfilename &amp;quot;dump_6379.rdb&amp;quot;
     5	cluster-enabled yes
     6	cluster-config-file nodes-6379.conf
     7	cluster-node-timeout 15000
     8	
[root@0725pc myredis]# wc -w redis_6379.conf 
14 redis_6379.conf
[root@0725pc myredis]# wc -l redis_6379.conf 
8 redis_6379.conf
[root@0725pc myredis]# wc -m redis_6379.conf 
188 redis_6379.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;82-cut&#34;&gt;8.2 cut&lt;/h3&gt;
&lt;p&gt;​		cut的工作就是“剪”，具体的说就是在文件中负责剪切数据用的。cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段输出。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;基本用法&lt;/p&gt;
&lt;p&gt;cut [选项参数]  filename&lt;/p&gt;
&lt;p&gt;说明：默认分隔符是制表符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选项参数说明&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;选项参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-f&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;f为fileds，列号，提取第几列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-d&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;d为Descriptor分隔符，按照指定分隔符分割列&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;案例实操&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;以：为间隔，切割PATH环境变量的第一列&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@0725pc ~]# echo $PATH
/usr/lib64/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/opt/jdk1.8.0_121/bin:/root/bin
[root@0725pc ~]# echo $PATH | cut -d &#39;:&#39; -f 1
/usr/lib64/qt-3.3/bin
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;以：为间隔，切割PATH环境变量的第二、三列&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@0725pc ~]# echo $PATH
/usr/lib64/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/opt/jdk1.8.0_121/bin:/root/bin
[root@0725pc ~]# echo $PATH | cut -d &#39;:&#39; -f 2,3
/usr/local/sbin:/usr/local/bin
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选取系统PATH变量值，第2个“：”开始后的所有路径：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@hadoop101 datas]$ echo $PATH
/usr/lib64/qt-3.3/bin:/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/root/bin

[root@hadoop102 datas]$ echo $PATH | cut -d: -f 3-
/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/root/bin
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;以：为间隔，切割PATH环境变量的第一到三列，和第五列&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@0725pc ~]# echo $PATH
/usr/lib64/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/opt/jdk1.8.0_121/bin:/root/bin
[root@0725pc ~]# echo $PATH | cut -d &#39;:&#39; -f 1-3,5
/usr/lib64/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/bin
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;切割ifconfig 后打印的IP地址&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;root@hadoop101 datas]$ ifconfig eth0 | grep &amp;quot;inet addr&amp;quot; | cut -d: -f 2 | cut -d&amp;quot; &amp;quot; -f1
192.168.1.102
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;83-sed&#34;&gt;8.3 sed&lt;/h3&gt;
&lt;p&gt;sed是一种流编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”，接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有改变，除非你使用重定向存储输出。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;基本用法&lt;/p&gt;
&lt;p&gt;sed [选项参数] ‘command’ filename&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选项参数说明&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;选项参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-e&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;直接在指令列模式上进行sed的动作编辑。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;命令功能描述&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;命令&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;功能描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;a&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;新增，a的后面可以接字串，在下一行出现&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;d&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;删除&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;s&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;查找并替换&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;案例实操&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;数据准备&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@hadoop102 datas]$ touch sed.txt
[root@hadoop102 datas]$ vim sed.txt
dong shen
guan zhen
wo  wo
lai  lai

le  le
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将“mei nv”这个单词插入到sed.txt第二行下，打印。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@hadoop102 datas]$ sed &#39;2a mei nv&#39; sed.txt 
dong shen
guan zhen
mei nv
wo  wo
lai  lai

le  le
[root@hadoop102 datas]$ cat sed.txt 
dong shen
guan zhen
wo  wo
lai  lai

le  le
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：文件并没有改变&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除sed.txt文件所有包含wo的行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@hadoop102 datas]$ sed &#39;/wo/d&#39; sed.txt
dong shen
guan zhen
lai  lai

le  le
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除sed.txt文件第二行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@0725pc ~]# cat sed.txt
dong shen
guan zhen
wo  wo
lai  lai

le  le

[root@0725pc ~]# sed &#39;2d&#39; sed.txt 
dong shen
wo  wo
lai  lai

le  le
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除sed.txt文件最后一行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@0725pc ~]# sed &#39;2,$d&#39; sed.txt 
dong shen
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除sed.txt文件第二行至最后一行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@0725pc ~]# sed &#39;2,$d&#39; sed.txt 
dong shen
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将sed.txt文件中wo替换为ni&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@hadoop102 datas]$ sed &#39;s/wo/ni/g&#39; sed.txt 
dong shen
guan zhen
ni  ni
lai  lai

le  le
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：‘g’表示global，全部替换，不加g只会替换第一个匹配到的字符。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将sed.txt文件中的第二行删除并将wo替换为ni&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@hadoop102 datas]$ sed -e &#39;2d&#39; -e &#39;s/wo/ni/g&#39; sed.txt 
dong shen
ni  ni
lai  lai

le  le
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;84-awk&#34;&gt;8.4 awk&lt;/h3&gt;
&lt;p&gt;一个强大的文本分析工具，把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行分析处理。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;基本用法&lt;/p&gt;
&lt;p&gt;awk [选项参数] ‘pattern1{action1} pattern2{action2}...’ filename&lt;/p&gt;
&lt;p&gt;pattern：表示AWK在数据中查找的内容，就是匹配模式&lt;/p&gt;
&lt;p&gt;action：在找到匹配内容时所执行的一系列命令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选项参数说明&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;选项参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-F&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;指定输入文件折分隔符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-v&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;赋值一个用户定义变量&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;案例实操&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;数据准备&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@hadoop102 datas]$ sudo cp /etc/passwd ./
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;搜索passwd文件以root关键字开头的所有行，并输出该行的第7列。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@hadoop102 datas]$ awk -F: &#39;/^root/{print $7}&#39; passwd 
/bin/bash
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;搜索passwd文件以root关键字开头的所有行，并输出该行的第1列和第7列，中间以“，”号分割。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@hadoop102 datas]$ awk -F: &#39;/^root/{print $1&amp;quot;,&amp;quot;$7}&#39; passwd 
root,/bin/bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：只有匹配了patter的行才会执行action&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只显示/etc/passwd的第一列和第七列，以逗号分割，且在所有行前面添加列名user，shell在最后一行添加&amp;quot;dahaige，/bin/zuishuai&amp;quot;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@hadoop102 datas]$ awk -F : &#39;BEGIN{print &amp;quot;user, shell&amp;quot;} {print $1&amp;quot;,&amp;quot;$7} END{print &amp;quot;dahaige,/bin/zuishuai&amp;quot;}&#39; passwd
user, shell
root,/bin/bash
bin,/sbin/nologin
。。。
root,/bin/bash
dahaige,/bin/zuishuai
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：BEGIN 在所有数据读取行之前执行；END 在所有数据执行之后执行。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将passwd文件中的用户id增加数值1并输出&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@hadoop102 datas]$ awk -v i=1 -F: &#39;{print $3+i}&#39; passwd
1
2
3
4
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;awk的内置变量&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;变量&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;FILENAME&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;文件名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;NR&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;已读的记录数（行号）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;NF&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;浏览记录的域的个数（切割后列的个数）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;案例实操&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;统计passwd文件名，每行的行号，每行的列数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@hadoop102 datas]$ awk -F: &#39;{print &amp;quot;filename:&amp;quot;  FILENAME &amp;quot;, linenumber:&amp;quot; NR  &amp;quot;,columns:&amp;quot; NF}&#39; passwd 
filename:passwd, linenumber:1,columns:7
filename:passwd, linenumber:2,columns:7
filename:passwd, linenumber:3,columns:7
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;切割IP&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@hadoop102 datas]$ ifconfig eth0 | grep &amp;quot;inet addr&amp;quot; | awk -F: &#39;{print $2}&#39; | awk -F &amp;quot; &amp;quot; &#39;{print $1}&#39; 
192.168.1.102
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查询sed.txt中空行所在的行号&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@hadoop102 datas]$ awk &#39;/^$/{print NR}&#39; sed.txt 
5
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;85-sort&#34;&gt;8.5 sort&lt;/h3&gt;
&lt;p&gt;sort命令是在Linux里非常有用，它将文件进行排序，并将排序结果标准输出。默认情况以第一个字符串的字典顺序来排序！&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;基本语法&lt;/p&gt;
&lt;p&gt;sort(选项)(参数)&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;选项&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-n&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;依照数值的大小排序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-r&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;以相反的顺序来排序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-t&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;设置排序时所用的分隔字符，默认使用TAB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-k&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;指定需要排序的列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-u&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;u为unique的缩写，即如果出现相同的数据，只出现一行&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;参数：指定待排序的文件列表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;案例实操&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;数据准备&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@hadoop102 datas]$ touch sort.sh
[root@hadoop102 datas]$ vim sort.sh 
bb:40:5.4
bd:20:4.2
xz:50:2.3
cls:10:3.5
ss:30:1.6
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按照“：”分割后的第三列倒序排序。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@hadoop102 datas]$ sort -t : -nrk 3  sort.sh 
bb:40:5.4
bd:20:4.2
cls:10:3.5
xz:50:2.3
ss:30:1.6
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
">Shell编程</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jonchan1013.github.io/post/docker/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200815145424.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;1-容器介绍&#34;&gt;1、容器介绍&lt;/h2&gt;
&lt;p&gt;容器其实是⼀种沙盒技术。顾名思义，沙盒就是能够像⼀个集装箱⼀样，把你的应⽤&amp;quot;装&amp;quot;起来的技术。这样，应⽤与应⽤之间，就因为有了边界⽽不⾄于相互⼲扰；⽽被装进集装箱的应⽤，也可以被⽅便地搬来搬去，这其实是 PaaS 最理想的状态。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;strong&gt;问题：容器的本质到底是什么？&lt;/strong&gt;&lt;br&gt;
容器的本质是进程。容器就是未来云计算系统中的进程；容器镜像就是这个系统⾥的&amp;quot;.exe&amp;quot;安装包。Kubernetes 就是操作系统！&lt;/p&gt;
&lt;h3 id=&#34;11-docker介绍&#34;&gt;1.1 Docker介绍&lt;/h3&gt;
&lt;h4 id=&#34;111-docker公司认知&#34;&gt;1.1.1 Docker公司认知&lt;/h4&gt;
&lt;p&gt;官⽹地址：docker.io docker.com&lt;/p&gt;
&lt;p&gt;公司名称：原名dotCloud  14年改名为docker&lt;/p&gt;
&lt;p&gt;容器产品：docker 16年已经被更名为Moby&lt;/p&gt;
&lt;h4 id=&#34;112-容器简史&#34;&gt;1.1.2 容器简史&lt;/h4&gt;
&lt;p&gt;和虚拟机⼀样，容器技术也是⼀种资源隔离的虚拟化技术。我们追溯它的历史，会发现它的技术雏形早已有之。&lt;/p&gt;
&lt;p&gt;容器概念始于 1979 年提出的 UNIX chroot，它是⼀个 UNIX 操作系统的系统调⽤，将⼀个进程及其⼦进程的根⽬录改变到⽂件系统中的⼀个新位置，让这些进程只能访问到这个新的位置，从⽽达到了进程隔离的⽬的。&lt;/p&gt;
&lt;p&gt;2000 年的时候 FreeBSD 开发了⼀个类似于 chroot 的容器技术 Jails，这是最早期，也是功能最多的容器技术。Jails 英译过来是监狱的意思，这个“监狱”（⽤沙盒更为准确）包含了⽂件系统、⽤户、⽹络、进程等的隔离。&lt;/p&gt;
&lt;p&gt;2001 Linux 也发布⾃⼰的容器技术 Linux VServer，2004 Solaris 也发布了 Solaris Containers，两者都将资源进⾏划分，形成⼀个个 zones，⼜叫做虚拟服务器。&lt;/p&gt;
&lt;p&gt;2005 年推出 OpenVZ，它通过对 Linux 内核进⾏补丁来提供虚拟化的⽀持，每个 OpenVZ 容器完整⽀持了⽂件系统、⽤户及⽤户、进程、⽹络、设备和 IPC 对象的隔离。&lt;/p&gt;
&lt;p&gt;2007 年 Google 实现了 Control Groups( cgroups )，并加⼊到 Linux 内核中，这是划时代的，为后期容器的资源配额提供了技术保障。&lt;/p&gt;
&lt;p&gt;2008 年基于 cgroups 和 linux namespace 推出了第⼀个最为完善的 Linux 容器 LXC。&lt;/p&gt;
&lt;p&gt;2013 年推出到现在为⽌最为流⾏和使⽤最⼴泛的容器 Docker，相⽐其他早期的容器技术，Docker 引⼊了⼀整套容器管理的⽣态系统，包括分层的镜像模型，容器注册库，友好的 Rest API。&lt;/p&gt;
&lt;p&gt;2014 年 CoreOS 也推出了⼀个类似于 Docker 的容器 Rocket，CoreOS ⼀个更加轻量级的 Linux 操作系统，在安全性上⽐ Docker 更严格。&lt;/p&gt;
&lt;p&gt;2016 年微软也在 Windows 上提供了容器的⽀持，Docker 可以以原⽣⽅式运⾏在 Windows 上，⽽不是需要使⽤ Linux 虚拟机。&lt;/p&gt;
&lt;p&gt;基本上到这个时间节点，容器技术就已经很成熟了，再往后就是容器云的发展，由此也衍⽣出多种容器云的平台管理技术，其中以 kubernetes 最为出众，有了这样⼀些细粒度的容器集群管理技术，也为微服务的发展奠定了基⽯。因此，对于未来来说，应⽤的微服务化是⼀个较⼤的趋势。&lt;/p&gt;
&lt;h4 id=&#34;113-容器需求成因&#34;&gt;1.1.3 容器需求成因&lt;/h4&gt;
&lt;p&gt;其⼀，这是技术演进的⼀种创新结果，其⼆，这是⼈们追求⾼效⽣产活动的⼀种⼯具。&lt;/p&gt;
&lt;p&gt;随着软件开发的发展，相⽐于早期的集中式应⽤部署⽅式，现在的应⽤基本都是采⽤分布式的部署⽅式，⼀个应⽤可能包含多种服务或多个模块，因此多种服务可能部署在多种环境中，如虚拟服务器、公有云、私有云等，由于多种服务之间存在⼀些依赖关系，所以可能存在应⽤在运⾏过程中的动态迁移问题，那这时如何保证不同服务在不同环境中都能平滑的适配，不需要根据环境的不同⽽去进⾏相应的定制，就显得尤为重要。&lt;/p&gt;
&lt;p&gt;就像货物的运输问题⼀样，如何将不同的货物放在不同的运输机器上，减少因货物的不同⽽频繁进⾏货物的装载和卸载，浪费⼤量的⼈⼒物⼒。&lt;/p&gt;
&lt;p&gt;为此⼈们发明了集装箱，将货物根据尺⼨形状等的不同，⽤不同规格的集装箱装载，然后再放到运输机上运输，由于集装箱密封，只有货物到达⽬的地才需拆封，在运输过程能够再不同运输机上平滑过渡，所以避免了资源的浪费。&lt;/p&gt;
&lt;p&gt;因此集装箱被誉为是运输业与世界贸易最重要的发明。&lt;/p&gt;
&lt;p&gt;Docker 容器的思想就是采⽤集装箱思想，为应⽤提供了⼀个基于容器的标准化运输系统。Docker 可以将任何应⽤及其依赖打包成⼀个轻量级、可移植、⾃包含的容器。容器可以运⾏在⼏乎所有的操作系统上。这样容器就可以跑在任何环境中，因此才有了那句话：Build Once, Run Anywhere&lt;/p&gt;
&lt;p&gt;这种集装箱的思想我们也能从 Docker 的 Logo 中看出来，这不就是⼀堆集装箱吗？&lt;/p&gt;
&lt;h4 id=&#34;114-docker-vs-传统&#34;&gt;1.1.4、Docker VS 传统&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;部署模式区别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;传统的部署模式：  安装(包管理⼯具或者源码包编译)-&amp;gt;配置-&amp;gt;运⾏&lt;/p&gt;
&lt;p&gt;Docker部署模式：复制-&amp;gt;运⾏&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;容器和虚拟机区别&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;容器提供了基于进程的隔离，⽽虚拟机提供了资源的完全隔离。&lt;/li&gt;
&lt;li&gt;虚拟机可能需要⼀分钟来启动，⽽容器只需要⼀秒钟或更短。&lt;/li&gt;
&lt;li&gt;容器使⽤宿主操作系统的内核，⽽虚拟机使⽤独⽴的内核&lt;/li&gt;
&lt;li&gt;容器只是⼀个进程，⽽虚拟机不是&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Docker对服务器端开发/部署带来的变化：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实现更轻量级的虚拟化，⽅便快速部署&lt;/p&gt;
&lt;p&gt;对于部署来说可以极⼤的减少部署的时间成本和⼈⼒成本&lt;/p&gt;
&lt;p&gt;Docker⽀持将应⽤打包进⼀个可以移植的容器中，重新定义了应⽤开发，测试，部署上线的过程，核⼼&lt;br&gt;
理念就&lt;/p&gt;
&lt;p&gt;是 Build once, Run anywhere&lt;/p&gt;
&lt;p&gt;1）标准化应⽤发布，docker容器包含了运⾏环境和可执⾏程序，可以跨平台和主机使⽤；&lt;/p&gt;
&lt;p&gt;2）节约时间，快速部署和启动，VM启动⼀般是分钟级，docker容器启动是秒级；&lt;/p&gt;
&lt;p&gt;3）⽅便构建基于SOA架构或微服务架构的系统，通过服务编排，更好的松耦合；&lt;/p&gt;
&lt;p&gt;4）节约成本，以前⼀个虚拟机⾄少需要⼏个G的磁盘空间，docker容器可以减少到MB级；&lt;/p&gt;
&lt;p&gt;5）⽅便持续集成，通过与代码进⾏关联使持续集成⾮常⽅便；&lt;/p&gt;
&lt;p&gt;6）可以作为集群系统的轻量主机或节点，在IaaS平台上，已经出现了CaaS，通过容器替代原来的主机。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Docker 优势&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、交付物标准化&lt;/p&gt;
&lt;p&gt;Docker是软件⼯程领域的&amp;quot;标准化&amp;quot;交付组件，最恰到好处的类⽐是&amp;quot;集装箱&amp;quot;。&lt;/p&gt;
&lt;p&gt;集装箱将零散、不易搬运的⼤量物品封装成⼀个整体，集装箱更重要的意义在于它提供了⼀种通⽤的封装货物的&lt;/p&gt;
&lt;p&gt;标准，卡⻋、⽕⻋、货轮、桥吊等运输或搬运⼯具采⽤此标准，隧道、桥梁等也采⽤此标准。以集装箱为中⼼的&lt;/p&gt;
&lt;p&gt;标准化设计⼤⼤提⾼了物流体系的运⾏效率。&lt;/p&gt;
&lt;p&gt;传统的软件交付物包括：应⽤程序、依赖软件安装包、配置说明⽂档、安装⽂档、上线⽂档等⾮标准化组件。&lt;/p&gt;
&lt;p&gt;Docker的标准化交付物称为&amp;quot;镜像&amp;quot;，它包含了应⽤程序及其所依赖的运⾏环境，⼤⼤简化了应⽤交付的模式。&lt;/p&gt;
&lt;p&gt;2、⼀次构建，多次交付&lt;/p&gt;
&lt;p&gt;类似于集装箱的&amp;quot;⼀次装箱，多次运输&amp;quot;，Docker镜像可以做到&amp;quot;⼀次构建，多次交付&amp;quot;。当涉及到应⽤程序多副本&lt;/p&gt;
&lt;p&gt;部署或者应⽤程序迁移时，更能体现Docker的价值。&lt;/p&gt;
&lt;p&gt;3、应⽤隔离&lt;/p&gt;
&lt;p&gt;集装箱可以有效做到货物之间的隔离，使化学物品和⻝品可以堆砌在⼀起运输。Docker可以隔离不同应&lt;br&gt;
⽤程序之间的相互影响，但是⽐虚拟机开销更⼩。&lt;/p&gt;
&lt;p&gt;总之，容器技术部署速度快，开发、测试更敏捷；提⾼系统利⽤率，降低资源成本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Docker的度量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Docker是利⽤容器来实现的⼀种轻量级的虚拟技术，从⽽在保证隔离性的同时达到节省资源的⽬的。&lt;br&gt;
Docker的可移植性可以让它⼀次建⽴，到处运⾏。Docker的度量可以从以下四个⽅⾯进⾏：&lt;/p&gt;
&lt;p&gt;1）隔离性&lt;/p&gt;
&lt;p&gt;Docker采⽤libcontainer作为默认容器，代替了以前的LXC。libcontainer的隔离性主要是通过内核的命名空 间来实现 的，有pid、net、ipc、mnt、uts命令空间，将容器的进程、⽹络、消息、⽂件系统和主机名进⾏隔 离。&lt;/p&gt;
&lt;p&gt;2）可度量性&lt;/p&gt;
&lt;p&gt;Docker主要通过cgroups控制组来控制资源的度量和分配。&lt;/p&gt;
&lt;p&gt;3）移植性&lt;/p&gt;
&lt;p&gt;Docker利⽤AUFS来实现对容器的快速更新。&lt;/p&gt;
&lt;p&gt;AUFS是⼀种⽀持将不同⽬录挂载到同⼀个虚拟⽂件系统下的⽂件系统，⽀持对每个⽬录的读写权限管理。AUFS具有层 的概念，每⼀次修改都是在已有的只写层进⾏增量修改，修改的内容将形成新的⽂件层，不影响原有的层。&lt;/p&gt;
&lt;p&gt;4）安全性&lt;/p&gt;
&lt;p&gt;安全性可以分为容器内部之间的安全性；容器与托管主机之间的安全性。&lt;/p&gt;
&lt;p&gt;容器内部之间的安全性主要是通过命名空间和cgroups来保证的。&lt;/p&gt;
&lt;p&gt;容器与托管主机之间的安全性主要是通过内核能⼒机制的控制，可以防⽌Docker⾮法⼊侵托管主机。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Docker容器使⽤AUFS作为⽂件系统，有如下优势&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）节省存储空间&lt;/p&gt;
&lt;p&gt;多个容器可以共享同⼀个基础镜像存储。&lt;/p&gt;
&lt;p&gt;2）快速部署&lt;/p&gt;
&lt;p&gt;如果部署多个来⾃同⼀个基础镜像的容器时，可以避免多次复制操作。&lt;/p&gt;
&lt;p&gt;3）升级⽅便&lt;/p&gt;
&lt;p&gt;升级⼀个基础镜像即可影响到所有基于它的容器。&lt;/p&gt;
&lt;p&gt;4）增量修改&lt;/p&gt;
&lt;p&gt;可以在不改变基础镜像的同时修改其⽬录的⽂件，所有的更⾼都发⽣在最上层的写操作层，增加了基础镜像的可共享内容。&lt;/p&gt;
&lt;h4 id=&#34;115-容器的应用场景&#34;&gt;1.1.5、 容器的应⽤场景&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;简化配置&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这是Docker公司宣传的Docker的主要使⽤场景。虚拟机的最⼤好处是能在你的硬件设施上运⾏各种配置不⼀样的平台（软件、系统），Docker在降低额外开销的情况下提供了同样的功能。它能让你将运⾏环境和配置放在代码中然后部署，同⼀个Docker的配置可以在不同的环境中使⽤，这样就降低了硬件要求和应⽤环境之间耦合度。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;代码流⽔线管理&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;前⼀个场景对于管理代码的流⽔线起到了很⼤的帮助。代码从开发者的机器到最终在⽣产环境上的部署，需要经过很多的中间环境。⽽每⼀个中间环境都有⾃⼰微⼩的差别，Docker给应⽤提供了⼀个从开发到上线均⼀致的环境，让代码的流⽔线变得简单不少。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;提⾼开发效率&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这就带来了⼀些额外的好处：Docker能提升开发者的开发效率。如果你想看⼀个详细⼀点的例⼦，可以参考Aater在DevOpsDays Austin 2014 ⼤会或者是DockerCon上的演讲。&lt;/p&gt;
&lt;p&gt;不同的开发环境中，我们都想把两件事做好。⼀是我们想让开发环境尽量贴近⽣产环境，⼆是我们想快速搭建开发环境。&lt;/p&gt;
&lt;p&gt;理想状态中，要达到第⼀个⽬标，我们需要将每⼀个服务都跑在独⽴的虚拟机中以便监控⽣产环境中服务的运⾏状态。然⽽，我们却不想每次都需要⽹络连接，每次重新编译的时候远程连接上去特别麻烦。这就是Docker做的特别好的地⽅，开发环境的机器通常内存⽐较⼩，之前使⽤虚拟的时候，我们经常需要为开发环境的机器加内存，⽽现在Docker可以轻易的让⼏⼗个服务在Docker中跑起来。&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;strong&gt;隔离应⽤&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有很多种原因会让你选择在⼀个机器上运⾏不同的应⽤，⽐如之前提到的提⾼开发效率的场景等。&lt;/p&gt;
&lt;p&gt;我们经常需要考虑两点，⼀是因为要降低成本⽽进⾏服务器整合，⼆是将⼀个整体式的应⽤拆分成松耦合的单个服务（译者注：微服务架构）。如果你想了解为什么松耦合的应⽤这么重要，请参考Steve Yege的这篇论⽂，⽂中将Google和亚⻢逊做了⽐较。&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;&lt;strong&gt;整合服务器&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;正如通过虚拟机来整合多个应⽤，Docker隔离应⽤的能⼒使得Docker可以整合多个服务器以降低成本。由于没有多个操作系统的内存占⽤，以及能在多个实例之间共享没有使⽤的内存，Docker可以⽐虚拟机提供更好的服务器整合解决⽅案。&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;&lt;strong&gt;调试能⼒&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Docker提供了很多的⼯具，这些⼯具不⼀定只是针对容器，但是却适⽤于容器。它们提供了很多的功能，包括可以为容器设置检查点、设置版本和查看两个容器之间的差别，这些特性可以帮助调试Bug。你可以在《Docker拯救世界》的⽂章中找到这⼀点的例证。&lt;/p&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;&lt;strong&gt;多租户环境&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;另外⼀个Docker有意思的使⽤场景是在多租户的应⽤中，它可以避免关键应⽤的重写。我们⼀个特别的关于这个场景的例⼦是为物联⽹的应⽤开发⼀个快速、易⽤的多租户环境。这种多租户的基本代码⾮常复杂，很难处理，重新规划这样⼀个应⽤不但消耗时间，也浪费⾦钱。&lt;/p&gt;
&lt;p&gt;使⽤Docker，可以为每⼀个租户的应⽤层的多个实例创建隔离的环境，这不仅简单⽽且成本低廉，当然这⼀切得益于Docker环境的启动速度和其⾼效的命令。&lt;/p&gt;
&lt;ol start=&#34;8&#34;&gt;
&lt;li&gt;&lt;strong&gt;快速部署&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在虚拟机之前，引⼊新的硬件资源需要消耗⼏天的时间。虚拟化技术将这个时间缩短到了分钟级别。⽽Docker通过为进程仅仅创建⼀个容器⽽⽆需启动⼀个操作系统，再次将这个过程缩短到了秒级。这正是Google和Facebook都看重的特性。&lt;/p&gt;
&lt;h3 id=&#34;12-docker容器历史解读扩展阅读&#34;&gt;1.2 Docker容器历史解读【扩展阅读】&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;PaaS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从过去以物理机和虚拟机为主体的开发运维环境，向以容器为核⼼的基础设施的转变过程，并不是⼀次温和的改⾰，⽽是涵盖了对⽹络、存储、调度、操作系统、分布式原理等各个⽅⾯的容器化理解和改造。&lt;/p&gt;
&lt;p&gt;2013 年的后端技术领域，已经太久没有出现过令⼈兴奋的东⻄了。曾经被⼈们寄予厚望的云计算技术，也已经从当初虚⽆缥缈的概念蜕变成了实实在在的虚拟机和账单。⽽相⽐于如⽇中天 AWS 和盛极⼀时的 OpenStack，以 Cloud Foundry 为代表的开源 PaaS 项⽬，却成为了当时云计算技术中的⼀股清流。&lt;/p&gt;
&lt;p&gt;当时，Cloud Foundry 项⽬已经基本度过了最艰难的概念普及和⽤户教育阶段，吸引了包括百度、京东、华为、IBM 等⼀⼤批国内外技术⼚商，开启了以开源 PaaS 为核⼼构建平台层服务能⼒的变⾰。如果你有机会问问当时的云计算从业者们，他们⼗有⼋九都会告诉你：PaaS 的时代就要来了！&lt;/p&gt;
&lt;p&gt;这个说法其实⼀点⼉没错，如果不是后来⼀个叫 Docker 的开源项⽬突然冒出来的话。&lt;/p&gt;
&lt;p&gt;事实上，当时还名叫 dotCloud 的 Docker 公司，也是这股 PaaS 热潮中的⼀份⼦。只不过相⽐于 Heroku、Pivotal、Red Hat 等 PaaS 弄潮⼉们，dotCloud 公司实在是太微不⾜道了，⽽它的主打产品由于跟主流的 Cloud Foundry 社区脱节，⻓期以来也⽆⼈问津。眼看就要被如⽕如荼的 PaaS ⻛潮抛弃，dotCloud 公司却做出了这样⼀个决定：开源⾃⼰的容器项⽬ Docker。&lt;/p&gt;
&lt;p&gt;显然，这个决定在当时根本没⼈在乎。&lt;/p&gt;
&lt;p&gt;&amp;quot;容器&amp;quot;这个概念从来就不是什么新鲜的东⻄，也不是 Docker 公司发明的。即使在当时最热⻔的 PaaS 项⽬ Cloud Foundry 中，容器也只是其最底层、最没⼈关注的那⼀部分。说到这⾥，正好以当时的事实标准 Cloud Foundry 为例，来解说⼀下 PaaS 技术。&lt;/p&gt;
&lt;p&gt;PaaS 项⽬被⼤家接纳的⼀个主要原因，就是它提供了⼀种名叫&amp;quot;应⽤托管&amp;quot;的能⼒。 在当时，虚拟机和云计算已经是⽐较普遍的技术和服务了，那时主流⽤户的普遍⽤法，就是租⼀批 AWS 或者 OpenStack 的虚拟机，然后像以前管理物理服务器那样，⽤脚本或者⼿⼯的⽅式在这些机器上部署应⽤。&lt;/p&gt;
&lt;p&gt;当然，这个部署过程难免会碰到云端虚拟机和本地环境不⼀致的问题，所以当时的云计算服务，⽐的就是谁能更好地模拟本地服务器环境，能带来更好的&amp;quot;上云&amp;quot;体验。⽽ PaaS 开源项⽬的出现，就是当时解决这个问题的⼀个最佳⽅案。&lt;/p&gt;
&lt;p&gt;举个例⼦，虚拟机创建好之后，运维⼈员只需要在这些机器上部署⼀个 Cloud Foundry 项⽬，然后开发者只要执⾏⼀条命令就能把本地的应⽤部署到云上，这条命令就是：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cf push &amp;quot; 我的应⽤ &amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;是不是很神奇？&lt;/p&gt;
&lt;p&gt;事实上，像 Cloud Foundry 这样的 PaaS 项⽬，最核⼼的组件就是⼀套应⽤的打包和分发机制。 Cloud Foundry 为每种主流编程语⾔都定义了⼀种打包格式，⽽&amp;quot;cf push&amp;quot;的作⽤，基本上等同于⽤户把应⽤的可执⾏⽂件和启动脚本打进⼀个压缩包内，上传到云上 Cloud Foundry 的存储中。接着，Cloud&lt;br&gt;
Foundry 会通过调度器选择⼀个可以运⾏这个应⽤的虚拟机，然后通知这个机器上的 Agent 把应⽤压缩包下载下来启动。&lt;/p&gt;
&lt;p&gt;这时候关键来了，由于需要在⼀个虚拟机上启动很多个来⾃不同⽤户的应⽤，Cloud Foundry 会调⽤操作系统的 Cgroups 和 Namespace 机制为每⼀个应⽤单独创建⼀个称作&amp;quot;沙盒&amp;quot;的隔离环境，然后在&amp;quot;沙盒&amp;quot;中启动这些应⽤进程。这样，就实现了把多个⽤户的应⽤互不⼲涉地在虚拟机⾥批量地、⾃动地运⾏起来的⽬的。&lt;/p&gt;
&lt;p&gt;这，正是 PaaS 项⽬最核⼼的能⼒。 ⽽这些 Cloud Foundry ⽤来运⾏应⽤的隔离环境，或者说&amp;quot;沙盒&amp;quot;，就是所谓的&amp;quot;容器&amp;quot;。&lt;/p&gt;
&lt;p&gt;⽽ Docker 项⽬，实际上跟 Cloud Foundry 的容器并没有太⼤不同，所以在它发布后不久，Cloud Foundry 的⾸席产品经理 James Bayer 就在社区⾥做了⼀次详细对⽐，告诉⽤户 Docker 实际上只是⼀个同样使⽤ Cgroups 和 Namespace 实现的&amp;quot;沙盒&amp;quot;⽽已，没有什么特别的⿊科技，也不需要特别关注。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cf push &amp;quot; 我的应⽤ &amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然⽽，短短⼏个⽉，Docker 项⽬就迅速崛起了。它的崛起速度如此之快，以⾄于 Cloud Foundry 以及所有的 PaaS 社区还没来得及成为它的竞争对⼿，就直接被宣告出局了。那时候，⼀位多年的 PaaS 从业者曾经如此感慨道：这简直就是⼀场&amp;quot;降维打击&amp;quot;啊。&lt;/p&gt;
&lt;p&gt;事实上，Docker 项⽬确实与 Cloud Foundry 的容器在⼤部分功能和实现原理上都是⼀样的，可偏偏就是这剩下的⼀⼩部分不⼀样的功能，成了 Docker 项⽬接下来&amp;quot;呼⻛唤⾬&amp;quot;的不⼆法宝。&lt;/p&gt;
&lt;p&gt;这个功能，就是 Docker 镜像。&lt;/p&gt;
&lt;p&gt;恐怕连 Docker 项⽬的作者 Solomon Hykes ⾃⼰当时都没想到，这个⼩⼩的创新，在短短⼏年内就如此迅速地改变了整个云计算领域的发展历程。&lt;/p&gt;
&lt;p&gt;前⾯已经介绍过，PaaS 之所以能够帮助⽤户⼤规模部署应⽤到集群⾥，是因为它提供了⼀套应⽤打包的功能。可就是这个打包功能，却成了 PaaS ⽇后不断遭到⽤户诟病的⼀个&amp;quot;软肋&amp;quot;。&lt;/p&gt;
&lt;p&gt;出现这个问题的根本原因是，⼀旦⽤上了 PaaS，⽤户就必须为每种语⾔、每种框架，甚⾄每个版本的应⽤维护⼀个打好的包。这个打包过程，没有任何章法可循，更麻烦的是，明明在本地运⾏得好好的应⽤，却需要做很多修改和配置⼯作才能在 PaaS ⾥运⾏起来。⽽这些修改和配置，并没有什么经验可以借鉴，基本上得靠不断试错，直到你摸清楚了本地应⽤和远端 PaaS 匹配的&amp;quot;脾⽓&amp;quot;才能够搞定。&lt;/p&gt;
&lt;p&gt;最后结局就是，&amp;quot;cf push&amp;quot;确实是能⼀键部署了，但是为了实现这个⼀键部署，⽤户为每个应⽤打包的⼯作可谓⼀波三折，费尽⼼机。&lt;/p&gt;
&lt;p&gt;⽽Docker 镜像解决的，恰恰就是打包这个根本性的问题。 所谓 Docker 镜像，其实就是⼀个压缩包。但是这个压缩包⾥的内容，⽐ PaaS 的应⽤可执⾏⽂件 + 启停脚本的组合就要丰富多了。实际上，⼤多数 Docker 镜像是直接由⼀个完整操作系统的所有⽂件和⽬录构成的，所以这个压缩包⾥的内容跟你本地开发和测试环境⽤的操作系统是完全⼀样的。&lt;/p&gt;
&lt;p&gt;这就有意思了：假设你的应⽤在本地运⾏时，能看⻅的环境是 CentOS 7.2 操作系统的所有⽂件和⽬录，那么只要⽤ CentOS 7.2 的 ISO 做⼀个压缩包，再把你的应⽤可执⾏⽂件也压缩进去，那么⽆论在哪⾥解压这个压缩包，都可以得到与你本地测试时⼀样的环境。当然，你的应⽤也在⾥⾯！&lt;/p&gt;
&lt;p&gt;这就是 Docker 镜像最厉害的地⽅：只要有这个压缩包在⼿，你就可以使⽤某种技术创建⼀个&amp;quot;沙盒&amp;quot;，在&amp;quot;沙盒&amp;quot;中解压这个压缩包，然后就可以运⾏你的程序了。&lt;/p&gt;
&lt;p&gt;更重要的是，这个压缩包包含了完整的操作系统⽂件和⽬录，也就是包含了这个应⽤运⾏所需要的所有依赖，所以你可以先⽤这个压缩包在本地进⾏开发和测试，完成之后，再把这个压缩包上传到云端运⾏。&lt;/p&gt;
&lt;p&gt;在这个过程中，你完全不需要进⾏任何配置或者修改，因为这个压缩包赋予了你⼀种极其宝贵的能⼒：本地环境和云端环境的⾼度⼀致！&lt;/p&gt;
&lt;p&gt;这，正是 Docker 镜像的精髓。&lt;/p&gt;
&lt;p&gt;那么，有了 Docker 镜像这个利器，PaaS ⾥最核⼼的打包系统⼀下⼦就没了⽤武之地，最让⽤户抓狂的打包过程也随之消失了。相⽐之下，在当今的互联⽹⾥，Docker 镜像需要的操作系统⽂件和⽬录，可谓唾⼿可得。&lt;/p&gt;
&lt;p&gt;所以，你只需要提供⼀个下载好的操作系统⽂件与⽬录，然后使⽤它制作⼀个压缩包即可，这个命令就：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ docker build 我的镜像
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;⼀旦镜像制作完成，⽤户就可以让 Docker 创建⼀个&amp;quot;沙盒&amp;quot;来解压这个镜像，然后在&amp;quot;沙盒&amp;quot;中运⾏⾃⼰的应⽤，这个命令就是：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ docker run &amp;quot; 我的镜像 &amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然，docker run 创建的&amp;quot;沙盒&amp;quot;，也是使⽤ Cgroups 和 Namespace 机制创建出来的隔离环境。&lt;/p&gt;
&lt;p&gt;所以，Docker 项⽬给 PaaS 世界带来的&amp;quot;降维打击&amp;quot;，其实是提供了⼀种⾮常便利的打包机制。这种机制直接打包了应⽤运⾏所需要的整个操作系统，从⽽保证了本地环境和云端环境的⾼度⼀致，避免了⽤户通过&amp;quot;试错&amp;quot;来匹配两种不同运⾏环境之间差异的痛苦过程。&lt;/p&gt;
&lt;p&gt;⽽对于开发者们来说，在终于体验到了⽣产⼒解放所带来的痛快之后，他们⾃然选择了⽤脚投票，直接宣告了 PaaS 时代的结束。&lt;/p&gt;
&lt;p&gt;不过，Docker 项⽬固然解决了应⽤打包的难题，但正如前⾯所介绍的那样，它并不能代替 PaaS 完成⼤规模部署应⽤的职责。&lt;/p&gt;
&lt;p&gt;遗憾的是，考虑到 Docker 公司是⼀个与⾃⼰有潜在竞争关系的商业实体，再加上对 Docker 项⽬普及程度的错误判断，Cloud Foundry 项⽬并没有第⼀时间使⽤ Docker 作为⾃⼰的核⼼依赖，去替换⾃⼰那套饱受诟病的打包流程。&lt;/p&gt;
&lt;p&gt;反倒是⼀些机敏的创业公司，纷纷在第⼀时间推出了 Docker 容器集群管理的开源项⽬（⽐如 Deis 和 Flynn），它们⼀般称⾃⼰为 CaaS，即 ontainer-as-a-Service，⽤来跟&amp;quot;过时&amp;quot;的 PaaS 们划清界限。&lt;/p&gt;
&lt;p&gt;⽽在 2014 年底的 DockerCon 上，Docker 公司雄⼼勃勃地对外发布了⾃家研发的&amp;quot;Docker 原⽣&amp;quot;容器集群管理项⽬ Swarm，不仅将这波&amp;quot;CaaS&amp;quot;热推向了⼀个前所未有的⾼潮，更是寄托了整个 Docker 公司重新定义 PaaS 的宏伟愿望。&lt;/p&gt;
&lt;p&gt;在 2014 年的这段巅峰岁⽉⾥，Docker 公司离⾃⼰的理想真的只有⼀步之遥。&lt;/p&gt;
&lt;p&gt;2013~2014 年，以 Cloud Foundry 为代表的 PaaS 项⽬，逐渐完成了教育⽤户和开拓市场的艰巨任务，也正是在这个将概念逐渐落地的过程中，应⽤&amp;quot;打包&amp;quot;困难这个问题，成了整个后端技术圈⼦的⼀块⼼病。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ docker build 我的镜像
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ docker run &amp;quot; 我的镜像 &amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Docker 项⽬的出现，则为这个根本性的问题提供了⼀个近乎完美的解决⽅案。这正是 Docker 项⽬刚刚开源不久，就能够带领⼀家原本默默⽆闻的 PaaS 创业公司脱颖⽽出，然后迅速占领了所有云计算领域头条的技术原因。&lt;/p&gt;
&lt;p&gt;⽽在成为了基础设施领域近⼗年难得⼀⻅的技术明星之后，dotCloud 公司则在 2013 年底⼤胆改名为 Docker 公司。不过，这个在当时就颇具争议的改名举动，也成为了⽇后容器技术圈⻛云变幻的⼀个关键伏笔。&lt;/p&gt;
&lt;p&gt;之前说到，伴随着 PaaS 概念的逐步普及，以 Cloud Foundry 为代表的经典 PaaS 项⽬，开始进⼊基础设施领域的视野，平台化和 PaaS 化成了这个⽣态中的⼀个最为重要的进化趋势。&lt;/p&gt;
&lt;p&gt;就在对开源 PaaS 项⽬落地的不断尝试中，这个领域的从业者们发现了 PaaS 中最为棘⼿也最亟待解决的⼀个问题：究竟如何给应⽤打包？&lt;/p&gt;
&lt;p&gt;遗憾的是，⽆论是 Cloud Foundry、OpenShift，还是 Clodify，⾯对这个问题都没能给出⼀个完美的答案，反⽽在竞争中⾛向了碎⽚化的歧途。&lt;/p&gt;
&lt;p&gt;⽽就在这时，⼀个并不引⼈瞩⽬的 PaaS 创业公司 dotCloud，却选择了开源⾃家的⼀个容器项⽬ Docker。更出⼈意料的是，就是这样⼀个普通到不能再普通的技术，却开启了⼀个名为&amp;quot;Docker&amp;quot;的全新时代。&lt;/p&gt;
&lt;p&gt;Docker 项⽬的崛起，是不是偶然呢？这个以&amp;quot;鲸⻥&amp;quot;为注册商标的技术创业公司，最重要的战略之⼀就是：坚持把&amp;quot;开发者&amp;quot;群体放在⾄⾼⽆上的位置。&lt;/p&gt;
&lt;p&gt;相⽐于其他正在企业级市场⾥厮杀得头破⾎流的经典 PaaS 项⽬们，Docker 项⽬的推⼴策略从⼀开始就呈现出⼀副&amp;quot;憨态可掬&amp;quot;的亲⼈姿态，把每⼀位后端技术⼈员（⽽不是他们的⽼板）作为主要的传播对象。&lt;/p&gt;
&lt;p&gt;简洁的 UI，有趣的 demo，&amp;quot;1 分钟部署⼀个 WordPress ⽹站&amp;quot;&amp;quot;3 分钟部署⼀个 Nginx 集群&amp;quot;，这种同开发者之间与⽣俱来的亲近关系，使 Docker 项⽬迅速成为了全世界 Meetup 上最受欢迎的⼀颗新星。&lt;/p&gt;
&lt;p&gt;在过去的很⻓⼀段时间⾥，相较于前端和互联⽹技术社区，服务器端技术社区⼀直是⼀个相对沉闷⽽⼩众的圈⼦。在这⾥，从事 Linux 内核开发的极客们⾃带&amp;quot;不合群&amp;quot;的&amp;quot;光环&amp;quot;，后端开发者们啃着多年不变的 TCP/IP 发着牢骚，运维更是天⽣注定的幕后英雄。&lt;/p&gt;
&lt;p&gt;⽽ Docker 项⽬，却给后端开发者提供了⾛向聚光灯的机会。就⽐如 Cgroups 和 Namespace 这种已经存在多年却很少被⼈们关⼼的特性，在 2014 年和 2015 年竟然频繁⼊选各⼤技术会议的分享议题，就因为听众们想要知道 Docker 这个东⻄到底是怎么⼀回事⼉。&lt;/p&gt;
&lt;p&gt;⽽ Docker 项⽬之所以能取得如此⾼的关注，⼀⽅⾯正如前⾯所说的那样，它解决了应⽤打包和发布这⼀困扰运维⼈员多年的技术难题；⽽另⼀⽅⾯，就是因为它第⼀次把⼀个纯后端的技术概念，通过⾮常友好的设计和封装，交到了最⼴⼤的开发者群体⼿⾥。&lt;/p&gt;
&lt;p&gt;在这种独特的氛围烘托下，你不需要精通 TCP/IP，也⽆需深谙 Linux 内核原理，哪怕只是⼀个前端或者⽹站的 PHP ⼯程师，都会对如何把⾃⼰的代码打包成⼀个随处可以运⾏的 Docker 镜像充满好奇和兴趣。&lt;/p&gt;
&lt;p&gt;这种受众群体的变⾰，正是 Docker 这样⼀个后端开源项⽬取得巨⼤成功的关键。这也是经典 PaaS 项⽬想做却没有做好的⼀件事情：PaaS 的最终⽤户和受益者，⼀定是为这个 PaaS 编写应⽤的开发者们，⽽在 Docker 项⽬开源之前，PaaS 与开发者之间的关系却从未如此紧密过。&lt;/p&gt;
&lt;p&gt;解决了应⽤打包这个根本性的问题，同开发者与⽣俱来的的亲密关系，再加上 PaaS 概念已经深⼊⼈⼼的完美契机，成为 Docker 这个技术上看似平淡⽆奇的项⽬⼀举⾛红的重要原因。&lt;/p&gt;
&lt;p&gt;⼀时之间，&amp;quot;容器化&amp;quot;取代&amp;quot;PaaS 化&amp;quot;成为了基础设施领域最炙⼿可热的关键词，⼀个以&amp;quot;容器&amp;quot;为中⼼的、全新的云计算市场，正呼之欲出。⽽作为这个⽣态的⼀⼿缔造者，此时的 dotCloud 公司突然宣布将公司名称改为&amp;quot;Docker&amp;quot;。&lt;/p&gt;
&lt;p&gt;这个举动，在当时颇受质疑。在⼤家印象中，Docker 只是⼀个开源项⽬的名字。可是现在，这个单词却成了 Docker 公司的注册商标，任何⼈在商业活动中使⽤这个单词，以及鲸⻥的 Logo，都会⽴刻受到法律警告。&lt;/p&gt;
&lt;p&gt;Docker 项⽬在短时间内迅速崛起的三个重要原因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Docker 镜像通过技术⼿段解决了 PaaS 的根本性问题；&lt;/li&gt;
&lt;li&gt;Docker 容器同开发者之间有着与⽣俱来的密切关系；&lt;/li&gt;
&lt;li&gt;PaaS 概念已经深⼊⼈⼼的完美契机。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;121-何为paas&#34;&gt;1.2.1 何为Paas&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;PaaS 项⽬成功的主要原因&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;是它提供了⼀种名叫&amp;quot;应⽤托管&amp;quot;的能⼒。&lt;/p&gt;
&lt;p&gt;paas之前主流⽤户的普遍⽤法是租⼀批 AWS 或者 OpenStack 的虚拟机，然后像以前管理物理服务器那样，⽤脚本或者⼿⼯的⽅式在这些机器上部署应⽤。&lt;/p&gt;
&lt;p&gt;这个部署过程会碰到云端虚拟机和本地环境不⼀致的问题，所以当时的云计算服务，⽐的就是谁能更好地模拟本地服务器环境，能带来更好的&amp;quot;上云&amp;quot;体验。⽽ PaaS 开源项⽬的出现，就是当时解决这个问题的⼀个最佳⽅案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PaaS 如何部署应⽤&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虚拟机创建好之后，运维⼈员只需要在这些机器上部署⼀个 Cloud Foundry 项⽬，然后开发者只要执⾏⼀条命令就能把本地的应⽤部署到云上，这条命令就是：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt; [root@Linux ~]# cf push &amp;quot; 应⽤ &amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;PaaS 项⽬的核⼼组件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;像 Cloud Foundry 这样的 PaaS 项⽬，最核⼼的组件就是⼀套应⽤的打包和分发机制。 Cloud Foundry 为每种主流编程语⾔都定义了⼀种打包格式，⽽&amp;quot;cf push&amp;quot;的作⽤，基本上等同于⽤户把应⽤的可执⾏⽂件和启动脚本打进⼀个压缩包内，上传到云上 Cloud Foundry 的存储中。接着，Cloud Foundry 会通过调度器选择⼀个可以运⾏这个应⽤的虚拟机，然后通知这个机器上的 Agent 把应⽤压缩包下载下来启动。&lt;/p&gt;
&lt;p&gt;由于需要在⼀个虚拟机上启动很多个来⾃不同⽤户的应⽤，Cloud Foundry 会调⽤操作系统的 Cgroups 和 Namespace 机制为每⼀个应⽤单独创建⼀个称作&amp;quot;沙盒&amp;quot;的隔离环境，然后在&amp;quot;沙盒&amp;quot;中启动这些应⽤进程。这就实现了把多个⽤户的应⽤互不⼲涉地在虚拟机⾥批量⾃动地运⾏起来的⽬的。&lt;/p&gt;
&lt;p&gt;这正是 PaaS 项⽬最核⼼的能⼒。 ⽽这些 Cloud Foundry ⽤来运⾏应⽤的隔离环境，或者说&amp;quot;沙盒&amp;quot;，就是所谓的&amp;quot;容器&amp;quot;。&lt;/p&gt;
&lt;p&gt;注：Cloud Foundry是当时⾮常主流⾮常⽕的⼀个PaaS项⽬&lt;/p&gt;
&lt;h4 id=&#34;122-docker对paas的降维打击&#34;&gt;1.2.2 Docker对Paas的降维打击&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Docker 镜像&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Docker 项⽬确实与 Cloud Foundry 的容器在⼤部分功能和实现原理上都是⼀样的，可偏偏就是这剩下的⼀⼩部分不⼀样的功能，成了 Docker 项⽬接下来&amp;quot;呼⻛唤⾬&amp;quot;的不⼆法宝。这个功能，就是 Docker 镜像。&lt;/p&gt;
&lt;p&gt;恐怕连 Docker 项⽬的作者 Solomon Hykes ⾃⼰当时都没想到，这个⼩⼩的创新，在短短⼏年内就如此迅速地改变了整个云计算领域的发展历程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PaaS的问题：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;PaaS 之所以能够帮助⽤户⼤规模部署应⽤到集群⾥，是因为它提供了⼀套应⽤打包的功能。可就是这个打包功能，却成了 PaaS ⽇后不断遭到⽤户诟病的⼀个&amp;quot;软肋&amp;quot;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;根本原因：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;⼀旦⽤上了 PaaS，⽤户就必须为每种语⾔、每种框架，甚⾄每个版本的应⽤维护⼀个打好的包。这个打包过程，没有任何章法可循，更麻烦的是，明明在本地运⾏得好好的应⽤，却需要做很多修改和配置⼯作才能在 PaaS ⾥运⾏起来。⽽这些修改和配置，并没有什么经验可以借鉴，基本上得靠不断试错，直到你摸清楚了本地应⽤和远端 PaaS 匹配的&amp;quot;脾⽓&amp;quot;才能够搞定。&lt;/p&gt;
&lt;p&gt;最后结局是，&amp;quot;cf push&amp;quot;确实是能⼀键部署了，但是为了实现这个⼀键部署，⽤户为每个应⽤打包的⼯作可谓⼀波三折，费尽⼼机。&lt;/p&gt;
&lt;p&gt;⽽Docker 镜像解决的，恰恰就是打包这个根本性的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Docker 镜像的精髓&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所谓 Docker 镜像，其实就是⼀个压缩包。但是这个压缩包⾥的内容，⽐ PaaS 的应⽤可执⾏⽂件 + 启停脚本的组合就要丰富多了。实际上，⼤多数 Docker 镜像是直接由⼀个完整操作系统的所有⽂件和⽬录构成的，所以这个压缩包⾥的内容跟你本地开发和测试环境⽤的操作系统是完全⼀样的。&lt;/p&gt;
&lt;p&gt;这就有意思了：假设你的应⽤在本地运⾏时，能看⻅的环境是 CentOS 7.2 操作系统的所有⽂件和⽬录，那么只要⽤ CentOS 7.2 的 ISO 做⼀个压缩包，再把你的应⽤可执⾏⽂件也压缩进去，那么⽆论在哪⾥解压这个压缩包，都可以得到与你本地测试时⼀样的环境。当然，你的应⽤也在⾥⾯！&lt;/p&gt;
&lt;p&gt;这就是 Docker 镜像最厉害的地⽅：只要有这个压缩包在⼿，你就可以使⽤某种技术创建⼀个&amp;quot;沙盒&amp;quot;，在&amp;quot;沙盒&amp;quot;中解压这个压缩包，然后就可以运⾏你的程序了。&lt;/p&gt;
&lt;p&gt;更重要的是，这个压缩包包含了完整的操作系统⽂件和⽬录，也就是包含了这个应⽤运⾏所需要的所有依赖，所以你可以先⽤这个压缩包在本地进⾏开发和测试，完成之后，再把这个压缩包上传到云端运⾏。&lt;/p&gt;
&lt;p&gt;在这个过程中，你完全不需要进⾏任何配置或者修改，因为这个压缩包赋予了你⼀种极其宝贵的能⼒：本地环境和云端环境的⾼度⼀致！&lt;/p&gt;
&lt;p&gt;这，正是 Docker 镜像的精髓。&lt;/p&gt;
&lt;p&gt;那么，有了 Docker 镜像这个利器，PaaS ⾥最核⼼的打包系统⼀下⼦就没了⽤武之地，最让⽤户抓狂的打包过程也随之消失了。相⽐之下，在当今的互联⽹⾥，Docker 镜像需要的操作系统⽂件和⽬录，可谓唾⼿可得。&lt;/p&gt;
&lt;p&gt;所以，你只需要提供⼀个下载好的操作系统⽂件与⽬录，然后使⽤它制作⼀个压缩包即可，这个命令就是：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker build &amp;quot; 镜像 &amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;镜像制作完成，⽤户就可以让 Docker 创建⼀个&amp;quot;沙盒&amp;quot;来解压这个镜像，然后在&amp;quot;沙盒&amp;quot;中运⾏⾃⼰的应⽤，这个命令就是：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker run &amp;quot; 镜像 &amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Docker 项⽬给 PaaS 世界带来的&amp;quot;降维打击&amp;quot;&lt;/p&gt;
&lt;p&gt;其实是提供了⼀种⾮常便利的打包机制。这种机制直接打包了应⽤运⾏所需要的整个操作系统，从⽽保证了本地环境和云端环境的⾼度⼀致，避免了⽤户通过&amp;quot;试错&amp;quot;来匹配两种不同运⾏环境之间差异的痛苦过程。&lt;/p&gt;
&lt;h2 id=&#34;2-docker安装&#34;&gt;2、Docker安装&lt;/h2&gt;
&lt;h3 id=&#34;21-docker版本解读&#34;&gt;2.1 Docker版本解读&lt;/h3&gt;
&lt;p&gt;moby、docker-ce与docker-ee&lt;/p&gt;
&lt;p&gt;最早时docker是⼀个开源项⽬，主要由docker公司维护。&lt;/p&gt;
&lt;p&gt;2017年3⽉1⽇起，docker公司将原先的docker项⽬改名为moby，并创建了docker-ce和docker-ee。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三者关系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;moby是继承了原先的docker的项⽬，是社区维护的的开源项⽬，谁都可以在moby的基础打造⾃⼰的容器产品&lt;/p&gt;
&lt;p&gt;docker-ce是docker公司维护的开源项⽬，是⼀个基于moby项⽬的免费的容器产品&lt;/p&gt;
&lt;p&gt;docker-ee是docker公司维护的闭源产品，是docker公司的商业产品。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;版本维护&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;moby project由社区维护，docker-ce project是docker公司维护，docker-ee是闭源的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Docker-ce发布计划&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;v1.13.1之后，发布计划更改为:&lt;/p&gt;
&lt;p&gt;Edge:  ⽉版本，每⽉发布⼀次，命名格式为YY.MM，维护到下个⽉的版本发布&lt;/p&gt;
&lt;p&gt;Stable: 季度版本，每季度发布⼀次，命名格式为YY.MM，维护4个⽉&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;版本获取&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要使⽤免费的docker，从https://github.com/docker/docker-ce上获取。&lt;/p&gt;
&lt;p&gt;要使⽤收费的docker，从https://www.docker.com/products/docker-enterprise上获取。&lt;/p&gt;
&lt;h3 id=&#34;22-官方安装方案&#34;&gt;2.2 官⽅安装⽅案&lt;/h3&gt;
&lt;p&gt;docker-ce的release计划跟随moby的release计划，可以使⽤下⾯的命令直接安装最新的docker-ce&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# curl -fsSL https://get.docker.com/ | sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果是centos，上⾯的安装命令会在系统上添加yum源:/etc/yum.repos.d/docker-ce.repo&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt; [root@Linux ~]# wget https://download.docker.com/linux/centos/docker-ce.repo
  [root@Linux ~]# mv docker-ce.repo /etc/yum.repos.d
  [root@Linux ~]# yum install -y docker-ce
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者直接下载rpm安装&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# wget https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-ce-17.09.0.ce-1.el7.centos.x86_64.rpm
  [root@Linux ~]# yum localinstall docker-ce-17.09.0.ce-1.el7.centos.x86_64.rpm
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;23-docker加速器&#34;&gt;2.3 Docker加速器&lt;/h3&gt;
&lt;p&gt;使⽤Aliyun Docker Yum源安装Docker&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;删除已安装的Docker&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# yum remove docker \
        docker-client \
        docker-client-latest \
        docker-common \
        docker-latest \
        docker-latest-logrotate \
        docker-logrotate \
        docker-selinux \
        docker-engine-selinux \
        docker-engine
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;配置阿⾥云Docker Yum源&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# yum install -y yum-utils device-mapper-persistent-data lvm2 git
  [root@Linux ~]# yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;如何安装指定版本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查看Docker版本：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# yum list docker-ce --showduplicates
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装较旧版本（⽐如Docker 17.03.2) ：&lt;/p&gt;
&lt;p&gt;需要指定完整的rpm包的包名，并且加上--setopt=obsoletes=0 参数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt; [root@Linux ~]# yum install -y --setopt=obsoletes=0 \
   docker-ce-17.03.2.ce-1.el7.centos.x86_64 \
   docker-ce-selinux-17.03.2.ce-1.el7.centos.noarch
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装Docker最新版&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;  [root@Linux ~]# yum install docker-ce -y
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Centos8安装Docker报错解决⽅案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;官⽅docker rpm包地址&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;https://download.docker.com/linux/centos/7/x86_64/stable/Packages/
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;有关runc&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200819171538.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有关containerd.io&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200819171555.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;启动Docker服务&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]#systemctl enable docker
 [root@Linux ~]#systemctl start docker 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看Docker版本及启动状态&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker -v
  Docker version 1.13.1, build 8633870/1.13.1  

  [root@Linux ~]# docker version
  Client:
   Version:        18.09.0
   API version:    1.39
   Go version:     go1.10.4
   Git commit:     4d60db4
   Built:          Wed Nov  7 00:48:22 2018
   OS/Arch:        linux/amd64
   Experimental:   false

  Server: Docker Engine - Community
   Engine:
   Version:        18.09.0
   API version:    1.39 (minimum version 1.12)
   Go version:     go1.10.4
   Git commit:     4d60db4
   Built:          Wed Nov  7 00:19:08 2018
   OS/Arch:        linux/amd64
   Experimental:   false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看Docker运⾏状态&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker info
  Containers: 0
   Running: 0
   Paused: 0
   Stopped: 0
  Images: 0
  Server Version: 18.09.0
  Storage Driver: overlay2
   Backing Filesystem: xfs
   Supports d_type: true
   Native Overlay Diff: true
  Logging Driver: json-file
  Cgroup Driver: cgroupfs
  Plugins:
   Volume: local
   Network: bridge host macvlan null overlay
   Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog
  Swarm: inactive
  Runtimes: runc
  Default Runtime: runc
  Init Binary: docker-init
  containerd version: c4446665cb9c30056f4998ed953e6d4ff22c7c39
  runc version: 4fc53a81fb7c994640722ac585fa9ca548971871
  init version: fec3683
  Security Options:
   seccomp
   Profile: default
  Kernel Version: 3.10.0-957.el7.x86_64
  Operating System: CentOS Linux 7 (Core)
  OSType: linux
  Architecture: x86_64
  CPUs: 4
  Total Memory: 1.934GiB
  Name: docker
  ID: MF5S:ZX25:SWJ3:XEIG:FFHP:5VXF:F5AL:KQFF:KKXP:XZGY:YGTE:EBQF
  Docker Root Dir: /var/lib/docker
  Debug Mode (client): false
  Debug Mode (server): false
  Registry: https://index.docker.io/v1/
  Labels:
  Experimental: false
  Insecure Registries:
   127.0.0.0/8
  Live Restore Enabled: false
  Product License: Community Engine
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;问题1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;docker info的时候报如下错误&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;bridge-nf-call-iptables is disabled
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;解决&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;追加如下配置,然后重启系统&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# vim /etc/sysctl.conf  
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
net.bridge.bridge-nf-call-arptables = 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;问题2&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虚拟机ping百度也能ping通，但是需要等好⼏秒才出结果，关键是下载镜像⼀直报错如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker pull daocloud.io/library/nginx
Using default tag: latest
Error response from daemon: Get https://daocloud.io/v2/: dial tcp: lookup daocloud.io on 192.168.1.2:53: read udp  192.168.1.189:41335-&amp;gt;192.168.1.2:53: i/o timeout
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;解决&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我的虚拟机⽤的⽹关和dns都是虚拟机⾃⼰的.1或者.2，把DNS改成8.8.8.8问题就解决了，ping百度也秒出结果&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt; [root@Linux ~]# vim /etc/resolv.conf
  nameserver 8.8.8.8
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;24-国内源镜像源&#34;&gt;2.4 国内源镜像源&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Daocloud&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Aliyun&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;⽹易蜂巢&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-docker核心概念&#34;&gt;3、Docker核⼼概念&lt;/h2&gt;
&lt;h3 id=&#34;31-docker系统&#34;&gt;3.1 Docker系统&lt;/h3&gt;
&lt;p&gt;Docker系统有两个程序：Docker服务端和Docker客户端&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Docker服务端：
	是⼀个服务进程，管理着所有的容器。
    docker engine  
Docker客户端：
    扮演着docker服务端的远程控制器，可以⽤来控制docker的服务端进程。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;32-docker核心组件&#34;&gt;3.2 Docker核⼼组件&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Docker 镜像 - Docker  images&lt;/p&gt;
&lt;p&gt;Docker 仓库 - Docker  registeries&lt;/p&gt;
&lt;p&gt;Docker 容器 - Docker  containers&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;容器组成要素&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;名称空间 namespace&lt;/p&gt;
&lt;p&gt;资源限制 cgroups&lt;/p&gt;
&lt;p&gt;⽂件系统 overlay2(UnionFS)&lt;/p&gt;
&lt;h4 id=&#34;321-docker-仓库&#34;&gt;3.2.1 Docker 仓库&lt;/h4&gt;
&lt;p&gt;⽤来保存镜像，可以理解为代码控制中的代码仓库。同样的，Docker 仓库也有公有和私有的概念。&lt;/p&gt;
&lt;p&gt;公有的 Docker  仓库名字是 Docker Hub。Docker Hub  提供了庞⼤的镜像集合供使⽤。这些镜像可以是⾃⼰创建，或者在别⼈的镜像基础上创建。Docker 仓库是 Docker 的分发部分。&lt;/p&gt;
&lt;h4 id=&#34;322-docker-镜像&#34;&gt;3.2.2 Docker 镜像&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200819172539.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;Docker 镜像是 Docker 容器运⾏时的只读模板，每⼀个镜像由⼀系列的层 (layers) 组成。Docker 使⽤  UnionFS 来将这些层联合到单独的镜像中。UnionFS  允许独⽴⽂件系统中的⽂件和⽂件夹(称之为分⽀)被透明覆盖，形成⼀个单独连贯的⽂件系统。正因为有了这些层的存在，Docker  是如此的轻量。当你改变了⼀个 Docker  镜像，⽐如升级到某个程序到新的版本，⼀个新的层会被创建。因此，不⽤替换整个原先的镜像或者重新建⽴(在使⽤虚拟机的时候你可能会这么做)，只是⼀个新的层被添加或升级了。现在你不⽤重新发布整个镜像，只需要升级，层使得分发 Docker 镜像变得简单和快。&lt;/p&gt;
&lt;p&gt;在 Docker 的术语⾥，⼀个只读层被称为镜像，⼀个镜像是永久不会变的。&lt;/p&gt;
&lt;p&gt;由于 Docker 使⽤⼀个统⼀⽂件系统，Docker 进程认为整个⽂件系统是以读写⽅式挂载的。 但是所有的变更都发⽣顶层的可写层，⽽下层的原始的只读镜像⽂件并未变化。由于镜像不可写，所以镜像是⽆状态的。&lt;/p&gt;
&lt;p&gt;每⼀个镜像都可能依赖于由⼀个或多个下层的组成的另⼀个镜像。下层那个镜像是上层镜像的⽗镜像。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;镜像名称组成&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;registry/repo:tag&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基础镜像&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;⼀个没有任何⽗镜像的镜像，谓之基础镜像&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;镜像ID&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所有镜像都是通过⼀个 64 位⼗六进制字符串 （内部是⼀个 256 bit 的值）来标识的。 为简化使⽤，前 12 个字符可以组成⼀个短ID，可以在命令⾏中使⽤。短ID还是有⼀定的碰撞机率，所以服务器总是返回⻓ID。&lt;/p&gt;
&lt;h4 id=&#34;323-docker-容器&#34;&gt;3.2.3 Docker 容器&lt;/h4&gt;
&lt;p&gt;Docker 容器和⽂件夹很类似，⼀个Docker容器包含了所有的某个应⽤运⾏所需要的环境。每⼀个 Docker 容器都是从 Docker  镜像创建的。Docker 容器可以运⾏、开始、停⽌、移动和删除。每⼀个 Docker 容器都是独⽴和安全的应⽤平台，Docker 容器是  Docker 的运⾏部分。&lt;/p&gt;
&lt;h4 id=&#34;324-docker镜像和容器区别&#34;&gt;3.2.4 Docker镜像和容器区别&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Docker镜像&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要理解Docker镜像和docker容器之间的区别，确实不容易。&lt;/p&gt;
&lt;p&gt;假设Linux内核是第0层，那么⽆论怎么运⾏Docker，它都是运⾏于内核层之上的。这个Docker镜像，是⼀个只读的镜像，位于第1层，它不能被修改或不能保存状态。&lt;/p&gt;
&lt;p&gt;⼀个Docker镜像可以构建于另⼀个Docker镜像之上，这种层叠关系可以是多层的。第1层的镜像层我们称之为基础镜像（Base  Image），其他层的镜像（除了最顶层）我们称之为⽗层镜像（Parent  Image）。这些镜像继承了他们的⽗层镜像的所有属性和设置，并在Dockerﬁle中添加了⾃⼰的配置。&lt;/p&gt;
&lt;p&gt;Docker镜像通过镜像ID进⾏识别。镜像ID是⼀个64字符的⼗六进制的字符串。但是当我们运⾏镜像时，通常我们不会使⽤镜像ID来引⽤镜像，⽽是使⽤镜像名来引⽤。&lt;/p&gt;
&lt;p&gt;要列出本地所有有效的镜像，可以使⽤命令&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker images
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;镜像可以发布为不同的版本，这种机制我们称之为标签（Tag）。&lt;/p&gt;
&lt;p&gt;如上图所示，neo4j镜像有两个版本：lastest版本和2.1.5版本。&lt;/p&gt;
&lt;p&gt;可以使⽤pull命令加上指定的标签：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker pull ubuntu:14.04
[root@Linux ~]# docker pull ubuntu:12.04
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Docker容器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Docker容器可以使⽤命令创建&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker run imagename
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它会在所有的镜像层之上增加⼀个可写层。这个可写层有运⾏在CPU上的进程，⽽且有两个不同的状态：运⾏态（Running）和退出态 （Exited）。这就是Docker容器。当我们使⽤docker  run启动容器，Docker容器就进⼊运⾏态，当我们停⽌Docker容器时，它就进⼊退出态。&lt;/p&gt;
&lt;p&gt;当我们有⼀个正在运⾏的Docker容器时，从运⾏态到停⽌态，我们对它所做的⼀切变更都会永久地写到容器的⽂件系统中。要切记，对容器的变更是写⼊到容器的⽂件系统的，⽽不是写⼊到Docker镜像中的。&lt;/p&gt;
&lt;p&gt;我们可以⽤同⼀个镜像启动多个Docker容器，这些容器启动后都是活动的，彼此还是相互隔离的。我们对其中⼀个容器所做的变更只会局限于那个容器本身。&lt;/p&gt;
&lt;p&gt;如果对容器的底层镜像进⾏修改，那么当前正在运⾏的容器是不受影响的，不会发⽣⾃动更新现象。&lt;/p&gt;
&lt;p&gt;如果想更新容器到其镜像的新版本，那么必须当⼼，确保我们是以正确的⽅式构建了数据结构，否则我们可能会导致损失容器中所有数据的后果。&lt;/p&gt;
&lt;p&gt;64字符的⼗六进制的字符串来定义容器ID，它是容器的唯⼀标识符。容器之间的交互是依靠容器ID识别的，由于容器ID的字符太⻓，我们通常只需键⼊容器ID的前4个字符即可。当然，我们还可以使⽤容器名，但显然⽤4字符的容器ID更为简便。&lt;/p&gt;
&lt;h3 id=&#34;33-名字空间&#34;&gt;3.3 名字空间&lt;/h3&gt;
&lt;p&gt;名字空间是 Linux 内核⼀个强⼤的特性。每个容器都有⾃⼰单独的名字空间，运⾏在其中的应⽤都像是在独⽴的操作系统中运⾏⼀样。名字空间保证了容器之间彼此互不影响。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;pid 名字空间&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不同⽤户的进程就是通过 pid 名字空间隔离开的，且不同名字空间中可以有相同 pid。所有的 LXC 进程在 Docker中的⽗进程为Docker进程，每个 LXC 进程具有不同的名字空间。同时由于允许嵌套，因此可以很⽅便的实现嵌套的 Docker 容器。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;net 名字空间&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有 了 pid 名字空间, 每个名字空间中的 pid 能够相互隔离，但是⽹络端⼝还是共享 host 的端⼝。⽹络隔离是通过 net 名字空间实现的，每个 net 名字空间有独⽴的 ⽹络设备, IP 地址, 路由表, /proc/net ⽬录。这样每个容器的⽹络就能隔离开来。Docker  默认采⽤ veth 的⽅式，将容器中的虚拟⽹卡同 host 上的⼀ 个Docker ⽹桥 docker0 连接在⼀起。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;ipc 名字空间&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;容器中进程交互还是采⽤了 Linux 常⻅的进程间交互⽅法(interprocess communication - IPC),  包括信号量、消息队列和共享内存、socket、管道等。然⽽同 VM 不同的是，容器的进程间交互实际上还是 host 上具有相同 pid  名字空间中的进程间交互，因此需要在 IPC 资源申请时加⼊名字空间信息，每个 IPC 资源有⼀个唯⼀的 32 位 id。&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;mnt名字空间&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;类似 change root，将⼀个进程放到⼀个特定的⽬录执⾏。mnt 名字空间允许不同名字空间的进程看到的⽂件结构不同，这样每个名字空间  中的进程所看到的⽂件⽬录就被隔离开了。同 chroot 不同，每个名字空间中的容器在 /proc/mounts 的信息只包含所在名字空间的  mount point。&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;uts 名字空间&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;UTS(&amp;quot;UNIX Time-sharing System&amp;quot;) 名字空间允许每个容器拥有独⽴的 hostname 和 domain name, 使其在⽹络上可以被视作⼀个独⽴的节点⽽⾮主机上的⼀个进程。&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;user 名字空间&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;每个容器可以有不同的⽤户和组 id, 也就是说可以在容器内⽤容器内部的⽤户执⾏程序⽽⾮主机上的⽤户。&lt;/p&gt;
&lt;h2 id=&#34;4-镜像管理&#34;&gt;4、镜像管理&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;搜索镜像：  这种⽅法只能⽤于官⽅镜像库
例如搜索基于 Centos 操作系统的镜像
[root@Linux ~]# docker search centos

按星级搜索镜像
查找 star 数⾄少为 100 的镜像，默认不加 s 选项找出所有相关 ubuntu 镜像
[root@Linux ~]# docker search ubuntu -f stars=100  
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;拉取镜像
[root@Linux ~]# docker pull centos

查看本地镜像
[root@Linux ~]# docker image list

查看镜像详情
[root@Linux ~]# docker image inspect 镜像id

删除镜像
删除⼀个或多个，多个之间⽤空格隔开，可以使⽤镜像名称或id
[root@Linux ~]# docker rmi daocloud.io/library/mysql
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5-docker容器管理&#34;&gt;5、Docker容器管理&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;创建新容器但不启动
[root@Linux ~]# docker create -it 
daocloud.io/library/centos:5 /bin/bash

创建并运⾏⼀个新Docker 容器
同⼀个镜像可以启动多个容器,每次执⾏run⼦命令都会运⾏⼀个全新的容器
[root@Linux ~]# docker run -it --restart=always 
centos /bin/bash
   如果执⾏成功，说明CentOS 容器已经被启动，并且应该已经得到了 bash 提示符。
  -i  
   捕获标准输⼊输出
  -t  
   分配⼀个终端或控制台
  --restart=always  
   容器随docker engine⾃启动，因为在重启docker的时候默认容器都会被关闭  
   也适⽤于create选项    
  --rm
   默认情况下，每个容器在退出时，它的⽂件系统也会保存下来，这样⼀⽅⾯调试会⽅便些，因为你可以通过查看⽇志等⽅式来确定最终状态。另⼀⽅⾯，也可以保存容器所产⽣的数据。
    但是当你仅仅需要短暂的运⾏⼀个容器，并且这些数据不需要保存，你可能就希望Docker能在容器结束时⾃动清理其所产⽣的数据。这个时候就需要--rm参数了。注意：--rm 和 -d不能共⽤

  容器名称
  --name= Assign a name to the container   
          --为容器分配⼀个名字，如果没有指定，docker会⾃动分配⼀个随机名称
          是docker run⼦命令的参数

  可以通过三种⽅式调⽤容器命名：
  1）使⽤UUID⻓命名
（&amp;quot;f78375b1c487e03c9438c729345e54db9d20cfa2ac1fc3494b6eb60872e74778&amp;quot;）
  2）使⽤UUID短Id（&amp;quot;f78375b1c487&amp;quot;）
  3）使⽤Name(&amp;quot;evil_ptolemy&amp;quot;) 

  这个UUID标识是由Docker deamon⽣成的。
  如果你在执⾏docker run时没有指定--name，那么deamon会⾃动⽣成⼀个随机字符串UUID。
  但是对于⼀个容器来说有个name会⾮常⽅便，当你需要连接其它容器时或者类似需要区分其它容器时，使⽤容器名称可以简化操作。⽆论容器运⾏在前台或者后台，这个名字都是有效的。

保存容器PID equivalent：
如果在使⽤Docker时有⾃动化的需求，你可以将containerID输出到指定的⽂件中（PIDfile），类似于某些应⽤程序将⾃身ID输出到⽂件中，⽅便后续脚本操作。
--cidfile=&amp;quot;&amp;quot;: Write the container ID to the file

断开与容器的连接，并且关闭容器：
root@d33c4e8c51f8 /#exit

如果只想断开和容器的连接⽽不关闭容器：
快捷键：ctrl+p+q

查看容器：
  只查看运⾏状态的容器：
    [root@Linux ~]#docker ps
    [root@Linux ~]#docker ps -a
    -a  查看所有容器
    
  只查看所有容器id:
        [root@Linux ~]# docker ps -a -q

  列出最近⼀次启动的容器(了解)
        [root@Linux ~]# docker ps -l  

    查看容器详细信息
    inspect  Return low-level information on a container or image
    ⽤于查看容器的配置信息，包含容器名、环境变量、运⾏命令、主机配置、⽹络配置和数据卷配置等。
    ⽬标：
    查找某⼀个运⾏中容器的id，然后使⽤docker inspect命令查看容器的信息。

    提示：可以使⽤镜像id的前⾯部分，不需要完整的id。
    [root@Linux ~]# docker inspect d95   //d95是我机器上运⾏的⼀个容器ID的前3个字符
    [
    {
       &amp;quot;Id&amp;quot;: 
&amp;quot;d95a220a498e352cbfbc098c949fc528dbf5a5c911710b108ea3a9b4aa3a4761&amp;quot;,
        &amp;quot;Created&amp;quot;: &amp;quot;2017-07-08T03:59:16.18225183Z&amp;quot;,
        &amp;quot;Path&amp;quot;: &amp;quot;bash&amp;quot;,
        &amp;quot;Args&amp;quot;: [],
        &amp;quot;State&amp;quot;: {
         &amp;quot;Status&amp;quot;: &amp;quot;exited&amp;quot;,
          &amp;quot;Running&amp;quot;: false,
          &amp;quot;Paused&amp;quot;: false,
          &amp;quot;Restarting&amp;quot;: false,
          &amp;quot;OOMKilled&amp;quot;: false,
          &amp;quot;Dead&amp;quot;: false,
          &amp;quot;Pid&amp;quot;: 0,
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;容器信息很多，这⾥只粘贴了⼀部分&lt;br&gt;
⽐如：容器⾥在安装ip或ifconﬁg命令之前，查看⽹卡IP显示容器IP地址和端⼝号，如果输出是空的说明没有配置IP地址（不同的Docker容器可以通过此IP地址互相访问）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker inspect --format=&#39;{{.NetworkSettings.IPAddress}}&#39;  容器id
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;列出所有绑定的端⼝&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker inspect --format=&#39;{{range $p, $conf := .NetworkSettings.Ports}} {{$p}} {{(index $conf ).HostPort}} {{end}}&#39; $INSTANCE_ID
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker inspect --format=&#39;{{range 
$p, $conf := .NetworkSettings.Ports}} {{$p}} -&amp;gt; {{(index $conf 0).HostPort}} {{end}}&#39; b220fabf815a 22/tcp -&amp;gt; 20020
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;找出特殊的端⼝映射&lt;br&gt;
⽐如找出容器⾥22端⼝所映射的docker本机的端⼝&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker inspect --format=&#39;{{(index (index .NetworkSettings.Ports &amp;quot;22/tcp&amp;quot;) 0).HostPort}}&#39; $INSTANCE_ID
[root@Linux ~]# docker inspect --format=&#39;{{(index (index .NetworkSettings.Ports &amp;quot;22/tcp&amp;quot;) 0).HostPort}}&#39; b220fabf815a 20020
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;stop和kill的区别&lt;/strong&gt;&lt;br&gt;
docker stop命令给容器中的进程发送SIGTERM信号，默认⾏为是会导致容器退出，当然，容器内程序可以捕获该信号并⾃⾏处理，例如可以选择忽略。⽽docker kill则是给容器的进程发送SIGKILL信号，该信号将会使容器必然退出。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;删除容器
[root@Linux ~]# docker rm 容器id或名称
要删除⼀个运⾏中的容器，添加 -f 参数

根据格式删除所有容器：
[root@Linux ~]# docker rm $(docker ps -qf status=exited)

重启容器：
[root@Linux ~]#docker restart name

暂停容器：
pause  --暂停容器内的所有进程，
  通过docker stats可以观察到此时的资源使⽤情况是固定不变的，通过docker logs -f也观察不到⽇志的进⼀步输出。

恢复容器：
unpause  --恢复容器内暂停的进程，与pause参数相对应
[root@Linux ~]# docker start infallible_ramanujan  
这⾥的名字是状态⾥⾯NAMES列列出的名字，这种⽅式同样会让容器运⾏在后台

让容器运⾏在后台：
如果在docker run后⾯追加-d=true或者-d，那么容器将会运⾏在后台模式。此时所有I/O数据只能通过⽹络资源或者共享卷组来进⾏交互。因为容器不再监听你执⾏docker run的这个终端命令⾏窗⼝。但你可以通过执⾏
docker attach来重新附着到该容器的回话中。
注：
容器运⾏在后台模式下，是不能使⽤--rm选项的(⽼版本是这样，新版本已经可以同时⽣效) 
[root@Linux ~]#docker run -d IMAGE[:TAG] 命令
[root@Linux ~]#docker logs container_id  
[root@Linux ~]#打印该容器的输出
[root@Linux ~]# docker run -it -d --name mytest docker.io/centos /bin/sh -c &amp;quot;while true; do echo hello world; sleep 2; done&amp;quot;
37738fe3d6f9ef26152cb25018df9528a89e7a07355493020e72f147a291cd17

[root@Linux ~]# docker logs mytest
hello world
hello world

docker attach container_id #附加该容器的标准输出到当前
命令⾏
[root@Linux ~]# docker attach mytest
hello world
hello world
.......
此时，ctrl+d等同于exit命令，按ctrl+p+q可以退出到宿主机，⽽保持container仍然在运⾏

rename 
  Rename a container

stats   
  Display a live stream of container(s) resource usage statistics   
  --动态显示容器的资源消耗情况，包括：CPU、内存、⽹络I/O   
 

port   
  List port mappings or a specific mapping for the CONTAINER
   --输出容器端⼝与宿主机端⼝的映射情况
[root@Linux ~]# docker port blog
   80/tcp -&amp;gt; 0.0.0.0:80
   容器blog的内部端⼝80映射到宿主机的80端⼝，这样可通过宿主机的80端⼝查看容器blog提供的服务

连接容器：   
⽅法1.attach
[root@Linux ~]# docker attach 容器id  //前提是容器创建时必须指定了交互shell

⽅法2.exec    
  通过exec命令可以创建两种任务：后台型任务和交互型任务
  交互型任务：
   [root@Linux ~]# docker exec -it  容器id  /bin/bash
   root@68656158eb8e:/[root@Linux ~]# ls    

  后台型任务：
     [root@Linux ~]# docker exec 容器id touch /testfile

监控容器的运⾏：
可以使⽤logs、top、events、wait这些⼦命令
  logs:
    使⽤logs命令查看守护式容器
    可以通过使⽤docker logs命令来查看容器的运⾏⽇志，其中--tail选项可以指定查看最后⼏条⽇志，⽽-t选项则可以对⽇志条⽬附加时间戳。使⽤-f选项可以跟踪⽇志的输出，直到⼿动停⽌。
    [root@Linux ~]# docker logs  App_Container  //不同终端操作
    [root@Linux ~]# docker logs -f App_Container

  top:
  显示⼀个运⾏的容器⾥⾯的进程信息
        [root@Linux ~]# docker top birdben/ubuntu:v1

  events   
    Get real time events from the server
    实时输出Docker服务器端的事件，包括容器的创建，启动，关
闭等。
    [root@Linux ~]# docker start loving_meninsky         
    loving_meninsky
    [root@Linux ~]# docker events  //不同终端操作
      2017-07-08T16:39:23.177664994+08:00 network connect df15746d60ffaad2d15db0854a696d6e49fdfcedc7cfd8504a8aac51a43de6d4 
     
 (container=50a0449d7729f94046baf0fe5a1ce2119742261bb3ce8c3c98f35c80458e3e7a, 
      name=bridge, type=bridge)
      2017-07-08T16:39:23.356162529+08:00 
container start 
      
50a0449d7729f94046baf0fe5a1ce2119742261bb3ce8c3c98f35c80458e3e7a (image=ubuntu,  name=loving_meninsky)

  wait（X）   
   Block until a container stops, then print its 
exit code  
    --捕捉容器停⽌时的退出码
   执⾏此命令后，该命令会&amp;quot;hang&amp;quot;在当前终端，直到容器停⽌，此时，会打印出容器的退出码
        [root@Linux ~]# docker wait 01d8aa  //不同终端操作
        137

  diff
    查看容器内发⽣改变的⽂件，以elated_lovelace容器为例
            root@68656158eb8e:/# touch c.txt

    ⽤diff查看：
    包括⽂件的创建、删除和⽂件内容的改变都能看到
    [root@Linux ~]# docker diff  容器名称 
        A /c.txt

    C对应的⽂件内容的改变，A对应的均是⽂件或者⽬录的创建删
除
    [root@Linux ~]# docker diff 7287
        A /a.txt
        C /etc
        C /etc/passwd
        A /run
        A /run/secrets   

宿主机和容器之间相互Copy⽂件
cp的⽤法如下：
  docker cp [OPTIONS] CONTAINER:PATH LOCALPATH
  docker cp [OPTIONS] LOCALPATH CONTAINER:PATH
如：容器mysql中/usr/local/bin/存在docker-
entrypoint.sh⽂件，可如下⽅式copy到宿主机
    [root@Linux ~]# docker cp mysql:/usr/local/bin/docker-entrypoint.sh  /root

修改完毕后，将该⽂件重新copy回容器
    [root@Linux ~]# docker cp /root/docker-entrypoint.sh mysql:/usr/local/bin/ 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;6-docker容器镜像制作&#34;&gt;6、Docker容器镜像制作&lt;/h2&gt;
&lt;h3 id=&#34;61-容器文件系统打包&#34;&gt;6.1 容器⽂件系统打包&lt;/h3&gt;
&lt;p&gt;将容器的⽂件系统打包成tar⽂件,也就是把正在运⾏的容器直接导出为tar包的镜像⽂件&lt;br&gt;
export Export a container&#39;s ﬁlesystem as a tar archive&lt;/p&gt;
&lt;p&gt;有两种⽅式（elated_lovelace为容器名）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;第⼀种：
  [root@master ~][root@Linux ~]# docker export -o elated_lovelace.tar elated_lovelace
第⼆种：
  [root@master ~][root@Linux ~]# docker export 容器名称 &amp;gt; 镜像.tar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;导⼊镜像归档⽂件到其他宿主机&lt;br&gt;
import Import the contents from a tarball to create a ﬁlesystem image&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt; [root@Linux ~]# docker import elated_lovelace.tar  elated_lovelace:v1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果导⼊镜像时没有起名字，随后可以单独起名字(没有名字和tag)，可以⼿动加tag&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker tag 镜像ID mycentos:7
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;62-通过容器创建本地镜像&#34;&gt;6.2 通过容器创建本地镜像&lt;/h3&gt;
&lt;p&gt;背景：&lt;br&gt;
容器运⾏起来后，⼜在⾥⾯做了⼀些操作，并且要把操作结果保存到镜像⾥&lt;br&gt;
⽅案：&lt;br&gt;
使⽤ docker commit 指令，把⼀个正在运⾏的容器，直接提交为⼀个镜像。commit 是提交的意思,类似告诉svn服务器我要⽣成⼀个新的版本。&lt;/p&gt;
&lt;p&gt;例：在容器内部新建了⼀个⽂件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker exec -it 4ddf4638572d 
/bin/sh  
root@4ddf4638572d# touch test.txt
root@4ddf4638572d# exit
将这个新建的⽂件提交到镜像中保存
[root@Linux ~]# docker commit 4ddf4638572d wing/helloworld:v2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker commit -m &amp;quot;my images 
version1&amp;quot; -a &amp;quot;wing&amp;quot; 108a85b1ed99 
daocloud.io/ubuntu:v2
  
sha256:ffa8a185ee526a9b0d8772740231448a25855031f25c61c1b63077220469b057
  -m                   添加注释
  -a                   作者
  108a85b1ed99         容器环境id
  daocloud.io/ubuntu:v2    镜像名称：hub的名称/镜像名称：
tag 
  -p，–pause=true        提交时暂停容器运⾏
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Init 层的存在，是为了避免执⾏ docker commit 时，把 Docker⾃⼰对 /etc/hosts 等⽂件做的修改，也⼀起提交掉。&lt;/p&gt;
&lt;h3 id=&#34;63-镜像迁移&#34;&gt;6.3 镜像迁移&lt;/h3&gt;
&lt;p&gt;保存⼀台宿主机上的镜像为tar⽂件，然后可以导⼊到其他的宿主机上：&lt;br&gt;
save Save an image(s) to a tar archive&lt;/p&gt;
&lt;p&gt;将镜像打包，与下⾯的load命令相对应&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker save -o nginx.tar nginx
[root@Linux ~]# docker save &amp;gt; nginx.tar nginx
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;load Load an image from a tar archive or STDIN&lt;br&gt;
与上⾯的save命令相对应，将上⾯sava命令打包的镜像通过load命令导⼊&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker load &amp;lt; nginx.tar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注：&lt;br&gt;
1.tar⽂件的名称和保存的镜像名称没有关系&lt;br&gt;
2.导⼊的镜像如果没有名称，⾃⼰打tag起名字&lt;/p&gt;
&lt;h3 id=&#34;64-通过dockerfile创建镜像&#34;&gt;6.4 通过Dockerﬁle创建镜像&lt;/h3&gt;
&lt;p&gt;虽然可以⾃⼰制作 rootfs(⻅&#39;容器⽂件系统那些事⼉&#39;)，但Docker提供了⼀种更便捷的⽅式，叫作 Dockerﬁle&lt;br&gt;
docker build命令⽤于根据给定的Dockerﬁle和上下⽂以构建Docker镜像。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;docker build语法&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker build [OPTIONS] &amp;lt;PATH | URL | -&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;选项说明&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;--build-arg，设置构建时的变量&lt;br&gt;
--no-cache，默认false。设置该选项，将不使⽤Build Cache构建镜像&lt;/p&gt;
&lt;p&gt;--pull，默认false。设置该选项，总是尝试pull镜像的最新版本&lt;/p&gt;
&lt;p&gt;--compress，默认false。设置该选项，将使⽤gzip压缩构建的上下⽂&lt;br&gt;
--disable-content-trust，默认true。设置该选项，将对镜像进⾏验证&lt;br&gt;
--ﬁle, -f，Dockerﬁle的完整路径，默认值为‘PATH/Dockerﬁle’&lt;br&gt;
--isolation，默认--isolation=&amp;quot;default&amp;quot;，即Linux命名空间；其他还有process或hyperv&lt;br&gt;
--label，为⽣成的镜像设置metadata&lt;br&gt;
--squash，默认false。设置该选项，将新构建出的多个层压缩为⼀个新层，但是将⽆法在多个镜像之间共享新层；设置该选项，实际上是创建了新image，同时保留原有image。&lt;br&gt;
--tag, -t，镜像的名字及tag，通常name:tag或者name格式；可以在⼀次构建中为⼀个镜像设置多个tag&lt;br&gt;
--network，默认default。设置该选项，Set the networking mode for the RUN instructions during build&lt;br&gt;
--quiet, -q ，默认false。设置该选项，Suppress the build output and print image ID on success&lt;br&gt;
--force-rm，默认false。设置该选项，总是删除掉中间环节的容器&lt;br&gt;
--rm，默认--rm=true，即整个构建过程成功后删除中间环节的容器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;PATH | URL | -说明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给出命令执⾏的上下⽂。&lt;br&gt;
上下⽂可以是构建执⾏所在的本地路径，也可以是远程URL，如Git库、tarball或⽂本⽂件等。&lt;br&gt;
如果是Git库，如https://github.com/docker/rootfs.git#container:docker，则隐含先执⾏git clone --depth 1 --recursive，到本地临时⽬录；然后再将该临时⽬录发送给构建进程。&lt;br&gt;
构建镜像的进程中，可以通过ADD命令将上下⽂中的任何⽂件（注意⽂件必须在上下⽂中）加⼊到镜像中。&lt;br&gt;
-表示通过STDIN给出Dockerﬁle或上下⽂。&lt;br&gt;
示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker build - &amp;lt; Dockerfile 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;说明：该构建过程只有Dockerﬁle，没有上下⽂&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker build - &amp;lt; context.tar.gz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;说明：其中Dockerﬁle位于context.tar.gz的根路径&lt;br&gt;
可以同时设置多个tag&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt; [root@Linux ~]# docker build -t champagne/bbauto:latest -t champagne/bbauto:v2.1 . 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建镜像所在的⽂件夹和Dockerﬁle⽂件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mkdir dockerfile-test 
cd dockerfile-test 
touch Dockerfile 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在Dockerﬁle⽂件中写⼊指令，每⼀条指令都会更新镜像的信息例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# vim Dockerfile 
[root@Linux ~]# This is a comment 
FROM  daocloud.io/library/centos:7 
MAINTAINER wing wing@Linux
RUN  命令1;命令2；命令3
RUN  命令
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;格式说明&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;每⾏命令都是以 INSTRUCTION statement 形式，就是命令+清单的模式。命令要⼤写，&amp;quot;#&amp;quot;是注解。&lt;br&gt;
FROM 命令是告诉docker 我们的镜像什么。&lt;br&gt;
MAINTAINER 是描述 镜像的创建⼈。&lt;br&gt;
RUN 命令是在镜像内部执⾏。就是说他后⾯的命令应该是针对镜像可以运⾏的命令。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;创建镜像&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker build  -t  centos:v2 . 
     docker build  是docker创建镜像的命令 
     -t  镜像名称  
     &amp;quot;.&amp;quot; 是⽤来指明我们使⽤的Dockerfile⽂件所在的当前⽬录
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.4、创建完成后，⽤这个镜像运⾏容器&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker run -it centos:v2 /bin/bash
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;65-dockerfile实例01容器化python的flask应用&#34;&gt;6.5 Dockerﬁle实例01：容器化Python的Flask应⽤&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;⽬标&lt;/strong&gt;&lt;br&gt;
⽤ Docker 部署⼀个⽤ Python 编写的 Web 应⽤。&lt;br&gt;
&lt;strong&gt;应⽤代码部分&lt;/strong&gt;&lt;br&gt;
代码功能：如果当前环境中有&amp;quot;NAME&amp;quot;这个环境变量，就把它打印&amp;quot;Hello&amp;quot;后，否则就打印&amp;quot;Hello world&amp;quot;，最后再打印出当前环境的hostname。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# mkdir python_app
[root@Linux ~]# cd python_app
[root@Linux ~]# vim app.py
from flask import Flask
import socket
import os
app = Flask(__name__)
@app.route(&#39;/&#39;)
def hello():
  html = &amp;quot;&amp;lt;h3&amp;gt;Hello {name}!&amp;lt;/h3&amp;gt;&amp;quot; \
      &amp;quot;&amp;lt;b&amp;gt;Hostname:&amp;lt;/b&amp;gt; {hostname}&amp;lt;br/&amp;gt;&amp;quot;      
  return html.format(name=os.getenv(&amp;quot;NAME&amp;quot;, &amp;quot;world&amp;quot;), hostname=socket.gethostname())
if __name__ == &amp;quot;__main__&amp;quot;:
  app.run(host=&#39;0.0.0.0&#39;, port=80)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;应⽤依赖&lt;br&gt;
定义在同⽬录下的 requirements.txt ⽂件⾥，内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# vim requirements.txt
Flask
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编写Dockerﬁle&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# vim Dockerfile
FROM python:2.7-slim
WORKDIR /app
ADD  .  /app
RUN pip install --trusted-host pypi.python.org -r 
requirements.txt
EXPOSE 80
ENV NAME World
CMD [&amp;quot;python&amp;quot;, &amp;quot;app.py&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Dockerﬁle⽂件说明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;FROM python:2.7-slim&lt;br&gt;
使⽤官⽅提供的 Python 开发镜像作为基础镜像&lt;br&gt;
指定&amp;quot;python:2.7-slim&amp;quot;这个官⽅维护的基础镜像，从⽽免去安装Python 等语⾔环境的操作。否则，这⼀段就得这么写了：&lt;br&gt;
FROM ubuntu:latest&lt;br&gt;
RUN apt-get update -y&lt;br&gt;
RUN apt-get install -y python-pip python-dev build-essential&lt;br&gt;
WORKDIR /app&lt;br&gt;
将⼯作⽬录切换为 /app，意思是在这⼀句之后，Dockerﬁle 后⾯的操作都以这⼀句指定的 /app ⽬录作为当前⽬录。&lt;br&gt;
ADD . /app&lt;br&gt;
将当前⽬录下的所有内容复制到 /app 下，Dockerﬁle ⾥的原语并不都是指对容器内部的操作。⽐如 ADD，指的是把当前⽬录（即Dockerﬁle 所在的⽬录）⾥的⽂件，复制到指定容器内的⽬录当中。&lt;/p&gt;
&lt;p&gt;RUN pip install --trusted-host pypi.python.org -r requirements.txt&lt;br&gt;
使⽤ pip 命令安装这个应⽤所需要的依赖&lt;br&gt;
EXPOSE 80 //允许外界访问容器的 80 端⼝&lt;br&gt;
ENV NAME World //设置环境变量&lt;br&gt;
CMD [&amp;quot;python&amp;quot;, &amp;quot;app.py&amp;quot;]&lt;br&gt;
设置容器进程为：python app.py，即：这个 Python 应⽤的启动&lt;br&gt;
命令&lt;br&gt;
这⾥app.py 的实际路径是 /app/app.py。CMD [&amp;quot;python&amp;quot;,&amp;quot;app.py&amp;quot;] 等价于 &amp;quot;docker run python app.py&amp;quot;。&lt;br&gt;
在使⽤ Dockerﬁle 时，可能还会看到⼀个叫作 ENTRYPOINT 的原语。它和 CMD 都是 Docker 容器进程启动所必需的参数，完整执⾏格式是：&amp;quot;ENTRYPOINT CMD&amp;quot;。&lt;br&gt;
但是，默认，Docker 会提供⼀个隐含的 ENTRYPOINT，即：/bin/sh -c。所以，在不指定 ENTRYPOINT 时，⽐如在这个例⼦⾥，实际上运⾏在容器⾥的完整进程是：/bin/sh -c &amp;quot;python app.py&amp;quot;，即 CMD 的内容就是 ENTRYPOINT 的参数。&lt;br&gt;
基于以上原因，后⾯会统⼀称 Docker 容器的启动进程为ENTRYPOINT，⽽不是 CMD。&lt;br&gt;
现在⽬录结构：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# ls
Dockerfile  app.py  requirements.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;构建镜像&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker build -t helloworld .
-t  给这个镜像加⼀个 Tag
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Dockerﬁle 中的每个原语执⾏后，都会⽣成⼀个对应的镜像层。即使原语本身并没有明显地修改⽂件的操作（⽐如，ENV 原语），它对应的层也会存在。只不过在外界看来，这个层是空的。&lt;/p&gt;
&lt;p&gt;查看结果&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker image ls
REPOSITORY       TAG             IMAGE ID
helloworld       latest        653287cdf998
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;启动容器&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker run -p 4000:80 helloworld
镜像名 helloworld 后⾯，什么都不⽤写，因为在 Dockerfile 中已经指定了 CMD。
否则，就得把进程的启动命令加在后⾯：
[root@Linux ~]# docker run -p 4000:80 helloworld python app.py
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看容器&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker ps
CONTAINER ID     IMAGE         COMMAND          
CREATED
4ddf4638572d     helloworld    &amp;quot;python app.py&amp;quot;   10 
seconds ago
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;进⼊容器&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker exec -it b69 /bin/bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;访问容器内应⽤&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# curl http://localhost:4000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Hello World!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hostname: 4ddf4638572d&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;⾄此，已经使⽤容器完成了⼀个应⽤的开发与测试，如果现在想要把这个容器的镜像上传到 DockerHub 上分享给更多的⼈，⾸先要注册⼀个 Docker Hub 账号，然后使⽤ docker login 命令登录。&lt;/p&gt;
&lt;p&gt;给容器镜像打tag起⼀个完整的名字：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker tag helloworld chenyoong/helloworld:v1
chenyong为我在docker hub的⽤户名
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;推送镜像到Docker Hub&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker push chenyong/helloworld:v1
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;66-dockerfile实例02制作kubectl的镜像&#34;&gt;6.6 Dockerﬁle实例02：制作Kubectl的镜像&lt;/h3&gt;
&lt;p&gt;注：本实例学完k8s之后才能做&lt;br&gt;
制作镜像：wing/kubectl&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]#cat Dockerfile/kubectl/Dockerfile
FROM alpine
MAINTAINER wing &amp;lt;276267003@qq.com&amp;gt;
LABEL org.label-schema.vcs-ref=$VCS_REF \
   org.label-schema.vcs-
url=&amp;quot;https://github.com/vfarcic/kubectl&amp;quot; \
   org.label-schema.docker.dockerfile=&amp;quot;/Dockerfile&amp;quot;
ENV KUBE_LATEST_VERSION=&amp;quot;v1.13.0&amp;quot;
RUN apk add --update ca-certificates &amp;amp;&amp;amp; \
  apk add --update -t deps curl &amp;amp;&amp;amp; \
  curl -L https://storage.googleapis.com/kubernetes-release/release/${KUBE_LATEST_VERSION}/bin/linux/amd64/kubectl -o /usr/local/bin/kubectl &amp;amp;&amp;amp; \
  chmod +x /usr/local/bin/kubectl &amp;amp;&amp;amp; \
  apk del --purge deps &amp;amp;&amp;amp; \
  rm /var/cache/apk/* 
CMD [&amp;quot;kubectl&amp;quot;, &amp;quot;help&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;67-dockerfile优化&#34;&gt;6.7 Dockerﬁle优化&lt;/h3&gt;
&lt;p&gt;编译⼀个简单的nginx成功以后发现好⼏百M。&lt;br&gt;
1、RUN 命令要尽量写在⼀条⾥，每次 RUN 命令都是在之前的镜像上封装，只会增⼤不会减⼩&lt;br&gt;
2、每次进⾏依赖安装后使⽤yum clean all清除缓存中的rpm头⽂件和包⽂件&lt;br&gt;
3、选择⽐较⼩的基础镜像，⽐如：alpine&lt;/p&gt;
&lt;h2 id=&#34;7-docker私有仓库&#34;&gt;7、Docker私有仓库&lt;/h2&gt;
&lt;h3 id=&#34;71-仓库镜像&#34;&gt;7.1 仓库镜像&lt;/h3&gt;
&lt;p&gt;Docker hub官⽅已提供容器镜像registry,⽤于搭建私有仓库&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;拉取镜像&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker pull daocloud.io/library/registry:latest
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;72-运行容器&#34;&gt;7.2 运⾏容器&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker run --name &amp;quot;pri_registry&amp;quot; --restart=always -d -p 5000:5000 daocloud.io/library/registry 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注：如果创建容器不成功，报错防⽕墙，解决⽅案如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]#systemctl stop firewalld
[root@Linux ~]#yum install iptables*
[root@Linux ~]#systemctl start iptables
[root@Linux ~]#iptables -F
[root@Linux ~]#systemctl restart docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;73-查看容器&#34;&gt;7.3 查看容器&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker ps
CONTAINER ID  IMAGE  COMMAND  CREATED  STATUS   PORTS 
  NAMES
1f444285bed8     daocloud.io/library/registry 
 &amp;quot;/entrypoint.sh /etc/&amp;quot;  23 seconds ago    Up 21 
seconds    0.0.0.0:5000-&amp;gt;5000/tcp  elegant_rosalind
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;74-连接容器查看端口状态&#34;&gt;7.4 连接容器查看端⼝状态&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker exec -it  1f444285bed8  /bin/sh    //这⾥是sh 不是bash
  /# netstat -lnp                        //查看5000端
⼝是否开启
  Active Internet connections (only servers)
  Proto Recv-Q Send-Q Local Address      Foreign 
Address     State    PID/Program name   
  tcp     0    0 :::5000         :::*           
LISTEN    1/registry
  Active UNIX domain sockets (only servers)
  Proto RefCnt Flags    Type    State     I-Node 
PID/Program name   Path
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在本机查看能否访问该私有仓库,看看状态码是不是200&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# curl  -I  127.0.0.1:5000   //参数是⼤写的i
HTTP/1.1 200 OK    
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;75-仓库功能测试&#34;&gt;7.5 仓库功能测试&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;为了⽅便，下载1个⽐较⼩的镜像,buysbox
 [root@Linux ~]# docker pull busybox

上传前必须给镜像打tag  注明ip和端⼝：
 [root@Linux ~]# docker tag  busybox  私有仓库IP:端⼝/busybox

这是直接从官⽅拉的镜像，很慢：
  [root@Linux ~]# docker tag busybox 192.168.245.136:5000/busybox
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下⾯这个Mysql是我测试的第⼆个镜像，从daocloud拉取的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker tag daocloud.io/library/mysql 192.168.245.136:5000/daocloud.io/library/mysql
  注：tag后⾯可以使⽤镜像名称也可以使⽤id,我这⾥使⽤的镜像名称，如果使⽤官⽅的镜像，不需要加前缀，但是daocloud.io的得加前缀
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改请求⽅式为http&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;默认为https，不改会报以下错误:
    Get https://master.up.com:5000/v1/_ping: http: 
server gave HTTP response to HTTPS client
  [root@Linux ~]# vim /etc/docker/daemon.json
  { &amp;quot;insecure-registries&amp;quot;:[&amp;quot;192.168.245.136:5000&amp;quot;] }
  
重启docker:
  [root@Linux ~]# systemctl restart docker
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上传镜像到私有仓库&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt; [root@Linux ~] # docker push 192.168.245.136:5000/busybox 
 [root@Linux ~] # docker push 192.168.245.136:5000/daocloud.io/library/mysql
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看私有仓库⾥的所有镜像&lt;br&gt;
注：我这⾥是⽤的是ubuntu的例⼦&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~] # curl 192.168.245.130:5000/v2/_catalog
 { &amp;quot;repositories&amp;quot; :[ &amp;quot;daocloud.io/ubuntu&amp;quot; ]}
或者
[root@Linux ~] # curl http://192.168.245.130:5000/v2/daocloud.io/ubuntu/tags/list
 { &amp;quot;name&amp;quot; : &amp;quot;daocloud.io/ubuntu&amp;quot; , &amp;quot;tags&amp;quot; :[ &amp;quot;v2&amp;quot; ]}
[root@Linux ~] # curl http://192.168.245.130:5000/v2/repo 名字/tags/list
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;拉取镜像测试&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~] # docker pull 192.168.245.136:5000/busybox
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;8-部署docker-webui&#34;&gt;8、部署Docker-WebUI&lt;/h2&gt;
&lt;h3 id=&#34;81-下载并运行容器&#34;&gt;8.1 下载并运⾏容器&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]#docker pull uifd/ui-for-docker 
[root@Linux ~]#docker run -it -d --name docker-web -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock docker.io/uifd/ui-for-docker 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;82-浏览器访问测试&#34;&gt;8.2 浏览器访问测试&lt;/h3&gt;
&lt;p&gt;http://ip:9000&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200820012943.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;9-docker资源限制&#34;&gt;9、Docker资源限制&lt;/h2&gt;
&lt;p&gt;在使⽤ Docker 运⾏容器时，⼀台主机上可能会运⾏⼏百个容器，这些容器虽然互相隔离，但是底层却使⽤着相同的 CPU、内存和磁盘资源。如果不对容器使⽤的资源进⾏限制，那么容器之间会互相影响，⼩的来说会导致容器资源使⽤不公平；⼤的来说，可能会导致主机和集群资源耗尽，服务完全不可⽤。&lt;br&gt;
CPU 和内存的资源限制已经是⽐较成熟和易⽤，能够满⾜⼤部分⽤户的需求。磁盘限制也是不错的，虽然现在⽆法动态地限制容量，但是限制磁盘读写速度也能应对很多场景。&lt;/p&gt;
&lt;p&gt;⾄于⽹络，Docker 现在并没有给出⽹络限制的⽅案，也不会在可⻅的未来做这件事情，因为⽬前⽹络是通过插件来实现的，和容器本身的功能相对独⽴，不是很容易实现，扩展性也很差。&lt;br&gt;
资源限制⼀⽅⾯可以让我们为容器（应⽤）设置合理的 CPU、内存等资源，⽅便管理；另外⼀⽅⾯也能有效地预防恶意的攻击和异常，&lt;br&gt;
对容器来说是⾮常重要的功能。如果你需要在⽣产环境使⽤容器，请务&lt;br&gt;
必要花时间去做这件事情。&lt;/p&gt;
&lt;h3 id=&#34;91-系统压力测试&#34;&gt;9.1 系统压⼒测试&lt;/h3&gt;
&lt;p&gt;Stress是⼀个linux下的压⼒测试⼯具，专⻔为那些想要测试⾃⼰的系统，完全⾼负荷和监督这些设备运⾏的⽤户。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;安装
[root@Linux ~]# yum install stress -y
 
测试场景举例 
测试CPU负荷 
[root@Linux ~]# stress -c 4  //增加4个cpu进程，处理sqrt()函数函数，以提⾼系统CPU负荷
 
内存测试
[root@Linux ~]# stress –i 4 –vm 10 –vm-bytes 1G –vm-hang 100 –timeout 100s
新增4个io进程，10个内存分配进程，每次分配⼤⼩1G，分配后不释放，测试100S

磁盘I/O测试
[root@Linux ~]# stress –d 1 --hdd-bytes 3G  //新增1个写进程，每次写3G⽂件块

硬盘测试（不删除）
[root@Linux ~]# stress –i 1 –d 10 --hdd-bytes 3G –hdd-noclean
新增1个IO进程，10个写进程，每次写⼊3G⽂件块，且不清除，会逐步将硬盘耗尽。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Stress各主⽤参数说明&lt;/strong&gt;&lt;br&gt;
-表示后接⼀个中划线，--表示后接2个中划线，均可⽤于stress后接参数，不同表达⽅式&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;-？&lt;br&gt;
--help 显示帮助信息&lt;br&gt;
--version 显示软件版本信息&lt;br&gt;
-t secs:&lt;br&gt;
--timeout secs指定运⾏多少秒&lt;br&gt;
--backoﬀ usecs 等待usecs微秒后才开始运⾏&lt;br&gt;
-c forks:&lt;br&gt;
--cpu forks 产⽣多个处理sqrt()函数的CPU进程&lt;br&gt;
-m forks&lt;br&gt;
--vm forks:产⽣多个处理malloc()内存分配函数的进程，后接进程数量&lt;br&gt;
-i forks&lt;br&gt;
--io forks:产⽣多个处理sync()函数的磁盘I/O进程&lt;br&gt;
--vm-bytes bytes：指定内存的byte数，默认值是1&lt;br&gt;
--vm-hang:表示malloc分配的内存多少时间后在free()释放掉&lt;br&gt;
-d :&lt;/p&gt;
&lt;p&gt;--hdd:写进程，写⼊固定⼤⼩，通过mkstemp()函数写⼊当前⽬录&lt;/p&gt;
&lt;p&gt;--hdd-bytes bytes:指定写的byte数，默认1G&lt;br&gt;
--hdd-noclean:不要将写⼊随机ascii数据的⽂件unlink，则写⼊的⽂件不删除，会保留在硬盘空间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;92-cpu资源限制&#34;&gt;9.2 Cpu资源限制&lt;/h3&gt;
&lt;p&gt;Cpu 资源&lt;br&gt;
主机上的进程会通过时间分⽚机制使⽤ CPU，CPU 的量化单位是频率，也就是每秒钟能执⾏的运算次数。为容器限制 CPU 资源并不能改变 CPU 的运⾏频率，⽽是改变每个容器能使⽤的 CPU 时间⽚。理想状态下，CPU 应该⼀直处于运算状态（并且进程需要的计算量不会超过 CPU 的处理能⼒）。&lt;/p&gt;
&lt;h4 id=&#34;921-限制cpu-share&#34;&gt;9.2.1 限制Cpu Share&lt;/h4&gt;
&lt;p&gt;什么是cpu share？&lt;br&gt;
docker 允许⽤户为每个容器设置⼀个数字，代表容器的 CPUshare，默认情况下每个容器的 share 是 1024。这个 share 是相对的，本身并不能代表任何确定的意义。当主机上有多个容器运⾏时，每个容器占⽤的 CPU 时间⽐例为它的 share 在总额中的⽐例。docker 会根据主机上运⾏的容器和进程动态调整每个容器使⽤ CPU 的时间⽐例。&lt;br&gt;
例：&lt;br&gt;
如果主机上有两个⼀直使⽤ CPU 的容器（为了简化理解，不考虑主机上其他进程），其 CPU share 都是 1024，那么两个容器 CPU 使⽤率都是 50%；如果把其中⼀个容器的 share 设置为 512，那么两者CPU 的使⽤率分别为 67% 和 33%；如果删除 share 为 1024 的容器，剩下来容器的 CPU 使⽤率将会是 100%。&lt;br&gt;
好处：&lt;br&gt;
能保证 CPU 尽可能处于运⾏状态，充分利⽤ CPU 资源，⽽且保证所有容器的相对公平；&lt;br&gt;
缺点：&lt;br&gt;
⽆法指定容器使⽤ CPU 的确定值。&lt;br&gt;
设置 CPU share 的参数：&lt;br&gt;
-c --cpu-shares，它的值是⼀个整数。&lt;br&gt;
我的机器是 4 核 CPU，因此运⾏⼀个stress容器,使⽤ stress 启动4 个进程来产⽣计算压⼒：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker pull progrium/stress
[root@Linux ~]# yum install htop -y
[root@Linux ~]# docker run --rm -it 
progrium/stress --cpu 4 
stress: info: [1] dispatching hogs: 4 cpu, 0 io, 0 vm, 0 hdd
stress: dbug: [1] using backoff sleep of 12000us
stress: dbug: [1] --&amp;gt; hogcpu worker 4 [7] forked
stress: dbug: [1] using backoff sleep of 9000us
stress: dbug: [1] --&amp;gt; hogcpu worker 3 [8] forked
stress: dbug: [1] using backoff sleep of 6000us
stress: dbug: [1] --&amp;gt; hogcpu worker 2 [9] forked
stress: dbug: [1] using backoff sleep of 3000us
stress: dbug: [1] --&amp;gt; hogcpu worker 1 [10] forked
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在另外⼀个 Terminal 使⽤ htop 查看资源的使⽤情况：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200820013659.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;上图中看到，CPU 四个核资源都达到了 100%。四个 stress 进程CPU 使⽤率没有达到 100% 是因为系统中还有其他机器在运⾏。为了⽐较，另外启动⼀个 share 为 512 的容器：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker run --rm -it -c 512 
progrium/stress --cpu 4 
stress: info: [1] dispatching hogs: 4 cpu, 0 io, 0 vm, 0 hdd
stress: dbug: [1] using backoff sleep of 12000us
stress: dbug: [1] --&amp;gt; hogcpu worker 4 [6] forked
stress: dbug: [1] using backoff sleep of 9000us
stress: dbug: [1] --&amp;gt; hogcpu worker 3 [7] forked
stress: dbug: [1] using backoff sleep of 6000us
stress: dbug: [1] --&amp;gt; hogcpu worker 2 [8] forked
stress: dbug: [1] using backoff sleep of 3000us
stress: dbug: [1] --&amp;gt; hogcpu worker 1 [9] forked
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为默认情况下，容器的 CPU share 为 1024，所以这两个容器的CPU 使⽤率应该⼤致为 2：1，下⾯是启动第⼆个容器之后的监控截图：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200820013735.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;两个容器分别启动了四个 stress 进程，第⼀个容器 stress 进程CPU 使⽤率都在 54% 左右，第⼆个容器 stress 进程 CPU 使⽤率在25% 左右，⽐例关系⼤致为 2：1，符合之前的预期。&lt;/p&gt;
&lt;h4 id=&#34;922-限制cpu-核数&#34;&gt;9.2.2 限制Cpu 核数&lt;/h4&gt;
&lt;p&gt;限制容器能使⽤的 CPU 核数&lt;br&gt;
-c --cpu-shares 参数只能限制容器使⽤ CPU 的⽐例，或者说优先级，⽆法确定地限制容器使⽤ CPU 的具体核数；从 1.13 版本之后，docker 提供了 --cpus 参数可以限定容器能使⽤的 CPU 核数。这个功能可以让我们更精确地设置容器 CPU 使⽤量，是⼀种更容易理解也因此更常⽤的⼿段。&lt;br&gt;
--cpus 后⾯跟着⼀个浮点数，代表容器最多使⽤的核数，可以精确到⼩数点⼆位，也就是说容器最⼩可以使⽤ 0.01 核 CPU。&lt;br&gt;
限制容器只能使⽤ 1.5 核数 CPU&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker run --rm -it --cpus 1.5 
progrium/stress --cpu 3 
stress: info: [1] dispatching hogs: 3 cpu, 0 io, 0 vm, 0 hdd
stress: dbug: [1] using backoff sleep of 9000us
stress: dbug: [1] --&amp;gt; hogcpu worker 3 [7] forked
stress: dbug: [1] using backoff sleep of 6000us
stress: dbug: [1] --&amp;gt; hogcpu worker 2 [8] forked
stress: dbug: [1] using backoff sleep of 3000us
stress: dbug: [1] --&amp;gt; hogcpu worker 1 [9] forked
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在容器⾥启动三个 stress 来跑 CPU 压⼒，如果不加限制，这个容器会导致 CPU 的使⽤率为 300% 左右（也就是说会占⽤三个核的计算能⼒）。实际的监控如下图：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200820013841.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;可以看到，每个 stress 进程 CPU 使⽤率⼤约在 50%，总共的使⽤率为 150%，符合 1.5 核的设置。&lt;br&gt;
如果设置的 --cpus 值⼤于主机的 CPU 核数，docker 会直接报错：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker run --rm -it --cpus 8 
progrium/stress --cpu 3 
docker: Error response from daemon: Range of CPUs is from 0.01 to 4.00, as there are only 4 CPUs available.
See &#39;docker run --help&#39;.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果多个容器都设置了 --cpus ，并且它们之和超过主机的 CPU 核数，并不会导致容器失败或者退出，这些容器之间会竞争使⽤ CPU，具体分配的 CPU 数量取决于主机运⾏情况和容器的 CPU share 值。也就是说 --cpus 只能保证在 CPU 资源充⾜的情况下容器最多能使⽤的CPU 数，docker 并不能保证在任何情况下容器都能使⽤这么多的CPU（因为这根本是不可能的）。&lt;/p&gt;
&lt;h4 id=&#34;923-cpu-绑定&#34;&gt;9.2.3 CPU 绑定&lt;/h4&gt;
&lt;p&gt;限制容器运⾏在某些 CPU 核&lt;br&gt;
注：&lt;br&gt;
⼀般并&lt;strong&gt;不推荐&lt;/strong&gt;在⽣产中这样使⽤&lt;br&gt;
docker 允许调度的时候限定容器运⾏在哪个 CPU 上。&lt;/p&gt;
&lt;p&gt;限制容器运⾏在哪些核上并不是⼀个很好的做法，因为它需要实现知道主机上有多少 CPU 核，⽽且⾮常不灵活。除⾮有特别的需求，⼀般并不推荐在⽣产中这样使⽤。&lt;br&gt;
假如主机上有 4 个核，可以通过 --cpuset 参数让容器只运⾏在前两个核上：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker run --rm -it --cpuset-
cpus=0,1 progrium/stress --cpu 2 
stress: info: [1] dispatching hogs: 2 cpu, 0 io, 0 vm, 0 hdd
stress: dbug: [1] using backoff sleep of 6000us
stress: dbug: [1] --&amp;gt; hogcpu worker 2 [7] forked
stress: dbug: [1] using backoff sleep of 3000us
stress: dbug: [1] --&amp;gt; hogcpu worker 1 [8] forked
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样，监控中可以看到只有前⾯两个核 CPU 达到了 100% 使⽤率。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200820014059.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;--cpuset-cpus 参数可以和 -c --cpu-shares ⼀起使⽤，限制容器只能运⾏在某些 CPU 核上，并且配置了使⽤率。&lt;/p&gt;
&lt;h3 id=&#34;93-mem资源限制&#34;&gt;9.3 Mem资源限制&lt;/h3&gt;
&lt;p&gt;Docker 默认没有对容器内存进⾏限制，容器可以使⽤主机提供的所有内存。&lt;br&gt;
不限制内存带来的问题：&lt;/p&gt;
&lt;p&gt;这是⾮常危险的事情，如果某个容器运⾏了恶意的内存消耗软件，或者代码有内存泄露，很可能会导致主机内存耗尽，因此导致服务不可⽤。可以为每个容器设置内存使⽤的上限，⼀旦超过这个上限，容器会被杀死，⽽不是耗尽主机的内存。&lt;br&gt;
限制内存带来的问题：&lt;br&gt;
限制内存上限虽然能保护主机，但是也可能会伤害到容器⾥的服务。如果为服务设置的内存上限太⼩，会导致服务还在正常⼯作的时候就被 OOM 杀死；如果设置的过⼤，会因为调度器算法浪费内存。&lt;br&gt;
合理做法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为应⽤做内存压⼒测试，理解正常业务需求下使⽤的内存情况，然后才能进⼊⽣产环境使⽤&lt;/li&gt;
&lt;li&gt;⼀定要限制容器的内存使⽤上限，尽量保证主机的资源充⾜，⼀旦通过监控发现资源不⾜，就进⾏扩容或者对容器进⾏迁移如果可以（内存资源充⾜的情况）&lt;/li&gt;
&lt;li&gt;尽量不要使⽤ swap，swap 的使⽤会导致内存计算复杂，对调度器⾮常不友好&lt;br&gt;
Docker 限制容器内存使⽤量:&lt;br&gt;
docker 启动参数中，和内存限制有关的包括（参数的值⼀般是内存⼤⼩，也就是⼀个正数，后⾯跟着内存单位 b、k、m、g，分别对应bytes、KB、MB、和 GB）：&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;-m --memory：&lt;br&gt;
容器能使⽤的最⼤内存⼤⼩，最⼩值为 4m&lt;br&gt;
--memory-swap：&lt;br&gt;
容器能够使⽤的 swap ⼤⼩&lt;br&gt;
--memory-swap 必须在 --memory 也配置的情况下才能有⽤。&lt;br&gt;
如果 --memory-swap 的值⼤于 --memory，那么容器能使⽤的总内存（内存 + swap）为 --memory-swap 的值，能使⽤的swap 值为 --memory-swap 减去 --memory 的值&lt;br&gt;
如果 --memory-swap 为 0，或者和 --memory 的值相同，那么容器能使⽤两倍于内存的 swap ⼤⼩，如果 --memory 对应的值是 200M，那么容器可以使⽤ 400M swap&lt;br&gt;
如果 --memory-swap 的值为 -1，那么不限制 swap 的使⽤，也就是说主机有多少 swap，容器都可以使⽤&lt;br&gt;
--memory-swappiness：&lt;br&gt;
默认情况下，主机可以把容器使⽤的匿名⻚（anonymous page）swap 出来，你可以设置⼀个 0-100 之间的值，代表允许swap 出来的⽐例&lt;br&gt;
--memory-reservation：&lt;br&gt;
设置⼀个内存使⽤的 soft limit，如果 docker 发现主机内存不⾜，会执⾏ OOM 操作。这个值必须⼩于 --memory 设置的值&lt;br&gt;
--kernel-memory：&lt;br&gt;
容器能够使⽤的 kernel memory ⼤⼩，最⼩值为 4m。&lt;br&gt;
--oom-kill-disable：&lt;br&gt;
是否运⾏ OOM 的时候杀死容器。只有设置了 -m，才可以把这个选项设置为 false，否则容器会耗尽主机内存，⽽且导致主机应⽤被杀死&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果限制容器的内存使⽤为 64M，在申请 64M 资源的情况下，容器运⾏正常（如果主机上内存⾮常紧张，并不⼀定能保证这⼀点）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker run --rm -it -m 64m progrium/stress --vm 1 --vm-bytes 64M --vm-hang 0
WARNING: Your kernel does not support swap limit 
capabilities or the cgroup is not mounted. Memory 
limited without swap.
stress: info: [1] dispatching hogs: 0 cpu, 0 io, 1 vm, 0 hdd
stress: dbug: [1] using backoff sleep of 3000us
stress: dbug: [1] --&amp;gt; hogvm worker 1 [7] forked
stress: dbug: [7] allocating 67108864 bytes ...
stress: dbug: [7] touching bytes in strides of 4096 bytes ...
stress: dbug: [7] sleeping forever with allocated memory .....
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;⽽如果申请 100M 内存，会发现容器⾥的进程被 kill 掉了（worker 7 got signal 9，signal 9 就是 kill 信号）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker run --rm -it -m 64m progrium/stress --vm 1 --vm-bytes 100M --vm-hang 0 
WARNING: Your kernel does not support swap limit capabilities or the cgroup is not mounted. Memory limited without swap.
stress: info: [1] dispatching hogs: 0 cpu, 0 io, 1 vm, 0 hdd
stress: dbug: [1] using backoff sleep of 3000us
stress: dbug: [1] --&amp;gt; hogvm worker 1 [7] forked
stress: dbug: [7] allocating 104857600 bytes ...
stress: dbug: [7] touching bytes in strides of 4096 bytes ...
stress: FAIL: [1] (415) &amp;lt;-- worker 7 got signal 9
stress: WARN: [1] (417) now reaping child worker processes
stress: FAIL: [1] (421) kill error: No such process
stress: FAIL: [1] (451) failed run completed in 0s
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;94-io-资源限制扩展&#34;&gt;9.4 IO 资源限制【扩展】&lt;/h3&gt;
&lt;p&gt;对于磁盘来说，考量的参数是容量和读写速度，因此对容器的磁盘限制也应该从这两个维度出发。⽬前 docker ⽀持对磁盘的读写速度进⾏限制，但是并没有⽅法能限制容器能使⽤的磁盘容量（⼀旦磁盘mount 到容器⾥，容器就能够使⽤磁盘的所有容量）。&lt;br&gt;
限制磁盘的读写速率&lt;br&gt;
docker 允许你直接限制磁盘的读写速率，对应的参数有：&lt;br&gt;
--device-read-bps：磁盘每秒最多可以读多少⽐特（bytes）&lt;br&gt;
--device-write-bps：磁盘每秒最多可以写多少⽐特（bytes）&lt;br&gt;
上⾯两个参数的值都是磁盘以及对应的速率，限制 limit 为正整数，单位可以是 kb、mb 和 gb。&lt;/p&gt;
&lt;p&gt;⽐如可以把设备的读速率限制在 1mb：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker run -it --device /dev/sda:/dev/sda --device-read-bps /dev/sda:1mb ubuntu:16.04 bash 
root@6c048edef769# cat /sys/fs/cgroup/blkio/blkio.throttle.read_bps_device 
8:0 1048576
root@6c048edef769# dd iflag=direct,nonblock if=/dev/sda of=/dev/null bs=5M count=10
10+0 records in
10+0 records out
52428800 bytes (52 MB) copied, 50.0154 s, 1.0 MB/s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从磁盘中读取 50m 花费了 50s 左右，说明磁盘速率限制起了作⽤。&lt;/p&gt;
&lt;p&gt;另外两个参数可以限制磁盘读写频率（每秒能执⾏多少次读写操作）：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;--device-read-iops：磁盘每秒最多可以执⾏多少 IO 读操作&lt;br&gt;
--device-write-iops：磁盘每秒最多可以执⾏多少 IO 写操作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上⾯两个参数的值都是磁盘以及对应的 IO 上限。&lt;br&gt;
⽐如，可以让磁盘每秒最多读 100 次：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker run -it --device /dev/sda:/dev/sda --device-read-iops /dev/sda:100 ubuntu:16.04 bash root@2e3026e9ccd2:/[root@Linux 
~]# dd iflag=direct,nonblock if=/dev/sda of=/dev/null bs=1k count=1000
1000+0 records in
1000+0 records out
1024000 bytes (1.0 MB) copied, 9.9159 s, 103 kB/s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从测试中可以看出，容器设置了读操作的 iops 为 100，在容器内部从 block 中读取 1m 数据（每次 1k，⼀共要读 1000 次），共计耗时约 10s，换算起来就是 100 iops/s，符合预期结果。&lt;/p&gt;
&lt;h2 id=&#34;10-端口转发&#34;&gt;10、端⼝转发&lt;/h2&gt;
&lt;p&gt;使⽤端⼝转发解决容器端⼝访问问题&lt;/p&gt;
&lt;h3 id=&#34;101-mysql应用端口转发&#34;&gt;10.1 MySQL应⽤端⼝转发&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;-p&lt;/strong&gt;&lt;br&gt;
创建应⽤容器的时候，⼀般会做端⼝映射，这样是为了让外部能够访问这些容器⾥的应⽤。可以⽤多个-p&lt;strong&gt;指定&lt;/strong&gt;多个端⼝映射关系。&lt;br&gt;
本例使⽤-p把本地3307转发到容器的3306，其他参数需要查看发布容器的⻚⾯提示&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;查看本地地址：
[root@Linux ~]#ip a 
  ens33: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000
  link/ether 00:0c:29:0a:5b:8b brd ff:ff:ff:ff:ff:ff
  inet 192.168.245.134/24 brd 192.168.245.255 scope global dynamic ens33
    valid_lft 1444sec preferred_lft 1444sec

运⾏容器：
[root@Linux ~]# docker run --name mysql1 -p 3307:3306  -e MYSQL_ROOT_PASSWORD=123 daocloud.io/library/mysql

查看Ip地址：
[root@Linux ~]# docker inspect  mysql1 | grep 
IPAddress
      &amp;quot;SecondaryIPAddresses&amp;quot;: null,
      &amp;quot;IPAddress&amp;quot;: &amp;quot;172.17.0.2&amp;quot;,
          &amp;quot;IPAddress&amp;quot;: &amp;quot;172.17.0.2&amp;quot;,
          
通过本地IP：192.168.245.134的3307端⼝访问容器mysql1内的数
据库，出现如下提示恭喜你
[root@Linux ~]# mysql -u root -p123 -h 192.168.245.134 -P3307
Welcome to the MariaDB monitor.  Commands end with ; 
or \g.
Your MySQL connection id is 3
Server version: 5.7.18 MySQL Community Server (GPL)
Copyright (c) 2000, 2016, Oracle, MariaDB 
Corporation Ab and others.
Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.
MySQL [(none)]&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;102-redis应用端口转发&#34;&gt;10.2 Redis应⽤端⼝转发&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;-P&lt;/strong&gt;&lt;br&gt;
Docker 会&lt;strong&gt;随机映射&lt;/strong&gt;⼀个 49000~49900 的端⼝到内部容器开放的⽹络端⼝。如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker images
REPOSITORY      TAG         IMAGE ID       CREATED       SIZE
docker.io/redis   latest        e4a35914679d     2weeks ago     182.9 MB
 
[root@Linux ~]# docker run --name myredis -P -d docker.io/redis
805d0e21e531885aad61d3e82395210b50621f1991ec4b7f9a0e
25c815cc0272

[root@Linux ~]# docker ps
CONTAINER ID     IMAGE        COMMAND          
CREATED       STATUS        PORTS           NAMES
805d0e21e531     docker.io/redis   &amp;quot;docker-
entrypoint.sh&amp;quot;  4 seconds ago    Up 3 seconds     
0.0.0.0:32768-&amp;gt;6379/tcp  myredis
从上⾯的结果中可以看出，本地主机的32768端⼝被映射到了redis容器的6379端⼝上，也就是说访问本机的32768端⼝即可访问容器内redis端⼝。

测试看下，登陆redis容器，随意写个数据
[root@Linux ~]# docker run --rm -it --name myredis2 --link myredis:redisdb docker.io/redis /bin/
bash
root@be44d955d6f4:/data[root@Linux ~]# redis-cli -h redisdb -p 6379
redisdb:6379&amp;gt; set wing 123
OK
redisdb:6379&amp;gt;

在别的机器上通过上⾯映射的端⼝32768连接这个容器的redis
[root@Linux ~]# redis-cli -h 192.168.245.134 -p 32768
192.168.1.23:32768&amp;gt; get wing
&amp;quot;123&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;11-容器卷&#34;&gt;11、容器卷&lt;/h2&gt;
&lt;h3 id=&#34;111-容器卷操作&#34;&gt;11.1 容器卷操作&lt;/h3&gt;
&lt;p&gt;容器卷是容器和宿主机之间的⽂件共享⽅式之⼀&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;新卷只能在容器创建过程当中挂载
[root@Linux ~]# docker run -it --name=&amp;quot;voltest&amp;quot; -v /tmp:/test  daocloud.io/library/centos:5 /bin/bash

共享其他容器的卷：
[root@Linux ~]# docker run -it --volumes-from bc4181  daocloud.io/library/centos:5  /bin/bash

实际应⽤中可以利⽤多个-v选项把宿主机上的多个⽬录同时共享给新建
容器：

⽐如： 
[root@Linux ~]# docker run -it -v /abc:/abc -v /def:/def 1ae9
[root@Linux ~]# docker run  -v /vol/index.html:/usr/share/nginx/html/index.html -it nginx /bin/bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：&lt;br&gt;
如果是⽂件共享，数据不能同步更新&lt;/p&gt;
&lt;h3 id=&#34;112-volume扩展阅读&#34;&gt;11.2 Volume【扩展阅读】&lt;/h3&gt;
&lt;p&gt;容器技术使⽤了 rootfs 机制和 Mount Namespace，构建出了⼀个同宿主机完全隔离开的⽂件系统环境。这时候，就需要考虑这样两个问题：&lt;br&gt;
容器⾥进程新建的⽂件，怎么才能让宿主机获取到？&lt;br&gt;
宿主机上的⽂件和⽬录，怎么才能让容器⾥的进程访问到？&lt;/p&gt;
&lt;p&gt;这正是 Docker Volume 要解决的问题：Volume 机制，允许你将宿主机上指定的⽬录或者⽂件，挂载到容器⾥⾯进⾏读取和修改操作。&lt;br&gt;
在 Docker 项⽬⾥，它⽀持两种 Volume 声明⽅式，可以把宿主机⽬录挂载进容器的 /test ⽬录当中：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker run -v /test ...
[root@Linux ~]# docker run -v /home:/test ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这两种声明⽅式的本质是相同的：都是把⼀个宿主机的⽬录挂载进了容器的 /test ⽬录。&lt;br&gt;
第⼀种情况没有显示声明宿主机⽬录，Docker 就会默认在宿主机上创建⼀个临时⽬录 /var/lib/docker/volumes/[VOLUME_ID]/_data，然后把它挂载到容器的 /test ⽬录上。&lt;br&gt;
第⼆种情况，Docker 就直接把宿主机的 /home ⽬录挂载到容器的 /test ⽬录上。&lt;br&gt;
那么，Docker ⼜是如何做到把⼀个宿主机上的⽬录或者⽂件，挂载到容器⾥⾯去呢？难道⼜是 Mount Namespace 的⿊科技吗？实际上，并不需要这么麻烦。&lt;br&gt;
已经介绍过，当容器进程被创建之后，尽管开启了 MountNamespace，但是在它执⾏ chroot（或者 pivot_root）之前，容器进程⼀直可以看到宿主机上的整个⽂件系统。&lt;br&gt;
⽽宿主机上的⽂件系统，也⾃然包括了要使⽤的容器镜像。这个镜像的各个层，保存在 /var/lib/docker/aufs/diﬀ ⽬录下，在容器进程启动后，它们会被联合挂载在 /var/lib/docker/aufs/mnt/ ⽬录中，这样容器所需的 rootfs 就准备好了。&lt;/p&gt;
&lt;p&gt;所以，只需要在 rootfs 准备好之后，在执⾏ chroot 之前，把Volume 指定的宿主机⽬录（⽐如 /home ⽬录），挂载到指定的容器⽬录（⽐如 /test ⽬录）在宿主机上对应的⽬录（即/var/lib/docker/aufs/mnt/[可读写层 ID]/test）上，这个 Volume 的挂载⼯作就完成了。&lt;br&gt;
由于执⾏这个挂载操作时，&amp;quot;容器进程&amp;quot;已经创建了，也就意味着此时 Mount Namespace 已经开启了。所以，这个挂载事件只在这个容器⾥可⻅。你在宿主机上，是看不⻅容器内部的这个挂载点的。这就保证了容器的隔离性不会被 Volume 打破。&lt;br&gt;
注意：这⾥提到的 &amp;quot; 容器进程 &amp;quot;，是 Docker 创建的⼀个容器初始化进程 (dockerinit)，⽽不是应⽤进程 (ENTRYPOINT + CMD)。dockerinit 会负责完成根⽬录的准备、挂载设备和⽬录、配置hostname 等⼀系列需要在容器内进⾏的初始化操作。最后，它通过execv() 系统调⽤，让应⽤进程取代⾃⼰，成为容器⾥的 PID=1 的进程。&lt;br&gt;
⽽这⾥要使⽤到的挂载技术，就是 Linux 的绑定挂载（bind mount）机制。它的主要作⽤就是，允许你将⼀个⽬录或者⽂件，⽽不是整个设备，挂载到⼀个指定的⽬录上。并且，这时你在该挂载点上进⾏的任何操作，只是发⽣在被挂载的⽬录或者⽂件上，⽽原挂载点的内容则会被隐藏起来且不受影响。&lt;br&gt;
其实，如果你了解 Linux 内核的话，就会明⽩，绑定挂载实际上是⼀个 inode 替换的过程。在 Linux 操作系统中，inode 可以理解为存放⽂件内容的&amp;quot;对象&amp;quot;，⽽ dentry，也叫⽬录项，就是访问这个 inode所使⽤的&amp;quot;指针&amp;quot;&lt;br&gt;
mount --bind /home /test，会将 /home 挂载到 /test 上。其实相当于将 /test 的 dentry，重定向到了 /home 的 inode。这样当修改/test ⽬录时，实际修改的是 /home ⽬录的 inode。这也就是为何，⼀旦执⾏ umount 命令，/test ⽬录原先的内容就会恢复：因为修改真正发⽣在的，是 /home ⽬录⾥。进程在容器⾥对这个 /test ⽬录进⾏的所有操作，都实际发⽣在宿主机的对应⽬录（⽐如，/home，或者/var/lib/docker/volumes/[VOLUME_ID]/_data）⾥，⽽不会影响容器镜像的内容。&lt;br&gt;
这个 /test ⽬录⾥的内容，既然挂载在容器 rootfs 的可读写层，它会不会被 docker commit 提交掉呢？也不会。&lt;br&gt;
原因前⾯提到过。容器的镜像操作，⽐如 docker commit，都是发⽣在宿主机空间的。⽽由于 Mount Namespace 的隔离作⽤，宿主机并不知道这个绑定挂载的存在。所以，在宿主机看来，容器中可读写层的 /test ⽬录（/var/lib/docker/aufs/mnt/[可读写层 ID]/test），始终是空的。&lt;br&gt;
不过，由于 Docker ⼀开始还是要创建 /test 这个⽬录作为挂载点，所以执⾏了 docker commit 之后，新产⽣的镜像⾥，会多出来⼀个空的 /test ⽬录。毕竟，新建⽬录操作，⼜不是挂载操作，MountNamespace 对它可起不到&amp;quot;障眼法&amp;quot;的作⽤。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;1.启动⼀个 helloworld 容器，给它声明⼀个 Volume，挂载在容器⾥的 /test ⽬录上：
[root@Linux ~]# docker run -d -v /test helloworld
cf53b766fa6f

2.容器启动之后，查看⼀下这个 Volume 的 ID：
[root@Linux ~]# docker volume ls
DRIVER        VOLUME NAME
local        
cb1c2f7221fa9b0971cc35f68aa1034824755ac44a034c0c0a1d
d318838d3a6d

3.使⽤这个 ID，可以找到它在 Docker ⼯作⽬录下的 volumes 路径：
[root@Linux ~]# ls /var/lib/docker/volumes/cb1c2f7221fa/_data/
这个 _data ⽂件夹，就是这个容器的 Volume 在宿主机上对应的临时⽬录了。

4.在容器的 Volume ⾥，添加⼀个⽂件 text.txt：
[root@Linux ~]# docker exec -it cf53b766fa6f /bin/sh
cd test/
touch text.txt

5.再回到宿主机，就会发现 text.txt 已经出现在了宿主机上对应的临时⽬录⾥：
[root@Linux ~]# ls /var/lib/docker/volumes/cb1c2f7221fa/_data/
text.txt
可是，如果你在宿主机上查看该容器的可读写层，虽然可以看到这个 /test ⽬录，但其内容是空的：
[root@Linux ~]# ls /var/lib/docker/aufs/mnt/6780d0778b8a/test
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以确认，容器 Volume ⾥的信息，并不会被 docker commit 提交掉；但这个挂载点⽬录 /test 本身，则会出现在新的镜像当中。以上内容，就是 Docker Volume 的核⼼原理了。&lt;br&gt;
&lt;strong&gt;Docker 容器&amp;quot;全景图&amp;quot;：&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200820020548.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;⼀个&amp;quot;容器&amp;quot;，实际上是⼀个由 Linux Namespace、Linux Cgroups和 rootfs 三种技术构建出来的进程的隔离环境。&lt;/p&gt;
&lt;h2 id=&#34;12-优化centos7镜像&#34;&gt;12、优化Centos7镜像&lt;/h2&gt;
&lt;p&gt;镜像下载：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker pull daocloud.io/library/centos:latest
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;包管理:&lt;br&gt;
默认情况下，为了减⼩镜像的尺⼨，在构建 CentOS 镜像时⽤了yum的nodocs选项。 如果您安装⼀个包后发现⽂件缺失，请在/etc/yum.conf中注释掉tsﬂogs=nodocs并重新安装您的包。&lt;br&gt;
systemd 整合:&lt;/p&gt;
&lt;p&gt;因为 systemd 要求 CAPSYSADMIN 权限，从⽽得到了读取到宿主机 cgroup 的能⼒，CentOS7 中已经⽤ fakesystemd 代替了 systemd来解决依赖问题。 如果仍然希望使⽤ systemd，可⽤参考下⾯的Dockerﬁle：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# vim Dockerfile
FROM daocloud.io/library/centos:7
MAINTAINER &amp;quot;wing&amp;quot;  wing@qq.com
ENV container docker
RUN yum -y swap -- remove fakesystemd -- install  
systemd systemd-libs
RUN yum -y update; yum clean all; \
(cd /lib/systemd/system/sysinit.target.wants/; for i 
in *; do [ $i == systemd-tmpfiles-setup.service ] || 
rm -f $i; done); \
rm -f /lib/systemd/system/multi-user.target.wants/*;\
rm -f /etc/systemd/system/*.wants/*;\
rm -f /lib/systemd/system/local-fs.target.wants/*; \
rm -f 
/lib/systemd/system/sockets.target.wants/*udev*; \
rm -f 
/lib/systemd/system/sockets.target.wants/*initctl*; 
\
rm -f /lib/systemd/system/basic.target.wants/*;\
rm -f /lib/systemd/system/anaconda.target.wants/*;
VOLUME [ &amp;quot;/sys/fs/cgroup&amp;quot; ]
CMD [&amp;quot;/usr/sbin/init&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个Dockerﬁle删除fakesystemd 并安装了 systemd。然后再构建基础镜像:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker build --rm -t local/c7- systemd .
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;⼀个包含 systemd 的应⽤容器示例&lt;br&gt;
为了使⽤像上⾯那样包含 systemd 的容器，需要创建⼀个类似下⾯的Dockerﬁle：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# vim Dockerfile
FROM local/c7-systemd
RUN yum -y install httpd; yum clean all; systemctl 
enable httpd.service
EXPOSE 80
CMD [&amp;quot;/usr/sbin/init&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;构建镜像:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker build --rm -t local/c7-systemd-httpd .
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运⾏包含 systemd 的应⽤容器:&lt;br&gt;
为了运⾏⼀个包含 systemd 的容器，需要使⽤--privileged选项，并且挂载主机的 cgroups ⽂件夹。 下⾯是运⾏包含 systemd 的 httpd容器的示例命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker run --privileged -ti -v /sys/fs/cgroup:/sys/fs/cgroup:ro -p 80:80 local/c7-systemd-httpd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：上条命令不能添加/bin/bash，添加了会导致服务不可⽤，⽽且有些服务可能会发现之前提到的权限不够的问题，但是如果不加会运⾏在前台(没有⽤-d)，可以⽤ctrl+p+q放到后台去测试可⽤：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# elinks --dump http://docker    //下⾯为apache默认⻚⾯
                      Testing 123..
  This page is used to test the proper operation of the [1]Apache HTTP
  server after it has been installed. If you can read this page it means
  that this site is working properly. This server is powered by [2]CentOS.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再来个安装openssh-server的例⼦：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# vim Dockerfile
FROM local/c7-systemd
RUN yum -y install openssh-server; yum clean all; 
systemctl enable sshd.service
RUN echo 1 | passwd --stdin root
EXPOSE 22
CMD [&amp;quot;/usr/sbin/init&amp;quot;]

[root@Linux ~]# docker build --rm -t local/c7-systemd-sshd .  
[root@Linux ~]# docker run --privileged -ti -v /sys/fs/cgroup:/sys/fs/cgroup:ro -p 2222:22 local/c7-systemd-sshd  
[root@Linux ~]# ssh docker -p 2222  //docker为我宿主机的主机名称
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;13-docker网络&#34;&gt;13、Docker⽹络&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;容器⽹络&lt;/strong&gt;&lt;br&gt;
注：⾯试⽤，⽤了编排之后就没有⽤了&lt;/p&gt;
&lt;p&gt;Docker安装后，默认会创建三种⽹络类型，bridge、host和none&lt;br&gt;
查看当前⽹络：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker network list
NETWORK  ID      NAME        DRIVER        SCOPE
90b22f633d2f     bridge      bridge        local
e0b365da7fd2     host       host        local
da7b7a090837     none       null         local
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1、bridge:⽹络桥接&lt;br&gt;
默认情况下启动、创建容器都是⽤该模式，所以每次docker容器重启时会按照顺序获取对应ip地址，这就导致容器每次重启，ip都发⽣变化&lt;br&gt;
2、none：⽆指定⽹络&lt;br&gt;
启动容器时，可以通过--network=none,docker容器不会分配局域⽹ip&lt;br&gt;
3、host：主机⽹络&lt;br&gt;
docker容器的⽹络会附属在主机上，两者是互通的。&lt;/p&gt;
&lt;p&gt;使⽤host⽹络创建容器：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker run -it --name testnginx1 --net host 27a18801 /bin/bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4、固定ip（个⼈认为是bridge）:&lt;br&gt;
&lt;strong&gt;创建固定Ip的容器&lt;/strong&gt;&lt;br&gt;
4.1、创建⾃定义⽹络类型，并且指定⽹段&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]#docker network create --subnet=192.168.0.0/16 staticnet
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过docker network ls可以查看到⽹络类型中多了⼀个staticnet&lt;br&gt;
4.2、使⽤新的⽹络类型创建并启动容器&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]#docker run -it --name userserver --net staticnet --ip 192.168.0.2 centos:6 /bin/bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过docker inspect可以查看容器ip为192.168.0.2，关闭容器并重启，发现容器ip并未发⽣改变&lt;br&gt;
不能使⽤默认桥接⽹络，不然会报错&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker run -it --rm --name &amp;quot;test&amp;quot; -v /test/b.txt:/tmp/b.txt -v /tmp:/abc --net bridge --ip 172.17.0.9 1f8fe54 /bin/sh
docker: Error response from daemon: user specified IP address is supported on user defined networks only.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;扩展：异主容器互联&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;路由⽅式&lt;br&gt;
⼩规模docker环境⼤部分运⾏在单台主机上，如果公司⼤规模采⽤docker，那么多个宿主机上的docker如何互联&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200820021231.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;Docker默认的内部ip为172.17.42.0⽹段，所以必须要修改其中⼀台的默认⽹段以免ip冲突。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# vim /etc/sysconfig/docker-network
DOCKER_NETWORK_OPTIONS= --bip=172.18.42.1/16
[root@Linux ~]# reboot 


docker 130上：
[root@Linux ~]# route add -net 172.18.0.0/16 gw 192.168.18.128
docker 128上：
[root@Linux ~]# route add -net 172.17.0.0/16 gw 192.168.18.130
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在两台宿主机⾥的容器就可以通信了。&lt;/p&gt;
&lt;h2 id=&#34;14-docker数据存储位置&#34;&gt;14、Docker数据存储位置&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;查看默认存储位置&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# docker info | grep Root
Docker Root Dir:  /var/lib/docker
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;修改默认存储位置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在dockerd的启动命令后⾯追加--data-root参数指定新的位置&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@Linux ~]# vim /usr/lib/systemd/system/docker.service
ExecStart=/usr/bin/dockerd -H fd:// --
containerd=/run/containerd/containerd.sock --data-
root=/data
[root@Linux ~]# systemctl daemon-reload
[root@Linux ~]# systemctl restart docker
查看是否⽣效：
[root@Linux ~]# docker info | grep Root
Docker Root Dir: /data
&lt;/code&gt;&lt;/pre&gt;
">Docker</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jonchan1013.github.io/post/springmvc/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200804155812.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;1-回顾mvc&#34;&gt;1、回顾MVC&lt;/h2&gt;
&lt;h3 id=&#34;11-什么是mvc&#34;&gt;1.1 什么是MVC?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;MVC是模型（model）,视图（view）,控制器(controller)的简写，是一种软件设计规范&lt;/li&gt;
&lt;li&gt;是将业务逻辑代码，数据，显示分离的方法来组织代码&lt;/li&gt;
&lt;li&gt;MVC主要的作用是&lt;strong&gt;降低了视图与业务逻辑之间的双向耦合&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;MVC不是一种设置模式，MVC是一种架构模式，当然不同的MVC存在差异。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200804160234.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;**Model（模型）：**数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。&lt;/p&gt;
&lt;p&gt;**View（视图）：**负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。&lt;/p&gt;
&lt;p&gt;**Controller（控制器）：**接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。 也就是说控制器做了个调度员的工作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最经典的MVC就是：JSP+Servlet+javabean的模式&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;12-时代划分&#34;&gt;1.2 时代划分&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Model1时代&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在web早期的开发中，通常采用的都是Model1。&lt;/li&gt;
&lt;li&gt;Model1中，主要分为两层，视图层和模型层。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200804160303.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;Model2时代&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Model2把一个项目分成三部分，包括&lt;strong&gt;视图、控制、模型&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200804160310.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;用户发送请求&lt;/li&gt;
&lt;li&gt;Servlet接受请求数据，并调用对应的业务逻辑方法&lt;/li&gt;
&lt;li&gt;业务处理完毕，返回更新后的Servlet&lt;/li&gt;
&lt;li&gt;servlet转向JSP,由JSP来渲染页面&lt;/li&gt;
&lt;li&gt;响应给前端更新后的页面&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;职业分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Controller：控制器&lt;/strong&gt;（Servlet）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;取得表单数据&lt;/li&gt;
&lt;li&gt;调用业务逻辑&lt;/li&gt;
&lt;li&gt;转向指定的页面&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Model：模型&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;业务逻辑&lt;/li&gt;
&lt;li&gt;保存数据的状态&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;View：视图&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;13-总结&#34;&gt;1.3 总结&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Model2这样不仅提高的代码的复用率与项目的扩展性，且大大降低了项目的维护成本。&lt;/li&gt;
&lt;li&gt;Model 1模式的实现比较简单，适用于快速开发小规模项目，Model1中JSP页面身兼View和Controller两种角色，将控制逻辑和表现逻辑混杂在一起，从而导致代码的重用性非常低，增加了应用的扩展性和维护的难度。Model2消除了Model1的缺点&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-hellospringmvc&#34;&gt;2、HelloSpringMVC&lt;/h2&gt;
&lt;h3 id=&#34;21-配置版实现&#34;&gt;2.1 配置版实现&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;新建一个Moudle ， 添加web的支持！&lt;/li&gt;
&lt;li&gt;确定导入了SpringMVC 的依赖！&lt;/li&gt;
&lt;li&gt;配置web.xml ， 注册DispatcherServlet&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;web-app xmlns=&amp;quot;http://xmlns.jcp.org/xml/ns/javaee&amp;quot;
         xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
         xsi:schemaLocation=&amp;quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&amp;quot;
         version=&amp;quot;4.0&amp;quot;&amp;gt;
    
&amp;lt;!--配置DispatchServlet:这个是SpringMVC的核心，请求分发器，前端控制器--&amp;gt;
    
    &amp;lt;servlet&amp;gt;
        &amp;lt;servlet-name&amp;gt;springmvc&amp;lt;/servlet-name&amp;gt;
        &amp;lt;servlet-class&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt;
&amp;lt;!--DispatcherServlet要绑定Spring的配置文件--&amp;gt;
        &amp;lt;init-param&amp;gt;
            &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
            &amp;lt;param-value&amp;gt;classpath:springmvc-servlet.xml&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;
&amp;lt;!--启动级别：初始化启动--&amp;gt;
        &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;
    &amp;lt;/servlet&amp;gt;

&amp;lt;!--在Springmvc中 / 和 /*的区别
/: 只匹配所有的请求，不会匹配JSP页面
/*:匹配所有的请求，包括jsp页面--&amp;gt;
    &amp;lt;servlet-mapping&amp;gt;
        &amp;lt;servlet-name&amp;gt;springmvc&amp;lt;/servlet-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/servlet-mapping&amp;gt;
    
&amp;lt;/web-app&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;
&lt;p&gt;编写SpringMVC 的 配置文件！&lt;/p&gt;
&lt;p&gt;名称：springmvc-servlet.xml : [servletname]-servlet.xml说明，这里的名称要求是按照官方来的&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
      xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
      xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&amp;quot;&amp;gt;

&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;添加处理器映射&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--处理器映射器--&amp;gt;
    &amp;lt;bean class=&amp;quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;添加处理器适配器&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--处理器适配器--&amp;gt;
&amp;lt;bean class=&amp;quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;添加视图解析器&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--视图解析器 以后模板引擎会使用：Thymeleaf Freemarker--&amp;gt;
    &amp;lt;bean class=&amp;quot;org.springframework.web.servlet.view.InternalResourceViewResolver&amp;quot; id=&amp;quot;internalResourceViewResolver&amp;quot;&amp;gt;
&amp;lt;!-- 前缀和后缀--&amp;gt;
        &amp;lt;property name=&amp;quot;prefix&amp;quot; value=&amp;quot;/WEB-INF/JSP/&amp;quot;/&amp;gt;
        &amp;lt;property name=&amp;quot;suffix&amp;quot; value=&amp;quot;.jsp&amp;quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;8&#34;&gt;
&lt;li&gt;编写我们要操作业务的Controller，要么实现Controller接口，要么增加注解；（需要返回一个ModelandView，封装数据，转发视图）&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.zhuuu.Controller;

import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.Controller;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class HelloController implements Controller {
    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {
        
        ModelAndView mv = new ModelAndView();

        //业务代码：封装数据
        String result = &amp;quot;HelloSpringMVC&amp;quot;;
        mv.addObject(&amp;quot;msg&amp;quot;,result);

        //视图跳转
        mv.setViewName(&amp;quot;test&amp;quot;);

        //返回model and view
        return mv;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;9&#34;&gt;
&lt;li&gt;将自己的类交给SpringIOC容器，注册bean&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--BeanNameUrlHandlerMapping:bean--&amp;gt;
    &amp;lt;bean id=&amp;quot;/hello&amp;quot; class=&amp;quot;com.zhuuu.Controller.HelloController&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;10&#34;&gt;
&lt;li&gt;编写需要跳转的页面&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;%@ page contentType=&amp;quot;text/html;charset=UTF-8&amp;quot; language=&amp;quot;java&amp;quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

${msg}

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;11&#34;&gt;
&lt;li&gt;配置Tomcat 启动测试！&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;404error的问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可能遇到的问题：访问出现404，排查步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;查看控制台输出，看一下是不是缺少了什么jar包。&lt;/li&gt;
&lt;li&gt;如果jar包存在，显示无法输出，就在IDEA的项目发布中，添加lib依赖！&lt;/li&gt;
&lt;li&gt;重启Tomcat 即可解决！&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200804161133.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;22-注解版实现&#34;&gt;2.2 注解版实现&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;第一步:新建一个Moudle , 添加web支持！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二步:由于Maven可能存在资源过滤的问题，我们将配置完善&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;build&amp;gt;
    &amp;lt;resources&amp;gt;
        &amp;lt;resource&amp;gt;
            &amp;lt;directory&amp;gt;src/main/java&amp;lt;/directory&amp;gt;
            &amp;lt;includes&amp;gt;
                &amp;lt;include&amp;gt;**/*.properties&amp;lt;/include&amp;gt;
                &amp;lt;include&amp;gt;**/*.xml&amp;lt;/include&amp;gt;
            &amp;lt;/includes&amp;gt;
            &amp;lt;filtering&amp;gt;false&amp;lt;/filtering&amp;gt;
        &amp;lt;/resource&amp;gt;
        &amp;lt;resource&amp;gt;
            &amp;lt;directory&amp;gt;src/main/resources&amp;lt;/directory&amp;gt;
            &amp;lt;includes&amp;gt;
                &amp;lt;include&amp;gt;**/*.properties&amp;lt;/include&amp;gt;
                &amp;lt;include&amp;gt;**/*.xml&amp;lt;/include&amp;gt;
            &amp;lt;/includes&amp;gt;
            &amp;lt;filtering&amp;gt;false&amp;lt;/filtering&amp;gt;
        &amp;lt;/resource&amp;gt;
    &amp;lt;/resources&amp;gt;
&amp;lt;/build&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第三步:在pom.xml文件引入相关的依赖&lt;/strong&gt;：&lt;br&gt;
主要有Spring框架核心库、Spring MVC、servlet , JSTL等。我们在父依赖中已经引入了！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第四步:配置web.xml&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;web-app xmlns=&amp;quot;http://xmlns.jcp.org/xml/ns/javaee&amp;quot;
         xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
         xsi:schemaLocation=&amp;quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&amp;quot;
         version=&amp;quot;4.0&amp;quot;&amp;gt;

    &amp;lt;!--1.注册servlet--&amp;gt;
    &amp;lt;servlet&amp;gt;
        &amp;lt;servlet-name&amp;gt;SpringMVC&amp;lt;/servlet-name&amp;gt;
        &amp;lt;servlet-class&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt;
        &amp;lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&amp;gt;
        &amp;lt;init-param&amp;gt;
            &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
            &amp;lt;param-value&amp;gt;classpath:springmvc-servlet.xml&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;
        &amp;lt;!-- 启动顺序，数字越小，启动越早 --&amp;gt;
        &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;
    &amp;lt;/servlet&amp;gt;

    &amp;lt;!--所有请求都会被springmvc拦截 --&amp;gt;
    &amp;lt;servlet-mapping&amp;gt;
        &amp;lt;servlet-name&amp;gt;SpringMVC&amp;lt;/servlet-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/servlet-mapping&amp;gt;

&amp;lt;/web-app&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第五步:添加Spring MVC配置文件&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;让IOC的注解生效&lt;/li&gt;
&lt;li&gt;静态资源过滤 ：HTML . JS . CSS . 图片 ， 视频 …..&lt;/li&gt;
&lt;li&gt;MVC的注解驱动&lt;/li&gt;
&lt;li&gt;配置视图解析器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在resource目录下添加springmvc-servlet.xml配置文件，配置的形式与Spring容器配置基本类似，为了支持基于注解的IOC，设置了自动扫描包的功能，具体配置信息如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
       xmlns:context=&amp;quot;http://www.springframework.org/schema/context&amp;quot;
       xmlns:mvc=&amp;quot;http://www.springframework.org/schema/mvc&amp;quot;
       xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/mvc
        https://www.springframework.org/schema/mvc/spring-mvc.xsd&amp;quot;&amp;gt;

    &amp;lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&amp;gt;
    &amp;lt;context:component-scan base-package=&amp;quot;com.zhuuu.controller&amp;quot;/&amp;gt;
    &amp;lt;!-- 让Spring MVC不处理静态资源 .css .js .html .mp3 .mp4--&amp;gt;
    &amp;lt;mvc:default-servlet-handler /&amp;gt;
    &amp;lt;!--
    支持mvc注解驱动
        在spring中一般采用@RequestMapping注解来完成映射关系
        要想使@RequestMapping注解生效
        必须向上下文中注册DefaultAnnotationHandlerMapping
        和一个AnnotationMethodHandlerAdapter实例
        这两个实例分别在类级别和方法级别处理。
        而annotation-driven配置帮助我们自动完成上述两个实例的注入。
     --&amp;gt;
    &amp;lt;mvc:annotation-driven /&amp;gt;

    &amp;lt;!-- 视图解析器 --&amp;gt;
    &amp;lt;bean class=&amp;quot;org.springframework.web.servlet.view.InternalResourceViewResolver&amp;quot;
          id=&amp;quot;internalResourceViewResolver&amp;quot;&amp;gt;
        &amp;lt;!-- 前缀 --&amp;gt;
        &amp;lt;property name=&amp;quot;prefix&amp;quot; value=&amp;quot;/WEB-INF/jsp/&amp;quot; /&amp;gt;
        &amp;lt;!-- 后缀 --&amp;gt;
        &amp;lt;property name=&amp;quot;suffix&amp;quot; value=&amp;quot;.jsp&amp;quot; /&amp;gt;
    &amp;lt;/bean&amp;gt;

&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;在视图解析器中我们把所有的视图都存放在/WEB-INF/目录下，这样可以保证视图安全，因为这个目录下的文件，客户端不能直接访问。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第六步:创建Controller&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.zhuuu.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class HelloController{
    @RequestMapping(&amp;quot;/hello&amp;quot;)
    public String hello(Model model){

        //封装数据
        model.addAttribute(&amp;quot;msg&amp;quot;,&amp;quot;hello,Spring MVC annatation&amp;quot;);

        return &amp;quot;hello&amp;quot;; // 会被视图解析器处理
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;@Controller是为了让Spring IOC容器初始化时达到自动扫描的目的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@RequestMapping是为了映射请求路径&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第七步:创建视图层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在WEB-INF/ jsp目录中创建hello.jsp ， 视图可以直接取出并展示从Controller带回的信息；&lt;/p&gt;
&lt;p&gt;可以通过EL表示取出Model中存放的值，或者对象；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;%@ page contentType=&amp;quot;text/html;charset=UTF-8&amp;quot; language=&amp;quot;java&amp;quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

${msg}

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第八步:配置Tomcat运行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OK，运行成功！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意事项:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;**/ 和 /\* 的区别：**
&amp;lt; url-pattern &amp;gt; / &amp;lt;/ url-pattern &amp;gt; 不会匹配到.jsp， 只针对我们编写的请求；
即：.jsp 不会进入spring的 DispatcherServlet类 。
&amp;lt; url-pattern &amp;gt; /* &amp;lt;/ url-pattern &amp;gt; 会匹配 *.jsp，
会出现返回 jsp视图 时再次进入spring的DispatcherServlet 类，导致找不到对应的controller所以报404错。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;23-小结&#34;&gt;2.3 小结&lt;/h3&gt;
&lt;p&gt;实现步骤其实非常简单：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;新建一个web项目&lt;/li&gt;
&lt;li&gt;导入相关jar包&lt;/li&gt;
&lt;li&gt;编写web.xml，注册DispatchterServlet&lt;/li&gt;
&lt;li&gt;编写SpringMVC配置文件&lt;/li&gt;
&lt;li&gt;接下来就要使去创建对应的控制类，controller&lt;/li&gt;
&lt;li&gt;最后完善前端试图和controller之间的对应&lt;/li&gt;
&lt;li&gt;测试运行调试&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;使用springMVC必须配置的三大件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;处理器映射器、处理器适配器、视图解析器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通常，我们只需要&lt;strong&gt;手动配置视图解析器&lt;/strong&gt;，而&lt;strong&gt;处理器映射器&lt;/strong&gt;和&lt;strong&gt;处理器适配器&lt;/strong&gt;只需要开启&lt;strong&gt;注解驱动&lt;/strong&gt;即可，而省去了大段的xml配置&lt;/p&gt;
&lt;h2 id=&#34;3-restful风格&#34;&gt;3、Restful风格&lt;/h2&gt;
&lt;h3 id=&#34;31-概念&#34;&gt;3.1 概念&lt;/h3&gt;
&lt;p&gt;Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。&lt;/p&gt;
&lt;h3 id=&#34;32-功能&#34;&gt;3.2 功能&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;资源：互联网所有的事物都可以被抽象为资源&lt;/li&gt;
&lt;li&gt;资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。&lt;/li&gt;
&lt;li&gt;分别对应 添加、 删除、修改、查询。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;321-传统方式操作资源&#34;&gt;3.2.1 传统方式操作资源&lt;/h4&gt;
&lt;p&gt;通过不同的参数来实现不同的效果！方法单一，post 和 get&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;http://127.0.0.1/item/queryItem.action?id=1 查询,GET&lt;/li&gt;
&lt;li&gt;http://127.0.0.1/item/saveItem.action 新增,POST&lt;/li&gt;
&lt;li&gt;http://127.0.0.1/item/updateItem.action 更新,POST&lt;/li&gt;
&lt;li&gt;http://127.0.0.1/item/deleteItem.action?id=1 删除,GET或POST&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;322-使用restful操作资源&#34;&gt;3.2.2 使用RESTful操作资源&lt;/h4&gt;
&lt;p&gt;可以通过不同的请求方式来实现不同的效果！如下：请求地址一样，但是功能可以不同！&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;http://127.0.0.1/item/1 查询,GET&lt;/li&gt;
&lt;li&gt;http://127.0.0.1/item 新增,POST&lt;/li&gt;
&lt;li&gt;http://127.0.0.1/item 更新,PUT&lt;/li&gt;
&lt;li&gt;http://127.0.0.1/item/1 删除,DELETE&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;学习测试&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在新建一个类 RestFulController&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Controller
public class RestFulController {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;在Spring MVC中可以使用 @PathVariable 注解，让方法参数的值对应绑定到一个URI模板变量上。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Controller
public class RestFulController {

    //映射访问路径
    @RequestMapping(&amp;quot;/commit/{p1}/{p2}&amp;quot;)
    public String index(@PathVariable int p1, @PathVariable int p2, Model model){
        
        int result = p1+p2;
        //Spring MVC会自动实例化一个Model对象用于向视图中传值
        model.addAttribute(&amp;quot;msg&amp;quot;, &amp;quot;结果：&amp;quot;+result);
        //返回视图位置
        return &amp;quot;test&amp;quot;;
    }
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;测试请求查看下&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200804162003.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;思考：使用路径变量的好处？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使得路径变得更加简洁&lt;/li&gt;
&lt;li&gt;获得参数更加方便，框架会自动进行类型转换&lt;/li&gt;
&lt;li&gt;通过路径变量可以约束访问参数，如果类型不一样，则访问不到对应的请求方法，如这里访问是的路径是/commit/1/a，则路径与方法不匹配，而不会是参数转换失败。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200804162028.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;我们来修改下对应的参数类型，再次测试&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//映射访问路径
@RequestMapping(&amp;quot;/commit/{p1}/{p2}&amp;quot;)
public String index(@PathVariable int p1, @PathVariable String p2, Model model){

    String result = p1+p2;
    //Spring MVC会自动实例化一个Model对象用于向视图中传值
    model.addAttribute(&amp;quot;msg&amp;quot;, &amp;quot;结果：&amp;quot;+result);
    //返回视图位置
    return &amp;quot;test&amp;quot;;

}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200804162101.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;使用method属性指定请求类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用于约束请求的类型，可以收窄请求范围。指定请求谓词的类型如GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE等&lt;/p&gt;
&lt;p&gt;Spring MVC 的 @RequestMapping 注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所有的地址栏请求默认都会是 HTTP GET 类型的。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@GetMapping
@PostMapping
@PutMapping
@DeleteMapping
@PatchMapping
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;@GetMapping 是一个组合注解&lt;/p&gt;
&lt;p&gt;它所扮演的是 @RequestMapping(method =RequestMethod.GET) 的一个快捷方式。&lt;/p&gt;
&lt;p&gt;平时使用的会比较多！&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Controller
public class RestfulController  {
    @RequestMapping(value = &amp;quot;/commit/{p1}/{p2}&amp;quot;,method = RequestMethod.GET)
    public String index(@PathVariable int p1 , @PathVariable int p2, Model model){
        int result = p1+p2;
        model.addAttribute(&amp;quot;msg&amp;quot;,&amp;quot;结果&amp;quot;+result);
        return &amp;quot;test&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-结果跳转方式&#34;&gt;3、结果跳转方式&lt;/h2&gt;
">SpringMVC</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jonchan1013.github.io/post/zong-he-xing-b2c-dian-zi-shang-wu-ping-tai-xiang-mu/"" data-c="
          &lt;h2 id=&#34;1-项目介绍&#34;&gt;1、项目介绍&lt;/h2&gt;
&lt;h3 id=&#34;11-电商行业发展&#34;&gt;1.1 电商行业发展&lt;/h3&gt;
&lt;p&gt;商务部统计数据显示，2012 年到 2016 年，我国网络购物用户人数从 2.42 亿人增长至4.67 亿人，增长近一倍。电子商务交易额从 8.1 万亿元增长至 26.1 万亿元，年均增长 34%。其中，网络零售交易额从 1.31 万亿元增长至 5.16 万亿元，年均增长 40%，对社会消费品零售总额增加值的贡献率从 17%增长至 30%。电子商务发展直接和间接带动的就业人数从1500 万人增长至 3700 万人。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;经过多年发展，目前规模较大电子商务平台企业纷纷开始构建生态系统，平台为商家和消费者提供交易、支付、物流等各方面全周期支持与服务，各大平台与平台商家之间依存越来越紧密，阿里系、腾讯系、百度系、京东系等主体均取得了显著规模效益。&lt;/p&gt;
&lt;h3 id=&#34;12-电商行业模式&#34;&gt;1.2 电商行业模式&lt;/h3&gt;
&lt;p&gt;B2B：企业到企业，商家到商家。代表：阿里巴巴。&lt;/p&gt;
&lt;p&gt;B2C：商家到客户。代表：京东、淘宝商城（B2B2C）、天猫网。&lt;/p&gt;
&lt;p&gt;C2C：客户到客户。淘宝集市、闲鱼、转转。&lt;/p&gt;
&lt;p&gt;O2O：线上到线下。&lt;/p&gt;
&lt;h3 id=&#34;13-百战商城介绍&#34;&gt;1.3 百战商城介绍&lt;/h3&gt;
&lt;p&gt;百战商城项目是一个综合性的 B2C 电子商务平台，功能类似于淘宝、京东。用户可以在系统中通过搜索商品、查看商品详情、加入购物车、购买商品并生成订单完成购物操作。&lt;/p&gt;
&lt;p&gt;百战商城共分为两部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;商城后台管理系统&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;主要实现对商品、商品分类、规格参数、CMS 等业务的处理。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;商城前台系统&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;主要提供用户通过访问首页，完成购物流程的处理。&lt;/p&gt;
&lt;h2 id=&#34;2-项目架构介绍&#34;&gt;2、项目架构介绍&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200805102652.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200805102703.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;3-项目技术介绍&#34;&gt;3、 项目技术介绍&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Spring Data&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Spring Data Redis2.1.9.RELEASE&lt;/li&gt;
&lt;li&gt;Spring Data Solr4.0.9.RELEASE&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Spring Boot 2.1.6.RELEASE&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Spring Boot Data Redis 2.1.6.RELEASE&lt;/li&gt;
&lt;li&gt;Spring Boot Data Solr 2.1.6.RELEASE&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Spring Cloud Greenwich.SR2&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Spring Cloud Netflix Eureka&lt;/li&gt;
&lt;li&gt;Spring Cloud Netflix Zuul&lt;/li&gt;
&lt;li&gt;Spring Cloud Netflix Hystrix&lt;/li&gt;
&lt;li&gt;Spring Cloud OpenFeign&lt;/li&gt;
&lt;li&gt;Spring Cloud Config&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TX-LCN 5.0.2.RELEASE&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-搭建项目环境&#34;&gt;4、搭建项目环境&lt;/h2&gt;
&lt;h3 id=&#34;41-创建数据库并导入-sql-文件&#34;&gt;4.1 创建数据库并导入 sql 文件&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200805104424.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;42-创建项目&#34;&gt;4.2  创建项目&lt;/h3&gt;
&lt;h4 id=&#34;421-创建父工程&#34;&gt;4.2.1 创建父工程&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建项目&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200805104518.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 POM 文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot;
         xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
         xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;bz_parent&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;modules&amp;gt;
        &amp;lt;module&amp;gt;common_mapper&amp;lt;/module&amp;gt;
        &amp;lt;module&amp;gt;common_pojo&amp;lt;/module&amp;gt;
    &amp;lt;/modules&amp;gt;
    &amp;lt;packaging&amp;gt;pom&amp;lt;/packaging&amp;gt;

    &amp;lt;!--Spring Boot父工程--&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.1.6.RELEASE&amp;lt;/version&amp;gt;
    &amp;lt;/parent&amp;gt;

    &amp;lt;!-- 自定义属性标签 --&amp;gt;
    &amp;lt;properties&amp;gt;
        &amp;lt;mybatis-version&amp;gt;3.5.1&amp;lt;/mybatis-version&amp;gt;
        &amp;lt;mysql-connector-java-version&amp;gt;5.1.38&amp;lt;/mysql-connector-java-version&amp;gt;
        &amp;lt;druid-version&amp;gt;1.0.9&amp;lt;/druid-version&amp;gt;
        &amp;lt;pagehelper-version&amp;gt;1.2.10&amp;lt;/pagehelper-version&amp;gt;
        &amp;lt;logback-version&amp;gt;5.0&amp;lt;/logback-version&amp;gt;
        &amp;lt;spring-mybats-version&amp;gt;2.0.1&amp;lt;/spring-mybats-version&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;dependencyManagement&amp;gt;
        &amp;lt;dependencies&amp;gt;
            &amp;lt;!--Spring Cloud Platform--&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;Greenwich.SR2&amp;lt;/version&amp;gt;
                &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
                &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt;
            &amp;lt;/dependency&amp;gt;

            &amp;lt;!-- MyBatis --&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${mybatis-version}&amp;lt;/version&amp;gt;
            &amp;lt;/dependency&amp;gt;

            &amp;lt;!-- MySql Driver  --&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${mysql-connector-java-version}&amp;lt;/version&amp;gt;
            &amp;lt;/dependency&amp;gt;

            &amp;lt;!--Alibaba DataBase Connection Pool--&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;druid&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${druid-version}&amp;lt;/version&amp;gt;
            &amp;lt;/dependency&amp;gt;

            &amp;lt;!--PageHelper--&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;com.github.pagehelper&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;pagehelper-spring-boot-starter&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${pagehelper-version}&amp;lt;/version&amp;gt;
            &amp;lt;/dependency&amp;gt;

            &amp;lt;!--MyBatis And Spring Integration Starter--&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${spring-mybats-version}&amp;lt;/version&amp;gt;
            &amp;lt;/dependency&amp;gt;

            &amp;lt;!--Logback--&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;net.logstash.logback&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;logstash-logback-encoder&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${logback-version}&amp;lt;/version&amp;gt;
            &amp;lt;/dependency&amp;gt;

        &amp;lt;/dependencies&amp;gt;
    &amp;lt;/dependencyManagement&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;pluginManagement&amp;gt;
            &amp;lt;!--Spring Boot Maven Plugin--&amp;gt;
            &amp;lt;plugins&amp;gt;
                &amp;lt;plugin&amp;gt;
                    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                    &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;/plugin&amp;gt;
            &amp;lt;/plugins&amp;gt;
        &amp;lt;/pluginManagement&amp;gt;
    &amp;lt;/build&amp;gt;


&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;422-创建-mapper-与-pojo&#34;&gt;4.2.2 创建 Mapper 与 Pojo&lt;/h4&gt;
&lt;p&gt;​	&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200805104706.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;423-使用工具生成-mapper-与-pojo&#34;&gt;4.2.3 使用工具生成 Mapper 与 Pojo&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;generatorSqlmapCustom 工具的使用&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200805104805.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 Mapper 的 POM 文件添加依赖坐标&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;!DOCTYPE generatorConfiguration
  PUBLIC &amp;quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&amp;quot;
  &amp;quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&amp;quot;&amp;gt;

&amp;lt;generatorConfiguration&amp;gt;
	&amp;lt;context id=&amp;quot;testTables&amp;quot; targetRuntime=&amp;quot;MyBatis3&amp;quot;&amp;gt;
		&amp;lt;commentGenerator&amp;gt;
			&amp;lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&amp;gt;
			&amp;lt;property name=&amp;quot;suppressAllComments&amp;quot; value=&amp;quot;true&amp;quot; /&amp;gt;
		&amp;lt;/commentGenerator&amp;gt;
		&amp;lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&amp;gt;
		&amp;lt;jdbcConnection driverClass=&amp;quot;com.mysql.jdbc.Driver&amp;quot;
			connectionURL=&amp;quot;jdbc:mysql://localhost:3306/bz_shop&amp;quot; userId=&amp;quot;root&amp;quot;
			password=&amp;quot;root&amp;quot;&amp;gt;
		&amp;lt;/jdbcConnection&amp;gt;
		&amp;lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和 
			NUMERIC 类型解析为java.math.BigDecimal --&amp;gt;
		&amp;lt;javaTypeResolver&amp;gt;
			&amp;lt;property name=&amp;quot;forceBigDecimals&amp;quot; value=&amp;quot;false&amp;quot; /&amp;gt;
		&amp;lt;/javaTypeResolver&amp;gt;

		&amp;lt;!-- targetProject:生成PO类的位置 --&amp;gt;
		&amp;lt;javaModelGenerator targetPackage=&amp;quot;com.cy.pojo&amp;quot;
			targetProject=&amp;quot;.\src&amp;quot;&amp;gt;
			&amp;lt;!-- enableSubPackages:是否让schema作为包的后缀 --&amp;gt;
			&amp;lt;property name=&amp;quot;enableSubPackages&amp;quot; value=&amp;quot;false&amp;quot; /&amp;gt;
			&amp;lt;!-- 从数据库返回的值被清理前后的空格 --&amp;gt;
			&amp;lt;property name=&amp;quot;trimStrings&amp;quot; value=&amp;quot;true&amp;quot; /&amp;gt;
		&amp;lt;/javaModelGenerator&amp;gt;
        &amp;lt;!-- targetProject:mapper映射文件生成的位置 --&amp;gt;
		&amp;lt;sqlMapGenerator targetPackage=&amp;quot;com.cy.mapper&amp;quot;
			targetProject=&amp;quot;.\src&amp;quot;&amp;gt;
			&amp;lt;!-- enableSubPackages:是否让schema作为包的后缀 --&amp;gt;
			&amp;lt;property name=&amp;quot;enableSubPackages&amp;quot; value=&amp;quot;false&amp;quot; /&amp;gt;
		&amp;lt;/sqlMapGenerator&amp;gt;
		&amp;lt;!-- targetPackage：mapper接口生成的位置 --&amp;gt;
		&amp;lt;javaClientGenerator type=&amp;quot;XMLMAPPER&amp;quot;
			targetPackage=&amp;quot;com.cy.mapper&amp;quot;
			targetProject=&amp;quot;.\src&amp;quot;&amp;gt;
			&amp;lt;!-- enableSubPackages:是否让schema作为包的后缀 --&amp;gt;
			&amp;lt;property name=&amp;quot;enableSubPackages&amp;quot; value=&amp;quot;false&amp;quot; /&amp;gt;
		&amp;lt;/javaClientGenerator&amp;gt;
		&amp;lt;!-- 指定数据库表 --&amp;gt;
		&amp;lt;table schema=&amp;quot;&amp;quot; tableName=&amp;quot;tb_content&amp;quot;&amp;gt;&amp;lt;/table&amp;gt;
		&amp;lt;table schema=&amp;quot;&amp;quot; tableName=&amp;quot;tb_content_category&amp;quot;&amp;gt;&amp;lt;/table&amp;gt;
		&amp;lt;table schema=&amp;quot;&amp;quot; tableName=&amp;quot;tb_item&amp;quot;&amp;gt;&amp;lt;/table&amp;gt;
		&amp;lt;table schema=&amp;quot;&amp;quot; tableName=&amp;quot;tb_item_cat&amp;quot;&amp;gt;&amp;lt;/table&amp;gt;
		&amp;lt;table schema=&amp;quot;&amp;quot; tableName=&amp;quot;tb_item_desc&amp;quot;&amp;gt;&amp;lt;/table&amp;gt;
		&amp;lt;table schema=&amp;quot;&amp;quot; tableName=&amp;quot;tb_item_param&amp;quot;&amp;gt;&amp;lt;/table&amp;gt;
		&amp;lt;table schema=&amp;quot;&amp;quot; tableName=&amp;quot;tb_item_param_item&amp;quot;&amp;gt;&amp;lt;/table&amp;gt;
		&amp;lt;table schema=&amp;quot;&amp;quot; tableName=&amp;quot;tb_order&amp;quot;&amp;gt;&amp;lt;/table&amp;gt;
		&amp;lt;table schema=&amp;quot;&amp;quot; tableName=&amp;quot;tb_order_item&amp;quot;&amp;gt;&amp;lt;/table&amp;gt;
		&amp;lt;table schema=&amp;quot;&amp;quot; tableName=&amp;quot;tb_order_shipping&amp;quot;&amp;gt;&amp;lt;/table&amp;gt;
		&amp;lt;table schema=&amp;quot;&amp;quot; tableName=&amp;quot;tb_user&amp;quot;&amp;gt;&amp;lt;/table&amp;gt;
	&amp;lt;/context&amp;gt;
&amp;lt;/generatorConfiguration&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行GeneratorSqlmap类，并将生成的mapper和pojo拷贝到该项目的mapper和pojo子项目中&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;43-搭建-eureka-注册中心&#34;&gt;4.3 搭建 Eureka 注册中心&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;搭建 Eureka 注册中心&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200805114120.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 POM 文件添加依赖&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot;
         xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
         xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;artifactId&amp;gt;bz_parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
        &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;/parent&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;artifactId&amp;gt;common_eureka&amp;lt;/artifactId&amp;gt;

    &amp;lt;dependencies&amp;gt;
    &amp;lt;!--Spring Boot Web Starter--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!--Spring Cloud Eureka Server Starter--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-server&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

        &amp;lt;build&amp;gt;
        &amp;lt;!--Spring Boot Maven Plugin 必须有这个，否则打包的时候不会将springboot依赖的包打包进来--&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建配置文件，添加配置&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;spring:
  application:
    name: eureka-server

server:
  port: 8761

# 关闭注册
eureka:
  client:
    register-with-eureka: false
    fetch-registry: false

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建启动类，添加相关注解&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

/**
 * eureka 注册中心
 */
@SpringBootApplication
@EnableEurekaServer
public class EurekaServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(EurekaServerApplication.class, args);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将 Eureka 注册中心部署到 Linux 环境中&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安装 lrzsz 上传下载工具&lt;br&gt;
安装命令：yum install lrzsz -y&lt;/p&gt;
&lt;p&gt;上传命令：rz&lt;/p&gt;
&lt;p&gt;下载命令：sz&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;上传注册中心 jar&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200805153124.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;上传启动脚本文件(server.sh)&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200805153142.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建 common_utils 项目(工具集)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建项目&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200805153224.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;添加常用工具类&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200805153252.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 POM 文件添加依赖&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot;
         xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
         xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;artifactId&amp;gt;bz_parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
        &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;/parent&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;artifactId&amp;gt;common_utils&amp;lt;/artifactId&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;!--Spring Boot Web Starter--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.httpcomponents&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;httpclient&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;4.5.2&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;commons-net&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;commons-net&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;3.6&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;5-开发百战商城后台系统&#34;&gt;5、开发百战商城后台系统&lt;/h2&gt;
&lt;h3 id=&#34;51-百战商城服务设计&#34;&gt;5.1 百战商城服务设计&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200805162958.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;52-创建-common_item-服务&#34;&gt;5.2  创建 common_item 服务&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建项目&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200805163028.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 POM 文件添加依赖坐标&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot;
         xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
         xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;artifactId&amp;gt;bz_parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
        &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;/parent&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;artifactId&amp;gt;common_item&amp;lt;/artifactId&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;!--mapper--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;common_mapper&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--utils--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;common_utils&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!--Spring Boot Web Starter--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--Spring Cloud Eureka Client Starter--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建配置文件，添加相关配置&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;spring:
  application:
    name: common-item
  datasource:
    driverClassName: com.mysql.jdbc.Driver
    url: jdbc:mysql://localhost:3306/db_shop?characterEncoding=UTF-8
    username: root
    password: root
    type: com.alibaba.druid.pool.DruidDataSource

server:
  port: 9010

eureka:
  client:
    serviceUrl:
      defaultZone: http://eureka-server:8761/eureka/
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 common_mapper 项目的 POM 文件，添加资源拷贝&lt;br&gt;
插件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;    &amp;lt;build&amp;gt;
    &amp;lt;resources&amp;gt;
        &amp;lt;resource&amp;gt;
            &amp;lt;directory&amp;gt;src/main/java&amp;lt;/directory&amp;gt;
            &amp;lt;includes&amp;gt;
                &amp;lt;include&amp;gt;**/*.xml&amp;lt;/include&amp;gt;
            &amp;lt;/includes&amp;gt;
        &amp;lt;/resource&amp;gt;
        &amp;lt;resource&amp;gt;
            &amp;lt;directory&amp;gt;src/main/resources&amp;lt;/directory&amp;gt;
            &amp;lt;includes&amp;gt;
                &amp;lt;include&amp;gt;**/*.xml&amp;lt;/include&amp;gt;
            &amp;lt;/includes&amp;gt;
        &amp;lt;/resource&amp;gt;
    &amp;lt;/resources&amp;gt;
&amp;lt;/build&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建启动类，添加相关注解&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 通用common_item
 */
@SpringBootApplication
@EnableDiscoveryClient
@MapperScan(&amp;quot;com.cy.mapper&amp;quot;)
public class CommonItemApplication {
    public static void main(String[] args) {
        SpringApplication.run(CommonItemApplication.class, args);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 Host 文件添加注册中心域名与 IP 的映射&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200805173808.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动测试&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200805173854.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;53-创建-backend_item-服务&#34;&gt;5.3 创建 backend_item 服务&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建项目&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200805172041.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 POM 文件添加依赖坐标&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot;
         xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
         xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;artifactId&amp;gt;bz_parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
        &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;/parent&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;artifactId&amp;gt;backend_item&amp;lt;/artifactId&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;!--pojo--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;common_pojo&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!--utils--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;common_utils&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!--Spring Boot Web Starter--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--Spring Cloud Eureka Client Starter--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--Spring Cloud OpenFeign Starter--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-openfeign&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建配置文件，添加相关配置&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;spring:
  application:
    name: backend-item

server:
  port: 9011

eureka:
  client:
    serviceUrl:
      defaultZone: http://eureka-server:8761/eureka/
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建启动类，添加相关注解&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * BackendItem 服务
 */
@SpringBootApplication
@EnableDiscoveryClient
@EnableFeignClients
public class BackendItemApplication {
    public static void main(String[] args) {
        SpringApplication.run(BackendItemApplication.class, args);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动测试&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200805174108.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;54-开发商品管理接口&#34;&gt;5.4 开发商品管理接口&lt;/h3&gt;
&lt;h4 id=&#34;541-实现查询商品接口&#34;&gt;5.4.1 实现查询商品接口&lt;/h4&gt;
&lt;h5 id=&#34;5411-在-common_item-服务中实现查询商品&#34;&gt;5.4.1.1 在 common_item 服务中实现查询商品&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在 common_utils 项目中添加 PageResult 模型&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 分页模型
 */
public class PageResult implements Serializable {
    private Integer pageIndex; //当前页
    private Integer totalIndex; //总页数
    private List result; //结果集

    public Integer getPageIndex() {
        return pageIndex;
    }

    public void setPageIndex(Integer pageIndex) {
        this.pageIndex = pageIndex;
    }

    public Integer getTotalIndex() {
        return totalIndex;
    }

    public void setTotalIndex(Integer totalIndex) {
        this.totalIndex = totalIndex;
    }

    public List getResult() {
        return result;
    }

    public void setResult(List result) {
        this.result = result;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建 controller&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@RequestMapping(&amp;quot;/service/item&amp;quot;)
public class ItemController {

    @Autowired
    private ItemService itemService;

    /**
     * 查询商品数据
     */
    @RequestMapping(value = &amp;quot;/selectTbItemAllByPage&amp;quot;,method = RequestMethod.GET)
    public PageResult selectTbItemAllByPage(@RequestParam Integer page, @RequestParam Integer rows) {
        return this.itemService.selectTbItemAllByPage(page,rows);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建 service&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface ItemService {
    PageResult selectTbItemAllByPage(Integer page,Integer rows);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建 serviceImpl&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
public class ItemServiceImpl implements ItemService {

    @Autowired
    private TbItemMapper tbItemMapper;

    /**
     * 查询所有商品并分页
     * @param page
     * @param rows
     * @return
     */
    @Override
    public PageResult selectTbItemAllByPage(Integer page, Integer rows) {
        PageHelper.startPage(page, rows);
        //查询条件
        TbItemExample tbItemExample = new TbItemExample();
        TbItemExample.Criteria criteria = tbItemExample.createCriteria();
        criteria.andStatusEqualTo((byte) 1);
        List&amp;lt;TbItem&amp;gt; list = this.tbItemMapper.selectByExample(tbItemExample);
        //分页处理
        PageInfo&amp;lt;TbItem&amp;gt; pageInfo = new PageInfo&amp;lt;&amp;gt;(list);
        PageResult pageResult = new PageResult();
        pageResult.setPageIndex(page);
        pageResult.setTotalIndex((int) pageInfo.getTotal());
        pageResult.setResult(list);
        return pageResult;
    }


}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;5412-在-backend_item-服务中实现商品查询&#34;&gt;5.4.1.2 在 backend_item 服务中实现商品查询&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建 controller&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@RequestMapping(&amp;quot;/backend/item&amp;quot;)
public class ItemController {

    @Autowired
    private ItemService itemService;

    /**
     * 查询商品并分页处理
     * @param page
     * @param rows
     * @return
     */
    @RequestMapping(&amp;quot;/selectTbItemAllByPage&amp;quot;)
    public Result selectTbItemAllByPage(@RequestParam(defaultValue = &amp;quot;1&amp;quot;)Integer page,@RequestParam(defaultValue = &amp;quot;2&amp;quot;)Integer rows){

        try {
            return this.itemService.selectTbItemAllByPage(page,rows);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return Result.build(500, &amp;quot;查无结果&amp;quot;);
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建 service&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface ItemService {
    Result selectTbItemAllByPage(Integer page,Integer rows);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建 serviceImpl&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 商品管理
 */
@Service
public class ItemServiceImpl implements ItemService {

    @Autowired
    private CommonItemFeignClient commonItemFeignClient;

    @Override
    public Result selectTbItemAllByPage(Integer page, Integer rows) {
        PageResult pageResult = this.commonItemFeignClient.selectTbItemAllByPage(page, rows);
        if (pageResult != null &amp;amp;&amp;amp; pageResult.getResult() != null &amp;amp;&amp;amp; pageResult.getResult().size() &amp;gt;0){
            return Result.ok(pageResult);
        }
            return Result.error(&amp;quot;查无结果&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建 feignClient&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@FeignClient(value = &amp;quot;common-item&amp;quot;)
public interface CommonItemFeignClient {
    //------------/service/item
    @GetMapping(&amp;quot;/service/item/selectTbItemAllByPage&amp;quot;)
    PageResult selectTbItemAllByPage(@RequestParam(&amp;quot;page&amp;quot;) Integer page, @RequestParam(&amp;quot;rows&amp;quot;) Integer rows);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;测试&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200814205736.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;542-实现添加商品接口&#34;&gt;5.4.2 实现添加商品接口&lt;/h4&gt;
&lt;h5 id=&#34;5421-在-common_item-服务中实现商品分类查询&#34;&gt;5.4.2.1  在 common_item 服务中实现商品分类查询&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建 controller&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 商品类目
 */
@RestController
@RequestMapping(&amp;quot;/service/itemCategory&amp;quot;)
public class ItemCategoryController {

    @Autowired
    private ItemCategoryService itemCategoryService;
    /**
     * 根据分类ID查询子节点
     * @param id
     * @return
     */
    @RequestMapping(&amp;quot;/selectItemCategoryByParentId&amp;quot;)
    public List&amp;lt;TbItemCat&amp;gt; selectItemCategoryByParentId(@RequestParam Long id){
        return this.itemCategoryService.selectItemCategoryByParentId(id);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建 service&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface ItemCategoryService {
    List&amp;lt;TbItemCat&amp;gt; selectItemCategoryByParentId(Long id);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建 serviceImpl&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 商品分类查询
 */
@Service
public class ItemCategoryServiceImpl implements ItemCategoryService {

    @Autowired
    private TbItemCatMapper tbItemCatMapper;

    /**
     * 根据分类ID查询子节点
     * @param id
     * @return
     */
    @Override
    public List&amp;lt;TbItemCat&amp;gt; selectItemCategoryByParentId(Long id) {
        TbItemCatExample tbItemCatExample = new TbItemCatExample();
        TbItemCatExample.Criteria criteria = tbItemCatExample.createCriteria();
        criteria.andParentIdEqualTo(id);
        criteria.andStatusEqualTo(1);
        List&amp;lt;TbItemCat&amp;gt; list = this.tbItemCatMapper.selectByExample(tbItemCatExample);
        return list;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;5422-在-backend_item-服务中实现商品分类查询&#34;&gt;5.4.2.2 在 backend_item 服务中实现商品分类查询&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建 controller&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 商品类目Controller
 */
@RestController
@RequestMapping(&amp;quot;/backend/itemCategory&amp;quot;)
public class ItemCategoryController {

    @Autowired
    private ItemCategorySerivce itemCategorySerivce;
    /**
     * 根据类目ID查询当前类目子节点
     * @param id
     * @return
     */
    @RequestMapping(&amp;quot;selectItemCategoryByParentId&amp;quot;)
    public Result selectItemCategoryByParentId(@RequestParam(value = &amp;quot;id&amp;quot;,defaultValue = &amp;quot;0&amp;quot;)Long id){
        try {
            return this.itemCategorySerivce.selectItemCategoryByParentId(id);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return Result.build(500, &amp;quot;查无结果&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建Service&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface ItemCategorySerivce {
    Result selectItemCategoryByParentId(Long id);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建 serviceImpl&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 商品类目Service
 */
@Service
public class ItemCategoryServiceImpl implements ItemCategorySerivce {

    @Autowired
    private CommonItemFeignClient commonItemFeignClient;

    /**
     * 根据类目ID查询当前类目子节点
     *
     * @param id
     * @return
     */
    @Override
    public Result selectItemCategoryByParentId(Long id) {
        List&amp;lt;TbItemCat&amp;gt; list = this.commonItemFeignClient.selectItemCategoryByParentId(id);
        if (list != null &amp;amp;&amp;amp; list.size() &amp;gt; 0) {
            return Result.ok(list);
        }
        return Result.error(&amp;quot;查无结果&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 feignClient&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//-----------/service/itemCategory
@PostMapping(&amp;quot;/service/itemCategory/selectItemCategoryByParentId&amp;quot;)
List&amp;lt;TbItemCat&amp;gt; selectItemCategoryByParentId(@RequestParam(&amp;quot;id&amp;quot;) Long id);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200814211102.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;5423-在-common_item-服务中实现规格参数模板查询&#34;&gt;5.4.2.3 在 common_item 服务中实现规格参数模板查询&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建 controller&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * ItemParam
 */
@RestController
@RequestMapping(&amp;quot;/service/itemParam&amp;quot;)
public class ItemParamController {

    @Autowired
    private ItemParamService itemParamService;

    /**
     * 根据商品分类ID查询规格参数模板
     */
    @RequestMapping(&amp;quot;/selectItemParamByItemCatId&amp;quot;)
    public TbItemParam selectItemParamByItemCatId(@RequestParam Long itemCatId){
        return itemParamService.selectItemParamByItemCatId(itemCatId);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建 service&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface ItemParamService {
    TbItemParam selectItemParamByItemCatId(Long itemCatId);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建 serviceImpl&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * ItemParamService
 */
@Service
public class ItemParamServiceImpl implements ItemParamService {

    @Autowired
    private TbItemParamMapper tbItemParamMapper;

    @Override
    public TbItemParam selectItemParamByItemCatId(Long itemCatId) {
        TbItemParamExample tbItemParamExample = new TbItemParamExample();
        TbItemParamExample.Criteria criteria = tbItemParamExample.createCriteria();
        criteria.andItemCatIdEqualTo(itemCatId);
        //如需检索的字段中包含大字段类型时，必须用selectByExampleWithBLOBs，不检索大字段时，用selectByExample就足够了
        List&amp;lt;TbItemParam&amp;gt; list = tbItemParamMapper.selectByExampleWithBLOBs(tbItemParamExample);
        if (list != null &amp;amp;&amp;amp; list.size() &amp;gt; 0) {
            return list.get(0);
        }
        return null;
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;5424-在-backend_item-服务中实现规格参数模板查询&#34;&gt;5.4.2.4  在 backend_item 服务中实现规格参数模板查询&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * ItemParam
 */
@RestController
@RequestMapping(&amp;quot;/backend/itemParam&amp;quot;)
public class ItemParamController {

    @Autowired
    private ItemParamService itemParamService;
    /**
     * 根据商品类目ID查询规格参数模板
     */
    @RequestMapping(&amp;quot;/selectItemParamByItemCatId/{itemCatId}&amp;quot;)
    public Result selectItemParamByItemCatId(@PathVariable(&amp;quot;itemCatId&amp;quot;) Long itemCatId){
        try {
            return this.itemParamService.selectItemParamByItemCatId(itemCatId);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return Result.build(500, &amp;quot;查无结果&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建 service&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface ItemParamService {
    Result selectItemParamByItemCatId(Long itemCatId);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建 serviceImpl&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * ItemParamService
 */
@Service
public class ItemParamServiceImpl implements ItemParamService {

    @Autowired
    private CommonItemFeignClient commonItemFeignClient;

    /**
     * 根据商品类目Id查询规格参数模板
     */
    @Override
    public Result selectItemParamByItemCatId(Long itemCatId) {
        TbItemParam tbItemParam = this.commonItemFeignClient.selectItemParamByItemCatId(itemCatId);
        if (tbItemParam != null) {
            return Result.ok(tbItemParam);
        }
        return Result.error(&amp;quot;查无结果&amp;quot;);
    }

}

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 feignClient&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * @author cy
 * @date 2020-08-10 14:22
 */
@FeignClient(value = &amp;quot;common-item&amp;quot;)
public interface CommonItemFeignClient {
    //------------/service/item
    @GetMapping(&amp;quot;/service/item/selectTbItemAllByPage&amp;quot;)
    PageResult selectTbItemAllByPage(@RequestParam(&amp;quot;page&amp;quot;) Integer page, @RequestParam(&amp;quot;rows&amp;quot;) Integer rows);
    
    //-----------/service/itemCategory
    @PostMapping(&amp;quot;/service/itemCategory/selectItemCategoryByParentId&amp;quot;)
    List&amp;lt;TbItemCat&amp;gt; selectItemCategoryByParentId(@RequestParam(&amp;quot;id&amp;quot;) Long id);

    //-----------/service/itemParam
    @PostMapping(&amp;quot;/service/itemParam/selectItemParamByItemCatId&amp;quot;)
    TbItemParam selectItemParamByItemCatId(@RequestParam(&amp;quot;itemCatId&amp;quot;) Long itemCatId);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;5425-在-backend_item-服务中处理图片上传&#34;&gt;5.4.2.5 在 backend_item 服务中处理图片上传&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;添加 FtpUtil 工具类&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200814211638.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建 controller&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 图片上传Controller
 */
@RestController
@RequestMapping(&amp;quot;/file&amp;quot;)
public class FileUploadController {

    @Autowired
    private FileUploadService fileUploadService;

    /**
     * 图片上传
     *
     * @param file
     * @return
     */
    @RequestMapping(&amp;quot;/upload&amp;quot;)
    public Result fileUpload(MultipartFile file) {
        try {
            return this.fileUploadService.fileUpload(file);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return Result.build(500, &amp;quot;error&amp;quot;);

    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建 service&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface FileUploadService {
    Result fileUpload(MultipartFile file);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建 serviceImpl&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 图片上传Service
 */
@Service
public class FileUploadServiceImpl implements FileUploadService {

    /*FTP_HOST: 192.168.92.129
    FTP_PORT: 21
    FTP_USERNAME: ftpuser
    FTP_PASSWORD: ftpuser
    FTP_BASEPATH: /usr/local/ftp/ftpuser*/
    @Value(&amp;quot;${FTP_HOST}&amp;quot;)
    private String FTP_HOST;

    @Value(&amp;quot;${FTP_PORT}&amp;quot;)
    private int FTP_PORT;

    @Value(&amp;quot;${FTP_USERNAME}&amp;quot;)
    private String FTP_USERNAME;

    @Value(&amp;quot;${FTP_PASSWORD}&amp;quot;)
    private String FTP_PASSWORD;

    @Value(&amp;quot;${FTP_BASEPATH}&amp;quot;)
    private String FTP_BASEPATH;

    @Override
    public Result fileUpload(MultipartFile file) {
        try {
            //定义上传图片的目录结构
            SimpleDateFormat sd = new SimpleDateFormat(&amp;quot;/yyyy/MM/dd/&amp;quot;);
            String path = sd.format(new Date());

            //设置新的文件名
            String newFileName = IDUtils.genImageName() + file.getOriginalFilename().substring(file.getOriginalFilename().lastIndexOf(&amp;quot;.&amp;quot;));
            FtpUtil.uploadFile(this.FTP_HOST, this.FTP_PORT, this.FTP_USERNAME, this.FTP_PASSWORD, this.FTP_BASEPATH, path, newFileName, file.getInputStream());
            String imageURL = &amp;quot;http://&amp;quot; + this.FTP_HOST + path + newFileName;
            return Result.ok(imageURL);
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在配置文件中添相关配置&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;FTP_HOST: 192.168.92.129
FTP_PORT: 21
FTP_USERNAME: ftpuser
FTP_PASSWORD: ftpuser
FTP_BASEPATH: /usr/local/ftp/ftpuser
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;5426-在-common_item-服务中实现商品添加&#34;&gt;5.4.2.6 在 common_item 服务中实现商品添加&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;修改 controller&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@RequestMapping(&amp;quot;/service/item&amp;quot;)
public class ItemController {

    @Autowired
    private ItemService itemService;

    /**
     * 查询商品数据
     */
    @RequestMapping(value = &amp;quot;/selectTbItemAllByPage&amp;quot;,method = RequestMethod.GET)
    public PageResult selectTbItemAllByPage(@RequestParam Integer page, @RequestParam Integer rows) {
        return this.itemService.selectTbItemAllByPage(page,rows);
    }

    /**
     * 商品的增加
     */
    @RequestMapping(&amp;quot;/insertTbItem&amp;quot;)
    public Integer insertTbItem(@RequestBody TbItem tbItem){
        return this.itemService.insertTbItem(tbItem);
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 service&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface ItemService {
    PageResult selectTbItemAllByPage(Integer page,Integer rows);
    Integer insertTbItem(TbItem tbItem);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 serviceImpl&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
public class ItemServiceImpl implements ItemService {

    @Autowired
    private TbItemMapper tbItemMapper;

    /**
     * 查询所有商品并分页
     * @param page
     * @param rows
     * @return
     */
    @Override
    public PageResult selectTbItemAllByPage(Integer page, Integer rows) {
        PageHelper.startPage(page, rows);
        //查询条件
        TbItemExample tbItemExample = new TbItemExample();
        TbItemExample.Criteria criteria = tbItemExample.createCriteria();
        criteria.andStatusEqualTo((byte) 1);
        List&amp;lt;TbItem&amp;gt; list = this.tbItemMapper.selectByExample(tbItemExample);
        //分页处理
        PageInfo&amp;lt;TbItem&amp;gt; pageInfo = new PageInfo&amp;lt;&amp;gt;(list);
        PageResult pageResult = new PageResult();
        pageResult.setPageIndex(page);
        pageResult.setTotalIndex((int) pageInfo.getTotal());
        pageResult.setResult(list);
        return pageResult;
    }

    /**
     * 商品的增加
     */
    @Override
    public Integer insertTbItem(TbItem tbItem) {
        return this.tbItemMapper.insert(tbItem);
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;5427-在-common_item-服务中实现添加商品描述&#34;&gt;5.4.2.7  在 common_item 服务中实现添加商品描述&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建 controller&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * itemDescController
 */
@RestController
@RequestMapping(&amp;quot;/service/itemDesc&amp;quot;)
public class ItemDescController {

    @Autowired
    private ItemDescService itemDescService;

    /**
     * 添加商品描述
     */
    @RequestMapping(&amp;quot;/insertItemDesc&amp;quot;)
    public Integer insertItemDesc(@RequestBody TbItemDesc tbItemDesc){
        return itemDescService.insertItemDesc(tbItemDesc);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建 service&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface ItemDescService {
    Integer insertItemDesc(TbItemDesc tbItemDesc);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建serviceImpl&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
public class ItemDescServiceImpl implements ItemDescService {
    @Autowired
    private TbItemDescMapper tbItemDescMapper;

    /**
     * 添加商品描述
     * @param tbItemDesc
     * @return
     */
    @Override
    public Integer insertItemDesc(TbItemDesc tbItemDesc) {
        return this.tbItemDescMapper.insert(tbItemDesc);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;5428-在-common_item-服务中实现商品规格参数的添加&#34;&gt;5.4.2.8 在 common_item 服务中实现商品规格参数的添加&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建 controller&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@RequestMapping(&amp;quot;/service/itemParamItem&amp;quot;)
public class ItemParamItemController {

    @Autowired
    private ItemParamItemService itemParamItemService;
    /**
     * 添加商品规格参数
     */
    @RequestMapping(&amp;quot;/insertTbItemParamItem&amp;quot;)
    public Integer insertTbItemParamItem(@RequestBody TbItemParamItem tbItemParamItem) {
        return this.itemParamItemService.insertItemParamItem(tbItemParamItem);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建 service&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface ItemParamItemService {
    Integer insertItemParamItem(TbItemParamItem tbItemParamItem);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建 serviceImpl&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
public class ItemParamItemServiceImpl implements ItemParamItemService {

    @Autowired
    private TbItemParamItemMapper tbItemParamItemMapper;
    /**
     * 添加商品规格参数
     * @param tbItemParamItem
     * @return
     */
    @Override
    public Integer insertItemParamItem(TbItemParamItem tbItemParamItem) {
        return this.tbItemParamItemMapper.insert(tbItemParamItem);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;5429-在-backend_item-服务中实现商品添加&#34;&gt;5.4.2.9  在 backend_item 服务中实现商品添加&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;修改前台代码注释掉商品规格参数&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;18&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200815010329.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 controller&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@RequestMapping(&amp;quot;/backend/item&amp;quot;)
public class ItemController {

    @Autowired
    private ItemService itemService;

    /**
     * 查询商品并分页处理
     * @param page
     * @param rows
     * @return
     */
    @RequestMapping(&amp;quot;/selectTbItemAllByPage&amp;quot;)
    public Result selectTbItemAllByPage(@RequestParam(defaultValue = &amp;quot;1&amp;quot;)Integer page,@RequestParam(defaultValue = &amp;quot;2&amp;quot;)Integer rows){

        try {
            return this.itemService.selectTbItemAllByPage(page,rows);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return Result.build(500, &amp;quot;查无结果&amp;quot;);
    }

    /**
     * 商品添加
     * @param tbItem
     * @param desc
     * @param itemParams
     * @return
     */
    @RequestMapping(&amp;quot;/insertTbItem&amp;quot;)
    public Result insertTbItem(TbItem tbItem,String desc,String itemParams){
        try {
            return this.itemService.insertTbItem(tbItem, desc, itemParams);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return Result.build(500, &amp;quot;查无结果&amp;quot;);
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 service&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface ItemService {
    Result selectTbItemAllByPage(Integer page,Integer rows);
    Result insertTbItem(TbItem tbItem, String desc, String itemParams);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 serviceImpl&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 商品管理
 */
@Service
public class ItemServiceImpl implements ItemService {

    @Autowired
    private CommonItemFeignClient commonItemFeignClient;

    @Override
    public Result selectTbItemAllByPage(Integer page, Integer rows) {
        PageResult pageResult = this.commonItemFeignClient.selectTbItemAllByPage(page, rows);
        if (pageResult != null &amp;amp;&amp;amp; pageResult.getResult() != null &amp;amp;&amp;amp; pageResult.getResult().size() &amp;gt;0){
            return Result.ok(pageResult);
        }
            return Result.error(&amp;quot;查无结果&amp;quot;);
    }

    /**
     * 添加TbItem，添加TbitemDesc，添加TbItemParamItem
     * @param tbItem
     * @param desc
     * @param itemParams
     * @return
     */
    @Override
    public Result insertTbItem(TbItem tbItem, String desc, String itemParams) {
        //补齐 Tbitem 数据
        Date date = new Date();
        long itemId = IDUtils.genItemId();
        tbItem.setId(itemId);
        tbItem.setStatus((byte) 1);
        tbItem.setCreated(date);
        tbItem.setUpdated(date);
        Integer tbItemNum = this.commonItemFeignClient.insertTbItem(tbItem);

        //补齐商品描述对象
        TbItemDesc tbItemDesc = new TbItemDesc();
        tbItemDesc.setItemId(itemId);
        tbItemDesc.setItemDesc(desc);
        tbItemDesc.setCreated(date);
        tbItemDesc.setUpdated(date);
        Integer itemDescNum = this.commonItemFeignClient.insertItemDesc(tbItemDesc);

        //补齐商品规格参数
        TbItemParamItem tbItemParamItem = new TbItemParamItem();
        tbItemParamItem.setItemId(itemId);
        tbItemParamItem.setParamData(itemParams);
        tbItemParamItem.setCreated(date);
        tbItemParamItem.setUpdated(date);
        Integer itemParamItemNum = this.commonItemFeignClient.insertTbItemParamItem(tbItemParamItem);

        return Result.ok();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;54210-添加分布式事务-tx-lcn&#34;&gt;5.4.2.10  添加分布式事务 TX-LCN&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;搭建 TX-LCN 服务端&lt;/p&gt;
&lt;p&gt;注意：在 Spring Boot2.x 版本中要求 TX-LCN 必须是 5.0 以上&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;向数据库中导入 SQL 文件&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;19&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200825134700.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;20&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200825134719.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 application.properties 文件&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;21&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200825134806.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置 TX-managerID.Tx 的服务端在哪个环境上运行就配置那个环境的 IP&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;22&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200825134904.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置 Redis 地址&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;23&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200825140328.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将 TX 服务端上传到 Linux 中&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;24&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200825140404.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过 server.sh 启动脚本启动服务端&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;25&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200825140404.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;访问管理页面&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;26&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200825140451.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;54211创建-tx-lcn-客户端&#34;&gt;5.4.2.11创建 TX-LCN 客户端&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建 TX-LCN 客户端项目&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;27&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200825143407.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 POM 文件添加依赖&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot;
         xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
         xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;artifactId&amp;gt;bz_parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
        &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;/parent&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;artifactId&amp;gt;common_tx_manager_client&amp;lt;/artifactId&amp;gt;

    &amp;lt;dependencies&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.codingapi.txlcn&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;txlcn-tc&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;5.0.2.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.codingapi.txlcn&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;txlcn-txmsg-netty&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;5.0.2.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;54212-在服务中使用-tx-lcn-做分布式事务处理&#34;&gt;5.4.2.12 在服务中使用 TX-LCN 做分布式事务处理&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在 common_item 服务中添加 TX-LCN&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;common_tx_manager_client&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改配置文件，添加 TX-LCN 服务端地址&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;tx-lcn:
	client:
		manager-address: 124.70.181.124:8070
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改启动类，开启 TX-LCN&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@EnableDistributedTransaction
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	在方法上添加分布式事务处理注解&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@LcnTransaction
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;在 backend_item 服务中添加 TX-LCN&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
&amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;&amp;lt;artifactId&amp;gt;common_tx_manager_client&amp;lt;/artifactId&amp;gt;
&amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;!--mapper--&amp;gt;
&amp;lt;dependency&amp;gt;
&amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;common_mapper&amp;lt;/artifactId&amp;gt;
&amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改配置文件，添加 TX-LCN 服务端地址&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;tx-lcn:
	client:
		manager-address: 124.70.181.124:8070
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改启动类，开启 TX-LCN&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@EnableDistributedTransaction
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在方法上添加分布式事务处理注解&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@LcnTransaction
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;543-实现删除商品接口&#34;&gt;5.4.3 实现删除商品接口&lt;/h4&gt;
&lt;h5 id=&#34;5431-在-common_item-服务中实现删除商品&#34;&gt;5.4.3.1  在 common_item 服务中实现删除商品&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;修改 controller&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@RequestMapping(&amp;quot;/service/item&amp;quot;)
public class ItemController {

    @Autowired
    private ItemService itemService;

    /**
     * 查询商品数据
     */
    @RequestMapping(value = &amp;quot;/selectTbItemAllByPage&amp;quot;,method = RequestMethod.GET)
    public PageResult selectTbItemAllByPage(@RequestParam Integer page, @RequestParam Integer rows) {
        return this.itemService.selectTbItemAllByPage(page,rows);
    }

    /**
     * 商品的增加
     */
    @RequestMapping(&amp;quot;/insertTbItem&amp;quot;)
    public Integer insertTbItem(@RequestBody TbItem tbItem){
        return this.itemService.insertTbItem(tbItem);
    }

    /**
     * 商品的删除
     */
    @RequestMapping(&amp;quot;/deleteItemById&amp;quot;)
    public Integer deleteItemById(@RequestBody TbItem tbItem){
        return null;
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 service&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface ItemService {
    PageResult selectTbItemAllByPage(Integer page,Integer rows);
    Integer insertTbItem(TbItem tbItem);
    Integer updateItemById(TbItem tbItem);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 serviceImpl&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
public class ItemServiceImpl implements ItemService {

    @Autowired
    private TbItemMapper tbItemMapper;

    /**
     * 查询所有商品并分页
     * @param page
     * @param rows
     * @return
     */
    @Override
    public PageResult selectTbItemAllByPage(Integer page, Integer rows) {
        PageHelper.startPage(page, rows);
        //查询条件
        TbItemExample tbItemExample = new TbItemExample();
        TbItemExample.Criteria criteria = tbItemExample.createCriteria();
        criteria.andStatusEqualTo((byte) 1);
        List&amp;lt;TbItem&amp;gt; list = this.tbItemMapper.selectByExample(tbItemExample);
        //分页处理
        PageInfo&amp;lt;TbItem&amp;gt; pageInfo = new PageInfo&amp;lt;&amp;gt;(list);
        PageResult pageResult = new PageResult();
        pageResult.setPageIndex(page);
        pageResult.setTotalIndex((int) pageInfo.getTotal());
        pageResult.setResult(list);
        return pageResult;
    }

    /**
     * 商品的增加
     */
    @Override
    @LcnTransaction
    public Integer insertTbItem(TbItem tbItem) {
        return this.tbItemMapper.insert(tbItem);
    }

    /**
     * 商品的删除
     * 删除是更新 status 字段的值，修改为 3
     * @param tbItem
     * @return
     */
    @Override
    @LcnTransaction
    public Integer updateItemById(TbItem tbItem) {
        tbItem.setUpdated(new Date());
        // updateByPrimaryKeySelective会对字段进行判断再更新(如果为Null就忽略更新)，如果你只想更新某一字段，可以用这个方法。updateByPrimaryKey对你注入的字段全部更新
        return this.tbItemMapper.updateByPrimaryKeySelective(tbItem);
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;5432-在-backend_item-服务中实现删除商品&#34;&gt;5.4.3.2  在 backend_item 服务中实现删除商品&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;修改 controller&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@RequestMapping(&amp;quot;/backend/item&amp;quot;)
public class ItemController {

    @Autowired
    private ItemService itemService;

    /**
     * 查询商品并分页处理
     * @param page
     * @param rows
     * @return
     */
    @RequestMapping(&amp;quot;/selectTbItemAllByPage&amp;quot;)
    public Result selectTbItemAllByPage(@RequestParam(defaultValue = &amp;quot;1&amp;quot;)Integer page,@RequestParam(defaultValue = &amp;quot;2&amp;quot;)Integer rows){

        try {
            return this.itemService.selectTbItemAllByPage(page,rows);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return Result.build(500, &amp;quot;查无结果&amp;quot;);
    }

    /**
     * 商品添加
     * @param tbItem
     * @param desc
     * @param itemParams
     * @return
     */
    @RequestMapping(&amp;quot;/insertTbItem&amp;quot;)
    public Result insertTbItem(TbItem tbItem,String desc,String itemParams){
        try {
            return this.itemService.insertTbItem(tbItem, desc, itemParams);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return Result.build(500, &amp;quot;error&amp;quot;);
    }

    /**
     * 商品的删除
     */
    @RequestMapping(&amp;quot;/deleteItemById&amp;quot;)
    public Result deleteItemById(Long itemId){
        try {
            return this.itemService.deleteItemById(itemId);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return Result.build(500, &amp;quot;error&amp;quot;);
    }

}

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 service&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface ItemService {
    Result selectTbItemAllByPage(Integer page,Integer rows);
    Result insertTbItem(TbItem tbItem, String desc, String itemParams);
    Result deleteItemById(Long itemId);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 serviceImpl&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 商品管理
 */
@Service
public class ItemServiceImpl implements ItemService {

    @Autowired
    private CommonItemFeignClient commonItemFeignClient;

    @Override
    public Result selectTbItemAllByPage(Integer page, Integer rows) {
        PageResult pageResult = this.commonItemFeignClient.selectTbItemAllByPage(page, rows);
        if (pageResult != null &amp;amp;&amp;amp; pageResult.getResult() != null &amp;amp;&amp;amp; pageResult.getResult().size() &amp;gt; 0) {
            return Result.ok(pageResult);
        }
        return Result.error(&amp;quot;查无结果&amp;quot;);
    }

    /**
     * 添加TbItem，添加TbitemDesc，添加TbItemParamItem
     *
     * @param tbItem
     * @param desc
     * @param itemParams
     * @return
     */
    @Override
    @LcnTransaction
    public Result insertTbItem(TbItem tbItem, String desc, String itemParams) {
        //补齐 Tbitem 数据
        Date date = new Date();
        long itemId = IDUtils.genItemId();
        tbItem.setId(itemId);
        tbItem.setStatus((byte) 1);
        tbItem.setCreated(date);
        tbItem.setUpdated(date);
        Integer tbItemNum = this.commonItemFeignClient.insertTbItem(tbItem);

        //补齐商品描述对象
        TbItemDesc tbItemDesc = new TbItemDesc();
        tbItemDesc.setItemId(itemId);
        tbItemDesc.setItemDesc(desc);
        tbItemDesc.setCreated(date);
        tbItemDesc.setUpdated(date);
        Integer itemDescNum = this.commonItemFeignClient.insertItemDesc(tbItemDesc);

        //补齐商品规格参数
        TbItemParamItem tbItemParamItem = new TbItemParamItem();
        tbItemParamItem.setItemId(itemId);
        tbItemParamItem.setParamData(itemParams);
        tbItemParamItem.setCreated(date);
        tbItemParamItem.setUpdated(date);
        Integer itemParamItemNum = this.commonItemFeignClient.insertTbItemParamItem(tbItemParamItem);

        return Result.ok();
    }

    /**
     * 删除商品
     *
     * @param itemId
     * @return
     */
    @Override
    @LcnTransaction
    public Result deleteItemById(Long itemId) {
        TbItem tbItem = new TbItem();
        tbItem.setId(itemId);
        tbItem.setStatus((byte) 3);
        Integer itemNum = this.commonItemFeignClient.deleteItemById(tbItem);
        if (itemNum != null) {
            return Result.ok();
        }
        return Result.error(&amp;quot;删除失败&amp;quot;);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 feignClient&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@FeignClient(value = &amp;quot;common-item&amp;quot;)
public interface CommonItemFeignClient {
    //------------/service/item
    @GetMapping(&amp;quot;/service/item/selectTbItemAllByPage&amp;quot;)
    PageResult selectTbItemAllByPage(@RequestParam(&amp;quot;page&amp;quot;) Integer page, @RequestParam(&amp;quot;rows&amp;quot;) Integer rows);
    @PostMapping(&amp;quot;/service/item/insertTbItem&amp;quot;)
    Integer insertTbItem(@RequestBody TbItem tbItem);
    @PostMapping(&amp;quot;/service/item/deleteItemById&amp;quot;)
    Integer deleteItemById(@RequestBody TbItem tbItem);

    //-----------/service/itemCategory
    @PostMapping(&amp;quot;/service/itemCategory/selectItemCategoryByParentId&amp;quot;)
    List&amp;lt;TbItemCat&amp;gt; selectItemCategoryByParentId(@RequestParam(&amp;quot;id&amp;quot;) Long id);

    //-----------/service/itemParam
    @PostMapping(&amp;quot;/service/itemParam/selectItemParamByItemCatId&amp;quot;)
    TbItemParam selectItemParamByItemCatId(@RequestParam(&amp;quot;itemCatId&amp;quot;) Long itemCatId);

    //----------/service/itemDesc
    @PostMapping(&amp;quot;/service/itemDesc/insertItemDesc&amp;quot;)
    Integer insertItemDesc(@RequestBody TbItemDesc tbItemDesc);

    //----------/service/itemParamItem
    @PostMapping(&amp;quot;/service/itemParamItem/insertTbItemParamItem&amp;quot;)
    Integer insertTbItemParamItem(@RequestBody TbItemParamItem tbItemParamItem);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;28&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200827144259.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;29&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200827144326.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;30&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200827144406.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;544-实现预更新商品接口&#34;&gt;5.4.4 实现预更新商品接口&lt;/h4&gt;
&lt;h5 id=&#34;5441-在-common_item-服务中实现根据-id-查询商品&#34;&gt;5.4.4.1 在 common_item 服务中实现根据 ID 查询商品&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;修改 controller&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@RequestMapping(&amp;quot;/service/item&amp;quot;)
public class ItemController {

    @Autowired
    private ItemService itemService;

    /**
     * 查询商品数据
     */
    @RequestMapping(value = &amp;quot;/selectTbItemAllByPage&amp;quot;,method = RequestMethod.GET)
    public PageResult selectTbItemAllByPage(@RequestParam Integer page, @RequestParam Integer rows) {
        return this.itemService.selectTbItemAllByPage(page,rows);
    }

    /**
     * 商品的增加
     */
    @RequestMapping(&amp;quot;/insertTbItem&amp;quot;)
    public Integer insertTbItem(@RequestBody TbItem tbItem){
        return this.itemService.insertTbItem(tbItem);
    }

    /**
     * 商品的删除
     */
    @RequestMapping(&amp;quot;/deleteItemById&amp;quot;)
    public Integer deleteItemById(@RequestBody TbItem tbItem){
        return this.itemService.updateItemById(tbItem);
    }

    /**
     * 根据商品 ID 查询商品，商品分类，商品描述，商品规格参数
     */
    @RequestMapping(&amp;quot;/preUpdateItem&amp;quot;)
    public Map&amp;lt;String,Object&amp;gt; preUpdateItem(Long itemId){
        return this.itemService.preUpdateItem(itemId);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 service&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface ItemService {
    PageResult selectTbItemAllByPage(Integer page,Integer rows);
    Integer insertTbItem(TbItem tbItem);
    Integer updateItemById(TbItem tbItem);
    Map&amp;lt;String ,Object&amp;gt; preUpdateItem(Long itemId);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 serviceImpl&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
public class ItemServiceImpl implements ItemService {

    @Autowired
    private TbItemMapper tbItemMapper;

    @Autowired
    private TbItemDescMapper tbItemDescMapper;

    @Autowired
    private TbItemCatMapper tbItemCatMapper;

    @Autowired
    private TbItemParamItemMapper tbItemParamItemMapper;

    /**
     * 查询所有商品并分页
     *
     * @param page
     * @param rows
     * @return
     */
    @Override
    public PageResult selectTbItemAllByPage(Integer page, Integer rows) {
        PageHelper.startPage(page, rows);
        //查询条件
        TbItemExample tbItemExample = new TbItemExample();
        TbItemExample.Criteria criteria = tbItemExample.createCriteria();
        criteria.andStatusEqualTo((byte) 1);
        List&amp;lt;TbItem&amp;gt; list = this.tbItemMapper.selectByExample(tbItemExample);
        //分页处理
        PageInfo&amp;lt;TbItem&amp;gt; pageInfo = new PageInfo&amp;lt;&amp;gt;(list);
        PageResult pageResult = new PageResult();
        pageResult.setPageIndex(page);
        pageResult.setTotalIndex((int) pageInfo.getTotal());
        pageResult.setResult(list);
        return pageResult;
    }

    /**
     * 商品的增加
     */
    @Override
    public Integer insertTbItem(TbItem tbItem) {
        return this.tbItemMapper.insert(tbItem);
    }

    /**
     * 商品的删除
     * 删除是更新 status 字段的值，修改为 3
     *
     * @param tbItem
     * @return
     */
    @Override
    public Integer updateItemById(TbItem tbItem) {
        tbItem.setUpdated(new Date());
        // updateByPrimaryKeySelective会对字段进行判断再更新(如果为Null就忽略更新)，如果你只想更新某一字段，可以用这个方法。updateByPrimaryKey对你注入的字段全部更新
        return this.tbItemMapper.updateByPrimaryKeySelective(tbItem);
    }

    /**
     * 根据商品 ID 查询商品所有信息。
     *
     * @param itemId
     * @return
     */
    @Override
    public Map&amp;lt;String, Object&amp;gt; preUpdateItem(Long itemId) {
        Map&amp;lt;String, Object&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        //根据商品 ID 查询商品
        TbItem item = this.tbItemMapper.selectByPrimaryKey(itemId);
        map.put(&amp;quot;item&amp;quot;, item);
        //根据商品 ID 查询商品描述
        TbItemDesc tbItemDesc = this.tbItemDescMapper.selectByPrimaryKey(itemId);
        map.put(&amp;quot;itemDesc&amp;quot;, tbItemDesc);
        //根据商品 ID 查询商品类目
        TbItemCat tbItemCat = this.tbItemCatMapper.selectByPrimaryKey(item.getCid());
        map.put(&amp;quot;itemCat&amp;quot;, tbItemCat);
        //根据商品 ID 查询商品规格参数
        TbItemParamItemExample tbItemParamExample = new TbItemParamItemExample();
        TbItemParamItemExample.Criteria criteria = tbItemParamExample.createCriteria();
        criteria.andItemIdEqualTo(itemId);
        List&amp;lt;TbItemParamItem&amp;gt; list = this.tbItemParamItemMapper.selectByExampleWithBLOBs(tbItemParamExample);
        if (list != null || list.size() &amp;gt; 0){
            map.put(&amp;quot;itemParamItem&amp;quot;,list);
        }
            return map;
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;31&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200827145548.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;5442-在-backend_item-服务中实现商品预更新查询&#34;&gt;5.4.4.2 在 backend_item 服务中实现商品预更新查询&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;修改 controller&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@RequestMapping(&amp;quot;/backend/item&amp;quot;)
public class ItemController {

    @Autowired
    private ItemService itemService;

    /**
     * 查询商品并分页处理
     * @param page
     * @param rows
     * @return
     */
    @RequestMapping(&amp;quot;/selectTbItemAllByPage&amp;quot;)
    public Result selectTbItemAllByPage(@RequestParam(defaultValue = &amp;quot;1&amp;quot;)Integer page,@RequestParam(defaultValue = &amp;quot;2&amp;quot;)Integer rows){

        try {
            return this.itemService.selectTbItemAllByPage(page,rows);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return Result.build(500, &amp;quot;查无结果&amp;quot;);
    }

    /**
     * 商品添加
     * @param tbItem
     * @param desc
     * @param itemParams
     * @return
     */
    @RequestMapping(&amp;quot;/insertTbItem&amp;quot;)
    public Result insertTbItem(TbItem tbItem,String desc,String itemParams){
        try {
            return this.itemService.insertTbItem(tbItem, desc, itemParams);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return Result.build(500, &amp;quot;error&amp;quot;);
    }

    /**
     * 商品的删除
     */
    @RequestMapping(&amp;quot;/deleteItemById&amp;quot;)
    public Result deleteItemById(Long itemId){
        try {
            return this.itemService.deleteItemById(itemId);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return Result.build(500, &amp;quot;error&amp;quot;);
    }

    /**
     * 预更新商品查询
     */
    @RequestMapping(&amp;quot;/preUpdateItem&amp;quot;)
    public Result preUpdateItem(Long itemId){
        try {
            return this.itemService.preUpdateItem(itemId);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return Result.build(500, &amp;quot;error&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 service&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface ItemService {
    Result selectTbItemAllByPage(Integer page, Integer rows);

    Result insertTbItem(TbItem tbItem, String desc, String itemParams);

    Result deleteItemById(Long itemId);

    Result preUpdateItem(Long itemId);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 serviceImpl&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 商品管理
 */
@Service
public class ItemServiceImpl implements ItemService {

    @Autowired
    private CommonItemFeignClient commonItemFeignClient;

    @Override
    public Result selectTbItemAllByPage(Integer page, Integer rows) {
        PageResult pageResult = this.commonItemFeignClient.selectTbItemAllByPage(page, rows);
        if (pageResult != null &amp;amp;&amp;amp; pageResult.getResult() != null &amp;amp;&amp;amp; pageResult.getResult().size() &amp;gt; 0) {
            return Result.ok(pageResult);
        }
        return Result.error(&amp;quot;查无结果&amp;quot;);
    }

    /**
     * 添加TbItem，添加TbitemDesc，添加TbItemParamItem
     *
     * @param tbItem
     * @param desc
     * @param itemParams
     * @return
     */
    @Override
    public Result insertTbItem(TbItem tbItem, String desc, String itemParams) {
        //补齐 Tbitem 数据
        Date date = new Date();
        long itemId = IDUtils.genItemId();
        tbItem.setId(itemId);
        tbItem.setStatus((byte) 1);
        tbItem.setCreated(date);
        tbItem.setUpdated(date);
        Integer tbItemNum = this.commonItemFeignClient.insertTbItem(tbItem);

        //补齐商品描述对象
        TbItemDesc tbItemDesc = new TbItemDesc();
        tbItemDesc.setItemId(itemId);
        tbItemDesc.setItemDesc(desc);
        tbItemDesc.setCreated(date);
        tbItemDesc.setUpdated(date);
        Integer itemDescNum = this.commonItemFeignClient.insertItemDesc(tbItemDesc);

        //补齐商品规格参数
        TbItemParamItem tbItemParamItem = new TbItemParamItem();
        tbItemParamItem.setItemId(itemId);
        tbItemParamItem.setParamData(itemParams);
        tbItemParamItem.setCreated(date);
        tbItemParamItem.setUpdated(date);
        Integer itemParamItemNum = this.commonItemFeignClient.insertTbItemParamItem(tbItemParamItem);

        return Result.ok();
    }

    /**
     * 删除商品
     *
     * @param itemId
     * @return
     */
    @Override
    public Result deleteItemById(Long itemId) {
        TbItem tbItem = new TbItem();
        tbItem.setId(itemId);
        tbItem.setStatus((byte) 3);
        Integer itemNum = this.commonItemFeignClient.deleteItemById(tbItem);
        if (itemNum != null) {
            return Result.ok();
        }
        return Result.error(&amp;quot;删除失败&amp;quot;);
    }

    /**
     * 预更新查询
     * @param itemId
     * @return
     */
    @Override
    public Result preUpdateItem(Long itemId) {
        Map&amp;lt;String, Object&amp;gt; map = this.commonItemFeignClient.preUpdateItem(itemId);
        if (map!=null){
            return Result.ok(map);
        }
        return Result.error(&amp;quot;查无数据&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 feignClient&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@FeignClient(value = &amp;quot;common-item&amp;quot;)
public interface CommonItemFeignClient {
    /**
     * @RequestParam 注解是请求时带过来的参数，
     * @RequestBody 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；
     */
    //------------/service/item
    @GetMapping(&amp;quot;/service/item/selectTbItemAllByPage&amp;quot;)
    PageResult selectTbItemAllByPage(@RequestParam(&amp;quot;page&amp;quot;) Integer page, @RequestParam(&amp;quot;rows&amp;quot;) Integer rows);

    @PostMapping(&amp;quot;/service/item/insertTbItem&amp;quot;)
    Integer insertTbItem(@RequestBody TbItem tbItem);

    @PostMapping(&amp;quot;/service/item/deleteItemById&amp;quot;)
    Integer deleteItemById(@RequestBody TbItem tbItem);

    @PostMapping(&amp;quot;/service/item/preUpdateItem&amp;quot;)
    Map&amp;lt;String,Object&amp;gt; preUpdateItem(@RequestParam(&amp;quot;itemId&amp;quot;) Long itemId);

    //-----------/service/itemCategory
    @PostMapping(&amp;quot;/service/itemCategory/selectItemCategoryByParentId&amp;quot;)
    List&amp;lt;TbItemCat&amp;gt; selectItemCategoryByParentId(@RequestParam(&amp;quot;id&amp;quot;) Long id);

    //-----------/service/itemParam
    @PostMapping(&amp;quot;/service/itemParam/selectItemParamByItemCatId&amp;quot;)
    TbItemParam selectItemParamByItemCatId(@RequestParam(&amp;quot;itemCatId&amp;quot;) Long itemCatId);

    //----------/service/itemDesc
    @PostMapping(&amp;quot;/service/itemDesc/insertItemDesc&amp;quot;)
    Integer insertItemDesc(@RequestBody TbItemDesc tbItemDesc);

    //----------/service/itemParamItem
    @PostMapping(&amp;quot;/service/itemParamItem/insertTbItemParamItem&amp;quot;)
    Integer insertTbItemParamItem(@RequestBody TbItemParamItem tbItemParamItem);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;545-实现商品更新接口&#34;&gt;5.4.5 实现商品更新接口&lt;/h4&gt;
&lt;h5 id=&#34;5451-在-common_item-服务中实现商品更新&#34;&gt;5.4.5.1  在 common_item 服务中实现商品更新&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;修改 ItemController&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@RequestMapping(&amp;quot;/service/item&amp;quot;)
public class ItemController {

    @Autowired
    private ItemService itemService;

    /**
     * 查询商品数据
     */
    @RequestMapping(value = &amp;quot;/selectTbItemAllByPage&amp;quot;,method = RequestMethod.GET)
    public PageResult selectTbItemAllByPage(@RequestParam Integer page, @RequestParam Integer rows) {
        return this.itemService.selectTbItemAllByPage(page,rows);
    }

    /**
     * 商品的增加
     */
    @RequestMapping(&amp;quot;/insertTbItem&amp;quot;)
    public Integer insertTbItem(@RequestBody TbItem tbItem){
        return this.itemService.insertTbItem(tbItem);
    }

    /**
     * 商品的删除
     */
    @RequestMapping(&amp;quot;/deleteItemById&amp;quot;)
    public Integer deleteItemById(@RequestBody TbItem tbItem){
        return this.itemService.updateItemById(tbItem);
    }

    /**
     * 根据商品 ID 查询商品，商品分类，商品描述，商品规格参数
     */
    @RequestMapping(&amp;quot;/preUpdateItem&amp;quot;)
    public Map&amp;lt;String,Object&amp;gt; preUpdateItem(Long itemId){
        return this.itemService.preUpdateItem(itemId);
    }

    /**
     * 对商品表的更新操作
     */
    @RequestMapping(&amp;quot;/updateTbItem&amp;quot;)
    public Integer updateTbItem(@RequestBody TbItem tbItem){
        return this.itemService.updateItemById(tbItem);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 ItemDescController&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@RequestMapping(&amp;quot;/service/itemDesc&amp;quot;)
public class ItemDescController {

    @Autowired
    private ItemDescService itemDescService;

    /**
     * 添加商品描述
     */
    @RequestMapping(&amp;quot;/insertItemDesc&amp;quot;)
    public Integer insertItemDesc(@RequestBody TbItemDesc tbItemDesc){
        return itemDescService.insertItemDesc(tbItemDesc);
    }

    /**
     * 更新商品描述
     */
    @RequestMapping(&amp;quot;/updateItemDesc&amp;quot;)
    public Integer updateItemDesc(@RequestBody TbItemDesc tbItemDesc){
        return this.itemDescService.updateItemDesc(tbItemDesc);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 ItemParamItemController&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@RequestMapping(&amp;quot;/service/itemParamItem&amp;quot;)
public class ItemParamItemController {

    @Autowired
    private ItemParamItemService itemParamItemService;
    /**
     * 添加商品规格参数
     */
    @RequestMapping(&amp;quot;/insertTbItemParamItem&amp;quot;)
    public Integer insertTbItemParamItem(@RequestBody TbItemParamItem tbItemParamItem) {
        return this.itemParamItemService.insertItemParamItem(tbItemParamItem);
    }

    /**
     * 更新商品规格参数
     */
    @RequestMapping(&amp;quot;/updateTbItemParamItem&amp;quot;)
    public Integer updateTbItemParamItem(@RequestBody TbItemParamItem tbItemParamItem){
        return this.itemParamItemService.updateTbItemParamItem(tbItemParamItem);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 ItemDescService&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface ItemDescService {
    Integer insertItemDesc(TbItemDesc tbItemDesc);

    Integer updateItemDesc(TbItemDesc tbItemDesc);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 ItemParamItemService&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface ItemParamItemService {
    Integer insertItemParamItem(TbItemParamItem tbItemParamItem);
    Integer updateTbItemParamItem(TbItemParamItem tbItemParamItem);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 ItemDescServiceImpl&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
public class ItemDescServiceImpl implements ItemDescService {
    @Autowired
    private TbItemDescMapper tbItemDescMapper;

    /**
     * 添加商品描述
     * @param tbItemDesc
     * @return
     */
    @Override
    @LcnTransaction
    public Integer insertItemDesc(TbItemDesc tbItemDesc) {
        return this.tbItemDescMapper.insert(tbItemDesc);
    }

    /**
     * 更新商品描述
     * @param tbItemDesc
     * @return
     */
    @Override
    @LcnTransaction
    public Integer updateItemDesc(TbItemDesc tbItemDesc) {
        tbItemDesc.setUpdated(new Date());
        return this.tbItemDescMapper.updateByPrimaryKeySelective(tbItemDesc);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 ItemParamItemServiceImpl&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
public class ItemParamItemServiceImpl implements ItemParamItemService {

    @Autowired
    private TbItemParamItemMapper tbItemParamItemMapper;

    /**
     * 添加商品规格参数
     * @param tbItemParamItem
     * @return
     */
    @Override
    @LcnTransaction
    public Integer insertItemParamItem(TbItemParamItem tbItemParamItem) {
        return this.tbItemParamItemMapper.insert(tbItemParamItem);
    }

    /**
     * 更新商品规格参数
     * @param tbItemParamItem
     * @return
     */
    @Override
    @LcnTransaction
    public Integer updateTbItemParamItem(TbItemParamItem tbItemParamItem) {
        tbItemParamItem.setUpdated(new Date());
        TbItemParamItemExample tbItemParamItemExample = new TbItemParamItemExample();
        TbItemParamItemExample.Criteria criteria = tbItemParamItemExample.createCriteria();
        criteria.andItemIdEqualTo(tbItemParamItem.getItemId());
        return this.tbItemParamItemMapper.updateByExampleSelective(tbItemParamItem, tbItemParamItemExample);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;5452-在-backend_item-服务中实现商品更新&#34;&gt;5.4.5.2  在 backend_item 服务中实现商品更新&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;修改 controller&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@RequestMapping(&amp;quot;/backend/item&amp;quot;)
public class ItemController {

    @Autowired
    private ItemService itemService;

    /**
     * 查询商品并分页处理
     * @param page
     * @param rows
     * @return
     */
    @RequestMapping(&amp;quot;/selectTbItemAllByPage&amp;quot;)
    public Result selectTbItemAllByPage(@RequestParam(defaultValue = &amp;quot;1&amp;quot;)Integer page,@RequestParam(defaultValue = &amp;quot;2&amp;quot;)Integer rows){

        try {
            return this.itemService.selectTbItemAllByPage(page,rows);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return Result.build(500, &amp;quot;查无结果&amp;quot;);
    }

    /**
     * 商品添加
     * @param tbItem
     * @param desc
     * @param itemParams
     * @return
     */
    @RequestMapping(&amp;quot;/insertTbItem&amp;quot;)
    public Result insertTbItem(TbItem tbItem,String desc,String itemParams){
        try {
            return this.itemService.insertTbItem(tbItem, desc, itemParams);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return Result.build(500, &amp;quot;error&amp;quot;);
    }

    /**
     * 商品的删除
     */
    @RequestMapping(&amp;quot;/deleteItemById&amp;quot;)
    public Result deleteItemById(Long itemId){
        try {
            return this.itemService.deleteItemById(itemId);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return Result.build(500, &amp;quot;error&amp;quot;);
    }

    /**
     * 预更新商品查询
     */
    @RequestMapping(&amp;quot;/preUpdateItem&amp;quot;)
    public Result preUpdateItem(Long itemId){
        try {
            return this.itemService.preUpdateItem(itemId);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return Result.build(500, &amp;quot;error&amp;quot;);
    }

    /**
     * 商品更新
     */
    @RequestMapping(&amp;quot;/updateTbItem&amp;quot;)
    public Result updateTbItem(TbItem tbitem,String desc,String itemParams){
        try {
            return this.itemService.updateTbItem(tbitem,desc,itemParams);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return Result.build(500, &amp;quot;error&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 service&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface ItemService {
    Result selectTbItemAllByPage(Integer page, Integer rows);

    Result insertTbItem(TbItem tbItem, String desc, String itemParams);

    Result deleteItemById(Long itemId);

    Result preUpdateItem(Long itemId);

    Result updateTbItem(TbItem tbitem,String desc,String itemParams);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 serviceImpl&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 商品管理
 */
@Service
public class ItemServiceImpl implements ItemService {

    @Autowired
    private CommonItemFeignClient commonItemFeignClient;

    @Override
    public Result selectTbItemAllByPage(Integer page, Integer rows) {
        PageResult pageResult = this.commonItemFeignClient.selectTbItemAllByPage(page, rows);
        if (pageResult != null &amp;amp;&amp;amp; pageResult.getResult() != null &amp;amp;&amp;amp; pageResult.getResult().size() &amp;gt; 0) {
            return Result.ok(pageResult);
        }
        return Result.error(&amp;quot;查无结果&amp;quot;);
    }

    /**
     * 添加TbItem，添加TbitemDesc，添加TbItemParamItem
     *
     * @param tbItem
     * @param desc
     * @param itemParams
     * @return
     */
    @Override
    public Result insertTbItem(TbItem tbItem, String desc, String itemParams) {
        //补齐 Tbitem 数据
        Date date = new Date();
        long itemId = IDUtils.genItemId();
        tbItem.setId(itemId);
        tbItem.setStatus((byte) 1);
        tbItem.setCreated(date);
        tbItem.setUpdated(date);
        Integer tbItemNum = this.commonItemFeignClient.insertTbItem(tbItem);

        //补齐商品描述对象
        TbItemDesc tbItemDesc = new TbItemDesc();
        tbItemDesc.setItemId(itemId);
        tbItemDesc.setItemDesc(desc);
        tbItemDesc.setCreated(date);
        tbItemDesc.setUpdated(date);
        Integer itemDescNum = this.commonItemFeignClient.insertItemDesc(tbItemDesc);

        //补齐商品规格参数
        TbItemParamItem tbItemParamItem = new TbItemParamItem();
        tbItemParamItem.setItemId(itemId);
        tbItemParamItem.setParamData(itemParams);
        tbItemParamItem.setCreated(date);
        tbItemParamItem.setUpdated(date);
        Integer itemParamItemNum = this.commonItemFeignClient.insertTbItemParamItem(tbItemParamItem);

        return Result.ok();
    }

    /**
     * 删除商品
     *
     * @param itemId
     * @return
     */
    @Override
    public Result deleteItemById(Long itemId) {
        TbItem tbItem = new TbItem();
        tbItem.setId(itemId);
        tbItem.setStatus((byte) 3);
        Integer itemNum = this.commonItemFeignClient.deleteItemById(tbItem);
        if (itemNum != null) {
            return Result.ok();
        }
        return Result.error(&amp;quot;删除失败&amp;quot;);
    }

    /**
     * 预更新查询
     * @param itemId
     * @return
     */
    @Override
    public Result preUpdateItem(Long itemId) {
        Map&amp;lt;String, Object&amp;gt; map = this.commonItemFeignClient.preUpdateItem(itemId);
        if (map!=null){
            return Result.ok(map);
        }
        return Result.error(&amp;quot;查无数据&amp;quot;);
    }


    /**
     * 商品更新：更新 TbItem 表，更新 TbitemDesc 表，更新 TbItempParamItem 表
     * @param tbitem
     * @param desc
     * @param itemParams
     * @return
     */
    @Override
    public Result updateTbItem(TbItem tbitem, String desc, String itemParams) {
        //更新商品
        Integer itemNum = this.commonItemFeignClient.updateTbItem(tbitem);

        //更新商品描述,补齐参数
        TbItemDesc tbItemDesc = new TbItemDesc();
        tbItemDesc.setItemId(tbitem.getId());
        tbItemDesc.setItemDesc(desc);
        Integer itemDescNum = this.commonItemFeignClient.updateItemDesc(tbItemDesc);

        //更新商品规格参数，补齐参数
        TbItemParamItem tbItemParamItem = new TbItemParamItem();
        tbItemParamItem.setItemId(tbitem.getId());
        tbItemParamItem.setParamData(itemParams);
        Integer itemParamItemNum = this.commonItemFeignClient.updateTbItemParamItem(tbItemParamItem);
        return Result.ok();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 feignClient&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@FeignClient(value = &amp;quot;common-item&amp;quot;)
public interface CommonItemFeignClient {
    /**
     * @RequestParam 注解是请求时带过来的参数，
     * @RequestBody 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；
     */
    //------------/service/item
    @GetMapping(&amp;quot;/service/item/selectTbItemAllByPage&amp;quot;)
    PageResult selectTbItemAllByPage(@RequestParam(&amp;quot;page&amp;quot;) Integer page, @RequestParam(&amp;quot;rows&amp;quot;) Integer rows);

    @PostMapping(&amp;quot;/service/item/insertTbItem&amp;quot;)
    Integer insertTbItem(@RequestBody TbItem tbItem);

    @PostMapping(&amp;quot;/service/item/deleteItemById&amp;quot;)
    Integer deleteItemById(@RequestBody TbItem tbItem);

    @PostMapping(&amp;quot;/service/item/preUpdateItem&amp;quot;)
    Map&amp;lt;String,Object&amp;gt; preUpdateItem(@RequestParam(&amp;quot;itemId&amp;quot;) Long itemId);

    @PostMapping(&amp;quot;/service/item/updateTbItem&amp;quot;)
    Integer updateTbItem(@RequestBody TbItem tbItem);

    //-----------/service/itemCategory
    @PostMapping(&amp;quot;/service/itemCategory/selectItemCategoryByParentId&amp;quot;)
    List&amp;lt;TbItemCat&amp;gt; selectItemCategoryByParentId(@RequestParam(&amp;quot;id&amp;quot;) Long id);

    //-----------/service/itemParam
    @PostMapping(&amp;quot;/service/itemParam/selectItemParamByItemCatId&amp;quot;)
    TbItemParam selectItemParamByItemCatId(@RequestParam(&amp;quot;itemCatId&amp;quot;) Long itemCatId);

    //----------/service/itemDesc
    @PostMapping(&amp;quot;/service/itemDesc/insertItemDesc&amp;quot;)
    Integer insertItemDesc(@RequestBody TbItemDesc tbItemDesc);

    @PostMapping(&amp;quot;/service/itemDesc/updateItemDesc&amp;quot;)
    Integer updateItemDesc(@RequestBody TbItemDesc tbItemDesc);

    //----------/service/itemParamItem
    @PostMapping(&amp;quot;/service/itemParamItem/insertTbItemParamItem&amp;quot;)
    Integer insertTbItemParamItem(@RequestBody TbItemParamItem tbItemParamItem);

    @PostMapping(&amp;quot;/service/itemParamItem/updateTbItemParamItem&amp;quot;)
    Integer updateTbItemParamItem(@RequestBody TbItemParamItem tbItemParamItem);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;55-开发规格参数管理接口&#34;&gt;5.5 开发规格参数管理接口&lt;/h3&gt;
&lt;h4 id=&#34;551-实现查询所有规格参数模板接口&#34;&gt;5.5.1 实现查询所有规格参数模板接口&lt;/h4&gt;
&lt;h5 id=&#34;5511-在-common_item-服务中实现查询规格参数&#34;&gt;5.5.1.1 在 common_item 服务中实现查询规格参数&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;修改 controller&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * ItemParam
 */
@RestController
@RequestMapping(&amp;quot;/service/itemParam&amp;quot;)
public class ItemParamController {

    @Autowired
    private ItemParamService itemParamService;

    /**
     * 根据商品分类ID查询规格参数模板
     */
    @RequestMapping(&amp;quot;/selectItemParamByItemCatId&amp;quot;)
    public TbItemParam selectItemParamByItemCatId(@RequestParam Long itemCatId) {
        return itemParamService.selectItemParamByItemCatId(itemCatId);
    }

    /**
     * 查询所有商品规格参数模板
     *
     * @return
     */
    @RequestMapping(&amp;quot;/selectItemParamAll&amp;quot;)
    public PageResult selectItemParamAll(@RequestParam Integer page, @RequestParam Integer rows) {
        return this.itemParamService.selectItemParamAll(page, rows);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 service&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface ItemParamService {
    TbItemParam selectItemParamByItemCatId(Long itemCatId);

    PageResult selectItemParamAll(Integer page, Integer rows);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 serviceImpl&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * ItemParamService
 */
@Service
public class ItemParamServiceImpl implements ItemParamService {

    @Autowired
    private TbItemParamMapper tbItemParamMapper;

    @Override
    public TbItemParam selectItemParamByItemCatId(Long itemCatId) {
        TbItemParamExample tbItemParamExample = new TbItemParamExample();
        TbItemParamExample.Criteria criteria = tbItemParamExample.createCriteria();
        criteria.andItemCatIdEqualTo(itemCatId);
        //如需检索的字段中包含大字段类型时，必须用selectByExampleWithBLOBs，不检索大字段时，用selectByExample就足够了
        List&amp;lt;TbItemParam&amp;gt; list = tbItemParamMapper.selectByExampleWithBLOBs(tbItemParamExample);
        if (list != null &amp;amp;&amp;amp; list.size() &amp;gt; 0) {
            return list.get(0);
        }
        return null;
    }

    /**
     * 查询所有规格参数模板
     * @param page
     * @param rows
     * @return
     */
    @Override
    public PageResult selectItemParamAll(Integer page, Integer rows) {
        //设置分页规则
        PageHelper.startPage(page,rows);
        TbItemParamExample tbItemParamExample = new TbItemParamExample();
        List&amp;lt;TbItemParam&amp;gt; list = this.tbItemParamMapper.selectByExampleWithBLOBs(tbItemParamExample);

        //返回所有分页信息参数为查询所有记录的信息
        PageInfo&amp;lt;TbItemParam&amp;gt; pageInfo = new PageInfo&amp;lt;&amp;gt;(list);
        PageResult pageResult = new PageResult();
        pageResult.setPageIndex(page);
        pageResult.setResult(pageInfo.getList());
        pageResult.setTotalIndex((int) pageInfo.getTotal());
        return pageResult;
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;32&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200828144418.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;5512-在-backend_item-服务中实现查询规格参数&#34;&gt;5.5.1.2 在 backend_item 服务中实现查询规格参数&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;修改 controller&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * ItemParam
 */
@RestController
@RequestMapping(&amp;quot;/backend/itemParam&amp;quot;)
public class ItemParamController {

    @Autowired
    private ItemParamService itemParamService;

    /**
     * 根据商品类目ID查询规格参数模板
     */
    @RequestMapping(&amp;quot;/selectItemParamByItemCatId/{itemCatId}&amp;quot;)
    public Result selectItemParamByItemCatId(@PathVariable(&amp;quot;itemCatId&amp;quot;) Long itemCatId){
        try {
            return this.itemParamService.selectItemParamByItemCatId(itemCatId);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return Result.build(500, &amp;quot;查无结果&amp;quot;);
    }

    /**
     * 查询商品全部规格参数
     * @param page
     * @param rows
     * @return
     */
    @RequestMapping(&amp;quot;/selectItemParamAll&amp;quot;)
    public Result selectItemParamAll(@RequestParam(defaultValue = &amp;quot;1&amp;quot;) Integer page,@RequestParam(defaultValue = &amp;quot;30&amp;quot;) Integer rows){
        try {
            return this.itemParamService.selectItemParamAll(page, rows);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return Result.build(500, &amp;quot;查无结果&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 service&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface ItemParamService {
    Result selectItemParamByItemCatId(Long itemCatId);

    Result selectItemParamAll(Integer page,Integer rows);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 serviceImpl&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * ItemParamService
 */
@Service
public class ItemParamServiceImpl implements ItemParamService {

    @Autowired
    private CommonItemFeignClient commonItemFeignClient;

    /**
     * 根据商品类目Id查询规格参数模板
     */
    @Override
    public Result selectItemParamByItemCatId(Long itemCatId) {
        TbItemParam tbItemParam = this.commonItemFeignClient.selectItemParamByItemCatId(itemCatId);
        if (tbItemParam != null) {
            return Result.ok(tbItemParam);
        }
        return Result.error(&amp;quot;查无结果&amp;quot;);
    }

    /**
     *  查询所有规格参数模板
     * @param page
     * @param rows
     * @return
     */
    @Override
    public Result selectItemParamAll(Integer page, Integer rows) {
        PageResult pageResult = this.commonItemFeignClient.selectItemParamAll(page, rows);
        if (pageResult!=null||pageResult.getResult().size()&amp;gt;0){
            return Result.ok(pageResult);
        }
        return Result.error(&amp;quot;查无结果&amp;quot;);
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 feignClient&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@FeignClient(value = &amp;quot;common-item&amp;quot;)
public interface CommonItemFeignClient {
    /**
     * @RequestParam 注解是请求时带过来的参数，
     * @RequestBody 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；
     */
    //------------/service/item
    @GetMapping(&amp;quot;/service/item/selectTbItemAllByPage&amp;quot;)
    PageResult selectTbItemAllByPage(@RequestParam(&amp;quot;page&amp;quot;) Integer page, @RequestParam(&amp;quot;rows&amp;quot;) Integer rows);

    @PostMapping(&amp;quot;/service/item/insertTbItem&amp;quot;)
    Integer insertTbItem(@RequestBody TbItem tbItem);

    @PostMapping(&amp;quot;/service/item/deleteItemById&amp;quot;)
    Integer deleteItemById(@RequestBody TbItem tbItem);

    @PostMapping(&amp;quot;/service/item/preUpdateItem&amp;quot;)
    Map&amp;lt;String,Object&amp;gt; preUpdateItem(@RequestParam(&amp;quot;itemId&amp;quot;) Long itemId);

    @PostMapping(&amp;quot;/service/item/updateTbItem&amp;quot;)
    Integer updateTbItem(@RequestBody TbItem tbItem);

    //-----------/service/itemCategory
    @PostMapping(&amp;quot;/service/itemCategory/selectItemCategoryByParentId&amp;quot;)
    List&amp;lt;TbItemCat&amp;gt; selectItemCategoryByParentId(@RequestParam(&amp;quot;id&amp;quot;) Long id);

    //-----------/service/itemParam
    @PostMapping(&amp;quot;/service/itemParam/selectItemParamByItemCatId&amp;quot;)
    TbItemParam selectItemParamByItemCatId(@RequestParam(&amp;quot;itemCatId&amp;quot;) Long itemCatId);

    @PostMapping(&amp;quot;/service/itemParam/selectItemParamAll&amp;quot;)
    PageResult selectItemParamAll(@RequestParam(&amp;quot;page&amp;quot;) Integer page, @RequestParam(&amp;quot;rows&amp;quot;) Integer rows);

    //----------/service/itemDesc
    @PostMapping(&amp;quot;/service/itemDesc/insertItemDesc&amp;quot;)
    Integer insertItemDesc(@RequestBody TbItemDesc tbItemDesc);

    @PostMapping(&amp;quot;/service/itemDesc/updateItemDesc&amp;quot;)
    Integer updateItemDesc(@RequestBody TbItemDesc tbItemDesc);

    //----------/service/itemParamItem
    @PostMapping(&amp;quot;/service/itemParamItem/insertTbItemParamItem&amp;quot;)
    Integer insertTbItemParamItem(@RequestBody TbItemParamItem tbItemParamItem);

    @PostMapping(&amp;quot;/service/itemParamItem/updateTbItemParamItem&amp;quot;)
    Integer updateTbItemParamItem(@RequestBody TbItemParamItem tbItemParamItem);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;33&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200828150906.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
">综合性 B2C 电子商务平台项目</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jonchan1013.github.io/post/springcloud/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200730014043.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;1-系统架构演变&#34;&gt;1、系统架构演变&lt;/h2&gt;
&lt;p&gt;随着互联网的发展，网站应用的规模不断扩大。需求的激增，带来的是技术上的压力。系统架构也因此也不断的演进、升级、迭代。从单一应用，到垂直拆分，到分布式服务，到SOA，以及现在火热的微服务架构，还有在Google带领下来势汹涌的Service Mesh。我们到底是该乘坐微服务的船只驶向远方，还是偏安逸得过且过？&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;11-集中式架构&#34;&gt;1.1 集中式架构&lt;/h3&gt;
&lt;p&gt;当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200731105554.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;优点：&lt;br&gt;
系统开发速度快&lt;br&gt;
维护成本低&lt;br&gt;
适用于并发要求较低的系统&lt;/li&gt;
&lt;li&gt;缺点：&lt;br&gt;
代码耦合度高，后期维护困难&lt;br&gt;
无法针对不同模块进行针对性优化&lt;br&gt;
无法水平扩展&lt;br&gt;
单点容错率低，并发能力差&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;12-垂直拆分&#34;&gt;1.2 垂直拆分&lt;/h3&gt;
&lt;p&gt;当访问量逐渐增大，单一应用无法满足需求，此时为了应对更高的并发和业务需求，我们根据业务功能对系统进行拆分：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200731105826.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;优点：&lt;br&gt;
系统拆分实现了流量分担，解决了并发问题&lt;br&gt;
可以针对不同模块进行优化&lt;br&gt;
方便水平扩展，负载均衡，容错率提高&lt;/li&gt;
&lt;li&gt;缺点：&lt;br&gt;
系统间相互独立，会有很多重复开发工作，影响开发效率&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;13-分布式服务&#34;&gt;1.3 分布式服务&lt;/h3&gt;
&lt;p&gt;当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200731110007.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;优点：&lt;br&gt;
将基础服务进行了抽取，系统间相互调用，提高了代码复用和开发效率&lt;/li&gt;
&lt;li&gt;缺点：&lt;br&gt;
系统间耦合度变高，调用关系错综复杂，难以维护&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;14-面向服务架构soa&#34;&gt;1.4 面向服务架构（SOA）&lt;/h3&gt;
&lt;p&gt;SOA（Service Oriented Architecture）面向服务的架构：它是一种设计方法，其中包含多个服务， 服务之间通过相互依赖最终提供一系列的功能。一个服务 通常以独立的形式存在与操作系统进程中。各个服务之间 通过网络调用。&lt;br&gt;
SOA结构图：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200731110053.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;ESB（企业服务总线），简单 来说 ESB 就是一根管道，用来连接各个服务节点。为了集 成不同系统，不同协议的服务，ESB 做了消息的转化解释和路由工作，让不同的服务互联互通。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SOA缺点&lt;/strong&gt;：每个供应商提供的ESB产品有偏差，自身实现较为复杂；应用服务粒度较大，ESB集成整合所有服务和协议、数据转换使得运维、测试部署困难。所有服务都通过一个通路通信，直接降低了通信速度。&lt;/p&gt;
&lt;h3 id=&#34;15-微服务架构&#34;&gt;1.5 微服务架构&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;微服务架构是使用一套小服务来开发单个应用的方式或途径&lt;/strong&gt;，每个服务基于单一业务能力构建，运行在自己的进程中，并使用轻量级机制通信，通常是HTTP API，并能够通过自动化部署机制来独立部署。这些服务可以使用不同的编程语言实现，以及不同数据存储技术，并保持最低限度的集中式管理。&lt;br&gt;
微服务结构图：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200731110312.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;API Gateway网关是一个服务器，是系统的唯一入口。为每个客户端提供一个定制的API。API网关核心是，所有的客户端和消费端都通过统一的网关接入微服务，在网关层处理所有的非业务功能。如它还可以具有其它职责，如身份验证、监控、负载均衡、缓存、请求分片与管理、静态响应处理。通常，网关提供RESTful/HTTP的方式访问服务。而服务端通过服务注册中心进行服务注册和管理。&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;微服务的特点：&lt;br&gt;
单一职责：微服务中每一个服务都对应唯一的业务能力，做到单一职责&lt;br&gt;
微：微服务的服务拆分粒度很小，例如一个用户管理就可以作为一个服务。每个服务虽小，但“五脏俱全”。&lt;br&gt;
面向服务：面向服务是说每个服务都要对外暴露Rest风格服务接口API。并不关心服务的技术实现，做到与平台和语言无关，也不限定用什么技术实现，只要提供Rest的接口即可。&lt;br&gt;
自治：自治是说服务间互相独立，互不干扰
&lt;ul&gt;
&lt;li&gt;团队独立：每个服务都是一个独立的开发团队，人数不能过多。&lt;/li&gt;
&lt;li&gt;技术独立：因为是面向服务，提供Rest接口，使用什么技术没有别人干涉&lt;/li&gt;
&lt;li&gt;前后端分离：采用前后端分离开发，提供统一Rest接口，后端不用再为PC、移动端开发不同接口&lt;/li&gt;
&lt;li&gt;数据库分离：每个服务都使用自己的数据源&lt;/li&gt;
&lt;li&gt;部署独立，服务间虽然有调用，但要做到服务重启不影响其它服务。有利于持续集成和持续交付。每个服务都是独立的组件，可复用，可替换，降低耦合，易维护&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;微服务架构与SOA都是对系统进行拆分；微服务架构基于SOA思想，可以把微服务当做去除了ESB的SOA。ESB是SOA架构中的中心总线，设计图形应该是星形的，而微服务是去中心化的分布式软件架构。两者比较类似，但其实也有一些差别：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;功能&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;SOA&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;微服务&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;组件大小&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;大块业务逻辑&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;单独任务或小块业务逻辑&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;耦合&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;通常松耦合&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;总是松耦合&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;管理&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;着重中央管理&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;着重分散管理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;目标&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;确保应用能够交互操作&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;易维护、易扩展、更轻量级的交互&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;2-服务调用方式&#34;&gt;2、服务调用方式&lt;/h2&gt;
&lt;h3 id=&#34;21-rpc和http&#34;&gt;2.1 RPC和HTTP&lt;/h3&gt;
&lt;p&gt;无论是微服务还是SOA，都面临着服务间的远程调用。那么服务间的远程调用方式有哪些呢？&lt;br&gt;
常见的远程调用方式有以下2种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;RPC&lt;/strong&gt;：Remote Produce Call远程过程调用，&lt;strong&gt;RPC基于Socket，工作在会话层。自定义数据格式&lt;/strong&gt;，速度快，效率高。早期的webservice，现在热门的dubbo，都是RPC的典型代表&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Http&lt;/strong&gt;：http其实是**一种网络传输协议，基于TCP，工作在应用层，规定了数据传输的格式。**现在客户端浏览器与服务端通信基本都是采用Http协议，也可以用来进行远程服务调用。缺点是消息封装臃肿，优势是对服务的提供和调用方没有任何技术限定，自由灵活，更符合微服务理念。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在热门的Rest风格，就可以通过http协议来实现。&lt;br&gt;
&lt;strong&gt;区别&lt;/strong&gt;：RPC的机制是根据语言的API（language API）来定义的，而不是根据基于网络的应用来定义的。&lt;br&gt;
如果你们公司全部采用Java技术栈，那么使用Dubbo作为微服务架构是一个不错的选择。&lt;br&gt;
相反，如果公司的技术栈多样化，而且你更青睐Spring家族，那么Spring Cloud搭建微服务是不二之选。在我们的项目中，会选择Spring Cloud套件，因此会使用Http方式来实现服务间调用。&lt;/p&gt;
&lt;h3 id=&#34;22-http客户端工具&#34;&gt;2.2 Http客户端工具&lt;/h3&gt;
&lt;p&gt;既然微服务选择了Http，那么我们就需要考虑自己来实现对请求和响应的处理。不过开源世界已经有很多的http客户端工具，能够帮助我们做这些事情，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HttpClient&lt;/li&gt;
&lt;li&gt;OKHttp&lt;/li&gt;
&lt;li&gt;URLConnection&lt;br&gt;
不过这些不同的客户端，API各不相同。而Spring也有对http的客户端进行封装，提供了工具类叫RestTemplate。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;23-spring的resttemplate&#34;&gt;2.3 Spring的RestTemplate&lt;/h3&gt;
&lt;p&gt;Spring提供了一个RestTemplate模板工具类，对基于Http的客户端进行了封装，并且实现了对象与json的序列化和反序列化，非常方便。RestTemplate并没有限定Http的客户端类型，而是进行了抽象，目前常用的3种都有支持：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HttpClient&lt;/li&gt;
&lt;li&gt;OkHttp&lt;/li&gt;
&lt;li&gt;JDK原生的URLConnection（默认的）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在项目中的 HttpDemoApplication 注册一个RestTemplate 对象，可以在启动类位置注册：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;
import org.springframework.web.client.RestTemplate;

@SpringBootApplication
public class HttpDemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(HttpDemoApplication.class, args);
    }

    @Bean
    public RestTemplate restTemplate(){
         return new RestTemplate();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;启动springboot项目，在项目中的测试类中直接@Autowired 注入：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RunWith(SpringRunner.class)
@SpringBootTest
public class RestTemplateTest {

    @Autowired
    private RestTemplate restTemplate;

    @Test
    public void test(){
        //如果要测试需要启动spring boot项目，以便获取数据
        String url = &amp;quot;http://localhost/user/8&amp;quot;;
        User user = restTemplate.getForObject(url, User.class);
        System.out.println(user);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过RestTemplate的getForObject()方法，传递url地址及实体类的字节码，RestTemplate会自动发起请求，接收响应，并且帮我们对响应结果进行反序列化。&lt;/p&gt;
&lt;p&gt;了解完Http客户端工具，接下来就可以正式学习微服务了。&lt;/p&gt;
&lt;h2 id=&#34;3-初识spring-cloud&#34;&gt;3、 初识Spring Cloud&lt;/h2&gt;
&lt;p&gt;微服务是一种架构方式，最终肯定需要技术架构去实施。&lt;br&gt;
微服务的实现方式很多，但是最火的莫过于Spring Cloud了。为什么？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;后台硬：作为Spring家族的一员，有整个Spring全家桶靠山，背景十分强大。&lt;/li&gt;
&lt;li&gt;技术强：Spring作为Java领域的前辈，可以说是功力深厚。有强力的技术团队支撑，一般人还真比不了&lt;/li&gt;
&lt;li&gt;群众基础好：可以说大多数程序员的成长都伴随着Spring框架，试问：现在有几家公司开发不用Spring？&lt;/li&gt;
&lt;li&gt;Spring Cloud与Spring的各个框架无缝整合，对大家来说一切都是熟悉的配方，熟悉的味道。&lt;/li&gt;
&lt;li&gt;使用方便：相信大家都体会到了SpringBoot给我们开发带来的便利，而Spring Cloud完全支持Spring Boot的开发，用很少的配置就能完成微服务框架的搭建&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;31-简介&#34;&gt;3.1 简介&lt;/h3&gt;
&lt;p&gt;Spring Cloud是Spring旗下的项目之一，官网地址：http://projects.spring.io/spring-cloud/Spring最擅长的就是集成，把世界上最好的框架拿过来，集成到自己的项目中。&lt;br&gt;
Spring Cloud也是一样，它将现在非常流行的一些技术整合到一起，实现了诸如：配置管理，服务发现，智能路由，负载均衡，熔断器，控制总线，集群状态等功能；协调分布式环境中各个系统，为各类服务提供模板性配置。其主要&lt;br&gt;
涉及的组件包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Eureka：注册中心&lt;/li&gt;
&lt;li&gt;Zuul、Gateway：服务网关&lt;/li&gt;
&lt;li&gt;Ribbon：负载均衡&lt;/li&gt;
&lt;li&gt;Feign：服务调用&lt;/li&gt;
&lt;li&gt;Hystrix或Resilience4j：熔断器&lt;br&gt;
以上只是其中一部分，架构图：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200731111940.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;32-版本&#34;&gt;3.2 版本&lt;/h3&gt;
&lt;p&gt;Spring Cloud不是一个组件，而是许多组件的集合；它的版本命名比较特殊，是以A到Z的为首字母的一些单词（其实是伦敦地铁站的名字）组成：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200731111959.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;我们在项目中，使用最新稳定的Greenwich版本。&lt;/p&gt;
&lt;h2 id=&#34;4-微服务场景模拟&#34;&gt;4、 微服务场景模拟&lt;/h2&gt;
&lt;p&gt;首先，我们需要模拟一个服务调用的场景。方便后面学习微服务架构&lt;/p&gt;
&lt;h3 id=&#34;41-创建父工程&#34;&gt;4.1 创建父工程&lt;/h3&gt;
&lt;p&gt;微服务中需要同时创建多个项目，为了方便课堂演示，先创建一个父工程，然后后续的工程都以这个工程为父，实现maven的聚合。这样可以在一个窗口看到所有工程，方便讲解。&lt;strong&gt;在实际开发中，每个微服务可独立一个工程。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;修改pom文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot;
         xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
         xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 
http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
    &amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;heima-springcloud&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;

    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.1.5.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;relativePath/&amp;gt;
    &amp;lt;/parent&amp;gt;

    &amp;lt;properties&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
        &amp;lt;spring-cloud.version&amp;gt;Greenwich.SR1&amp;lt;/spring-cloud.version&amp;gt;
        &amp;lt;mapper.starter.version&amp;gt;2.1.5&amp;lt;/mapper.starter.version&amp;gt;
        &amp;lt;mysql.version&amp;gt;5.1.46&amp;lt;/mysql.version&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;dependencyManagement&amp;gt;
        &amp;lt;dependencies&amp;gt;
            &amp;lt;!-- springCloud --&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${spring-cloud.version}&amp;lt;/version&amp;gt;
                &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
                &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt;
            &amp;lt;/dependency&amp;gt;
            &amp;lt;!-- 通用Mapper启动器 --&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;tk.mybatis&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;mapper-spring-boot-starter&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${mapper.starter.version}&amp;lt;/version&amp;gt;
            &amp;lt;/dependency&amp;gt;
            &amp;lt;!-- mysql驱动 --&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${mysql.version}&amp;lt;/version&amp;gt;
            &amp;lt;/dependency&amp;gt;
        &amp;lt;/dependencies&amp;gt;
    &amp;lt;/dependencyManagement&amp;gt;
    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里已经对大部分要用到的依赖的版本进行了 管理，方便后续使用&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200731112314.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;42-服务提供者&#34;&gt;4.2 服务提供者&lt;/h3&gt;
&lt;p&gt;新建一个项目user-service，对外提供查询用户的服务。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;创建module&lt;/strong&gt;&lt;br&gt;
选中父工程：springclouddemo创建module&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;添加依赖&lt;/strong&gt;&lt;br&gt;
pom.xml 文件中的内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot;
         xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
         xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;artifactId&amp;gt;springcloud-demo&amp;lt;/artifactId&amp;gt;
        &amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
        &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;/parent&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;artifactId&amp;gt;user-service&amp;lt;/artifactId&amp;gt;

&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!-- 通用Mapper启动器 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;tk.mybatis&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;mapper-spring-boot-starter&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!-- mysql驱动 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;编写配置文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建user-service\src\main\resources\application.yml 属性文件,这里我们采用了yaml语法，而不是properties：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;server:
  port: 9091
spring:
  datasource:
    driver-class-name: com.mysql.jdbc.Driver
    url: jdbc:mysql://localhost:3306/springcloud
    username: root
    password: root
mybatis:
  type-aliases-package: com.cy.user.pojo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用mysql图形界面工具创建springcloud 数据库，将tb_user.sql 导入；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;编写代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;编写启动类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import tk.mybatis.spring.annotation.MapperScan;

@SpringBootApplication
@MapperScan(&amp;quot;com.cy.user.mapper&amp;quot;)
public class UserApplication {
    public static void main(String[] args) {
        SpringApplication.run(UserApplication.class, args);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编写实体类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import lombok.Data;
import tk.mybatis.mapper.annotation.KeySql;

import javax.persistence.Id;
import javax.persistence.Table;
import java.util.Date;

@Table(name = &amp;quot;tb_user&amp;quot;)
@Data
public class User {

    @Id
    @KeySql(useGeneratedKeys = true)
    private Long id;

    private String userName; // 用户名

    private String password; // 密码

    private String name;// 姓名

    private Integer age;// 年龄

    private Integer sex;// 性别，1男性，2女性

    private Date birthday;// 出生日期

    private Date created;// 创建时间

    private Date updated;// 更新时间

    private String note;// 备注
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编写UserMapper&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import com.cy.user.pojo.User;
import tk.mybatis.mapper.common.Mapper;

public interface UserMapper extends Mapper&amp;lt;User&amp;gt; {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编写UserService&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import com.cy.user.mapper.UserMapper;
import com.cy.user.pojo.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class UserService {

    @Autowired
    private UserMapper userMapper;

    public User queryById(Long id){
        return userMapper.selectByPrimaryKey(id);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;添加一个对外查询的接口处理器&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import com.cy.user.pojo.User;
import com.cy.user.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping(&amp;quot;/user&amp;quot;)
public class UserController {

    @Autowired
    private UserService userService;
     @GetMapping(&amp;quot;/{id}&amp;quot;)
    public User queryById(@PathVariable Long id){
        return userService.queryById(id);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建完上述代码后项目结构：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200731132923.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;启动并测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;启动 user-service 项目，访问接口：http://localhost:9091/user/8&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200731133358.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;43-服务调用者&#34;&gt;4.3 服务调用者&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;创建工程&lt;/strong&gt;&lt;br&gt;
与上面类似，这里不再赘述，需要注意的是，我们调用user-service 的功能，因此不需要mybatis相关依赖了。&lt;/p&gt;
&lt;p&gt;修改pom文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot;
         xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
         xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 
http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;artifactId&amp;gt;springclouddemo&amp;lt;/artifactId&amp;gt;
        &amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
        &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;/parent&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;consumer-demo&amp;lt;/artifactId&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;编写代码&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;编写启动类 consumer-demo\src\main\java\com\cy\consumer\ConsumerApplication.java 并在其中注册RestTemplate 具体如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;
import org.springframework.web.client.RestTemplate;

@SpringBootApplication
public class ConsumerApplication {
    public static void main(String[] args) {
        SpringApplication.run(ConsumerApplication.class, args);
    }

    @Bean
    public RestTemplate restTemplate(){
        return new RestTemplate();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建实体类 consumer-demo\src\main\java\com\cy\consumer\pojo\User.java&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import lombok.Data;

import java.util.Date;

@Data
public class User {

    private Long id;

    private String userName; // 用户名

    private String password; // 密码

    private String name;// 姓名

    private Integer age;// 年龄

    private Integer sex;// 性别，1男性，2女性

    private Date birthday;// 出生日期

    private Date created;// 创建时间

    private Date updated;// 更新时间

    private String note;// 备注

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编写consumer-demo\src\main\java\com\cy\consumer\controller\ConsumerController.java ，在controller中直接调用RestTemplate，远程访问user-service 的服务接口：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import com.cy.consumer.pojo.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.RestTemplate;

@RestController
@RequestMapping(&amp;quot;/consumer&amp;quot;)
public class ConsumerController {

    @Autowired
    private RestTemplate restTemplate;

    @GetMapping(&amp;quot;{id}&amp;quot;)
    public User queryById(@PathVariable Long id){
        String url = &amp;quot;http://localhost:9091/user/&amp;quot; + id;
        return restTemplate.getForObject(url, User.class);
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;服务调用者项目结构：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200731133845.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;启动测试&lt;/strong&gt;&lt;br&gt;
启动 consumer-demo 引导启动类；因为 consumer-demo 项目没有配置端口，那么默认就是8080，&lt;/p&gt;
&lt;p&gt;我们访问：http://localhost:8080/consumer/8&lt;/p&gt;
&lt;p&gt;一个简单的远程服务调用案例就实现了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;44-思考问题&#34;&gt;4.4 思考问题&lt;/h3&gt;
&lt;p&gt;简单回顾一下，刚才我们写了什么：&lt;br&gt;
user-service：对外提供了查询用户的接口&lt;br&gt;
consumer-demo：通过RestTemplate访问http://locahost:9091/user/{id} 接口，查询用户数据&lt;br&gt;
存在什么问题？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在consumer中，我们把url地址硬编码到了代码中，不方便后期维护&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;consumer需要记忆user-service的地址，如果出现变更，可能得不到通知，地址将失效&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;consumer不清楚user-service的状态，服务宕机也不知道&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;user-service只有1台服务，不具备高可用性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;即便user-service形成集群，consumer还需自己实现负载均衡&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其实上面说的问题，概括一下就是分布式服务必然要面临的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;服务管理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何自动注册和发现&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何实现状态监管&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何实现动态路由&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务如何实现负载均衡&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务如何解决容灾问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务如何实现统一配置&lt;br&gt;
以上的问题，都将在SpringCloud中得到答案。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;5-eureka注册中心&#34;&gt;5、Eureka注册中心&lt;/h2&gt;
&lt;h3 id=&#34;51-认识eureka&#34;&gt;5.1 认识Eureka&lt;/h3&gt;
&lt;p&gt;首先我们来解决第一问题，服务的管理。&lt;br&gt;
&lt;strong&gt;问题分析&lt;/strong&gt;&lt;br&gt;
在刚才的案例中，user-service对外提供服务，需要对外暴露自己的地址。而consumer-demo（调用者）需要记录服务提供者的地址。将来地址出现变更，还需要及时更新。这在服务较少的时候并不觉得有什么，但是在现在日益复杂的互联网环境，一个项目可能会拆分出十几，甚至几十个微服务。此时如果还人为管理地址，不仅开发困难，将来测试、发布上线都会非常麻烦，这与DevOps的思想是背道而驰的。&lt;br&gt;
DevOps的思想是系统可以通过一组过程、方法或系统；提高应用发布和运维的效率,降低管理成本。&lt;br&gt;
&lt;strong&gt;网约车&lt;/strong&gt;&lt;br&gt;
这就好比是 网约车出现以前，人们出门叫车只能叫出租车。一些私家车想做出租却没有资格，被称为黑车。而很多人想要约车，但是无奈出租车太少，不方便。私家车很多却不敢拦，而且满大街的车，谁知道哪个才是愿意载人的。一个想要，一个愿意给，就是缺少引子，缺乏管理啊。&lt;br&gt;
此时滴滴这样的网约车平台出现了，所有想载客的私家车全部到滴滴注册，记录你的车型（服务类型），身份信息（联系方式）。这样提供服务的私家车，在滴滴那里都能找到，一目了然。&lt;br&gt;
此时要叫车的人，只需要打开APP，输入你的目的地，选择车型（服务类型），滴滴自动安排一个符合需求的车到你面前，为你服务，完美！&lt;br&gt;
&lt;strong&gt;Eureka做什么？&lt;/strong&gt;&lt;br&gt;
Eureka就好比是滴滴，负责管理、记录服务提供者的信息。服务调用者无需自己寻找服务，而是把自己的需求告诉Eureka，然后Eureka会把符合你需求的服务告诉你。&lt;br&gt;
同时，服务提供方与Eureka之间通过“心跳” 机制进行监控，当某个服务提供方出现问题，Eureka自然会把它从服务列表中剔除。&lt;br&gt;
这就实现了服务的自动注册、发现、状态监控。&lt;/p&gt;
&lt;h3 id=&#34;52-原理图&#34;&gt;5.2 原理图&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;基本架构：&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/1560439174201.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;Eureka：就是服务注册中心（可以是一个集群），对外暴露自己的地址&lt;/li&gt;
&lt;li&gt;提供者：启动后向Eureka注册自己信息（地址，提供什么服务）&lt;/li&gt;
&lt;li&gt;消费者：向Eureka订阅服务，Eureka会将对应服务的所有提供者地址列表发送给消费者，并且定期更新&lt;/li&gt;
&lt;li&gt;心跳(续约)：提供者定期通过http方式向Eureka刷新自己的状态&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;53-入门案例&#34;&gt;5.3  入门案例&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;搭建eureka-server工程&lt;/strong&gt;&lt;br&gt;
接下来创建一个项目eureka-server ，启动一个Eureka Server Application服务注册中心。&lt;/p&gt;
&lt;p&gt;项目中的pom.xml 文件如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot;
         xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
         xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 
http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;artifactId&amp;gt;heima-springcloud&amp;lt;/artifactId&amp;gt;
        &amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
        &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;/parent&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;eureka-server&amp;lt;/artifactId&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-server&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编写启动类&lt;/p&gt;
&lt;p&gt;eureka-server\src\main\java\com\cy\EurekaServerApplication.java&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

//声明当前应用为eureka服务
@EnableEurekaServer
@SpringBootApplication
public class EurekaServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(EurekaServerApplication.class);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;编写配置文件&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;eureka-server\src\main\resources\application.yml&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;server:
  port: 10086
spring:
  application:
    name: eureka-server # 应用名称，会在Eureka中作为服务的id标识（serviceId）
eureka:
  client:
    service-url: # EurekaServer的地址，现在是自己的地址，如果是集群，需要写其它Server的地址。
      defaultZone: http://127.0.0.1:10086/eureka
    register-with-eureka: false # 不注册自己
    fetch-registry: false #不拉取
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;启动服务&lt;/strong&gt;&lt;br&gt;
启动 eureka-server 访问：http://127.0.0.1:10086&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200731134955.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200731135002.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;54-服务注册&#34;&gt;5.4 服务注册&lt;/h3&gt;
&lt;p&gt;注册服务，就是在服务上添加Eureka的客户端依赖，客户端代码会自动把服务注册到EurekaServer中。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;添加依赖&lt;/strong&gt;&lt;br&gt;
我们在user-service中添加Eureka客户端依赖：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- Eureka客户端 --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;修改启动类&lt;/strong&gt;&lt;br&gt;
在启动类上开启Eureka客户端功能&lt;br&gt;
通过添加@EnableDiscoveryClient 来开启Eureka客户端功能&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SpringBootApplication
@MapperScan(&amp;quot;com.cy.user.mapper&amp;quot;)
@EnableDiscoveryClient // 开启Eureka客户端发现功能
public class UserServiceDemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(UserServiceDemoApplication.class, args);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;修改配置文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;编写user-service\src\main\resources\application.yml配置文件为如下：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;server:
  port: 9091
spring:
  datasource:
    driver-class-name: com.mysql.jdbc.Driver
    url: jdbc:mysql://localhost:3306/springcloud
    username: root
    password: root
  application:
    #应用名
    name: user-service
mybatis:
  type-aliases-package: cn.itcast.user.pojo
eureka:
  client:
    service-url:
      defaultZone: http://localhost:10086/eureka
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这里我们添加了spring.application.name属性来指定应用名称，将来会作为服务的id使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;strong&gt;测试&lt;/strong&gt;&lt;br&gt;
重启 user-service 项目，访问Eureka监控页面&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200731135225.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;我们发现user-service服务已经注册成功了&lt;/p&gt;
&lt;h3 id=&#34;55-服务发现&#34;&gt;5.5 服务发现&lt;/h3&gt;
&lt;p&gt;接下来我们修改consumer-demo ，尝试从EurekaServer获取服务。&lt;br&gt;
方法与服务提供者类似，只需要在项目中添加EurekaClient依赖，就可以通过服务名称来获取信息了！&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;添加依赖&lt;/strong&gt;&lt;br&gt;
找到 consumer-demo\pom.xml 添加如下依赖&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- Eureka客户端 --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;修改启动类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;修改 consumer-demo\src\main\java\com\cy\consumer\ConsumerApplication.java 开启Eureka客户端&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.context.annotation.Bean;
import org.springframework.web.client.RestTemplate;

@SpringBootApplication
@EnableDiscoveryClient
public class ConsumerApplication {
    public static void main(String[] args) {
        SpringApplication.run(ConsumerApplication.class, args);
    }

    @Bean
    public RestTemplate restTemplate(){
        return new RestTemplate();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;新增配置文件&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;新增 consumer-demo\src\main\resources\application.yml 配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;server:
  port: 8080
spring:
  application:
    name: consumer-demo # 应用名称
eureka:
  client:
    service-url: # EurekaServer地址
      defaultZone: http://127.0.0.1:10086/eureka
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;strong&gt;修改处理器&lt;/strong&gt;&lt;br&gt;
修改 consumer-demo\src\main\java\com\cy\consumer\controller\ConsumerController.java 代码，用DiscoveryClient类的方法，根据服务名称，获取服务实例。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import com.cy.consumer.pojo.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.client.ServiceInstance;
import org.springframework.cloud.client.discovery.DiscoveryClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.RestTemplate;

import java.util.List;

@RestController
@RequestMapping(&amp;quot;/consumer&amp;quot;)
public class ConsumerController {

    @Autowired
    private RestTemplate restTemplate;

    @Autowired
    private DiscoveryClient discoveryClient;

    @GetMapping(&amp;quot;{id}&amp;quot;)
    public User queryById(@PathVariable Long id){
        String url = &amp;quot;http://localhost:9091/user/&amp;quot; + id;

        //获取eureka中注册的user-service实例列表
        List&amp;lt;ServiceInstance&amp;gt; serviceInstanceList = 
discoveryClient.getInstances(&amp;quot;user-service&amp;quot;);
        ServiceInstance serviceInstance = serviceInstanceList.get(0);

        url = &amp;quot;http://&amp;quot; + serviceInstance.getHost() + &amp;quot;:&amp;quot; + serviceInstance.getPort() 
+ &amp;quot;/user/&amp;quot; + id;
        return restTemplate.getForObject(url, User.class);
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;&lt;strong&gt;Debug跟踪运行&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;重启 consumer-demo 项目；然后再浏览器中再次访问 http://localhost:8080/consumer/8 ；在代码中debug跟进查看最终拼接要访问的URL：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200731135743.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;56-eureka详解&#34;&gt;5.6 Eureka详解&lt;/h3&gt;
&lt;h4 id=&#34;561-基础架构&#34;&gt;5.6.1 基础架构&lt;/h4&gt;
&lt;p&gt;Eureka架构中的三个核心角色：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务注册中心&lt;br&gt;
Eureka的服务端应用，提供服务注册和发现功能，就是刚刚我们建立的eureka-server&lt;/li&gt;
&lt;li&gt;服务提供者&lt;br&gt;
提供服务的应用，可以是SpringBoot应用，也可以是其它任意技术实现，只要对外提供的是Rest风格服务即可。本例中就是我们实现的user-service&lt;/li&gt;
&lt;li&gt;服务消费者&lt;br&gt;
消费应用从注册中心获取服务列表，从而得知每个服务方的信息，知道去哪里调用服务方。本例中就是我们实现的consumer-demo&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;562-高可用的eureka-server&#34;&gt;5.6.2 高可用的Eureka Server&lt;/h4&gt;
&lt;p&gt;Eureka Server即服务的注册中心，在刚才的案例中，我们只有一个EurekaServer，事实上EurekaServer也可以是一个集群，形成高可用的Eureka中心。&lt;br&gt;
&lt;strong&gt;服务同步&lt;/strong&gt;&lt;br&gt;
多个Eureka Server之间也会互相注册为服务，当服务提供者注册到Eureka Server集群中的某个节点时，该节点会把服务的信息同步给集群中的每个节点，从而实现&lt;strong&gt;数据同步&lt;/strong&gt;。因此，无论客户端访问到Eureka Server集群中的任意一个节点，都可以获取到完整的服务列表信息。&lt;br&gt;
而作为客户端，需要把信息注册到每个Eureka中：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;18&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200731140001.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如果有三个Eureka，则每一个EurekaServer都需要注册到其它几个Eureka服务中，例如：有三个分别为10086、10087、10088，则：&lt;br&gt;
10086要注册到10087和10088上&lt;br&gt;
10087要注册到10086和10088上&lt;br&gt;
10088要注册到10086和10087上&lt;br&gt;
&lt;strong&gt;动手搭建高可用的EurekaServer&lt;/strong&gt;&lt;br&gt;
我们假设要搭建两台EurekaServer的集群，端口分别为：10086和10087&lt;br&gt;
1）修改原来的EurekaServer配置；修改 eureka-server\src\main\resources\application.yml 如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;server:
  port: ${port:10086}

spring:
  application:
    # 应用名称，会在eureka中作为服务的id(serviceId)
    name: eureka-server
eureka:
  client:
    service-url:
      # eureka服务地址；如果是集群则是其它服务器地址，后面要加/eureka
      defaultZone: ${defaultZone:http://127.0.0.1:10086/eureka}
    # 是否注册自己，自身不提供服务所以不注册
    #register-with-eureka: false
    # 是否拉取服务
    #fetch-registry: false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所谓的高可用注册中心，其实就是把EurekaServer自己也作为一个服务，注册到其它EurekaServer上，这样多个EurekaServer之间就能互相发现对方，从而形成集群。因此我们做了以下修改：&lt;/p&gt;
&lt;p&gt;注意:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把register-with-eureka和fetch-registry修改为true或者注释掉&lt;/li&gt;
&lt;li&gt;在上述配置文件中的${}表示在jvm启动时候若能找到对应port或者defaultZone参数则使用，若无则使用后面的默认值&lt;/li&gt;
&lt;li&gt;把service-url的值改成了另外一台EurekaServer的地址，而不是自己&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2）另外一台在启动的时候可以指定端口port和defaultZone配置：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;19&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200731140210.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;修改原来的启动配置组件；在如下界面中的 VM options 中&lt;br&gt;
设置 -DdefaultZone=http:127.0.0.1:10087/eureka&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;20&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200731140228.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;复制一份并修改；在如下界面中的 VM options 中&lt;br&gt;
设置 -Dport=10087 -DdefaultZone=http:127.0.0.1:10086/eureka&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;21&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200731140239.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;3）启动测试；同时启动两台eureka server&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;22&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200731140248.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;4）客户端注册服务到集群&lt;br&gt;
因为EurekaServer不止一个，因此user-service 项目注册服务或者consumer-demo 获取服务的时候，service-url参数需要修改为如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;eureka:
  client:
    service-url: # EurekaServer地址,多个地址以&#39;,&#39;隔开
      defaultZone: http://127.0.0.1:10086/eureka,http://127.0.0.1:10087/eureka
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了方便后面内容的修改，在测试完上述配置后可以再次改回单个eureka server的方式。&lt;/p&gt;
&lt;h4 id=&#34;563-eureka客户端&#34;&gt;5.6.3 Eureka客户端&lt;/h4&gt;
&lt;p&gt;服务提供者要向EurekaServer注册服务，并且完成服务续约等工作。&lt;br&gt;
&lt;strong&gt;服务注册&lt;/strong&gt;&lt;br&gt;
服务提供者在启动时，会检测配置属性中的：eureka.client.register-with-erueka=true 参数是否正确，事实上默认就是true。如果值确实为true，则会向EurekaServer发起一个Rest请求，并携带自己的元数据信息，Eureka&lt;br&gt;
Server会把这些信息保存到一个双层Map结构中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一层Map的Key就是服务id，一般是配置中的spring.application.name 属性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二层Map的key是服务的实例id。一般host+ serviceId + port，例如：localhost:user-service:8081&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;值则是服务的实例对象，也就是说一个服务，可以同时启动多个不同实例，形成集群。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;默认注册时使用的是主机名或者localhost，如果想用ip进行注册，可以在user-service 中添加配置如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;eureka:
  instance:
    ip-address: 127.0.0.1 # ip地址
    prefer-ip-address: true # 更倾向于使用ip，而不是host名
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改完后先后重启user-service 和consumer-demo ；在调用服务的时候就已经变成ip地址；需要注意的是：不是在eureka中的控制台服务实例状态显示。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务续约&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在注册服务完成以后，服务提供者会维持一个心跳（定时向EurekaServer发起Rest请求），告诉EurekaServer：“我还活着”。这个我们称为服务的续约（renew）；&lt;br&gt;
有两个重要参数可以修改服务续约的行为；可以在 user-service 中添加如下配置项：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;eureka:
  instance:
    lease-expiration-duration-in-seconds: 90
    lease-renewal-interval-in-seconds: 30
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;lease-renewal-interval-in-seconds：服务续约(renew)的间隔，默认为30秒&lt;/li&gt;
&lt;li&gt;lease-expiration-duration-in-seconds：服务失效时间，默认值90秒&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也就是说，默认情况下每隔30秒服务会向注册中心发送一次心跳，证明自己还活着。如果超过90秒没有发送心跳，EurekaServer就会认为该服务宕机，会定时（eureka.server.eviction-interval-timer-in-ms设定的时间）从服务列表中移除，这两个值在生产环境不要修改，默认即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;获取服务列表&lt;/strong&gt;&lt;br&gt;
当服务消费者启动时，会检测eureka.client.fetch-registry=true 参数的值，如果为true，则会从EurekaServer服务的列表拉取只读备份，然后缓存在本地。并且每隔30秒会重新拉取并更新数据。可以在consumer-demo项目中通过下面的参数来修改：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;eureka:
  client:
    registry-fetch-interval-seconds: 30
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;564-失效剔除和自我保护&#34;&gt;5.6.4 失效剔除和自我保护&lt;/h4&gt;
&lt;p&gt;如下的配置都是在Eureka Server服务端进行：&lt;br&gt;
&lt;strong&gt;服务下线&lt;/strong&gt;&lt;br&gt;
当服务进行正常关闭操作时，它会触发一个服务下线的REST请求给Eureka Server，告诉服务注册中心：“我要下线了”。服务中心接受到请求之后，将该服务置为下线状态。&lt;br&gt;
&lt;strong&gt;失效剔除&lt;/strong&gt;&lt;br&gt;
有时我们的服务可能由于内存溢出或网络故障等原因使得服务不能正常的工作，而服务注册中心并未收到“服务下线”的请求。相对于服务提供者的“服务续约”操作，服务注册中心在启动时会创建一个定时任务，默认每隔一段时间（默认为60秒）将当前清单中超时（默认为90秒）没有续约的服务剔除，这个操作被称为失效剔除。&lt;br&gt;
可以通过eureka.server.eviction-interval-timer-in-ms 参数对其进行修改，单位是毫秒。&lt;br&gt;
&lt;strong&gt;自我保护&lt;/strong&gt;&lt;br&gt;
我们关停一个服务，很可能会在Eureka面板看到一条警告：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;23&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200731140915.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;这是触发了Eureka的自我保护机制。当服务未按时进行心跳续约时，Eureka会统计服务实例最近15分钟心跳续约的比例是否低于了85%。在生产环境下，因为网络延迟等原因，心跳失败实例的比例很有可能超标，但是此时就把服务剔除列表并不妥当，因为服务可能没有宕机。Eureka在这段时间内不会剔除任何服务实例，直到网络恢复正常。生产环境下这很有效，保证了大多数服务依然可用，不过也有可能获取到失败的服务实例，因此服务调用者必须做好服务的失败容错。&lt;br&gt;
可以通过下面的配置来关停自我保护：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;eureka:
  server:
    enable-self-preservation: false # 关闭自我保护模式（缺省为打开）
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;6-负载均衡ribbon&#34;&gt;6、负载均衡Ribbon&lt;/h2&gt;
&lt;p&gt;在刚才的案例中，我们启动了一个user-service ，然后通过DiscoveryClient来获取服务实例信息，然后获取ip和端口来访问。&lt;/p&gt;
&lt;p&gt;但是实际环境中，往往会开启很多个user-service 的集群。此时获取的服务列表中就会有多个，到底该访问哪一个呢？&lt;br&gt;
一般这种情况下就需要编写负载均衡算法，在多个实例列表中进行选择。&lt;br&gt;
不过Eureka中已经集成了负载均衡组件：Ribbon，简单修改代码即可使用。&lt;br&gt;
什么是Ribbon：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;24&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200731141223.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;接下来，我们就来使用Ribbon实现负载均衡。&lt;/p&gt;
&lt;h3 id=&#34;61-启动两个服务实例&#34;&gt;6.1 启动两个服务实例&lt;/h3&gt;
&lt;p&gt;首先我们配置启动两个user-service 实例，一个9091，一个9092。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;25&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200731141249.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;Eureka监控面板：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;26&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200731141259.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;62-开启负载均衡&#34;&gt;6.2 开启负载均衡&lt;/h3&gt;
&lt;p&gt;因为Eureka中已经集成了Ribbon，所以我们无需引入新的依赖。&lt;br&gt;
直接修改 consumer-demo\src\main\java\com\cy\consumer\ConsumerApplication.java&lt;br&gt;
在RestTemplate的配置方法上添加@LoadBalanced 注解：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SpringBootApplication
@EnableEurekaClient //开启eureka客户端发现
public class ConsumerApplication {
    public static void main(String[] args) {
        SpringApplication.run(ConsumerApplication.class,args);
    }

    @Bean
    public RestTemplate restTemplate(){
        return new RestTemplate();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改consumer-demo\src\main\java\com\cy\consumer\controller\ConsumerController.java 调用方式，不再手动获取ip和端口，而是直接通过服务名称调用；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@GetMapping(&amp;quot;{id}&amp;quot;)
public User queryById(@PathVariable(&amp;quot;id&amp;quot;) Long id){
    String url = &amp;quot;http://user-service/user/&amp;quot; + id;
    User user = restTemplate.getForObject(url, User.class);
    return user;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;访问页面，查看结果；并可以在9091和9092的控制台查看执行情况：&lt;/p&gt;
&lt;p&gt;了解：Ribbon默认的负载均衡策略是轮询。SpringBoot也帮提供了修改负载均衡规则的配置入口在consumer-demo的配置文件中添加如下，就变成随机的了：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;user-service:
  ribbon:
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;格式是：{服务名称}.ribbon.NFLoadBalancerRuleClassName&lt;/p&gt;
&lt;h3 id=&#34;63-源码跟踪&#34;&gt;6.3 源码跟踪&lt;/h3&gt;
&lt;p&gt;为什么只输入了service名称就可以访问了呢？之前还要获取ip和端口。&lt;br&gt;
显然是有组件根据service名称，获取到了服务实例的ip和端口。因为consumer-demo 使用的是RestTemplate，spring的负载均衡自动配置类 LoadBalancerAutoConfiguration.LoadBalancerInterceptorConfig 会自动配置负载均衡拦截器（在spring-cloud-commons-**.jar包中的spring.factories中定义的自动配置类）， 它就是LoadBalancerInterceptor ，这个类会在对RestTemplate的请求进行拦截，然后从Eureka根据服务id获取服务列表，随后利用负载均衡算法得到真实的服务地址信息，替换服务id。&lt;br&gt;
我们进行源码跟踪：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;27&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200731142533.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;继续跟入execute方法：发现获取了9092端口的服务&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;28&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200731142740.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;再跟下一次，发现获取的是9091、9092之间切换：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;29&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200731143101.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;多次访问consumer-demo 的请求地址；然后跟进代码，发现其果然实现了负载均衡。&lt;/p&gt;
&lt;h2 id=&#34;7-熔断器hystrix&#34;&gt;7、熔断器Hystrix&lt;/h2&gt;
&lt;h3 id=&#34;71-简介&#34;&gt;7.1 简介&lt;/h3&gt;
&lt;p&gt;Hystrix 在英文里面的意思是 豪猪，它的logo 看下面的图是一头豪猪，它在微服务系统中是一款提供保护机制的组件，和eureka一样也是由netﬂix公司开发。&lt;br&gt;
主页：https://github.com/Netﬂix/Hystrix/&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;30&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200731143149.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;那么Hystrix的作用是什么呢？具体要保护什么呢？&lt;br&gt;
Hystrix是Netﬂix开源的一个延迟和容错库，用于隔离访问远程服务、第三方库，防止出现级联失败。&lt;/p&gt;
&lt;h3 id=&#34;72-雪崩问题&#34;&gt;7.2 雪崩问题&lt;/h3&gt;
&lt;p&gt;微服务中，服务间调用关系错综复杂，一个请求，可能需要调用多个微服务接口才能实现，会形成非常复杂的调用链路：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;31&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200731143246.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如图，一次业务请求，需要调用A、P、H、I四个服务，这四个服务又可能调用其它服务。&lt;br&gt;
如果此时，某个服务出现异常：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;32&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200731143314.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;例如：微服务I 发生异常，请求阻塞，用户请求就不会得到响应，则tomcat的这个线程不会释放，于是越来越多的用户请求到来，越来越多的线程会阻塞：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;33&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200731143344.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;服务器支持的线程和并发数有限，请求一直阻塞，会导致服务器资源耗尽，从而导致所有其它服务都不可用，形成雪崩效应。&lt;br&gt;
这就好比，一个汽车生产线，生产不同的汽车，需要使用不同的零件，如果某个零件因为种种原因无法使用，那么就会造成整台车无法装配，陷入等待零件的状态，直到零件到位，才能继续组装。  此时如果有很多个车型都需要这个零件，那么整个工厂都将陷入等待的状态，导致所有生产都陷入瘫痪。一个零件的波及范围不断扩大。&lt;/p&gt;
&lt;p&gt;Hystrix解决雪崩问题的手段主要是服务降级，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程隔离&lt;/li&gt;
&lt;li&gt;服务熔断&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;73-线程隔离服务降级&#34;&gt;7.3 线程隔离&amp;amp;服务降级&lt;/h3&gt;
&lt;h4 id=&#34;731-原理&#34;&gt;7.3.1 原理&lt;/h4&gt;
&lt;p&gt;线程隔离示意图：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;34&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200731143445.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;解读：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hystrix为每个依赖服务调用分配一个小的线程池，如果线程池已满调用将被立即拒绝，默认不采用排队，&lt;strong&gt;加速失败判定时间。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;用户的请求将不再直接访问服务，而是通过线程池中的空闲线程来访问服务，如果线程池已满，或者请求超时，则会进行降级处理，什么是服务降级？&lt;br&gt;
&lt;strong&gt;服务降级：优先保证核心服务，而非核心服务不可用或弱可用。&lt;/strong&gt;&lt;br&gt;
用户的请求故障时，不会被阻塞，更不会无休止的等待或者看到系统崩溃，至少可以看到一个执行结果（例如返回友好的提示信息） 。&lt;br&gt;
&lt;strong&gt;服务降级虽然会导致请求失败，但是不会导致阻塞，而且最多会影响这个依赖服务对应的线程池中的资源，对其它服务没有响应。&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;触发Hystrix服务降级的情况：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;线程池已满&lt;/li&gt;
&lt;li&gt;请求超时&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;732-动手实践&#34;&gt;7.3.2 动手实践&lt;/h4&gt;
&lt;p&gt;1）引入依赖&lt;br&gt;
在consumer-demo 消费端系统的pom.xml文件添加如下依赖：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-hystrix&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2）开启熔断&lt;br&gt;
在启动类ConsumerApplication 上添加注解：@EnableCircuitBreaker&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SpringBootApplication
@EnableDiscoveryClient
@EnableCircuitBreaker
public class ConsumerApplication {
    // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，我们类上的注解越来越多，在微服务中，经常会引入上面的三个注解，于是Spring就提供了一个组合注解：@SpringCloudApplication&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;35&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200731145640.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;因此，我们可以使用这个组合注解来代替之前的3个注解。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SpringCloudApplication
public class ConsumerApplication {
    // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3）编写降级逻辑&lt;br&gt;
当目标服务的调用出现故障，我们希望快速失败，给用户一个友好提示。因此需要提前编写好失败时的降级处理逻辑，要使用HystrixCommand来完成。&lt;br&gt;
改造consumer-demo\src\main\java\com\cy\consumer\controller\ConsumerController.java 处理器类，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import com.cy.consumer.pojo.User;
import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.client.ServiceInstance;
import org.springframework.cloud.client.discovery.DiscoveryClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.RestTemplate;

import java.util.List;

@RestController
@RequestMapping(&amp;quot;/consumer&amp;quot;)
@Slf4j
public class ConsumerController {

    @Autowired
    private RestTemplate restTemplate;

    @Autowired
    private DiscoveryClient discoveryClient;

    @GetMapping(&amp;quot;{id}&amp;quot;)
    @HystrixCommand(fallbackMethod = &amp;quot;queryByIdFallback&amp;quot;)
    public String queryById(@PathVariable Long id){
        String url = &amp;quot;http://localhost:9091/user/&amp;quot; + id;

        //获取eureka中注册的user-service实例列表
        /*List&amp;lt;ServiceInstance&amp;gt; serviceInstanceList = 
discoveryClient.getInstances(&amp;quot;user-service&amp;quot;);
        ServiceInstance serviceInstance = serviceInstanceList.get(0);
    url = &amp;quot;http://&amp;quot; + serviceInstance.getHost() + &amp;quot;:&amp;quot; + serviceInstance.getPort() 
+ &amp;quot;/user/&amp;quot; + id;*/
        url = &amp;quot;http://user-service/user/&amp;quot; + id;

        return restTemplate.getForObject(url, String.class);
    }

    public String queryByIdFallback(Long id){
        log.error(&amp;quot;查询用户信息失败。id：{}&amp;quot;, id);
        return &amp;quot;对不起，网络太拥挤了！&amp;quot;;
    }

}     
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;要注意；因为熔断的降级逻辑方法必须跟正常逻辑方法保证：相同的参数列表和返回值声明。 失败逻辑中返回User对象没有太大意义，一般会返回友好提示。所以把queryById的方法改造为返回String，反正也是Json数据。这样失败逻辑中返回一个错误说明，会比较方便。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;@HystrixCommand(fallbackMethod = &amp;quot;queryByIdFallBack&amp;quot;)：用来声明一个降级逻辑的方法&lt;br&gt;
测试：&lt;br&gt;
当user-service 正常提供服务时，访问与以前一致。但是当将user-service 停机时，会发现页面返回了降级处理信息：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;36&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200731150137.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;4）默认的Fallback&lt;br&gt;
刚才把fallback写在了某个业务方法上，如果这样的方法很多，那岂不是要写很多。所以可以把Fallback配置加在类上，实现默认fallback；&lt;br&gt;
再次改造 consumer-demo\src\main\java\com\cy\consumer\controller\ConsumerController.java&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import com.cy.consumer.pojo.User;
import com.netflix.hystrix.contrib.javanica.annotation.DefaultProperties;
import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.client.ServiceInstance;
import org.springframework.cloud.client.discovery.DiscoveryClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.RestTemplate;

import java.util.List;

@RestController
@RequestMapping(&amp;quot;/consumer&amp;quot;)
@Slf4j
@DefaultProperties(defaultFallback = &amp;quot;defaultFallback&amp;quot;)
public class ConsumerController {

    @Autowired
    private RestTemplate restTemplate;

    @Autowired
    private DiscoveryClient discoveryClient;

    @GetMapping(&amp;quot;{id}&amp;quot;)
    //@HystrixCommand(fallbackMethod = &amp;quot;queryByIdFallback&amp;quot;)
    @HystrixCommand
    public String queryById(@PathVariable Long id){
        String url = &amp;quot;http://localhost:9091/user/&amp;quot; + id;

        //获取eureka中注册的user-service实例列表
        /*List&amp;lt;ServiceInstance&amp;gt; serviceInstanceList = 
discoveryClient.getInstances(&amp;quot;user-service&amp;quot;);
        ServiceInstance serviceInstance = serviceInstanceList.get(0);

        url = &amp;quot;http://&amp;quot; + serviceInstance.getHost() + &amp;quot;:&amp;quot; + serviceInstance.getPort() 
+ &amp;quot;/user/&amp;quot; + id;*/
        url = &amp;quot;http://user-service/user/&amp;quot; + id;

        return restTemplate.getForObject(url, String.class);
    }

    public String queryByIdFallback(Long id){
        log.error(&amp;quot;查询用户信息失败。id：{}&amp;quot;, id);
        return &amp;quot;对不起，网络太拥挤了！&amp;quot;;
    }

    public String defaultFallback(){
        return &amp;quot;默认提示：对不起，网络太拥挤了！&amp;quot;;
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;@DefaultProperties(defaultFallback = &amp;quot;defaultFallBack&amp;quot;)：在类上指明统一的失败降级方法；该类中所有方法返回类型要与处理失败的方法的返回类型一致。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;37&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200731150351.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;5）超时设置&lt;br&gt;
在之前的案例中，请求在超过1秒后都会返回错误信息，这是因为Hystrix的默认超时时长为1，我们可以通过配置修改这个值；修改 consumer-demo\src\main\resources\application.yml 添加如下配置：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;hystrix:
  command:
    default:
      execution:
        isolation:
          thread:
            timeoutInMilliseconds: 2000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个配置会作用于全局所有方法。为了方便复制到yml配置文件中，可以复制&lt;br&gt;
hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=2000 到yml文件中会自动格式化后再进行修改。&lt;/p&gt;
&lt;p&gt;为了触发超时，可以在user-service\src\main\java\com\cy\user\service\UserService.java 的方法中休眠2秒；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
public class UserService {

    @Autowired
    private UserMapper userMapper;

    public User queryById(Long id) {
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return userMapper.selectByPrimaryKey(id);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;38&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200731150557.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;可以发现，请求的时长已经到了2s+，证明配置生效了。如果把修改时间修改到2秒以下，又可以正常访问。&lt;/p&gt;
&lt;h3 id=&#34;74-服务熔断&#34;&gt;7.4 服务熔断&lt;/h3&gt;
&lt;h4 id=&#34;741-熔断原理&#34;&gt;7.4.1  熔断原理&lt;/h4&gt;
&lt;p&gt;在服务熔断中，使用的熔断器，也叫断路器，其英文单词为：Circuit Breaker&lt;br&gt;
熔断机制与家里使用的电路熔断原理类似；当如果电路发生短路的时候能立刻熔断电路，避免发生灾难。在分布式系统中应用服务熔断后；服务调用方可以自己进行判断哪些服务反应慢或存在大量超时，可以针对这些服务进行主动熔断，防止整个系统被拖垮。&lt;br&gt;
Hystrix的服务熔断机制，可以实现弹性容错；当服务请求情况好转之后，可以自动重连。通过断路的方式，将后续请求直接拒绝，一段时间（默认5秒）之后允许部分请求通过，如果调用成功则回到断路器关闭状态，否则继续打&lt;br&gt;
开，拒绝请求的服务。&lt;br&gt;
Hystrix的熔断状态机模型：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;39&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/1560682028169.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;状态机有3个状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Closed：关闭状态（断路器关闭），所有请求都正常访问。&lt;/li&gt;
&lt;li&gt;Open：打开状态（断路器打开），所有请求都会被降级。Hystrix会对请求情况计数，当一定时间内失败请求百分比达到阈值，则触发熔断，断路器会完全打开。默认失败比例的阈值是50%，请求次数最少不低于20次。&lt;/li&gt;
&lt;li&gt;Half Open：半开状态，不是永久的，断路器打开后会进入休眠时间（默认是5S）。随后断路器会自动进入半开状态。此时会释放部分请求通过，若这些请求都是健康的，则会关闭断路器，否则继续保持打开，再次进行休眠计时&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;742-动手实践&#34;&gt;7.4.2 动手实践&lt;/h4&gt;
&lt;p&gt;为了能够精确控制请求的成功或失败，在consumer-demo 的处理器业务方法中加入一段逻辑；&lt;br&gt;
修改 consumer-demo\src\main\java\com\cy\consumer\controller\ConsumerController.java&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@GetMapping(&amp;quot;{id}&amp;quot;)
@HystrixCommand
public String queryById(@PathVariable(&amp;quot;id&amp;quot;) Long id){
    if(id == 1){
        throw new RuntimeException(&amp;quot;太忙了&amp;quot;);
    }
    String url = &amp;quot;http://user-service/user/&amp;quot; + id;
    String user = restTemplate.getForObject(url, String.class);
    return user;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样如果参数是id为1，一定失败，其它情况都成功。（不要忘了清空user-service中的休眠逻辑）&lt;br&gt;
我们准备两个请求窗口：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个请求：http://localhost:8080/consumer/1，注定失败&lt;/li&gt;
&lt;li&gt;一个请求：http://localhost:8080/consumer/2，肯定成功&lt;br&gt;
当我们疯狂访问id为1的请求时（超过20次），就会触发熔断。断路器会打开，一切请求都会被降级处理。&lt;br&gt;
此时你访问id为2的请求，会发现返回的也是失败，而且失败时间很短，只有20毫秒左右；因进入半开状态之后2是可以的。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;40&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200803023239.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;不过，默认的熔断触发要求较高，休眠时间窗较短，为了测试方便，我们可以通过配置修改熔断策略：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# 配置熔断策略：
hystrix:
  command:
    default:
      circuitBreaker:
        errorThresholdPercentage: 50 # 触发熔断错误比例阈值，默认值50%
        sleepWindowInMilliseconds: 10000 # 熔断后休眠时长，默认值5秒
        requestVolumeThreshold: 10 # 熔断触发最小请求次数，默认值是20
      execution:
        isolation:
          thread:
            timeoutInMilliseconds: 2000 # 熔断超时设置，默认为1秒
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了方便复制上述配置，可以使用如下格式复制到yml文件中会自动格式化：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;hystrix.command.default.circuitBreaker.requestVolumeThreshold=10
hystrix.command.default.circuitBreaker.sleepWindowInMilliseconds=10000
hystrix.command.default.circuitBreaker.errorThresholdPercentage=50
hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=2000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述的配置项可以参考 HystrixCommandProperties 类中。&lt;/p&gt;
&lt;h2 id=&#34;8-feign&#34;&gt;8、Feign&lt;/h2&gt;
&lt;p&gt;在前面的学习中，使用了Ribbon的负载均衡功能，大大简化了远程调用时的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String url = &amp;quot;http://user-service/user/&amp;quot; + id;
User user = this.restTemplate.getForObject(url, User.class)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果就学到这里，可能以后需要编写类似的大量重复代码，格式基本相同，无非参数不一样。有没有更优雅的方式，来对这些代码再次优化呢？&lt;br&gt;
这就是接下来要学的Feign的功能了。&lt;/p&gt;
&lt;h3 id=&#34;81-简介&#34;&gt;8.1 简介&lt;/h3&gt;
&lt;p&gt;Feign也叫伪装：&lt;br&gt;
Feign可以把Rest的请求进行隐藏，伪装成类似SpringMVC的Controller一样。你不用再自己拼接url，拼接参数等等操作，一切都交给Feign去做。&lt;/p&gt;
&lt;p&gt;项目主页：https://github.com/OpenFeign/feign&lt;/p&gt;
&lt;h3 id=&#34;82-快速入门&#34;&gt;8.2 快速入门&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;导入依赖&lt;br&gt;
在consumer-demo 项目的pom.xml 文件中添加如下依赖&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-openfeign&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Feign的客户端&lt;/p&gt;
&lt;p&gt;在consumer-demo 中编写如下Feign客户端接口类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.itheima.consumer.client;

import com.itheima.consumer.pojo.User;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

@FeignClient(&amp;quot;user-service&amp;quot;)
public interface UserClient {

    @GetMapping(&amp;quot;/user/{id}&amp;quot;)
    User queryById(@PathVariable(&amp;quot;id&amp;quot;) Long id);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;首先这是一个接口，Feign会通过动态代理，帮我们生成实现类。这点跟mybatis的mapper很像&lt;/li&gt;
&lt;li&gt;@FeignClient ，声明这是一个Feign客户端，同时通过value 属性指定服务名称&lt;/li&gt;
&lt;li&gt;接口中的定义方法，完全采用SpringMVC的注解，Feign会根据注解帮我们生成URL，并访问获取结果&lt;/li&gt;
&lt;li&gt;@GetMapping中的/user，请不要忘记；因为Feign需要拼接可访问的地址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;编写新的控制器类ConsumerFeignController ，使用UserClient访问：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.itheima.consumer.controller;

import com.itheima.consumer.client.UserClient;
import com.itheima.consumer.pojo.User;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping(&amp;quot;/cf&amp;quot;)
public class ConsumerFeignController {

    @Autowired
    private UserClient userClient;

    @GetMapping(&amp;quot;/{id}&amp;quot;)
    public User queryById(@PathVariable Long id){
        return userClient.queryById(id);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开启Feign功能&lt;br&gt;
在ConsumerApplication 启动类上，添加注解，开启Feign功能&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.itheima.consumer;

import org.springframework.boot.SpringApplication;
import org.springframework.cloud.client.SpringCloudApplication;
import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.cloud.openfeign.EnableFeignClients;
import org.springframework.context.annotation.Bean;
import org.springframework.web.client.RestTemplate;

/*@SpringBootApplication
@EnableDiscoveryClient
@EnableCircuitBreaker*/
@SpringCloudApplication
@EnableFeignClients//开启Feign功能
public class ConsumerApplication {
    public static void main(String[] args) {
        SpringApplication.run(ConsumerApplication.class, args);
    }

    @Bean
    @LoadBalanced
    public RestTemplate restTemplate(){
        return new RestTemplate();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Feign中已经自动集成了Ribbon负载均衡，因此不需要自己定义RestTemplate进行负载均衡的配置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动测试&lt;/p&gt;
&lt;p&gt;访问接口：http://localhost:8080/cf/2&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;41&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200803023919.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;正常获取到了结果。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;83-负载均衡&#34;&gt;8.3 负载均衡&lt;/h3&gt;
&lt;p&gt;Feign中本身已经集成了Ribbon依赖和自动配置：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;42&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200803024003.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;因此不需要额外引入依赖，也不需要再注册RestTemplate 对象。&lt;/p&gt;
&lt;p&gt;Fegin内置的ribbon默认设置了请求超时时长，默认是1000，我们可以通过手动配置来修改这个超时时长：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;ribbon:
  ReadTimeout: 2000 # 读取超时时长
  ConnectTimeout: 1000 # 建立链接的超时时长
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为ribbon内部有重试机制，一旦超时，会自动重新发起请求。如果不希望重试，可以添加配置：&lt;br&gt;
修改 consumer-demo\src\main\resources\application.yml 添加如下配置：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;ribbon:
  ConnectTimeout: 1000 # 连接超时时长
  ReadTimeout: 2000 # 数据通信超时时长
  MaxAutoRetries: 0 # 当前服务器的重试次数
  MaxAutoRetriesNextServer: 0 # 重试多少次服务
  OkToRetryOnAllOperations: false # 是否对所有的请求方式都重试
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重新给UserService的方法设置上线程沉睡时间2秒可以测试上述配置&lt;/p&gt;
&lt;h3 id=&#34;84-hystrix支持了解&#34;&gt;8.4 Hystrix支持(了解)&lt;/h3&gt;
&lt;p&gt;Feign默认也有对Hystrix的集成：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;43&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200803024124.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;只不过，默认情况下是关闭的。需要通过下面的参数来开启；&lt;br&gt;
修改 consumer-demo\src\main\resources\application.yml 添加如下配置：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;feign:
  hystrix:
    enabled: true # 开启Feign的熔断功能
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是，Feign中的Fallback配置不像Ribbon中那样简单了。&lt;br&gt;
1）首先，要定义一个类，实现刚才编写的UserFeignClient，作为fallback的处理类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.itheima.consumer.client.fallback;

import com.itheima.consumer.client.UserClient;
import com.itheima.consumer.pojo.User;
import org.springframework.stereotype.Component;

@Component
public class UserClientFallback implements UserClient {
    @Override
    public User queryById(Long id) {
        User user = new User();
        user.setId(id);
        user.setName(&amp;quot;用户异常&amp;quot;);
        return user;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2）然后在UserFeignClient中，指定刚才编写的实现类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@FeignClient(value = &amp;quot;user-service&amp;quot;, fallback = UserClientFallback.class)
public interface UserClient {

    @GetMapping(&amp;quot;/user/{id}&amp;quot;)
    User queryById(@PathVariable(&amp;quot;id&amp;quot;) Long id);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3）重启测试&lt;br&gt;
重启启动 consumer-demo 并关闭user-service 服务，然后在页面访问：http://localhost:8080/cf/8&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;44&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200803024404.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;85-请求压缩了解&#34;&gt;8.5 请求压缩(了解)&lt;/h3&gt;
&lt;p&gt;Spring Cloud Feign 支持对请求和响应进行GZIP压缩，以减少通信过程中的性能损耗。通过下面的参数即可开启请求与响应的压缩功能：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;feign:
  compression:
    request:
      enabled: true # 开启请求压缩
    response:
      enabled: true # 开启响应压缩
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同时，我们也可以对请求的数据类型，以及触发压缩的大小下限进行设置：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;feign:
  compression:
    request:
      enabled: true # 开启请求压缩
      mime-types: text/html,application/xml,application/json # 设置压缩的数据类型
      min-request-size: 2048 # 设置触发压缩的大小下限
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注：上面的数据类型、压缩大小下限均为默认值。&lt;/p&gt;
&lt;h3 id=&#34;86-日志级别了解&#34;&gt;8.6  日志级别(了解)&lt;/h3&gt;
&lt;p&gt;前面讲过，通过logging.level.xx=debug 来设置日志级别。然而这个对Fegin客户端而言不会产生效果。因为@FeignClient 注解修改的客户端在被代理时，都会创建一个新的Fegin.Logger实例。我们需要额外指定这个日志的&lt;br&gt;
级别才可以。&lt;br&gt;
1）在consumer-demo 的配置文件中设置com.itheima包下的日志级别都为 debug&lt;br&gt;
修改 consumer-demo\src\main\resources\application.yml 添加如下配置：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;logging:
  level:
    com.itheima: debug
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2）在consumer-demo 编写FeignConﬁg配置类，定义日志级别&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.itheima.consumer.config;

import feign.Logger;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class FeignConfig {

    @Bean
    Logger.Level feignLoggerLevel(){
        //记录所有请求和响应的明细，包括头信息、请求体、元数据
        return Logger.Level.FULL;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里指定的Level级别是FULL，Feign支持4种级别：&lt;br&gt;
NONE：不记录任何日志信息，这是默认值。&lt;br&gt;
BASIC：仅记录请求的方法，URL以及响应状态码和执行时间&lt;br&gt;
HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息&lt;br&gt;
FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。&lt;/p&gt;
&lt;p&gt;3）在consumer-demo 的UserClient 接口类上的@FeignClient注解中指定配置类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.itheima.consumer.client;

import com.itheima.consumer.client.fallback.UserClientFallback;
import com.itheima.consumer.config.FeignConfig;
import com.itheima.consumer.pojo.User;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

@FeignClient(value = &amp;quot;user-service&amp;quot;, fallback = UserClientFallback.class,
configuration = FeignConfig.class)
public interface UserClient {

    @GetMapping(&amp;quot;/user/{id}&amp;quot;)
    User queryById(@PathVariable Long id);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4）重启项目，访问：http://localhost:8080/cf/8 ；即可看到每次访问的日志：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;45&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200803024710.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;9-spring-cloud-gateway网关&#34;&gt;9、Spring Cloud Gateway网关&lt;/h2&gt;
&lt;h3 id=&#34;91-简介&#34;&gt;9.1 简介&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Spring Cloud Gateway是Spring官网基于Spring 5.0、 Spring Boot 2.0、Project Reactor等技术开发的网关服务。&lt;/li&gt;
&lt;li&gt;Spring Cloud Gateway基于Filter链提供网关基本功能：安全、监控／埋点、限流等。&lt;/li&gt;
&lt;li&gt;Spring Cloud Gateway为微服务架构提供简单、有效且统一的API路由管理方式。&lt;/li&gt;
&lt;li&gt;Spring Cloud Gateway是替代Netﬂix Zuul的一套解决方案。&lt;br&gt;
Spring Cloud Gateway组件的核心是一系列的过滤器，通过这些过滤器可以将客户端发送的请求转发（路由）到对应的微服务。 Spring Cloud Gateway是加在整个微服务最前沿的防火墙和代理器，隐藏微服务结点IP端口信息，从而加强安全保护。Spring Cloud Gateway本身也是一个微服务，需要注册到Eureka服务注册中心。&lt;br&gt;
网关的核心功能是：&lt;strong&gt;过滤和路由&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;92-gateway加入后的架构&#34;&gt;9.2 Gateway加入后的架构&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;46&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200803024952.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;不管是来自于客户端（PC或移动端）的请求，还是服务内部调用。一切对服务的请求都可经过网关，然后再由网关来实现 鉴权、动态路由等等操作。Gateway就是我们服务的统一入口。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;93-核心概念&#34;&gt;9.3 核心概念&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;路由（route）&lt;/strong&gt; 路由信息的组成：由一个ID、一个目的URL、一组断言工厂、一组Filter组成。如果路由断言为真，说明请求URL和配置路由匹配。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;断言（Predicate）&lt;/strong&gt; Spring Cloud Gateway中的断言函数输入类型是Spring 5.0框架中的ServerWebExchange。Spring Cloud Gateway的断言函数允许开发者去定义匹配来自于Http Request中的任何信息比如请求头和参数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;过滤器（Filter）&lt;/strong&gt; 一个标准的Spring WebFilter。 Spring Cloud Gateway中的Filter分为两种类型的Filter，分别是Gateway Filter和Global Filter。过滤器Filter将会对请求和响应进行修改处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;94-快速入门&#34;&gt;9.4 快速入门&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;新建工程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;打开 heima-springcloud\heima-gateway\pom.xml 文件修改为如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot;
         xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
         xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 
http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;artifactId&amp;gt;heima-springcloud&amp;lt;/artifactId&amp;gt;
        &amp;lt;groupId&amp;gt;com.itheima&amp;lt;/groupId&amp;gt;
        &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;/parent&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;groupId&amp;gt;com.itheima&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;heima-gateway&amp;lt;/artifactId&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-gateway&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;编写启动类&lt;/strong&gt;&lt;br&gt;
在heima-gateway中创建com.itheima.gateway.GatewayApplication 启动类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.itheima.gateway;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;

@SpringBootApplication
@EnableDiscoveryClient
public class GatewayApplication {
    public static void main(String[] args) {
        SpringApplication.run(GatewayApplication.class, args);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;创建heima-gateway\src\main\resources\application.yml 文件，内容如下：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;server:
  port: 10010
spring:
  application:
    name: api-gateway

eureka:
  client:
    service-url:
      defaultZone: http://127.0.0.1:10086/eureka
  instance:
    prefer-ip-address: true
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;编写路由规则&lt;/strong&gt;&lt;br&gt;
需要用网关来代理user-service 服务，先看一下控制面板中的服务状态：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;47&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200803154326.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;ip为：127.0.0.1&lt;/li&gt;
&lt;li&gt;端口为：9091&lt;br&gt;
修改heima-gateway\src\main\resources\application.yml 文件为：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;server:
  port: 10010
spring:
  application:
    name: api-gateway
  cloud:
    gateway:
      routes:
        # 路由id，可以随意写
        - id: user-service-route
          # 代理的服务地址
          uri: http://127.0.0.1:9091
          # 路由断言，可以配置映射路径
          predicates:
            - Path=/user/**
eureka:
  client:
    service-url:
      defaultZone: http://127.0.0.1:10086/eureka
  instance:
    prefer-ip-address: true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将符合Path 规则的一切请求，都代理到 uri 参数指定的地址&lt;br&gt;
本例中，我们将路径中包含有 /user/** 开头的请求，代理到http://127.0.0.1:9091&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;启动测试&lt;/strong&gt;&lt;br&gt;
访问的路径中需要加上配置规则的映射路径，我们访问：http://localhost:10010/user/8&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;48&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200803154523.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;95-面向服务的路由&#34;&gt;9.5 面向服务的路由&lt;/h3&gt;
&lt;p&gt;在刚才的路由规则中，把路径对应的服务地址写死了！如果同一服务有多个实例的话，这样做显然不合理。应该根据服务的名称，去Eureka注册中心查找服务对应的所有实例列表，然后进行动态路由！&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;修改映射配置，通过服务名称获取&lt;/strong&gt;&lt;br&gt;
因为已经配置了Eureka客户端，可以从Eureka获取服务的地址信息。&lt;br&gt;
修改heima-gateway\src\main\resources\application.yml 文件如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;server:
  port: 10010
spring:
  application:
    name: api-gateway
  cloud:
    gateway:
      routes:
        # 路由id，可以随意写
        - id: user-service-route
          # 代理的服务地址；lb表示从eureka中获取具体服务
          uri: lb://user-service
          # 路由断言，可以配置映射路径
          predicates:
            - Path=/user/**
eureka:
  client:
    service-url:
      defaultZone: http://127.0.0.1:10086/eureka
  instance:
    prefer-ip-address: true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;路由配置中uri所用的协议为lb时（以uri: lb://user-service为例），gateway将使用 LoadBalancerClient把user-service通过eureka解析为实际的主机和端口，并进行ribbon负载均衡。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;启动测试&lt;/strong&gt;&lt;br&gt;
再次启动 heima-gateway ，这次gateway进行代理时，会利用Ribbon进行负载均衡访问：&lt;br&gt;
http://localhost:10010/user/8&lt;br&gt;
日志中可以看到使用了负载均衡器：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;49&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200803155238.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;96-路由前缀&#34;&gt;9.6 路由前缀&lt;/h3&gt;
&lt;h4 id=&#34;961-添加前缀&#34;&gt;9.6.1 添加前缀&lt;/h4&gt;
&lt;p&gt;在gateway中可以通过配置路由的过滤器PreﬁxPath，实现映射路径中地址的添加；&lt;br&gt;
修改heima-gateway\src\main\resources\application.yml 文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;server:
  port: 10010
spring:
  application:
    name: api-gateway
    cloud:
    gateway:
      routes:
        # 路由id，可以随意写
        - id: user-service-route
          # 代理的服务地址；lb表示从eureka中获取具体服务
          uri: lb://user-service
          # 路由断言，可以配置映射路径
          predicates:
            - Path=/**
          filters:
            # 添加请求路径的前缀
            - PrefixPath=/user
eureka:
  client:
    service-url:
      defaultZone: http://127.0.0.1:10086/eureka
  instance:
    prefer-ip-address: true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过PrefixPath=/xxx 来指定了路由要添加的前缀。&lt;br&gt;
也就是：&lt;br&gt;
PrefixPath=/user http://localhost:10010/8 --》http://localhost:9091/user/8&lt;br&gt;
PrefixPath=/user/abc http://localhost:10010/8 --》http://localhost:9091/user/abc/8&lt;br&gt;
以此类推。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;50&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200803155358.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;962-去除前缀&#34;&gt;9.6.2 去除前缀&lt;/h4&gt;
&lt;p&gt;在gateway中可以通过配置路由的过滤器StripPreﬁx，实现映射路径中地址的去除；&lt;/p&gt;
&lt;p&gt;修改heima-gateway\src\main\resources\application.yml 文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;server:
  port: 10010
spring:
  application:
    name: api-gateway
  cloud:
    gateway:
      routes:
        # 路由id，可以随意写
        - id: user-service-route
          # 代理的服务地址；lb表示从eureka中获取具体服务
          uri: lb://user-service
          # 路由断言，可以配置映射路径
          predicates:
            - Path=/api/user/**
          filters:
            # 表示过滤1个路径，2表示两个路径，以此类推
            - StripPrefix=1
eureka:
  client:
    service-url:
      defaultZone: http://127.0.0.1:10086/eureka
  instance:
    prefer-ip-address: true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过StripPrefix=1 来指定了路由要去掉的前缀个数。如：路径/api/user/1 将会被代理到/user/1 。&lt;br&gt;
也就是：&lt;br&gt;
StripPrefix=1 http://localhost:10010/api/user/8 --》http://localhost:9091/user/8&lt;br&gt;
StripPrefix=2 http://localhost:10010/api/user/8 --》http://localhost:9091/8&lt;br&gt;
以此类推。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;51&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200803155500.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;97-过滤器&#34;&gt;9.7  过滤器&lt;/h3&gt;
&lt;h4 id=&#34;971-简介&#34;&gt;9.7.1 简介&lt;/h4&gt;
&lt;p&gt;Gateway作为网关的其中一个重要功能，就是实现请求的鉴权。而这个动作往往是通过网关提供的过滤器来实现的。&lt;br&gt;
前面的 路由前缀 章节中的功能也是使用过滤器实现的。&lt;/p&gt;
&lt;p&gt;Gateway自带过滤器有几十个，常见自带过滤器有：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;过滤器名称&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;AddRequestHeader&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;对匹配上的请求加上Header&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;AddRequestParameters&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;对匹配上的请求路由添加参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;AddResponseHeader&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;对从网关返回的响应添加Header&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;StripPreﬁx&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;对匹配上的请求路径去除前缀&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;52&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200803155639.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;详细的说明在官网链接&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置全局默认过滤器&lt;/strong&gt;&lt;br&gt;
这些自带的过滤器可以和使用 路由前缀 章节中的用法类似，也可以将这些过滤器配置成不只是针对某个路由；而是可以对所有路由生效，也就是配置默认过滤器：&lt;br&gt;
了解如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;server:
  port: 10010
spring:
  application:
    name: api-gateway
  cloud:
    gateway:
      # 默认过滤器，对所有路由生效
       default-filters:
        # 响应头过滤器，对输出的响应设置其头部属性名称为X-Response-Default-MyName，值为itcast；
如果有多个参数多则重写一行设置不同的参数
        - AddResponseHeader=X-Response-Default-MyName, itcast
      routes:
        # 路由id，可以随意写
        - id: user-service-route
          # 代理的服务地址；lb表示从eureka中获取具体服务
          uri: lb://user-service
          # 路由断言，可以配置映射路径
          predicates:
            - Path=/api/user/**
          filters:
            # 表示过滤1个路径，2表示两个路径，以此类推
            - StripPrefix=1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述配置后，再访问 http://localhost:10010/api/user/8 的话；那么可以从其响应中查看到如下信息：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;53&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200803155843.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;过滤器类型&lt;/strong&gt;：Gateway实现方式上，有两种过滤器；&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;局部&lt;/strong&gt;过滤器：通过spring.cloud.gateway.routes.filters 配置在具体路由下，只作用在当前路由上；自带的过滤器都可以配置或者自定义按照自带过滤器的方式。如果配置spring.cloud.gateway.default-filters 上会对所有路由生效也算是全局的过滤器；但是这些过滤器的实现上都是要实现GatewayFilterFactory接口。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;全局&lt;/strong&gt;过滤器：不需要在配置文件中配置，作用在所有的路由上；实现 GlobalFilter 接口即可。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;972-执行生命周期&#34;&gt;9.7.2 执行生命周期&lt;/h4&gt;
&lt;p&gt;Spring Cloud Gateway 的 Filter 的生命周期也类似Spring MVC的拦截器有两个：“pre” 和 “post”。“pre”和 “post” 分别会在请求被执行前调用和被执行后调用。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;54&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200803155949.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;这里的 pre 和 post 可以通过过滤器的GatewayFilterChain 执行ﬁlter方法前后来实现。&lt;/p&gt;
&lt;h4 id=&#34;973-使用场景&#34;&gt;9.7.3 使用场景&lt;/h4&gt;
&lt;p&gt;常见的应用场景如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;请求鉴权：一般GatewayFilterChain 执行ﬁlter方法前，如果发现没有访问权限，直接就返回空。&lt;/li&gt;
&lt;li&gt;异常处理：一般GatewayFilterChain 执行ﬁlter方法后，记录异常并返回。&lt;/li&gt;
&lt;li&gt;服务调用时长统计：GatewayFilterChain 执行ﬁlter方法前后根据时间统计。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;98-自定义过滤器&#34;&gt;9.8 自定义过滤器&lt;/h3&gt;
&lt;h4 id=&#34;981-自定义局部过滤器&#34;&gt;9.8.1 自定义局部过滤器&lt;/h4&gt;
&lt;p&gt;需求：在application.yml中对某个路由配置过滤器，该过滤器可以在控制台输出配置文件中指定名称的请求参数的值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）编写过滤器&lt;/strong&gt;&lt;br&gt;
在heima-gateway工程编写过滤器工厂类MyParamGatewayFilterFactory&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.itheima.gateway.filter;

import org.springframework.cloud.gateway.filter.GatewayFilter;
import org.springframework.cloud.gateway.filter.factory.AbstractGatewayFilterFactory;
import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.stereotype.Component;

import java.util.Arrays;
import java.util.List;

@Component
public class MyParamGatewayFilterFactory extends 
AbstractGatewayFilterFactory&amp;lt;MyParamGatewayFilterFactory.Config&amp;gt; {

    public static final String PARAM_NAME = &amp;quot;param&amp;quot;;

    public MyParamGatewayFilterFactory() {
        super(Config.class);
    }

    @Override
    public List&amp;lt;String&amp;gt; shortcutFieldOrder() {
        return Arrays.asList(PARAM_NAME);
    }

    @Override
    public GatewayFilter apply(Config config) {
        return (exchange, chain) -&amp;gt; {
            ServerHttpRequest request = exchange.getRequest();

            if (request.getQueryParams().containsKey(config.param)) {
                request.getQueryParams().get(config.param)
                        .forEach(value -&amp;gt; System.out.printf(&amp;quot;----------局部过滤器-----%s 
= %s-----&amp;quot;,
                                config.param, value));
            }

            return chain.filter(exchange);
        };
    }

    public static class Config {
        private String param;

        public String getParam() {
            return param;
        }

        public void setParam(String param) {
            this.param = param;
        }
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2）修改配置文件&lt;br&gt;
在heima-gateway工程修改heima-gateway\src\main\resources\application.yml 配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;server:
  port: 10010
spring:
  application:
    name: api-gateway
  cloud:
    gateway:
      routes:
        # 路由id，可以随意写
        - id: user-service-route
          # 代理的服务地址；lb表示从eureka中获取具体服务
          uri: lb://user-service
          # 路由断言，可以配置映射路径
          predicates:
            - Path=/api/user/**
          filters:
            # 表示过滤1个路径，2表示两个路径，以此类推
            - StripPrefix=1
            # 自定义过滤器
            - MyParam=name
eureka:
  client:
    service-url:
      defaultZone: http://127.0.0.1:10086/eureka
  instance:
    prefer-ip-address: true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：自定义过滤器的命名应该为：***GatewayFilterFactory&lt;/p&gt;
&lt;p&gt;测试访问：http://localhost:10010/api/user/8?name=itcast 检查后台是否输出name和itcast；但是若访问http://localhost:10010/api/user/8?name2=itcast 则是不会输出的。&lt;/p&gt;
&lt;h4 id=&#34;982-自定义全局过滤器&#34;&gt;9.8.2 自定义全局过滤器&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;需求&lt;/strong&gt;：模拟一个登录的校验。基本逻辑：如果请求中有token参数，则认为请求有效，放行。&lt;/p&gt;
&lt;p&gt;在heima-gateway工程编写全局过滤器类MyGlobalFilter&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.itheima.gateway.filter;

import org.apache.commons.lang.StringUtils;
import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.cloud.gateway.filter.GlobalFilter;
import org.springframework.core.Ordered;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

@Component
public class MyGlobalFilter implements GlobalFilter, Ordered {
    @Override
    public Mono&amp;lt;Void&amp;gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        System.out.println(&amp;quot;-----------------全局过滤器MyGlobalFilter-------------------
--&amp;quot;);
        String token = exchange.getRequest().getQueryParams().getFirst(&amp;quot;token&amp;quot;);
        if (StringUtils.isBlank(token)) {
            exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
            return exchange.getResponse().setComplete();
        }
        return chain.filter(exchange);
    }

    @Override
    public int getOrder() {
        //值越小越先执行
        return 1;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;访问 http://localhost:10010/api/user/8&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;55&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200803170715.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;访问 http://localhost:10010/api/user/8?token=abc&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;56&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200803170749.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;99-负载均衡和熔断了解&#34;&gt;9.9 负载均衡和熔断（了解）&lt;/h3&gt;
&lt;p&gt;Gateway中默认就已经集成了Ribbon负载均衡和Hystrix熔断机制。但是所有的超时策略都是走的默认值，比如熔断超时时间只有1S，很容易就触发了。因此建议手动进行配置：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;hystrix:
  command:
    default:
      execution:
        isolation:
          thread:
            timeoutInMilliseconds: 6000
ribbon:
  ConnectTimeout: 1000
  ReadTimeout: 2000
  MaxAutoRetries: 0
  MaxAutoRetriesNextServer: 0
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;910-gateway跨域配置&#34;&gt;9.10 Gateway跨域配置&lt;/h3&gt;
&lt;p&gt;一般网关都是所有微服务的统一入口，必然在被调用的时候会出现跨域问题。&lt;br&gt;
&lt;strong&gt;跨域&lt;/strong&gt;：在js请求访问中，如果访问的地址与当前服务器的域名、ip或者端口号不一致则称为跨域请求。若不解决则不能获取到对应地址的返回结果。&lt;br&gt;
如：从在http://localhost:9090中的js访问 http://localhost:9000的数据，因为端口不同，所以也是跨域请求。&lt;/p&gt;
&lt;p&gt;在访问Spring Cloud Gateway网关服务器的时候，出现跨域问题的话；可以在网关服务器中通过配置解决，允许哪些服务是可以跨域请求的；具体配置如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;spring:
  cloud:
    gateway:
      globalcors:
        corsConfigurations:
          &#39;[/**]&#39;:
            #allowedOrigins: * # 这种写法或者下面的都可以，*表示全部
            allowedOrigins:
            - &amp;quot;http://docs.spring.io&amp;quot;
            allowedMethods:
            - GET
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述配置表示：可以允许来自 http://docs.spring.io 的get请求方式获取服务数据。&lt;br&gt;
allowedOrigins 指定允许访问的服务器地址，如：http://localhost:10000 也是可以的。&lt;br&gt;
&#39;[/**]&#39; 表示对所有访问到网关服务器的请求地址&lt;br&gt;
官网具体说明：https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.1.1.RELEASE/multi/multi__cors_conﬁguration.html&lt;/p&gt;
&lt;h3 id=&#34;911-gateway的高可用了解&#34;&gt;9.11 Gateway的高可用（了解）&lt;/h3&gt;
&lt;p&gt;启动多个Gateway服务，自动注册到Eureka，形成集群。如果是服务内部访问，访问Gateway，自动负载均衡，没问题。&lt;br&gt;
但是，Gateway更多是外部访问，PC端、移动端等。它们无法通过Eureka进行负载均衡，那么该怎么办？&lt;br&gt;
此时，可以使用其它的服务网关，来对Gateway进行代理。比如：Nginx&lt;/p&gt;
&lt;h3 id=&#34;912-gateway与feign的区别&#34;&gt;9.12 Gateway与Feign的区别&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Gateway 作为整个应用的流量入口，接收所有的请求，如PC、移动端等，并且将不同的请求转发至不同的处理微服务模块，其作用可视为nginx；大部分情况下用作权限鉴定、服务端流量控制&lt;/li&gt;
&lt;li&gt;Feign 则是将当前微服务的部分服务接口暴露出来，并且主要用于各个微服务之间的服务调用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;10-spring-cloud-config分布式配置中心&#34;&gt;10、Spring Cloud Conﬁg分布式配置中心&lt;/h2&gt;
&lt;h3 id=&#34;101-简介&#34;&gt;10.1 简介&lt;/h3&gt;
&lt;p&gt;在分布式系统中，由于服务数量非常多，配置文件分散在不同的微服务项目中，管理不方便。为了方便配置文件集中管理，需要分布式配置中心组件。在Spring Cloud中，提供了Spring Cloud Conﬁg，它支持配置文件放在配置服务的本地，也支持放在远程Git仓库（GitHub、码云）。&lt;br&gt;
使用Spring Cloud Conﬁg配置中心后的架构如下图：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;57&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200803171244.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;配置中心本质上也是一个微服务，同样需要注册到Eureka服务注册中心！&lt;/p&gt;
&lt;h3 id=&#34;102-git配置管理&#34;&gt;10.2 Git配置管理&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;远程Git仓库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;知名的Git远程仓库有国外的GitHub和国内的码云（gitee）；但是使用GitHub时，国内的用户经常遇到的问题是访问速度太慢，有时候还会出现无法连接的情况。如果希望体验更好一些，可以使用国内的Git托管服务——码云（gitee.com）。&lt;br&gt;
与GitHub相比，码云也提供免费的Git仓库。此外，还集成了代码质量检测、项目演示等功能。对于团队协作开发，码云还提供了项目管理、代码托管、文档管理的服务。本章中使用的远程Git仓库是码云。&lt;br&gt;
码云访问地址：https://gitee.com/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;创建远程仓库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先要使用码云上的私有远程git仓库需要先注册帐号；请先自行访问网站并注册帐号，然后使用帐号登录码云控制台并创建公开仓库。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;创建配置文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在新建的仓库中创建需要被统一配置管理的配置文件。&lt;br&gt;
配置文件的命名方式：{application}-{proﬁle}.yml 或 {application}-{proﬁle}.properties&lt;br&gt;
application为应用名称&lt;br&gt;
proﬁle用于区分开发环境，测试环境、生产环境等&lt;br&gt;
如user-dev.yml，表示用户微服务开发环境下使用的配置文件。&lt;br&gt;
这里将user-service工程的配置文件application.yml文件的内容复制作为user-dev.yml文件的内容，具体配置如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;58&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200803171438.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;创建 user-dev.yml ；内容来自 user-service\src\main\resources\application.yml （方便后面测试user-service项目的配置），可以如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;server:
  port: ${port:9091}
spring:
  datasource:
    driver-class-name: com.mysql.jdbc.Driver
    url: jdbc:mysql://localhost:3306/springcloud
    username: root
    password: root
  application:
    #应用名
    name: user-service
mybatis:
  type-aliases-package: com.itheima.user.pojo
eureka:
  client:
    service-url:
      defaultZone: http://127.0.0.1:10086/eureka
  instance:
  	ip-address: 127.0.0.1
    	prefer-ip-address: true
    	lease-expiration-duration-in-seconds: 90
    	lease-renewal-interval-in-seconds: 30
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;59&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200803171549.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;创建完user-dev.yml配置文件之后，gitee中的仓库如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;60&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200803171601.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;103-搭建配置中心微服务&#34;&gt;10.3 搭建配置中心微服务&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;创建工程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建配置中心微服务工程 config-server：&lt;/p&gt;
&lt;p&gt;添加依赖，修改config-server\pom.xml 如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot;
         xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
         xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 
http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;artifactId&amp;gt;heima-springcloud&amp;lt;/artifactId&amp;gt;
        &amp;lt;groupId&amp;gt;com.itheima&amp;lt;/groupId&amp;gt;
        &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;/parent&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;groupId&amp;gt;com.itheima&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;config-server&amp;lt;/artifactId&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-config-server&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;启动类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建配置中心工程config-server 的启动类；&lt;br&gt;
config-server\src\main\java\com\itheima\config\ConfigServerApplication.java 如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.itheima.config;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.config.server.EnableConfigServer;

@SpringBootApplication
@EnableConfigServer
public class ConfigServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(ConfigServerApplication.class, args);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;配置文件&lt;/strong&gt;&lt;br&gt;
创建配置中心工程config-server 的配置文件；&lt;br&gt;
config-server\src\main\resources\application.yml 如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;server:
  port: 12000
spring:
  application:
    name: config-server
  cloud:
    config:
      server:
        git:
          uri: https://gitee.com/liaojianbin/heima-config.git
eureka:
  client:
    service-url:
      defaultZone: http://127.0.0.1:10086/eureka
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意上述的 spring.cloud.conﬁg.server.git.uri 则是在码云创建的仓库地址；可修改为自己创建的仓库地址&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;启动测试&lt;/strong&gt;&lt;br&gt;
启动eureka注册中心和配置中心；然后访问http://localhost:12000/user-dev.yml ，查看能否输出在码云存储管理的user-dev.yml文件。并且可以在gitee上修改user-dev.yml然后刷新上述测试地址也能及时到最新数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;61&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200803171928.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;104-获取配置中心配置&#34;&gt;10.4 获取配置中心配置&lt;/h3&gt;
&lt;p&gt;前面已经完成了配置中心微服务的搭建，下面我们就需要改造一下用户微服务user-service ，配置文件信息不再由微服务项目提供，而是从配置中心获取。如下对user-service 工程进行改造。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;添加依赖&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在user-service 工程中的pom.xml文件中添加如下依赖：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;		&amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-config&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.1.1.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;修改配置&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;删除user-service 工程的user-service\src\main\resources\application.yml 文件（因为该文件从配置中心获取）&lt;/li&gt;
&lt;li&gt;创建user-service 工程user-service\src\main\resources\bootstrap.yml 配置文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;spring:
  cloud:
    config:
      # 与远程仓库中的配置文件的application保持一致
      name: user
      # 远程仓库中的配置文件的profile保持一致
      profile: dev
      # 远程仓库中的版本保持一致
      label: master
      discovery:
        # 使用配置中心
        enabled: true
        # 配置中心服务id
        service-id: config-server
eureka:
  client:
    service-url:
      defaultZone: http://127.0.0.1:10086/eureka
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;bootstrap.yml文件也是Spring Boot的默认配置文件，而且其加载的时间相比于application.yml更早。&lt;br&gt;
application.yml和bootstrap.yml虽然都是Spring Boot的默认配置文件，但是定位却不相同。bootstrap.yml可以理解成系统级别的一些参数配置，这些参数一般是不会变动的。application.yml 可以用来定义应用级别的参数，如果搭配 spring cloud conﬁg 使用，application.yml 里面定义的文件可以实现动态替换。&lt;/p&gt;
&lt;p&gt;总结就是，bootstrap.yml文件相当于项目启动时的引导文件，内容相对固定。application.yml文件是微服务的一些常规配置参数，变化比较频繁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;启动测试&lt;/strong&gt;&lt;br&gt;
启动注册中心eureka-server 、配置中心config-server 、用户服务user-service ，如果启动没有报错其实已经使用上配置中心内容，可以到注册中心查看，也可以检验user-service 的服务。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;62&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200803172413.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;11-spring-cloud-bus服务总线&#34;&gt;11、Spring Cloud Bus服务总线&lt;/h2&gt;
&lt;h3 id=&#34;111-问题&#34;&gt;11.1 问题&lt;/h3&gt;
&lt;p&gt;前面已经完成了将微服务中的配置文件集中存储在远程Git仓库，并且通过配置中心微服务从Git仓库拉取配置文件，当用户微服务启动时会连接配置中心获取配置信息从而启动用户微服务。&lt;br&gt;
如果我们更新Git仓库中的配置文件，那用户微服务是否可以及时接收到新的配置信息并更新呢？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;修改远程Git配置&lt;/strong&gt;&lt;br&gt;
修改在码云上的user-dev.yml文件，添加一个属性test.name。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;63&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200803172557.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;修改UserController&lt;/strong&gt;&lt;br&gt;
修改user-service 工程中的处理器类；&lt;br&gt;
user-service\src\main\java\com\itheima\user\controller\UserController.java 如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.itheima.user.controller;

import com.itheima.user.pojo.User;
import com.itheima.user.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping(&amp;quot;/user&amp;quot;)
public class UserController {
        @Autowired
    private UserService userService;

    @Value(&amp;quot;${test.name}&amp;quot;)
    private String name;

    @GetMapping(&amp;quot;/{id}&amp;quot;)
    public User queryById(@PathVariable Long id){
        System.out.println(&amp;quot;配置文件中的test.name = &amp;quot; + name);
        return userService.queryById(id);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;测试&lt;/strong&gt;&lt;br&gt;
依次启动注册中心eureka-server 、配置中心config-server 、用户服务user-service ；然后修改Git仓库中的配置信息，访问用户微服务，查看输出内容。&lt;/p&gt;
&lt;p&gt;**结论：**通过查看用户微服务控制台的输出结果可以发现，我们对于Git仓库中配置文件的修改并没有及时更新到用户微服务，只有重启用户微服务才能生效。&lt;br&gt;
如果想在不重启微服务的情况下更新配置该如何实现呢? &lt;strong&gt;可以使用Spring Cloud Bus来实现配置的自动更新。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;需要注意的是Spring Cloud Bus底层是基于RabbitMQ实现的，默认使用本地的消息队列服务，所以需要提前启动本地RabbitMQ服务（安装RabbitMQ以后才有），如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;64&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200803172726.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;112-spring-cloud-bus简介&#34;&gt;11.2 Spring Cloud Bus简介&lt;/h3&gt;
&lt;p&gt;Spring Cloud Bus是用轻量的消息代理将分布式的节点连接起来，可以用于广播配置文件的更改或者服务的监控管理。也就是消息总线可以为微服务做监控，也可以实现应用程序之间相互通信。 Spring Cloud Bus可选的消息代理&lt;br&gt;
有RabbitMQ和Kafka。&lt;/p&gt;
&lt;p&gt;使用了Bus之后：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;65&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200803172800.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;113-改造配置中心&#34;&gt;11.3 改造配置中心&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在config-server 项目的pom.xml文件中加入Spring Cloud Bus相关依赖&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-bus&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-stream-binder-rabbit&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在config-server 项目修改application.yml文件如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;server:
  port: 12000
spring:
  application:
    name: config-server
  cloud:
    config:
      server:
        git:
          uri: https://gitee.com/liaojianbin/heima-config.git
  # rabbitmq的配置信息；如下配置的rabbit都是默认值，其实可以完全不配置
  rabbitmq:
    host: localhost
    port: 5672
    username: guest
    password: guest
eureka:
  client:
    service-url:
      defaultZone: http://127.0.0.1:10086/eureka
management:
  endpoints:
    web:
      exposure:
        # 暴露触发消息总线的地址
        include: bus-refresh
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;114-改造用户服务&#34;&gt;11.4  改造用户服务&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在用户微服务user-service 项目的pom.xml中加入Spring Cloud Bus相关依赖&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-bus&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-stream-binder-rabbit&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改user-service 项目的bootstrap.yml如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;spring:
  cloud:
    config:
      # 与远程仓库中的配置文件的application保持一致
      name: user
      # 远程仓库中的配置文件的profile保持一致
      profile: dev
      # 远程仓库中的版本保持一致
      label: master
      discovery:
        # 使用配置中心
        enabled: true
        # 配置中心服务id
        service-id: config-server
  # rabbitmq的配置信息；如下配置的rabbit都是默认值，其实可以完全不配置
  rabbitmq:
    host: localhost
    port: 5672
    username: guest
    password: guest
eureka:
  client:
    service-url:
      defaultZone: http://127.0.0.1:10086/eureka
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;改造用户微服务user-service 项目的UserController&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;66&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200803173237.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;115-测试&#34;&gt;11.5 测试&lt;/h3&gt;
&lt;p&gt;前面已经完成了配置中心微服务和用户微服务的改造，下面来测试一下，当我们修改了Git仓库中的配置文件，用户微服务是否能够在不重启的情况下自动更新配置信息。&lt;br&gt;
&lt;strong&gt;测试步骤：&lt;/strong&gt;&lt;br&gt;
第一步：依次启动注册中心eureka-server 、配置中心config-server 、用户服务user-service&lt;br&gt;
第二步：访问用户微服务http://localhost:9091/user/8；查看IDEA控制台输出结果&lt;/p&gt;
&lt;p&gt;第三步：修改Git仓库中配置文件user-dev.yml 的test.name 内容&lt;br&gt;
第四步：使用Postman或者RESTClient工具发送POST方式请求访问地址http://127.0.0.1:12000/actuator/bus-refresh&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;67&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200803173322.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;第五步：访问用户微服务系统控制台查看输出结果&lt;/p&gt;
&lt;p&gt;说明：&lt;br&gt;
1、Postman或者RESTClient是一个可以模拟浏览器发送各种请求（POST、GET、PUT、DELETE等）的工具&lt;br&gt;
2、请求地址http://127.0.0.1:12000/actuator/bus-refresh中 /actuator是固定的，/bus-refresh对应的是配置中心conﬁg-server中的application.yml文件的配置项include的内容&lt;br&gt;
3、请求http://127.0.0.1:12000/actuator/bus-refresh地址的作用是访问配置中心的消息总线服务，消息总线服务接收到请求后会向消息队列中发送消息，各个微服务会监听消息队列。当微服务接收到队列中的消息后，会重新从配置中心获取最新的配置信息。&lt;/p&gt;
&lt;h3 id=&#34;116-spring-cloud-体系技术综合应用概览&#34;&gt;11.6 Spring Cloud 体系技术综合应用概览&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;68&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200803173833.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;12-思维导图&#34;&gt;12、思维导图&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;69&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200803174547.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">SpringCloud</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jonchan1013.github.io/post/spring-session/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200724102425.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;1-httpsession-回顾&#34;&gt;1、HttpSession 回顾&lt;/h2&gt;
&lt;h3 id=&#34;11-什么是-httpsession&#34;&gt;1.1  什么是 HttpSession&lt;/h3&gt;
&lt;p&gt;是JavaWeb 服务端提供的用来建立与客户端会话状态的对象。&lt;/p&gt;
&lt;!-- more --&gt;
">Spring Session</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jonchan1013.github.io/post/logstash_kibana/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200723030527.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;1-logstash-简介&#34;&gt;1、LogStash 简介&lt;/h2&gt;
&lt;h3 id=&#34;11-什么是logstash&#34;&gt;1.1 什么是LogStash&lt;/h3&gt;
&lt;p&gt;官方文字说明：Logstash 是开源的服务器端数据处理管道，能够同时从多个来源采集数据，转换数据，然后将数据发送到您最喜欢的“存储库”中。&lt;br&gt;
通俗说明：Logstash 是一款强大的数据处理工具，常用作日志处理。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200723030716.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
到目前为止，Logstash 已经有超过 200 个可用的插件，以及创建和贡献自己的灵活性。社区生态非常完善，对于我们可以放心的使用。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200724091204.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;12-为什么使用logstash&#34;&gt;1.2 为什么使用Logstash&lt;/h3&gt;
&lt;p&gt;通常当系统发生故障时，工程师需要登录到各个服务器上，使用 grep / sed / awk 等Linux 脚本工具去日志里查找故障原因。在没有日志系统的情况下，首先需要定位处理请求的服务器，如果这台服务器部署了多个实例，则需要去每个应用实例的日志目录下去找日志文件。每个应用实例还会设置日志滚动策略（如：每天生成一个文件），还有日志压缩归档策略等。&lt;/p&gt;
&lt;p&gt;这样一系列流程下来，对于我们排查故障以及及时找到故障原因，造成了比较大的麻烦。因此，如果我们能***把这些日志集中管理***，并提供集中检索功能，不仅可以提高诊断的效率，同时对系统情况有个全面的理解，避免事后救火的被动。&lt;br&gt;
所以日志集中管理功能就可以使用 ELK 技术栈进行实现。Elasticsearch 只有数据存储和分析的能力，Kibana 就是可视化管理平台。还缺少数据收集和整理的角色，这个功能就是Logstash 负责的。&lt;/p&gt;
&lt;h3 id=&#34;13-logstash-工作原理&#34;&gt;1.3  Logstash 工作原理&lt;/h3&gt;
&lt;h4 id=&#34;131-data-source&#34;&gt;1.3.1 Data Source&lt;/h4&gt;
&lt;p&gt;Logstash 支持的数据源有很多。例如对于日志功能来说只能能有日志记录和日志传递功能的日志都支持，Spring Boot 中默认推荐 logback 支持日志输出功能（输出到数据库、数据出到文件）。&lt;br&gt;
我们就使用 logback 进行日志输出给 Logstash。&lt;/p&gt;
&lt;h4 id=&#34;132-logstash-pipeline&#34;&gt;1.3.2 Logstash Pipeline&lt;/h4&gt;
&lt;p&gt;整个整体就是 Logstash 的功能。&lt;br&gt;
在 Logstash 中包含非常重要的三个功能：&lt;br&gt;
a) Input&lt;br&gt;
输入源，一般配置为自己监听的主机及端口。DataSource 向指定的 ip 及端口输出日志，Input 输入源监听到数据信息就可以进行收集。&lt;br&gt;
b) Filter&lt;br&gt;
过滤功能，对收集到的信息进行过滤（额外处理），也可以省略这个配置（不做处理）&lt;br&gt;
c) Output&lt;br&gt;
把收集到的信息发送给谁。在 ELK 技术栈中都是输出给 Elasticsearch，后面数据检索和数据分析的过程就给 Elasticsearch 了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最终效果：通过整体步骤就可以把原来一行日志信息转换为 Elasticsearch 支持的Document 形式（键值对形式）的数据进行存储。&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200724091938.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;2-安装logstash&#34;&gt;2、安装Logstash&lt;/h2&gt;
&lt;p&gt;前面已经安装好了 Elasticsearch 和 Kibana。下面是安装 Logstash 的步骤&lt;br&gt;
Logstash 是不需要必须和 Elasticsearch 安装到一起，如果独立安装到一台服务器，需要在服务器中先配置好 JDK 环境变量。在课堂中把 ELK 三个软件都装到一台服务器中。&lt;/p&gt;
&lt;h3 id=&#34;21-安装logstash&#34;&gt;2.1 安装Logstash&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;上传 Logstash 并解压&lt;/p&gt;
&lt;p&gt;上传压缩包到/usr/local/tmp 中后，解压压缩包。&lt;/p&gt;
&lt;p&gt;tar zxf logstash-6.8.4.tar.gz&lt;/p&gt;
&lt;p&gt;剪切到/usr/local 中并命名为 logstash&lt;/p&gt;
&lt;p&gt;mv logstash-6.8.4 ../logstash&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进入到 logstash 配置文件夹中&lt;/p&gt;
&lt;p&gt;cd /usr/local/logstash/config/&lt;/p&gt;
&lt;p&gt;创建配置文件，名称自定义。&lt;/p&gt;
&lt;p&gt;vim mylogstash.conf&lt;/p&gt;
&lt;p&gt;配置解释说明：&lt;br&gt;
input:接收日志输入配置&lt;br&gt;
tcp: 协议&lt;br&gt;
mode: logstash 服务&lt;br&gt;
host:logstash 主机 ip&lt;br&gt;
port：端口，自己指定。默认 4560&lt;br&gt;
output：日志处理输出&lt;br&gt;
elasticsearch: 交给 es 处理&lt;br&gt;
action：es 中 index 命令。也就是新增命令。&lt;br&gt;
hosts：es 的主机&lt;br&gt;
index:存储日志的索引。如果不存在可以自动创建。默认的 type 名称为 doc&lt;br&gt;
一定要先启动编辑状态（点击键盘i 键）在粘贴，如果没启用第一行是nput{少个i。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;input {
		tcp {
			mode =&amp;gt; &amp;quot;server&amp;quot;
			host =&amp;gt; &amp;quot;192.168.8.140&amp;quot;
			port =&amp;gt; 4560
		}
}
filter {
}
output {
		elasticsearch {
			action =&amp;gt; &amp;quot;index&amp;quot;
			hosts =&amp;gt; &amp;quot;192.168.8.140:9200&amp;quot;
			index =&amp;gt; &amp;quot;test_log&amp;quot;
		}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动 Logstash&lt;br&gt;
进入到 bin 目录&lt;/p&gt;
&lt;p&gt;cd /usr/local/logstash/bin&lt;/p&gt;
&lt;p&gt;需要先启动 Elasticsearch 否则会频繁提示无法连接到 Elasticsearch&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200724092726.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;启动 logstash&lt;/p&gt;
&lt;p&gt;./logstash -f /usr/local/logstash/config/mylogstash.conf&lt;/p&gt;
&lt;p&gt;如果启动完成没有出异常，提示 Successfully 说明安装成功。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200724092738.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-使用logback-向logstash-中输出日志&#34;&gt;3、使用Logback 向Logstash 中输出日志&lt;/h2&gt;
&lt;p&gt;需求：随意新建一个项目把输出到控制台的日志信息也输出到 Logstash 中。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;修改pom.xml&lt;br&gt;
logstash-logback-encoder 就是转码后向 logstash 中输入的依赖。&lt;br&gt;
注意：&lt;/p&gt;
&lt;p&gt;如果导入的是 6.x 版本不会在控制台看见任何额外日志信息。&lt;br&gt;
如果导入的是 5.x 版本会在控制台看见 logback.xml 加载的信息。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;parent&amp;gt;
	&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;2.2.6.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/parent&amp;gt;
&amp;lt;dependencies&amp;gt;
	&amp;lt;dependency&amp;gt;
		&amp;lt;groupId&amp;gt;net.logstash.logback&amp;lt;/groupId&amp;gt;
		&amp;lt;artifactId&amp;gt;logstash-logback-encoder&amp;lt;/artifactId&amp;gt;
		&amp;lt;version&amp;gt;6.3&amp;lt;/version&amp;gt;
	&amp;lt;/dependency&amp;gt;
	&amp;lt;dependency&amp;gt;
		&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
		&amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
	&amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;导入logback.xml&lt;br&gt;
将logback.xml文件粘贴到 resources 中。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200724093405.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;logback.xml 文件内容如下，红色部分表示向 logstash 中输出日志信息。&lt;br&gt;
红色中&lt;destination&gt;配置的是 logstash 配置文件中 input 里面 host 和 post 的信息。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!--该日志将日志级别不同的 log 信息保存到不同的文件中 --&amp;gt;
&amp;lt;configuration&amp;gt;
    &amp;lt;include resource=&amp;quot;org/springframework/boot/logging/logback/defaults.xml&amp;quot;&amp;gt;&amp;lt;/include&amp;gt;
    &amp;lt;springProperty scope=&amp;quot;context&amp;quot; name=&amp;quot;egoSearchLogback&amp;quot; source=&amp;quot;spring.application.name&amp;quot;/&amp;gt;

    &amp;lt;!-- 日志在工程中的输出位置 --&amp;gt;
    &amp;lt;property name=&amp;quot;EGO-LOG-APPENDER&amp;quot; value=&amp;quot;%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){faint} %clr(${LOG_LEVEL_PATTERN:-%5p}) %clr(${PID:- }){magenta} %clr(---){faint} %clr([%15.15t]){faint} %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;!-- 控制台的日志输出样式 --&amp;gt;
    &amp;lt;appender name=&amp;quot;consoleAppender&amp;quot; class=&amp;quot;ch.qos.logback.core.ConsoleAppender&amp;quot;&amp;gt;
        &amp;lt;filter class=&amp;quot;ch.qos.logback.classic.filter.ThresholdFilter&amp;quot;&amp;gt;
            &amp;lt;level&amp;gt;INFO&amp;lt;/level&amp;gt;
        &amp;lt;/filter&amp;gt;
        &amp;lt;encoder&amp;gt;
            &amp;lt;pattern&amp;gt;${EGO-LOG-APPENDER}&amp;lt;/pattern&amp;gt;
            &amp;lt;charset&amp;gt;utf8&amp;lt;/charset&amp;gt;
        &amp;lt;/encoder&amp;gt;
    &amp;lt;/appender&amp;gt;
    &amp;lt;!-- logstash 输出 --&amp;gt;
    &amp;lt;appender name=&amp;quot;logstashAppender&amp;quot; class=&amp;quot;net.logstash.logback.appender.LogstashTcpSocketAppender&amp;quot;&amp;gt;
        &amp;lt;destination&amp;gt;192.168.89.141:5044&amp;lt;/destination&amp;gt;
        &amp;lt;!-- 日志输出编码 --&amp;gt;
        &amp;lt;encoder charset=&amp;quot;UTF-8&amp;quot; class=&amp;quot;net.logstash.logback.encoder.LogstashEncoder&amp;quot;&amp;gt;&amp;lt;/encoder&amp;gt;
    &amp;lt;/appender&amp;gt;
    &amp;lt;!-- logstash 远程日志配置--&amp;gt;
&amp;lt;appender name=&amp;quot;logstash&amp;quot;
class=&amp;quot;net.logstash.logback.appender.LogstashTcpSocketAppender&amp;quot;&amp;gt;
&amp;lt;destination&amp;gt;192.168.8.140:4560&amp;lt;/destination&amp;gt;
&amp;lt;encoder charset=&amp;quot;UTF-8&amp;quot;
class=&amp;quot;net.logstash.logback.encoder.LogstashEncoder&amp;quot; /&amp;gt;
&amp;lt;/appender&amp;gt;
    &amp;lt;root level=&amp;quot;DEBUG&amp;quot;&amp;gt;
        &amp;lt;appender-ref ref=&amp;quot;consoleAppender&amp;quot;/&amp;gt;
        &amp;lt;appender-ref ref=&amp;quot;logstashAppender&amp;quot;/&amp;gt;
    &amp;lt;/root&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新建启动类&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;新建 com.cy.DemoApplication&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SpringBootApplication
public class DemoApplication {
	public static void main(String[] args) {
		SpringApplication.run(DemoApplication.class,args);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-在kibana-中查看日志信息&#34;&gt;4、在Kibana 中查看日志信息&lt;/h2&gt;
&lt;h3 id=&#34;41-使用命令方式查看&#34;&gt;4.1 使用命令方式查看&lt;/h3&gt;
&lt;p&gt;可以直接在 Dev Tools 中输入命令查看日志信息。&lt;br&gt;
输入： GET test_log/_search 查看全部。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200724094359.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;42-是kibana-界面查看&#34;&gt;4.2  是Kibana 界面查看&lt;/h3&gt;
&lt;p&gt;进入到 Kibana 后按图所示点击。创建索引表达式&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200724094419.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;选择没有时间过滤后，点击“Create index pattern”按钮&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200724094434.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;点击菜单中 Discover，选择右侧 test_log&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200724094507.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;每条日志在 Elasticsearch 中存储形式&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200724094920.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;IDEA 中控制台打印的原日志内容是下面内容。Logstash 作用就是把下面内容转换为上面Elasticsearch 存储的内容。在中间做了数据格式转换，收集数据放入 Elasticsearch 中的工作。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200724094935.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;5-搭建日志系统&#34;&gt;5、搭建日志系统&lt;/h2&gt;
&lt;p&gt;绝大多数项目在后台管理中都有日志管理。以前的日志信息是存储在 MySQL 中，日志随着项目运行时间会越来越多，一直存储在 MySQL 会导致查询降低。现在的日志信息通过ELK 技术栈进行操作。存储在 Elasticsearch 中，可以更好的分析日志内容及更快查询效率。&lt;/p&gt;
&lt;p&gt;给定简单需求：&lt;br&gt;
搭建日志系统，提供查询 Elasticsearch 中日志信息的接口。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;新建项目&lt;br&gt;
名称为 ELK_Demo&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改pom.xml&lt;br&gt;
搭建最基本的环境，实现需求，没有考虑 Spring Cloud 相关环境，如果考虑 Spring Cloud还需要配置 Eureka 等信息。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependencyManagement&amp;gt;
    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-dependencies&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.2.5.RELEASE&amp;lt;/version&amp;gt;
            &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
            &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
&amp;lt;/dependencyManagement&amp;gt;

&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-data-elasticsearch&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;创建配置文件&lt;br&gt;
在 resources 下新建 application.yml 配置文件。&lt;br&gt;
配置 Elasticsearch 相关配置信息。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;elasticsearch:
  rest:  # 配置ElasticsearchRestTemplate客户端的属性，是现在推荐使用的。
    uris:
      - http://192.168.89.140:9200
      - http://192.168.89.141:9200
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新建实体&lt;br&gt;
根据 kibana 中查看到日志信息可以得出看出，除了 message 是类类型，里面包含一些其他属性外，其他的属性都是简单类型属性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200724095948.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;新建 com.cy.pojo.Log。&lt;/p&gt;
&lt;p&gt;注意@version 和@timestamp 要使用@JsonProperty 进行接收。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Data
@Document(indexName = &amp;quot;test_log&amp;quot;,type = &amp;quot;doc&amp;quot;)
public class Log {
	@Id
	private String id;
	@Field(type= FieldType.Text)
	private String host;
	@Field(type= FieldType.Text)
	private String message;
	@Field(type= FieldType.Long)
	private Long port;
	@Field(type = FieldType.Date)
	@JsonProperty(&amp;quot;@timestamp&amp;quot;)
	private Date timestamp;
	@Field(type = FieldType.Text)
	@JsonProperty(&amp;quot;@version&amp;quot;)
	private String version;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;
&lt;p&gt;新建service 及实现类&lt;/p&gt;
&lt;p&gt;新建 com.cy.service.LogService 及实现类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface LogService {
    List&amp;lt;Log&amp;gt; selectByPage(int page,int size);
}

------------------------------------------------
    @Service
public class LogServiceImpl implements LogService {
	@Autowired
	private ElasticsearchTemplate elasticsearchTemplate;
	@Override
	public List&amp;lt;Log&amp;gt; selectByPage(int page, int size) {
		SearchQuery sq = new NativeSearchQuery(QueryBuilders.matchAllQuery());
		sq.setPageable(PageRequest.of(page-1,size));
		return elasticsearchTemplate.queryForList(sq,Log.class);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新建控制器&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;新建 com.cy.controller.LogController&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Controller
public class LogController {
	@Autowired
	private LogService logService;
	@RequestMapping(&amp;quot;/page&amp;quot;)
	@ResponseBody
	public List&amp;lt;Log&amp;gt; showPage(int page,int size){
		return logService.selectByPage(page,size);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;
&lt;p&gt;测试结果&lt;/p&gt;
&lt;p&gt;在浏览器输入: http://localhost:8080/page?page=1&amp;amp;size=2&lt;/p&gt;
&lt;p&gt;会看见下面的结果。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200724100358.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;6-logstashmysqlelasticsearch-实现数据增量导入双写一致&#34;&gt;6、LogStash+MySQL+Elasticsearch 实现数据增量导入（双写一致）&lt;/h2&gt;
&lt;p&gt;原有系统中，如果使用了缓存应用，全文搜索服务等额外数据存储，则在代码实现中，要保证双写一致，即写数据库的同时，把数据的变量同步到其他存储中。&lt;br&gt;
如果使用 LogStash，则可以实现数据的增量导入。&lt;br&gt;
思路：写数据到数据库，LogStash 监听数据库中数据的变化，把增量数据读取，并保存到 ES 中。&lt;/p&gt;
&lt;h3 id=&#34;61-环境准备&#34;&gt;6.1 环境准备&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;上传数据库驱动&lt;br&gt;
LogStash 本身不提供数据库驱动，需要使用者提供数据库的驱动包，且 LogStash 中的数据库 JDBC 插件就是 Java 开发的。需要上传数据库驱动到 LogStash 所在主机。&lt;br&gt;
Logstash5.x &amp;amp; 6.3.*以下版本，上传驱动不需要固定位置，任意位置即可。&lt;br&gt;
Logstash6.8.4 版本的上传位置固定是：$LogStash_HOME/logstash_core/lib/jars/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;准备数据库表格&lt;br&gt;
案例中使用电商项目中的商品表格，建表语句如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;CREATE TABLE `tb_item` (
`id` bigint(20) NOT NULL COMMENT &#39;商品 id，同时也是商品编号&#39;,
`title` varchar(100) NOT NULL COMMENT &#39;商品标题&#39;,
`sell_point` varchar(500) DEFAULT NULL COMMENT &#39;商品卖点&#39;,
`price` bigint(20) NOT NULL COMMENT &#39;商品价格，单位为：分&#39;,
   `num` int(10) NOT NULL COMMENT &#39;库存数量&#39;,
`barcode` varchar(30) DEFAULT NULL COMMENT &#39;商品条形码&#39;,
`image` varchar(500) DEFAULT NULL COMMENT &#39;商品图片&#39;,
`cid` bigint(10) NOT NULL COMMENT &#39;所属类目，叶子类目&#39;,
`status` tinyint(4) NOT NULL DEFAULT &#39;1&#39; COMMENT &#39;商品状态，1-正常，2-下架，3-删除&#39;,
`created` datetime NOT NULL COMMENT &#39;创建时间&#39;,
`updated` datetime NOT NULL COMMENT &#39;更新时间&#39;,
PRIMARY KEY (`id`),
KEY `cid` (`cid`),
KEY `status` (`status`),
KEY `updated` (`updated`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#39;商品表&#39;; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;LogStash 实现增量导入，需要有一个定位字段，这个字段的数据，可以表示数据的新旧，代表这个数据是否是一个需要导入到 ES 中的数据。案例中使用表格的 updated 字段作为定位字段，每次读取数据的时候，都会记录一个最大的 updated 时间，每次读取数据的时候，都读取 updated 大于等于记录的定位字段数据。每次查询的就都是最新的，要导入到 ES 中的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;62-编写logstash-配置文件&#34;&gt;6.2 编写LogStash 配置文件&lt;/h3&gt;
&lt;p&gt;在$LogStash_home/config/目录中，编写配置文件 ego-items-db2es.conf&lt;br&gt;
vim config/ego-items-db2es.conf&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;input {
  jdbc {
	# 连接地址
    jdbc_connection_string =&amp;gt; &amp;quot;jdbc:mysql://192.168.1.2:3306/ego?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=GMT%2B8&amp;quot;
	
	# 数据库用户名和密码
    jdbc_user =&amp;gt; &amp;quot;root&amp;quot;
    jdbc_password =&amp;gt; &amp;quot;root&amp;quot;

	# 驱 动 类 ， 如 果 使 用 低 版 本 的 logstash ， 需 要 再 增 加 配 置jdbc_driver_library，配置驱动包所在位置
    jdbc_driver_class =&amp;gt; &amp;quot;com.mysql.cj.jdbc.Driver&amp;quot;
	# 是否开启分页逻辑
    jdbc_paging_enabled =&amp;gt; true
	# 分页的长度是多少
    jdbc_page_size =&amp;gt; &amp;quot;2000&amp;quot;
	# 时区
    jdbc_default_timezone =&amp;gt; &amp;quot;Asia/Shanghai&amp;quot;

	# 执行的 SQL
    statement =&amp;gt; &amp;quot;select id, title, sell_point, price, image, updated from tb_item where updated &amp;gt;= :sql_last_value order by updated asc&amp;quot;

	# 执行 SQL 的周期， [秒] 分钟 小时 天 月 年
    schedule =&amp;gt; &amp;quot;* * * * *&amp;quot;
	# 是否使用字段的值作为比较策略
    use_column_value =&amp;gt; true
	# 作为比较策略的字段名称
    tracking_column =&amp;gt; &amp;quot;updated&amp;quot;
	# 作为比较策略的字段类型，可选为 numberic 和 timestamp
    tracking_column_type =&amp;gt; &amp;quot;timestamp&amp;quot;
	# 记录最近的比较策略字段值的文件是什么，相对寻址路径是 logstash 的安装路径
    last_run_metadata_path =&amp;gt; &amp;quot;./ego-items-db2es-last-value&amp;quot;
	# 是否每次执行 SQL 的时候，都删除 last_run_metadata_path 文件内容
    clean_run =&amp;gt; false
	# 是否强制把 ES 中的字段名都定义为小写。
    lowercase_column_names =&amp;gt; false
  }
}

output {
  elasticsearch {
    hosts =&amp;gt; [&amp;quot;http://192.168.89.140:9200&amp;quot;, &amp;quot;http://192.168.89.141:9200&amp;quot;]
    index =&amp;gt; &amp;quot;ego-items-index&amp;quot;
    action =&amp;gt; &amp;quot;index&amp;quot;
    document_id =&amp;gt; &amp;quot;%{id}&amp;quot;
  }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;63-安装logstash-input-jdbc-插件&#34;&gt;6.3  安装logstash-input-jdbc 插件&lt;/h3&gt;
&lt;p&gt;在 LogStash6.3.x 和 5.x 版本中，logstash-input-jdbc 插件是默认安装的。在 6.8.4 版本的LogStash 中是未安装的，需要手工安装。安装命令如下：&lt;br&gt;
$Logstash_HOME/bin/logstash-plugin install logstash-input-jdbc&lt;/p&gt;
&lt;h3 id=&#34;64-启动测试&#34;&gt;6.4 启动测试&lt;/h3&gt;
&lt;p&gt;启动 LogStash 命令不变：&lt;br&gt;
bin/logstash -f 配置文件&lt;/p&gt;
">Logstash_Kibana</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jonchan1013.github.io/post/elasticsearch/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200719014000.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;1-什么是-elastic-search&#34;&gt;1、什么是 Elastic Search&lt;/h2&gt;
&lt;p&gt;ElasticSearch 是一个基于 Lucene 的搜索服务器。它提供了一个分布式的全文搜索引擎，其对外服务是基于 RESTful web 接口发布的。Elasticsearch 是用 Java 开发的应用，并作为 Apache 许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到近实时搜索，稳定，可靠，快速，安装使用方便。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;11-相关概念&#34;&gt;1.1 相关概念&lt;/h3&gt;
&lt;h4 id=&#34;111-cluster&#34;&gt;1.1.1  cluster&lt;/h4&gt;
&lt;p&gt;集群。ElasticSearch 集群由一或多个节点组成，其中有一个主节点，这个主节点是可以通过选举产生的，主从节点是对于集群内部来说的。ElasticSearch 的一个概念就是去中心化，字面上理解就是无中心节点，这是对于集群外部来说的，因为从外部看 ElasticSearch集群，在逻辑上是个整体，你与集群中的任何一个节点通信和与整个 ElasticSearch 集群通信是等价的。也就是说，主节点的存在不会产生单点安全隐患、并发访问瓶颈等问题。&lt;/p&gt;
&lt;h4 id=&#34;112-shards&#34;&gt;1.1.2 shards&lt;/h4&gt;
&lt;p&gt;primary shard：代表索引的主分片，ElasticSearch 可以把一个完整的索引分成多个primary shard，这样的好处是可以把一个大的索引拆分成多个分片，分布存储在不同的ElasticSearch 节点上，从而形成分布式存储，并为搜索访问提供分布式服务，提高并发处理能。primary shard 的数量只能在索引创建时指定，并且索引创建后不能再更改 primaryshard 数量。&lt;/p&gt;
&lt;h4 id=&#34;113-replicas&#34;&gt;1.1.3 replicas&lt;/h4&gt;
&lt;p&gt;replica shard：代表索引主分片的副本，ElasticSearch 可以设置多个 replica shard。replica shard 的作用：一是提高系统的容错性，当某个节点某个 primary shard 损坏或丢失时可以从副本中恢复。二是提高 ElasticSearch 的查询效率，ElasticSearch 会自动对搜索请求进行负载均衡，将并发的搜索请求发送给合适的节点，增强并发处理能力。&lt;/p&gt;
&lt;h4 id=&#34;114-index&#34;&gt;1.1.4  Index&lt;/h4&gt;
&lt;p&gt;索引。相当于关系型数据库中的表。其中存储若干相似结构的 Document 数据。如：客户索引，订单索引，商品索引等。ElasticSearch 中的索引不像数据库表格一样有强制的数据结构约束，在理论上，可以存储任意结构的数据。但了为更好的为业务提供搜索数据支撑，还是要设计合适的索引体系来存储不同的数据。&lt;/p&gt;
&lt;h4 id=&#34;115-type&#34;&gt;1.1.5 Type&lt;/h4&gt;
&lt;p&gt;类型。每个索引中都必须有唯一的一个 Type，Type 是 Index 中的一个逻辑分类。ElasticSearch 中的数据 Document 是存储在索引下的 Type 中的。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;注 意 ： ElasticSearch5.x 及 更 低 版 本 中 ， 一 个 Index 中 可 以 有 多 个 Type 。ElasticSearch6.x 版本之后，type 概念被弱化，一个 index 中只能有唯一的一个 type。且在 7.x 版本之后，删除 type 定义。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h4 id=&#34;116-document&#34;&gt;1.1.6  Document&lt;/h4&gt;
&lt;p&gt;文档。ElasticSearch 中的最小数据单元。一个 Document 就是一条数据，一般使用JSON 数据结构表示。每个 Index 下的 Type 中都可以存储多个 Document。一个 Document中可定义多个 field，field 就是数据字段。如：学生数据（{&amp;quot;name&amp;quot;:&amp;quot;张三&amp;quot;, &amp;quot;age&amp;quot;:20,&amp;quot;gender&amp;quot;:&amp;quot;男&amp;quot;}）。&lt;/p&gt;
&lt;h4 id=&#34;117-反向索引倒排索引&#34;&gt;1.1.7 反向索引|倒排索引&lt;/h4&gt;
&lt;p&gt;对数据进行分析，抽取出数据中的词条，以词条作为 key，对应数据的存储位置作为value，实现索引的存储。这种索引称为倒排索引。倒排索引是 Document 写入 ElasticSearch时分析维护的。&lt;/p&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;数据&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;商品主键&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;商品名&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;商品描述&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;荣耀 10&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;更贵的手机&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;荣耀 8&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;相对便宜的手机&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;IPHONE X&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;要卖肾买的手机&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200720091147.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;12-elasticsearch-常见使用场景&#34;&gt;1.2 ElasticSearch 常见使用场景&lt;/h3&gt;
&lt;p&gt;维基百科：全文检索，高亮显示，搜索推荐&lt;/p&gt;
&lt;p&gt;The Guardian（国外的一个新闻网站），此平台可以对用户的行为（点击、浏览、收藏、评论）、社区网络数据（对新闻的评论等）进行数据分析，为新闻的发布者提供相关的公众反馈。&lt;/p&gt;
&lt;p&gt;Stack Overflow（国外的程序异常讨论论坛）&lt;/p&gt;
&lt;p&gt;Github（开源代码管理），在千亿级别的代码行中搜索信息&lt;/p&gt;
&lt;p&gt;电子商务平台等。&lt;/p&gt;
&lt;h3 id=&#34;13-为什么不用数据库做搜索&#34;&gt;1.3 为什么不用数据库做搜索？&lt;/h3&gt;
&lt;h4 id=&#34;131-查询语法复杂度高&#34;&gt;1.3.1  查询语法复杂度高。&lt;/h4&gt;
&lt;p&gt;如：电商系统中搜索商品数据 - select * from products where name like &#39;%关键字%&#39; and price bewteen xxx and yyy and ......。不同的用户提供的查询条件不同，需要提供的动态 SQL 过于复杂。&lt;/p&gt;
&lt;h4 id=&#34;132-关键字索引不全面搜索结果不符合要求&#34;&gt;1.3.2 关键字索引不全面，搜索结果不符合要求&lt;/h4&gt;
&lt;p&gt;如：电商系统中查询商品数据，条件为商品名包含&#39;笔记本电脑&#39;。那么对此关键字的分析结果为-笔记本、电脑、笔记等。对应的查询语法应该为 - select * from products where name like &#39;%笔记本%&#39; or name like &#39;%电脑%&#39; .......&lt;/p&gt;
&lt;h4 id=&#34;133-效率问题&#34;&gt;1.3.3 效率问题&lt;/h4&gt;
&lt;p&gt;数据量越大，查询反应效率越低。&lt;/p&gt;
&lt;h2 id=&#34;2-linux-安装-elasticsearch&#34;&gt;2、Linux 安装 ElasticSearch&lt;/h2&gt;
&lt;p&gt;使用的 ElasticSearch 的版本是 6.8.4。ElasticSearch6.x 要求 Linux 内核必须是 3.5+版本以上。&lt;/p&gt;
&lt;p&gt;在 linux 操作系统中，查看内核版本的命令是： uname -a&lt;/p&gt;
&lt;p&gt;课堂使用的 Linux 是 CentOS8。内核使用的是 4.4。&lt;/p&gt;
&lt;p&gt;ElasticSearch6.X 版本要求 JDK 版本至少是 1.8.0_131。 提供 1.8.0_161JDK 安装包。&lt;/p&gt;
&lt;h3 id=&#34;21-为-elasticsearch-提供完善的系统配置&#34;&gt;2.1  为 ElasticSearch 提供完善的系统配置&lt;/h3&gt;
&lt;p&gt;ElasticSearch 在 Linux 中安装部署的时候，需要系统为其提供若干系统配置。如：应用可启动的线程数、应用可以在系统中划分的虚拟内存、应用可以最多创建多少文件等。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;修改限制信息&lt;br&gt;
vi /etc/security/limits.conf&lt;/p&gt;
&lt;p&gt;是修改系统中允许应用最多创建多少文件等的限制权限。Linux 默认来说，一般限制应用最多创建的文件是 65535 个。但是 ElasticSearch 至少需要 65536 的文件创建权限。修改后的内容为：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;* soft nofile 65536&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;* hard nofile 65536&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改线程开启限制&lt;br&gt;
在 CentOS6.5 版本中编辑下述的配置文件&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;vi /etc/security/limits.d/90-nproc.conf&lt;/p&gt;
&lt;p&gt;在 CentOS7+版本中编辑配置文件是：&lt;/p&gt;
&lt;p&gt;vi /etc/security/limits.conf&lt;/p&gt;
&lt;p&gt;是修改系统中允许用户启动的进程开启多少个线程。默认的 Linux 限制 root 用户开启的进程可以开启任意数量的线程，其他用户开启的进程可以开启 1024 个线程。必须修改限制数为 4096+。因为 ElasticSearch 至少需要 4096 的线程池预备。ElasticSearch 在 5.x版本之后，强制要求在 linux 中不能使用 root 用户启动 ElasticSearch 进程。所以必须使用其他用户启动 ElasticSearch 进程才可以。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;* soft nproc 4096&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;root soft nproc unlimited&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;注意：Linux 低版本内核为线程分配的内存是 128K。4.x 版本的内核分配的内存更大。如果虚拟机的内存是 1G，最多只能开启 3000+个线程数。至少为虚拟机分配 1.5G 以上的内存。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;修改系统控制权限&lt;br&gt;
CentOS6.5 中的配置文件为：&lt;/p&gt;
&lt;p&gt;vi /etc/sysctl.conf&lt;/p&gt;
&lt;p&gt;CentOS8 中的配置文件为：&lt;/p&gt;
&lt;p&gt;vi /etc/sysctl.d/99-sysctl.conf&lt;/p&gt;
&lt;p&gt;系统控制文件是管理系统中的各种资源控制的配置文件。ElasticSearch 需要开辟一个65536 字节以上空间的虚拟内存。Linux 默认不允许任何用户和应用直接开辟虚拟内存。&lt;/p&gt;
&lt;p&gt;新增内容为：&lt;/p&gt;
&lt;p&gt;vm.max_map_count=655360&lt;/p&gt;
&lt;p&gt;使用命令： sysctl -p 。 让系统控制权限配置生效。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;22-安装-elasticsearch&#34;&gt;2.2 安装 ElasticSearch&lt;/h3&gt;
&lt;p&gt;ElasticSearch 是 java 开发的应用。在 6.8.4 版本中，要求 JDK 至少是 1.8.0_131 版本以上。&lt;/p&gt;
&lt;p&gt;ElasticSearch 的安装过程非常简单。解压立刻可以使用。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;解压缩安装压缩包&lt;br&gt;
tar -zxf elasticsearch-6.8.4.tar.gz&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;移动 ElasticSearch&lt;br&gt;
mv elasticsearch-6.8.4 /usr/local/elasticsearch/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 ElasticSearch 应用的所有者&lt;br&gt;
因为 ElasticSearch 不允许 root 用户启动，而课堂案例中，ElasticSearch 是 root 用户 解 压 缩 的 。 所 以 解 压 后 的 ElasticSearch 应 用 属 于 root 用 户 。 所 以 我 们 需 要 将ElasticSearch 应用的所有者修改为其他用户。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;chown -R user.user  /usr/local/elasticsearch&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;
&lt;p&gt;切换用户&lt;/p&gt;
&lt;p&gt;su user&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改配置&lt;br&gt;
修改 config/elasticsearch 的配置文件，设置可访问的客户端。0.0.0.0 代表任意客户端访问。&lt;/p&gt;
&lt;p&gt;vi config/elasticsearch.yml&lt;/p&gt;
&lt;p&gt;增加下述内容：&lt;/p&gt;
&lt;p&gt;network.host: 0.0.0.0&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动&lt;br&gt;
前台启动&lt;/p&gt;
&lt;p&gt;/usr/local/elasticsearch/bin/elasticsearch&lt;/p&gt;
&lt;p&gt;关闭： ctrl + c&lt;/p&gt;
&lt;p&gt;后台启动&lt;/p&gt;
&lt;p&gt;/usr/local/elasticsearch/bin/elasticsearch -d&lt;/p&gt;
&lt;p&gt;关闭：&lt;/p&gt;
&lt;p&gt;jps 命令查看 ElasticSearch 线程的编号&lt;/p&gt;
&lt;p&gt;kill -9 ElasticSearch 线程编号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;测试连接&lt;br&gt;
curl http://localhost:9200&lt;/p&gt;
&lt;p&gt;返回如下结果：&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;&amp;quot;name&amp;quot; : &amp;quot;L6WdN7y&amp;quot;,&lt;/p&gt;
&lt;p&gt;&amp;quot;cluster_name&amp;quot; : &amp;quot;elasticsearch&amp;quot;,&lt;/p&gt;
&lt;p&gt;&amp;quot;cluster_uuid&amp;quot; : &amp;quot;s7_GSd9YQnaH10VQBKCQ5w&amp;quot;,&lt;/p&gt;
&lt;p&gt;&amp;quot;version&amp;quot; : {&lt;/p&gt;
&lt;p&gt;&amp;quot;number&amp;quot; : &amp;quot;6.3.1&amp;quot;,&lt;/p&gt;
&lt;p&gt;&amp;quot;build_flavor&amp;quot; : &amp;quot;default&amp;quot;,&lt;/p&gt;
&lt;p&gt;&amp;quot;build_type&amp;quot; : &amp;quot;tar&amp;quot;,&lt;/p&gt;
&lt;p&gt;&amp;quot;build_hash&amp;quot; : &amp;quot;eb782d0&amp;quot;,&lt;/p&gt;
&lt;p&gt;&amp;quot;build_date&amp;quot; : &amp;quot;2019-06-29T21:59:26.107521Z&amp;quot;,&lt;/p&gt;
&lt;p&gt;&amp;quot;build_snapshot&amp;quot; : false,&lt;/p&gt;
&lt;p&gt;&amp;quot;lucene_version&amp;quot; : &amp;quot;7.3.1&amp;quot;,****&lt;/p&gt;
&lt;p&gt;&amp;quot;minimum_wire_compatibility_version&amp;quot; : &amp;quot;5.6.0&amp;quot;,&lt;/p&gt;
&lt;p&gt;&amp;quot;minimum_index_compatibility_version&amp;quot; : &amp;quot;5.0.0&amp;quot;&lt;/p&gt;
&lt;p&gt;},&lt;/p&gt;
&lt;p&gt;&amp;quot;tagline&amp;quot; : &amp;quot;You Know, for Search&amp;quot;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;23-搭建集群&#34;&gt;2.3 搭建集群&lt;/h3&gt;
&lt;p&gt;修改配置文件$elasticsearch_home/config/elasticsearch.yml&lt;/p&gt;
&lt;p&gt;增加配置：&lt;/p&gt;
&lt;p&gt;发现的节点 IP&lt;/p&gt;
&lt;p&gt;discovery.zen.ping.unicast.hosts: [&amp;quot;ip1&amp;quot;, &amp;quot;ip2&amp;quot;]&lt;/p&gt;
&lt;p&gt;最小集群数：常用计算公式 - 总数/2 + 1&lt;/p&gt;
&lt;p&gt;discovery.zen.minimum_master_nodes: min_nodes_count&lt;/p&gt;
&lt;h3 id=&#34;24-安装-kibana&#34;&gt;2.4 安装 Kibana&lt;/h3&gt;
&lt;p&gt;Kibana 是一个基于 WEB 的 ElasticSearch 管理控制台。现阶段安装 Kibana 主要是为了方便学习。&lt;/p&gt;
&lt;p&gt;在 Linux 中安装 Kibana 很方便。解压，启动即可。Kibana 要求的环境配置是小于ElasticSearch 的要求的。&lt;/p&gt;
&lt;p&gt;tar -zxf kibana-6.3.1-linux-x86_64.tar.gz&lt;/p&gt;
&lt;p&gt;修改 config/kibana.yml&lt;/p&gt;
&lt;p&gt;vi config/kibana.yml&lt;/p&gt;
&lt;p&gt;新增内容： server.host: &amp;quot;0.0.0.0&amp;quot;&lt;/p&gt;
&lt;p&gt;bin/kibana&lt;/p&gt;
&lt;p&gt;访问时，使用浏览器访问 http://192.168.2.119:5601/&lt;/p&gt;
&lt;h2 id=&#34;3-常用-elasticsearch-管理操作&#34;&gt;3、常用 ElasticSearch 管理操作&lt;/h2&gt;
&lt;h3 id=&#34;31-查看健康状态&#34;&gt;3.1 查看健康状态&lt;/h3&gt;
&lt;p&gt;GET _cat/health?v&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200721170056.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;status：green、yellow、red&lt;/p&gt;
&lt;p&gt;green：每个索引的 primary shard 和 replica shard 都是 active 的&lt;/p&gt;
&lt;p&gt;yellow：每个索引的 primary shard 都是 active 的，但部分的 replica shard 不是 active的&lt;/p&gt;
&lt;p&gt;red：不是所有的索引的 primary shard 都是 active 状态的。&lt;/p&gt;
&lt;h3 id=&#34;32-创建索引&#34;&gt;3.2 创建索引&lt;/h3&gt;
&lt;p&gt;命令语法：PUT 索引名{索引配置参数}&lt;/p&gt;
&lt;p&gt;index 名称必须是小写的，且不能以下划线&#39;_&#39;，&#39;-&#39;，&#39;+&#39;开头。&lt;/p&gt;
&lt;p&gt;在 ElasticSearch 中，默认的创建索引的时候，会分配 5 个 primary shard，并为每个primary shard 分配一个 replica shard（在 ES7 版本后，默认创建 1 个 primary shard）。在 ElasticSearch 中，默认的限制是：如果磁盘空间不足 15%的时候，不分配 replica shard。如果磁盘空间不足 5%的时候，不再分配任何的 primary shard。ElasticSearch 中对 shard的分布是有要求的。ElasticSearch 尽可能保证 primary shard 平均分布在多个节点上。Replica shard 会保证不和他备份的那个 primary shard 分配在同一个节点上。&lt;/p&gt;
&lt;p&gt;创建默认索引&lt;/p&gt;
&lt;p&gt;PUT test_index1&lt;/p&gt;
&lt;p&gt;创建索引时指定分片。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;PUT test_index2
{
	&amp;quot;settings&amp;quot;:{
		&amp;quot;number_of_shards&amp;quot; : 2,
		&amp;quot;number_of_replicas&amp;quot; : 1
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;33-修改索引&#34;&gt;3.3 修改索引&lt;/h3&gt;
&lt;p&gt;命令语法：PUT 索引名/&lt;em&gt;settings{索引配置参数}&lt;br&gt;
&lt;strong&gt;注意：索引一旦创建，primary shard 数量不可变化，可以改变 replica shard 数量。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;PUT test_index2/_settings
{
	&amp;quot;number_of_replicas&amp;quot; : 2
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;34-删除索引&#34;&gt;3.4  删除索引&lt;/h3&gt;
&lt;p&gt;命令语法：DELETE 索引名 1[, 索引名 2 ...]&lt;/p&gt;
&lt;p&gt;DELETE test_index1&lt;/p&gt;
&lt;h3 id=&#34;35-查看索引信息&#34;&gt;3.5  查看索引信息&lt;/h3&gt;
&lt;p&gt;GET _cat/indices?v&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200721171902.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;36-检查分片信息&#34;&gt;3.6 检查分片信息&lt;/h3&gt;
&lt;p&gt;查看索引的 shard 信息。&lt;/p&gt;
&lt;p&gt;GET _cat/shards?v&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200721171928.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;37-新增-document&#34;&gt;3.7 新增 Document&lt;/h3&gt;
&lt;p&gt;在索引中增加文档。在 index 中增加 document。&lt;/p&gt;
&lt;p&gt;ElasticSearch 有自动识别机制。如果增加的 document 对应的 index 不存在，自动创建 index；如果 index 存在，type 不存在，则自动创建 type。如果 index 和 type 都存在，则使用现有的 index 和 type。&lt;/p&gt;
&lt;h4 id=&#34;371-put-语法&#34;&gt;3.7.1 PUT 语法&lt;/h4&gt;
&lt;p&gt;此操作为手工指定 id 的 Document 新增方式。&lt;/p&gt;
&lt;p&gt;语法：PUT 索引名/类型名/唯一 ID{字段名:字段值}&lt;/p&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;PUT test_index/my_type/1
{
	&amp;quot;name&amp;quot;:&amp;quot;test_doc_01&amp;quot;,
	&amp;quot;remark&amp;quot;:&amp;quot;first test elastic search&amp;quot;,
	&amp;quot;order_no&amp;quot;:1
}

PUT test_index/my_type/2
{
	&amp;quot;name&amp;quot;:&amp;quot;test_doc_02&amp;quot;,
	&amp;quot;remark&amp;quot;:&amp;quot;second test elastic search&amp;quot;,
	&amp;quot;order_no&amp;quot;:2
}

PUT test_index/my_type/3
{
	&amp;quot;name&amp;quot;:&amp;quot;test_doc_03&amp;quot;,
	&amp;quot;remark&amp;quot;:&amp;quot;third test elastic search&amp;quot;,
	&amp;quot;order_no&amp;quot;:3
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200721172149.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如果使用 PUT 语法对同 id 的 Document 执行多次操作。是一种覆盖操作。如果需要ElasticSearch 辅助检查 PUT 的 Document 是否已存在，可以使用强制新增语法。使用强制新增语法时，如果 Document 的 id 在 ElasticSearch 中已存在，则会报错。（version conflict, document already exists）&lt;br&gt;
语法：&lt;/p&gt;
&lt;p&gt;PUT 索引名/类型名/唯一 ID/_create{字段名:字段值}&lt;/p&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;p&gt;PUT 索引名/类型名/唯一 ID?op_type=create{字段名:字段值}。&lt;/p&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;PUT test_index/my_type/1/_create
{
	&amp;quot;name&amp;quot;:&amp;quot;new_test_doc_01&amp;quot;,
	&amp;quot;remark&amp;quot;:&amp;quot;first test elastic search&amp;quot;,
	&amp;quot;order_no&amp;quot;:1
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;372-post-语法&#34;&gt;3.7.2 POST 语法&lt;/h4&gt;
&lt;p&gt;此操作为 ElasticSearch 自动生成 id 的新增 Document 方式。此语法格式和 PUT 请求的数据新增，只有唯一的区别，就是可以自动生成主键 id，其他的和 PUT 请求新增数据完全一致。&lt;/p&gt;
&lt;p&gt;语法：POST 索引名/类型名{字段名:字段值}&lt;/p&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;POST test_index/my_type
{
	&amp;quot;name&amp;quot;:&amp;quot;test_doc_04&amp;quot;,
	&amp;quot;remark&amp;quot;:&amp;quot;forth test elastic search&amp;quot;,
	&amp;quot;order_no&amp;quot;:4
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;38-查询-document&#34;&gt;3.8 查询 Document&lt;/h3&gt;
&lt;h4 id=&#34;381-get-id-单数据查询&#34;&gt;3.8.1 GET ID 单数据查询&lt;/h4&gt;
&lt;p&gt;语法：GET 索引名/类型名/唯一 ID&lt;/p&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;p&gt;GET test_index/my_type/1&lt;/p&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200721172429.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;382-get-_mget-批量查询&#34;&gt;3.8.2 GET _mget 批量查询&lt;/h4&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;批量查询可以提高查询效率。推荐使用（相对于单数据查询来说）。&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;
语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;GET _mget
{
	&amp;quot;docs&amp;quot; : [
	{
		&amp;quot;_index&amp;quot; : &amp;quot;索引名&amp;quot;,
		&amp;quot;_type&amp;quot; : &amp;quot;类型名&amp;quot;,
		&amp;quot;_id&amp;quot; : &amp;quot;唯一 ID 值&amp;quot;
	}, {}, {}
	]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;GET 索引名/_mget:
{
	&amp;quot;docs&amp;quot; : [
	{
		&amp;quot;_type&amp;quot; : &amp;quot;类型名&amp;quot;,
		&amp;quot;_id&amp;quot; : &amp;quot;唯一 ID 值&amp;quot;
	}, {}, {}
	]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;GET 索引名/类型名/_mget
{
	&amp;quot;docs&amp;quot; : [
	{
		&amp;quot;_id&amp;quot; : &amp;quot;唯一 ID 值&amp;quot;
	},
	{
		&amp;quot;_id&amp;quot; : &amp;quot;唯一 ID 值&amp;quot;
	}
	]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;39-修改-document&#34;&gt;3.9 修改 Document&lt;/h3&gt;
&lt;h4 id=&#34;391-替换-document全量替换&#34;&gt;3.9.1  替换 Document（全量替换）&lt;/h4&gt;
&lt;p&gt;和新增的 PUT|POST 语法是一致。&lt;/p&gt;
&lt;p&gt;PUT|POST 索引名/类型名/唯一 ID{字段名:字段值}&lt;br&gt;
本操作相当于覆盖操作。全量替换的过程中，ElasticSearch 不会真的修改 Document中的数据，而是标记 ElasticSearch 中原有的 Document 为 deleted 状态，再创建一个新的 Document 来存储数据，当 ElasticSearch 中的数据量过大时，ElasticSearch 后台回收 deleted 状态的 Document。&lt;br&gt;
如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;PUT test_index/my_type/1
{
	&amp;quot;name&amp;quot;:&amp;quot;new_test_doc_01&amp;quot;,
	&amp;quot;remark&amp;quot;:&amp;quot;first test elastic search&amp;quot;,
	&amp;quot;order_no&amp;quot;:1
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200722093619.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;392-更新-documentpartial-update&#34;&gt;3.9.2 更新 Document（partial update）&lt;/h4&gt;
&lt;p&gt;语法：POST 索引名/类型名/唯一 ID/_update{doc:{字段名:字段值}}&lt;/p&gt;
&lt;p&gt;只更新某 Document 中的部分字段。这种更新方式也是标记原有数据为 deleted 状态，创建一个新的 Document 数据，将新的字段和未更新的原有字段组成这个新的 Document，并创建。对比全量替换而言，只是操作上的方便，在底层执行上几乎没有区别。&lt;/p&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;POST test_index/my_type/1/_update
{
	&amp;quot;doc&amp;quot;:{
	&amp;quot;name&amp;quot;:&amp;quot; test_doc_01_for_update&amp;quot;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200722093937.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200722093949.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;310-删除-document&#34;&gt;3.10 删除 Document&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;ElasticSearch 中执行删除操作时，ElasticSearch 先标记 Document 为 deleted 状态，而不是直接物理删除。当 ElasticSearch 存储空间不足或工作空闲时，才会执行物理删除操作。标记为 deleted 状态的数据不会被查询搜索到。&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;
语法：DELETE 索引名/类型名/唯一 ID&lt;/p&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;DELETE test_index/my_type/1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200722094045.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;311-bulk-批量增删改&#34;&gt;3.11 bulk 批量增删改&lt;/h3&gt;
&lt;p&gt;使用 bulk 语法执行批量增删改。语法格式如下：&lt;/p&gt;
&lt;p&gt;POST _bulk&lt;br&gt;
{ &amp;quot;action_type&amp;quot; : { &amp;quot;metadata_name&amp;quot; : &amp;quot;metadata_value&amp;quot; } }&lt;br&gt;
{ document datas | action datas }&lt;/p&gt;
&lt;p&gt;语法中的 action_type 可选值为：&lt;br&gt;
create : 强制创建，相当于 PUT 索引名/类型名/唯一 ID/_create&lt;br&gt;
index: 普通的 PUT 操作，相当于创建 Document 或全量替换&lt;br&gt;
update: 更新操作（partial update）,相当于 POST 索引名/类型名/唯一 ID/_update&lt;br&gt;
delete: 删除操作&lt;/p&gt;
&lt;p&gt;案例如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;新增数据：
POST _bulk
{ &amp;quot;create&amp;quot; : { &amp;quot;_index&amp;quot; : &amp;quot;test_index&amp;quot; , &amp;quot;_type&amp;quot; : &amp;quot;my_type&amp;quot;, &amp;quot;_id&amp;quot; : &amp;quot;1&amp;quot; } }
{ &amp;quot;field_name&amp;quot; : &amp;quot;field value&amp;quot; }

PUT 操作新增或全量替换
POST _bulk
{ &amp;quot;index&amp;quot; : { &amp;quot;_index&amp;quot; : &amp;quot;test_index&amp;quot;, &amp;quot;_type&amp;quot; : &amp;quot;my_type&amp;quot; , &amp;quot;_id&amp;quot; : &amp;quot;2&amp;quot; } }
{ &amp;quot;field_name&amp;quot; : &amp;quot;field value 2&amp;quot; }

POST 更新数据
POST _bulk
{ &amp;quot;update&amp;quot; : { &amp;quot;_index&amp;quot; : &amp;quot;test_index&amp;quot;, &amp;quot;_type&amp;quot; : &amp;quot;my_type&amp;quot; , &amp;quot;_id&amp;quot; : 2, &amp;quot;_retry_on_conflict&amp;quot; : 3 } }
{ &amp;quot;doc&amp;quot; : { &amp;quot;field_name&amp;quot; : &amp;quot;partial update field value&amp;quot; } }

DELETE 删除数据
POST _bulk
{ &amp;quot;delete&amp;quot; : { &amp;quot;_index&amp;quot; : &amp;quot;test_index&amp;quot;, &amp;quot;_type&amp;quot; : &amp;quot;my_type&amp;quot;, &amp;quot;_id&amp;quot; : &amp;quot;2&amp;quot; } }

批量写操作
POST _bulk
{ &amp;quot;create&amp;quot; : { &amp;quot;_index&amp;quot; : &amp;quot;test_index&amp;quot; , &amp;quot;_type&amp;quot; : &amp;quot;my_type&amp;quot;, &amp;quot;_id&amp;quot; : &amp;quot;10&amp;quot; } }
{ &amp;quot;field_name&amp;quot; : &amp;quot;field value&amp;quot; }
{ &amp;quot;index&amp;quot; : { &amp;quot;_index&amp;quot; : &amp;quot;test_index&amp;quot;, &amp;quot;_type&amp;quot; : &amp;quot;my_type&amp;quot; , &amp;quot;_id&amp;quot; : &amp;quot;20&amp;quot; } }
{ &amp;quot;field_name&amp;quot; : &amp;quot;field value 2&amp;quot; }
{ &amp;quot;update&amp;quot; : { &amp;quot;_index&amp;quot; : &amp;quot;test_index&amp;quot;, &amp;quot;_type&amp;quot; : &amp;quot;my_type&amp;quot; , &amp;quot;_id&amp;quot; : 20, &amp;quot;_retry_on_conflict&amp;quot; : 3 } }
{ &amp;quot;doc&amp;quot; : { &amp;quot;field_name&amp;quot; : &amp;quot;partial update field value&amp;quot; } }
{ &amp;quot;delete&amp;quot; : { &amp;quot;_index&amp;quot; : &amp;quot;test_index&amp;quot;, &amp;quot;_type&amp;quot; : &amp;quot;my_type&amp;quot;, &amp;quot;_id&amp;quot; : &amp;quot;2&amp;quot; } }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;注意：bulk 语法中要求一个完整的 json 串不能有换行。不同的 json 串必须使用换行分隔。多个操作中，如果有错误情况，不会影响到其他的操作，只会在批量操作返回结果中标记失败。bulk 语法批量操作时，bulk request 会一次性加载到内存中，如果请求数据量太大，性能反而下降（内存压力过高），需要反复尝试一个最佳的 bulk request size。一般从 1000~5000 条数据开始尝试，逐渐增加。如果查看 bulk request size 的话，一般是 5~15MB 之间为好。&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;
&lt;em&gt;&lt;strong&gt;bulk 语法要求 json 格式是为了对内存的方便管理，和尽可能降低内存的压力。如果json 格式没有特殊的限制，ElasticSearch 在解释 bulk 请求时，需要对任意格式的 json进行解释处理，需要对 bulk 请求数据做 json 对象会 json array 对象的转化，那么内存的占用量至少翻倍，当请求量过大的时候，对内存的压力会直线上升，且需要 jvm gc 进程对垃圾数据做频繁回收，影响 ElasticSearch 效率。&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;
&lt;em&gt;&lt;strong&gt;生成环境中，bulk api 常用。都是使用 java 代码实现循环操作。一般一次 bulk 请求，执行一种操作。如：批量新增 10000 条数据等。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;4-分词器analyzer和标准化处理normalization&#34;&gt;4、分词器（analyzer）和标准化处理（normalization）&lt;/h2&gt;
&lt;h3 id=&#34;41-什么是分词器&#34;&gt;4.1 什么是分词器&lt;/h3&gt;
&lt;p&gt;分词器是一个字符串解析拆分工具。其作用是分析写入的 Document 中的文本数据field，并将 field 数据拆分成一个个有完整含义的、不可拆分的单词。&lt;/p&gt;
&lt;p&gt;如：I think dogs is human&#39;s best friend.在写入此数据的时候，ElasticSearch 会使用分词器分析并拆分数据，将上述的语句切分成若干的单词，分别是：I、 think、 dogs、human&#39;s、 best、 friend。&lt;/p&gt;
&lt;h3 id=&#34;42-什么是标准化处理&#34;&gt;4.2 什么是标准化处理&lt;/h3&gt;
&lt;p&gt;标准化处理是用于完善分词器结果的。&lt;/p&gt;
&lt;p&gt;分词器处理的文本结果，通常会有一些不需要的、有异议的、包含时态转化等情况的数据。在上述案例中的分词结果是：i、 think、 dogs、 human&#39;s、 best、 friend。其中i 是很少应用在搜索条件中的单词；dogs 是 dog 单词的复数形式，通常在搜索过程中使用dog 作为搜索条件更频繁一些；human&#39;s 是特殊的标记方式，通常不会在搜索中作为条件出现。那么 ElasticSearch 维护这些单词是没有太大必要的。这个时候就需要标准化处理了。&lt;/p&gt;
&lt;p&gt;如：china 搜索时，如果条件为 cn 是否可搜索到。如：dogs，搜索时，条件为 dog是否可搜索到数据。如果可以使用简写（cn）或者单复数（dog&amp;amp;dogs）搜索到想要的结果，那么称为搜索引擎人性化。&lt;/p&gt;
&lt;p&gt;normalization 是为了提升召回率的（recall），就是提升搜索能力的。&lt;/p&gt;
&lt;p&gt;normalization 是配合分词器(analyzer)完成其功能的。&lt;/p&gt;
&lt;h3 id=&#34;43-elasticsearch-默认提供的常见分词器&#34;&gt;4.3 ElasticSearch 默认提供的常见分词器&lt;/h3&gt;
&lt;p&gt;要切分的语句：Set the shape to semi-transparent by calling set_trans(5)&lt;br&gt;
standard analyzer - 是 ElasticSearch 中的默认分词器。标准分词器，处理英语语法的分词器。切分后的 key_words：set, the, shape, to, semi, transparent, by, calling,set_trans, 5。这种分词器也是 ElasticSearch 中默认的分词器。切分过程中不会忽略停止词（如：the、a、an 等）。会进行单词的大小写转换、过滤连接符（-）或括号等常见符号。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;GET _analyze
{
	&amp;quot;text&amp;quot;: &amp;quot;Set the shape to semi-transparent by calling set_trans(5)&amp;quot;,
	&amp;quot;analyzer&amp;quot;: &amp;quot;standard&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;simple analyzer - 简单分词器。切分后的 key_words：set, the, shape, to, semi,transparent, by, calling, set, trans。就是将数据切分成一个个的单词。使用较少，经常会破坏英语语法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;GET _analyze
{
	&amp;quot;text&amp;quot;: &amp;quot;Set the shape to semi-transparent by calling 	set_trans(5)&amp;quot;,
	&amp;quot;analyzer&amp;quot;: &amp;quot;simple&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;whitespace analyzer - 空白符分词器。切分后的 key_words：Set, the, shape, to,semi-transparent, by, calling, set_trans(5)。就是根据空白符号切分数据。如：空格、制表符等。使用较少，经常会破坏英语语法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;GET _analyze
{
	&amp;quot;text&amp;quot;: &amp;quot;Set the shape to semi-transparent by calling set_trans(5)&amp;quot;,
	&amp;quot;analyzer&amp;quot;: &amp;quot;whitespace&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;language analyzer - 语言分词器，如英语分词器（english）等。切分后的 key_words：set, shape, semi, transpar, call, set_tran, 5。根据英语语法分词，会忽略停止词、转换大小写、单复数转换、时态转换等，应用分词器分词功能类似 standard analyzer。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;GET _analyze
{
	&amp;quot;text&amp;quot;: &amp;quot;Set the shape to semi-transparent by calling set_trans(5)&amp;quot;,
	&amp;quot;analyzer&amp;quot;: &amp;quot;english&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;注意：ElasticSearch 中提供的常用分词器都是英语相关的分词器，对中文的分词都是一字一词。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&#34;44-安装中文分词器&#34;&gt;4.4  安装中文分词器&lt;/h3&gt;
&lt;p&gt;IK 中文分词器，很少有直接下载使用的，都需要通过 github 下载源码，本地编译打包。&lt;/p&gt;
&lt;p&gt;就是 maven 工程中的 package 能力。&lt;/p&gt;
&lt;p&gt;github 上提供的源码不是伴随 ES 的每个版本提供，一般只有分词器无效后，才提供新的版本。通常都是伴随 ES 的次版本号提供 IK 分词器版本。下载对应的 IK 分词器源码，本地 package 打包，生成 zip 压缩包，既是 IK 在 ES 中的分词器安装包。&lt;/p&gt;
&lt;p&gt;git clone https://github.com/medcl/elasticsearch-analysis-ik.git&lt;/p&gt;
&lt;p&gt;git checkout tags/v6.5.0&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安装 IK 分词器&lt;br&gt;
ElasticSearch 是一个开箱即用的工具。插件安装方式也非常简单。&lt;/p&gt;
&lt;p&gt;将 IK 分词器的 zip 压缩文件上传到 Linux，并在 ElasticSearch 安装目录的 plugins 目录中手工创建子目录，目录命名为 ik。将 zip 压缩文件解压缩到新建目录 ik 中。重新启动ElasticSearch 即可。&lt;/p&gt;
&lt;p&gt;复制中文分词器 zip 压缩文件到 ElasticSearch 应用目录中：&lt;/p&gt;
&lt;p&gt;cp elasticsearch-analysis-ik-6.8.4.zip /opt/es/plugins/&lt;/p&gt;
&lt;p&gt;创建 IK 中文分词器的插件子目录：&lt;/p&gt;
&lt;p&gt;mkdir /opt/es/plugins/ik/&lt;/p&gt;
&lt;p&gt;移动压缩文件到 ik 插件目录中：&lt;/p&gt;
&lt;p&gt;mv /opt/es/plugins/elasticsearch-analysis-ik-6.8.4.zip /usr/local/es/plugins/ik/&lt;/p&gt;
&lt;p&gt;解压缩：&lt;/p&gt;
&lt;p&gt;unzip /opt/es/plugins/ik/elasticsearch-analysis-ik-6.8.4.zip&lt;br&gt;
&lt;em&gt;&lt;strong&gt;所有的分词器，都是针对词语的，不是语句的。拆分单元是词语，不是语句。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;测试 IK 分词器&lt;br&gt;
IK 分词器提供了两种 analyzer，分别是 ik_max_word 和 ik_smart。&lt;br&gt;
&lt;em&gt;&lt;strong&gt;ik_max_word: 会将文本做最细粒度的拆分，比如会将“中华人民共和国国歌”拆分为“中华人民共和国,中华人民,中华,华人,人民共和国,人民,人,民,共和国,共和,国,国歌”，会穷尽各种可能的组合；&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;
&lt;em&gt;&lt;strong&gt;ik_smart: 会做最粗粒度的拆分，比如会将“中华人民共和国国歌”拆分为“中华人民共和国,国歌”。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;GET _analyze
{
	&amp;quot;text&amp;quot; : &amp;quot;中华人民共和国国歌&amp;quot;,
	&amp;quot;analyzer&amp;quot;: &amp;quot;ik_max_word&amp;quot;
}


GET _analyze
{
	&amp;quot;text&amp;quot; : &amp;quot;中华人民共和国国歌&amp;quot;,
	&amp;quot;analyzer&amp;quot;: &amp;quot;ik_smart&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IK 配置文件&lt;br&gt;
IK 的配置文件在 ElasticSearch 安装目录/plugins/ik/config/中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;配置文件有：&lt;/p&gt;
&lt;p&gt;main.dic ： IK 中内置的词典。 main dictionary。记录了 IK 统计的所有中文单词。一行一词。文件中未记录的单词，IK 无法实现有效分词。如：雨女无瓜。不建议修改当前文件中的单词。这个是最核心的中文单词库。就好像，很多的网络词不会收集到辞海中一样。&lt;/p&gt;
&lt;p&gt;quantifier.dic ： IK 内置的数据单位词典&lt;/p&gt;
&lt;p&gt;suffix.dic ：IK 内置的后缀词典&lt;/p&gt;
&lt;p&gt;surname.dic ：IK 内置的姓氏词典&lt;/p&gt;
&lt;p&gt;stopword.dic ：IK 内置的英文停用词&lt;/p&gt;
&lt;p&gt;preposition.dic ：IK 内置的中文停用词（介词）&lt;br&gt;
&lt;em&gt;&lt;strong&gt;IKAnalyzer.cfg.xml&lt;/strong&gt;&lt;/em&gt; ： 用于配置自定义词库的&lt;br&gt;
自定义词库是用户手工提供的特殊词典，类似网络热词，特定业务用词等。&lt;br&gt;
&lt;em&gt;&lt;strong&gt;ext_dict - 自定义词库，配置方式为相对于 IKAnalyzer.cfg.xml 文件所在位置的相对路径寻址方式。相当于是用户自定义的一个 main.dic 文件。是对 main.dic 文件的扩展。&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;
&lt;em&gt;&lt;strong&gt;ext_stopwords - 自定义停用词，配置方式为相对于 IKAnalyzer.cfg.xml 文件所在位置的相对路径寻址方式。相当于是 preposition.dic 的扩展。&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;
&lt;em&gt;&lt;strong&gt;注意：IK 的所有的 dic 词库文件，必须使用 UTF-8 字符集。不建议使用 windows 自带的文本编辑器编辑。Windows 中自带的文本编辑器是使用 GBK 字符集。IK 不识别，是乱码。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;5-elasticsearch-中的-mapping-问题&#34;&gt;5、 ElasticSearch 中的 mapping 问题&lt;/h2&gt;
&lt;p&gt;Mapping 在 ElasticSearch 中是非常重要的一个概念。决定了一个 index 中的 field 使用什么数据格式存储，使用什么分词器解析，是否有子字段等。&lt;/p&gt;
&lt;p&gt;Mapping 决定了 index 中的 field 的特征。&lt;/p&gt;
&lt;h3 id=&#34;51-mapping-核心数据类型&#34;&gt;5.1  mapping 核心数据类型&lt;/h3&gt;
&lt;p&gt;ElasticSearch 中的数据类型有很多，在这里只介绍常用的数据类型。&lt;/p&gt;
&lt;p&gt;文本（字符串）：text&lt;br&gt;
整数：byte、short、integer、long&lt;br&gt;
浮点型：float、double&lt;br&gt;
布尔类型：boolean&lt;br&gt;
日期类型：date&lt;br&gt;
数组类型：array {a:[]}&lt;br&gt;
对象类型：object {a:{}}&lt;br&gt;
不分词的字符串（关键字）： keyword&lt;/p&gt;
&lt;h3 id=&#34;52-dynamic-mapping-对字段的类型分配&#34;&gt;5.2 dynamic mapping 对字段的类型分配&lt;/h3&gt;
&lt;p&gt;true or false -&amp;gt; boolean&lt;br&gt;
123 -&amp;gt; long&lt;br&gt;
123.123 -&amp;gt; double&lt;br&gt;
2018-01-01 -&amp;gt; date&lt;br&gt;
hello world -&amp;gt; text&lt;br&gt;
[] -&amp;gt; array&lt;br&gt;
{} -&amp;gt; object&lt;br&gt;
在上述的自动 mapping 字段类型分配的时候，只有 text 类型的字段需要分词器。默认分词器是 standard 分词器。&lt;/p&gt;
&lt;h3 id=&#34;53-查看索引-mapping&#34;&gt;5.3 查看索引 mapping&lt;/h3&gt;
&lt;p&gt;可以通过命令查看已有 index 的 mapping 具体信息，语法如下：&lt;/p&gt;
&lt;p&gt;GET 索引名/_mapping&lt;/p&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;GET test_index/_mapping
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200722105155.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;54-custom-mapping&#34;&gt;5.4 custom mapping&lt;/h3&gt;
&lt;p&gt;可以通过命令，在创建 index 和 type 的时候来定制 mapping 映射，也就是指定字段的类型和字段数据使用的分词器。&lt;br&gt;
手工定制 mapping 时，只能***新增 mapping 设置，不能对已有的 mapping 进行修改。***&lt;br&gt;
如：有索引 a，其中有类型 b，增加字段 f1 的 mapping 定义。后续可以增加字段 f2的 mapping 定义，但是不能修改 f1 字段的 mapping 定义。&lt;/p&gt;
&lt;p&gt;通常都是手工创建 index，并进行各种定义。如：settings,mapping 等。&lt;/p&gt;
&lt;h4 id=&#34;541-创建索引时指定-mapping&#34;&gt;5.4.1 创建索引时指定 mapping&lt;/h4&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;PUT 索引名称
{
	&amp;quot;mappings&amp;quot;:{
		&amp;quot;类型名称&amp;quot;:{
			&amp;quot;properties&amp;quot;:{
				&amp;quot;字段名&amp;quot;:{
					&amp;quot;type&amp;quot;:类型,
					[&amp;quot;analyer&amp;quot;:字段的分词器,]
					[&amp;quot;fields&amp;quot;:{
						&amp;quot;子字段名称&amp;quot;:{
							&amp;quot;type&amp;quot;:类型,
							&amp;quot;ignore_above&amp;quot;:长度限制
							}
					}]
				}
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;PUT /test_index
{
	&amp;quot;settings&amp;quot;: {
		&amp;quot;number_of_shards&amp;quot;: 2,
		&amp;quot;number_of_replicas&amp;quot;: 1
},
	&amp;quot;mappings&amp;quot;: {
		&amp;quot;test_type&amp;quot;:{
			&amp;quot;properties&amp;quot;: {
				&amp;quot;author_id&amp;quot; : {
					&amp;quot;type&amp;quot;: &amp;quot;byte&amp;quot;,
					&amp;quot;index&amp;quot;: false
				},
			&amp;quot;title&amp;quot; : {
				&amp;quot;type&amp;quot;: &amp;quot;text&amp;quot;,
				&amp;quot;analyzer&amp;quot;: &amp;quot;ik_max_word&amp;quot;,
				&amp;quot;fields&amp;quot;: {
					&amp;quot;keyword&amp;quot; : {
					&amp;quot;type&amp;quot;: &amp;quot;keyword&amp;quot;,
					&amp;quot;ignore_above&amp;quot;: 256
					}
				}
			},
			&amp;quot;content&amp;quot; : {
				&amp;quot;type&amp;quot;: &amp;quot;text&amp;quot;,
                  &amp;quot;analyzer&amp;quot;: &amp;quot;ik_max_word&amp;quot;
			},
			&amp;quot;post_date&amp;quot; : {
				&amp;quot;type&amp;quot;: &amp;quot;date&amp;quot;
			}
		}
	}
}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;quot;index&amp;quot; - 是否可以作为搜索索引。可选值：true | false&lt;/p&gt;
&lt;p&gt;&amp;quot;analyzer&amp;quot; - 指定分词器。&lt;/p&gt;
&lt;p&gt;&amp;quot;type&amp;quot; - 指定字段类型&lt;/p&gt;
&lt;h4 id=&#34;542-为已有索引添加新的字段-mapping&#34;&gt;5.4.2 为已有索引添加新的字段 mapping&lt;/h4&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;PUT 索引名/_mapping/类型名
{
	&amp;quot;properties&amp;quot;:{
		&amp;quot;新字段名&amp;quot;:{
			&amp;quot;type&amp;quot;:类型,
			&amp;quot;analyer&amp;quot;:字段的分词器,
			&amp;quot;fields&amp;quot;:{
				&amp;quot;子字段名&amp;quot;:{
					&amp;quot;type&amp;quot;:类型,
					&amp;quot;ignore_above&amp;quot;:长度
				}
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;PUT /test_index/_mapping/test_type
{
	&amp;quot;properties&amp;quot; : {
		&amp;quot;new_field&amp;quot; : { &amp;quot;type&amp;quot; : &amp;quot;text&amp;quot; , &amp;quot;analyzer&amp;quot; : &amp;quot;standard&amp;quot; }
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;543-测试不同的字段的分词器&#34;&gt;5.4.3 测试不同的字段的分词器&lt;/h4&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;GET 索引名称/_analyze
{
	&amp;quot;field&amp;quot;:&amp;quot;索引中的 text 类型的字段名&amp;quot;,
	&amp;quot;text&amp;quot;:&amp;quot;要分词处理的文本数据&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用索引中的字段对应的分词器，对文本数据做分词处理。&lt;/p&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;GET /test_index/_analyze
{
	&amp;quot;field&amp;quot;: &amp;quot;new_field&amp;quot;,
	&amp;quot;text&amp;quot;: &amp;quot;中华人民共和国国歌&amp;quot;
}

GET /test_index/_analyze
{
	&amp;quot;field&amp;quot;: &amp;quot;content&amp;quot;,
	&amp;quot;text&amp;quot;: &amp;quot;中华人民共和国国歌&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;6-search-搜索详解&#34;&gt;6、 Search 搜索详解&lt;/h2&gt;
&lt;h3 id=&#34;61-搜索学习测试数据&#34;&gt;6.1 搜索学习测试数据&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;PUT test_search
{
	&amp;quot;mappings&amp;quot;: {
		&amp;quot;test_type&amp;quot; : {
			&amp;quot;properties&amp;quot;: {
				&amp;quot;dname&amp;quot; : {
					&amp;quot;type&amp;quot; : &amp;quot;text&amp;quot;,
					&amp;quot;analyzer&amp;quot;: &amp;quot;standard&amp;quot;
				},
				&amp;quot;ename&amp;quot; : {
					&amp;quot;type&amp;quot; : &amp;quot;text&amp;quot;,
					&amp;quot;analyzer&amp;quot;: &amp;quot;standard&amp;quot;
				},
				&amp;quot;eage&amp;quot; : {
					&amp;quot;type&amp;quot;: &amp;quot;long&amp;quot;
				},
				&amp;quot;hiredate&amp;quot; : {
					&amp;quot;type&amp;quot;: &amp;quot;date&amp;quot;
				},
				&amp;quot;gender&amp;quot; : {
					&amp;quot;type&amp;quot; : &amp;quot;keyword&amp;quot;
				}
			}
		}
	}
}


POST test_search/test_type/_bulk
{ &amp;quot;index&amp;quot;: {}}
{ &amp;quot;dname&amp;quot; : &amp;quot;Sales Department&amp;quot;, &amp;quot;ename&amp;quot; : &amp;quot; 张 三 &amp;quot;, &amp;quot;eage&amp;quot;:20, &amp;quot;hiredate&amp;quot; : &amp;quot;2019-01-01&amp;quot;,&amp;quot;gender&amp;quot; : &amp;quot;男性&amp;quot; }
{ &amp;quot;index&amp;quot;: {}}
{ &amp;quot;dname&amp;quot; : &amp;quot;Sales Department&amp;quot;, &amp;quot;ename&amp;quot; : &amp;quot; 李 四 &amp;quot;, &amp;quot;eage&amp;quot;:21, &amp;quot;hiredate&amp;quot; : &amp;quot;2019-02-01&amp;quot;,&amp;quot;gender&amp;quot; : &amp;quot;男性&amp;quot; }
{ &amp;quot;index&amp;quot;: {}}
{ &amp;quot;dname&amp;quot; : &amp;quot;Development Department&amp;quot;, &amp;quot;ename&amp;quot; : &amp;quot; 王 五 &amp;quot;, &amp;quot;eage&amp;quot;:23, &amp;quot;hiredate&amp;quot; :&amp;quot;2019-01-03&amp;quot;, &amp;quot;gender&amp;quot; : &amp;quot;男性&amp;quot; }
{ &amp;quot;index&amp;quot;: {}}
{ &amp;quot;dname&amp;quot; : &amp;quot;Development Department&amp;quot;, &amp;quot;ename&amp;quot; : &amp;quot; 赵 六 &amp;quot;, &amp;quot;eage&amp;quot;:26, &amp;quot;hiredate&amp;quot; :&amp;quot;2018-01-01&amp;quot;, &amp;quot;gender&amp;quot; : &amp;quot;男性&amp;quot; }
{ &amp;quot;index&amp;quot;: {}}
{ &amp;quot;dname&amp;quot; : &amp;quot;Development Department&amp;quot;, &amp;quot;ename&amp;quot; : &amp;quot; 韩 梅 梅 &amp;quot;, &amp;quot;eage&amp;quot;:24, &amp;quot;hiredate&amp;quot; :&amp;quot;2019-03-01&amp;quot;, &amp;quot;gender&amp;quot; : &amp;quot;女性&amp;quot; }
{ &amp;quot;index&amp;quot;: {}}
{ &amp;quot;dname&amp;quot; : &amp;quot;Development Department&amp;quot;, &amp;quot;ename&amp;quot; : &amp;quot; 钱 虹 &amp;quot;, &amp;quot;eage&amp;quot;:29, &amp;quot;hiredate&amp;quot; :&amp;quot;2018-03-01&amp;quot;, &amp;quot;gender&amp;quot; : &amp;quot;女性&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;62-query-string-search&#34;&gt;6.2 query string search&lt;/h3&gt;
&lt;p&gt;search 的参数都是类似 http 请求头中的字符串参数提供搜索条件的。&lt;/p&gt;
&lt;p&gt;GET&lt;br&gt;
[/index_name/type_name/]_search[?parameter_name=parameter_value&amp;amp;...]&lt;/p&gt;
&lt;h4 id=&#34;621-全搜索&#34;&gt;6.2.1 全搜索&lt;/h4&gt;
&lt;p&gt;timeout 参数：是超时时长定义。代表每个节点上的每个 shard 执行搜索时最多耗时多久。不会影响响应的正常返回。只会影响返回响应中的数据数量。&lt;br&gt;
如：索引 a 中，有 10 亿数据。存储在 5 个 shard 中，假设每个 shard 中 2 亿数据，执行全数据搜索的时候，需要耗时 1000 毫秒。定义 timeout 为 10 毫秒，代表的是 shard执行 10 毫秒，搜索出多少数据，直接返回。&lt;br&gt;
在商业项目中，是禁止全数据搜索的。必须指定搜索的索引，类型和关键字。如果没有指定索引或类型，则代表开发目的不明确，需要重新做用例分析。如果没有关键字，称为索引内全搜索，也叫魔鬼搜索。&lt;/p&gt;
&lt;p&gt;语法：&lt;br&gt;
GET [索引名/类型名/]_search?timeout=10ms&lt;/p&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;{
	&amp;quot;took&amp;quot;: 144, #请求耗时多少毫秒
	&amp;quot;timed_out&amp;quot;: false, #是否超时。默认情况下没有超时机制，也就是客户端等待 ElasticSearch 搜索结束（无论执行多久），提供超时机制的话，ElasticSearch 则在指定时长内处理搜索，在指定时长结束的时候，将搜索的结果直接返回（无论是否搜索结束）。指定超时的方式是传递参数，参数单位是：毫秒-ms。秒-s。分钟-m。
	&amp;quot;_shards&amp;quot;: {
		&amp;quot;total&amp;quot;: 1, #请求发送到多少个 shard 上
		&amp;quot;successful&amp;quot;: 1,#成功返回搜索结果的 shard
		&amp;quot;skipped&amp;quot;: 0, #停止服务的 shard
		&amp;quot;failed&amp;quot;: 0 #失败的 shard
	},
	&amp;quot;hits&amp;quot;: {
		&amp;quot;total&amp;quot;: 1, #返回了多少结果
		&amp;quot;max_score&amp;quot;: 1, #搜索结果中，最大的相关度分数，相关度越大分数越高，_score 越大，排位越靠前。
		&amp;quot;hits&amp;quot;: [ #搜索到的结果集合，默认查询前 10 条数据。
		{
			&amp;quot;_index&amp;quot;: &amp;quot;test_index&amp;quot;, #数据所在索引
			&amp;quot;_type&amp;quot;: &amp;quot;my_type&amp;quot;, #数据所在类型
			&amp;quot;_id&amp;quot;: &amp;quot;1&amp;quot;, #数据的 id
			&amp;quot;_score&amp;quot;: 1, #数据的搜索相关度分数
			&amp;quot;_source&amp;quot;: { # 数据的具体内容。
				&amp;quot;field&amp;quot;: &amp;quot;value&amp;quot;
			}
		}
	]
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;622-multi-index-搜索&#34;&gt;6.2.2 multi index 搜索&lt;/h4&gt;
&lt;p&gt;所谓的 multi-index 就是从多个 index 中搜索数据。相对使用较少，只有在复合数据搜索的时候，可能出现。一般来说，如果真使用复合数据搜索，都会使用_all。&lt;br&gt;
如：搜索引擎中的无条件搜索。（现在的应用中都被屏蔽了。使用的是默认搜索条件，执行数据搜索。 如： 电商中的搜索框默认值， 搜索引擎中的类别）&lt;br&gt;
无条件搜索，在搜索应用中称为“魔鬼搜索”，代表的是，搜索引擎会执行全数据检索，效率极低，且对资源有非常高的压力。&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;GET _search
GET 索引名 1,索引名 2/_search # 搜索多个 index 中的数据
GET 索引名/类型名/_search # 所属一个 index 中 type 的数据
GET prefix_*/_search # 通配符搜索
GET *_suffix/_search
GET 索引名 1,索引名 2/类型名/_search # 搜索多个 index 中 type 的数据
GET _all/_search # _all 代表所有的索引
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;623-条件搜索&#34;&gt;6.2.3 条件搜索&lt;/h4&gt;
&lt;p&gt;query string search 搜索是通过 HTTP 请求的请求头传递参数的，默认的 HTTP 请求头字符集是 ISO-8859-1，请求头传递中文会有乱码。&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;GET 索引名/_search?q=字段名:搜索条件
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;624-分页搜索&#34;&gt;6.2.4  分页搜索&lt;/h4&gt;
&lt;p&gt;默认情况下，ElasticSearch 搜索返回结果是 10 条数据。从第 0 条开始查询。&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;GET 索引名/_search?size=10 # size 查询数据的行数

GET 索引名/_search?from=0&amp;amp;size=10 # from 从第几行开始查询，行号从 0 开始。
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;625-搜索&#34;&gt;6.2.5 +/-搜索&lt;/h4&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;GET 索引名/_search?q=字段名:条件

GET 索引名/_search?q=+字段名:条件

GET 索引名/_search?q=-字段名:条件
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;+ ：和不定义符号含义一样，就是搜索指定的字段中包含 key words 的数据&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;- ： 与+符号含义相反，就是搜索指定的字段中不包含 key words 的数据&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;626-排序&#34;&gt;6.2.6 排序&lt;/h4&gt;
&lt;p&gt;语法：GET 索引名/_search?sort=字段名:排序规则&lt;br&gt;
排序规则： asc(升序) | desc(降序)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;GET test_search/_search?sort=eage:asc
GET test_search/_search?sort=eage:desc
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;63-query-dsl&#34;&gt;6.3  query DSL&lt;/h3&gt;
&lt;p&gt;DSL - Domain Specified Language ， 特殊领域的语言。&lt;/p&gt;
&lt;p&gt;请求参数是请求体传递的。在 ElasticSearch 中，请求体的字符集默认为 UTF-8。&lt;/p&gt;
&lt;p&gt;语法格式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;GET 索引名/_search
{
	&amp;quot;command&amp;quot;:{ &amp;quot;parameter_name&amp;quot; : &amp;quot;parameter_value&amp;quot;}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;631-查询所有数据&#34;&gt;6.3.1 查询所有数据&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;GET 索引名/_search
{
	&amp;quot;query&amp;quot; : { &amp;quot;match_all&amp;quot; : {} }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;632-match-search&#34;&gt;6.3.2  match search&lt;/h4&gt;
&lt;p&gt;全文检索。要求查询条件拆分后的任意词条与具体数据匹配就算搜索结果。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;GET 索引名/_search
{
	&amp;quot;query&amp;quot;: {
		&amp;quot;match&amp;quot;: {
			&amp;quot;字段名&amp;quot;: &amp;quot;搜索条件&amp;quot;
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;633-phrase-search&#34;&gt;6.3.3 phrase search&lt;/h4&gt;
&lt;p&gt;短语检索。要求查询条件必须和具体数据完全匹配才算搜索结果。其特征是：1-搜索条件不做任何分词解析；2-在搜索字段对应的倒排索引(正排索引)中进行精确匹配，不再是简单的全文检索。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;GET 索引名/_search
{
	&amp;quot;query&amp;quot;: {
		&amp;quot;match_phrase&amp;quot;: {
			&amp;quot;字段名&amp;quot;: &amp;quot;搜索条件&amp;quot;
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;634-range&#34;&gt;6.3.4 range&lt;/h4&gt;
&lt;p&gt;范围比较搜索&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;GET 索引名/类型名/_search
{
	&amp;quot;query&amp;quot; : {
		&amp;quot;range&amp;quot; : {
			&amp;quot;字段名&amp;quot; : {
				&amp;quot;gt&amp;quot; : 搜索条件 1,
				&amp;quot;lte&amp;quot; : 搜索条件 2
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;635-term&#34;&gt;6.3.5 term&lt;/h4&gt;
&lt;p&gt;词组比较，词组搜索。&lt;/p&gt;
&lt;p&gt;忽略搜索条件分词，在 ElasticSearch 倒排索引中进行精确匹配。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;GET 索引名/类型名/_search
{
	&amp;quot;query&amp;quot; : {
		&amp;quot;term&amp;quot; : {
			&amp;quot;字段名&amp;quot;: &amp;quot;搜索条件&amp;quot;
		}
	}
}

GET 索引名/类型名/_search
{
	&amp;quot;query&amp;quot; : {
		&amp;quot;terms&amp;quot; : {
			&amp;quot;字段名&amp;quot;: [&amp;quot;搜索条件 1&amp;quot;, &amp;quot;搜索条件 2&amp;quot;]
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;636-多条件复合搜索&#34;&gt;6.3.6  多条件复合搜索&lt;/h4&gt;
&lt;p&gt;在一个请求体中，有多个搜索条件，就是复合搜索。如：搜索数据，条件为部门名称是Sales Department，员工年龄在 20 到 26 之间，部门员工姓名叫张三。上述条件中，部门名称为可选条件，员工年龄必须满足要求，部门员工姓名为可选要求。这种多条件搜索就是符合搜索。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;GET 索引名/类型名/_search
{
	&amp;quot;query&amp;quot;: {
		&amp;quot;bool&amp;quot;: {
			&amp;quot;must&amp;quot;: [ #数组中的多个条件必须同时满足
				{
					&amp;quot;range&amp;quot;: {
						&amp;quot;字段名&amp;quot;: {
						&amp;quot;lt&amp;quot;: 条件
						}
					}
				}
				],
			&amp;quot;must_not&amp;quot;:[ #数组中的多个条件必须都不满足
				{
					&amp;quot;match&amp;quot;: {
						&amp;quot;字段名&amp;quot;: &amp;quot;条件&amp;quot;
					}
				},
				{
					&amp;quot;range&amp;quot;: {
						&amp;quot;字段名&amp;quot;: {
							&amp;quot;gte&amp;quot;: &amp;quot;搜索条件&amp;quot;
						}
					}
				}
				]
			&amp;quot;should&amp;quot;: [# 数组中的多个条件有任意一个满足即可。
				{
					&amp;quot;match&amp;quot;: {
						&amp;quot;字段名&amp;quot;: &amp;quot;条件&amp;quot;
					}
				},
				{
					&amp;quot;range&amp;quot;: {
						&amp;quot;字段名&amp;quot;: {
							&amp;quot;gte&amp;quot;: &amp;quot;搜索条件&amp;quot;
       					 }
					}
				}
				]
			}
		}
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;637-排序&#34;&gt;6.3.7  排序&lt;/h4&gt;
&lt;p&gt;在 ElasticSearch 的搜索中，默认是使用相关度分数实现排序的。可以通过搜索语法实现定制化排序。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;GET 索引名/类型名/_search
{
	&amp;quot;query&amp;quot;: {
		[搜索条件]
	},
	&amp;quot;sort&amp;quot;: [
		{
			&amp;quot;字段名 1&amp;quot;: {
				&amp;quot;order&amp;quot;: &amp;quot;asc&amp;quot;
			}
		},
		{
			&amp;quot;字段名 2&amp;quot;: {
				&amp;quot;order&amp;quot;: &amp;quot;desc&amp;quot;
			}
		}
	]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;注意：在 ElasticSearch 中，如果使用 text 类型的字段作为排序依据，会有问题。ElasticSearch 需要对 text 类型字段数据做分词处理。如果使用 text 类型字段做排序，ElasticSearch 给出的排序结果未必友好，毕竟分词后，先使用哪一个单词做排序都是不合理的。所以 ElasticSearch 中默认情况下不允许使用 text 类型的字段做排序，如果需要使用字符串做结果排序，则可使用 keyword 类型字段作为排序依据，因为 keyword 字段不做分词处理。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h4 id=&#34;638-分页&#34;&gt;6.3.8 分页&lt;/h4&gt;
&lt;p&gt;DSL 分页也是使用 from 和 size 实现的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;GET 索引名称/_search
{
	&amp;quot;query&amp;quot;:{
		&amp;quot;match_all&amp;quot;:{}
	},
	&amp;quot;from&amp;quot;: 起始下标,
	&amp;quot;size&amp;quot;: 查询记录数
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;639-highlight-display&#34;&gt;6.3.9  highlight display&lt;/h4&gt;
&lt;p&gt;在搜索中，经常需要对搜索关键字做高亮显示，这个时候就可以使用 highlight 语法。&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;GET 索引名/_search
{
	&amp;quot;query&amp;quot;: {
		&amp;quot;match&amp;quot;: {
			&amp;quot;字段名&amp;quot;: &amp;quot;条件&amp;quot;
		}
	},
	&amp;quot;highlight&amp;quot;: {
		&amp;quot;fields&amp;quot;: {
			&amp;quot;要高亮显示的字段名&amp;quot;: {
				&amp;quot;fragment_size&amp;quot;: 5, #每个分段长度，默认 20
				&amp;quot;number_of_fragments&amp;quot;: 1 #返回多少个分段，默认 3
			}
		},
		&amp;quot;pre_tags&amp;quot;: [&amp;quot;前缀&amp;quot;],
		&amp;quot;post_tags&amp;quot;: [&amp;quot;后缀&amp;quot;]
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;演示案例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;GET test_search/_search
{
	&amp;quot;query&amp;quot;: {
		&amp;quot;bool&amp;quot;: {
			&amp;quot;should&amp;quot;: [
				{
					&amp;quot;match&amp;quot;: {
						&amp;quot;dname&amp;quot;: &amp;quot;Development department&amp;quot;
					}
				},
				{
					&amp;quot;match&amp;quot;: {
					&amp;quot;gender&amp;quot;: &amp;quot;男性&amp;quot;
				}
			}
		]
		}
	},
	&amp;quot;highlight&amp;quot;: {
		&amp;quot;fields&amp;quot;: {
			&amp;quot;dname&amp;quot;: {
				&amp;quot;fragment_size&amp;quot;: 20,
				&amp;quot;number_of_fragments&amp;quot;: 1
			},
			&amp;quot;gender&amp;quot;: {
				&amp;quot;fragment_size&amp;quot;: 20,
				&amp;quot;number_of_fragments&amp;quot;: 1
			}
		},
		&amp;quot;pre_tags&amp;quot;:[&amp;quot;&amp;lt;span style=&#39;color:red&#39;&amp;gt;&amp;quot;],
		&amp;quot;post_tags&amp;quot;:[&amp;quot;&amp;lt;/span&amp;gt;&amp;quot;]
	},
	&amp;quot;from&amp;quot;: 2,
	&amp;quot;size&amp;quot;: 2
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;fragment_size：代表字段数据如果过长，则分段，每个片段数据长度为多少。长度不是字符数量，是 ElasticSearch 内部的数据长度计算方式。默认不对字段做分段。number_of_fragments：代表搜索返回的高亮片段数量，默认情况下会将拆分后的所有片段都返回。&lt;/p&gt;
&lt;p&gt;pre_tags：高亮前缀&lt;/p&gt;
&lt;p&gt;post_tags：高亮后缀&lt;/p&gt;
&lt;p&gt;很多搜索结果显示页面中都不会显示完整的数据，这样在数据过长的时候会导致页面效果 不 佳 ， 都 会 按 照 某 一 个 固 定 长 度 来 显 示 搜 索 结 果 ， 所 以 fragment_size 和number_of_fragments 参数还是很常用的。&lt;/p&gt;
&lt;h2 id=&#34;7-spring-data-elasticsearch&#34;&gt;7、Spring Data ElasticSearch&lt;/h2&gt;
&lt;p&gt;使用 Spring Data 下二级子项目 Spring Data Elasticsearch 进行操作。支持 POJO 方法操作 Elasticsearch。相比 Elasticsearch 提供的 API 更加简单更加方便。&lt;/p&gt;
&lt;h3 id=&#34;71-修改-pom-文件添加依赖&#34;&gt;7.1 修改 POM 文件添加依赖&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;spring-boot-starter-data-elasticsearch&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;72-修改配置文件&#34;&gt;7.2 修改配置文件&lt;/h3&gt;
&lt;p&gt;集群版多地址之间使用逗号分隔。&lt;/p&gt;
&lt;p&gt;在 ElasticSearch5.x 以前的版本中，客户端使用的是 Transport 客户端，通过 TCP 协议和 9300 端口访问 ES。在 6.x 及之后的版本中，官方推荐使用 Rest 客户端，通过 Http协议和 9200 端口访问 ES。且在新版的 Spring Data Elasticsearch 框架中，Transport 客户端配置已经设置为过时配置，推荐使用 Rest 客户端。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;高版本新客户端&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;elasticsearch:
    rest: # 配置ElasticsearchRestTemplate客户端的属性，是现在推荐使用的。
      uris:
        - http://124.70.181.124:9200
        - http://124.70.181.124:9201
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;低版本常用客户端&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;spring:
  data:
    elasticsearch:
      cluster-name: elasticsearch # 必须提供的配置，集群的名称。
      cluster-nodes: 124.70.181.124:9300,124.70.181.124:9301 # transport客户端的端口是9300
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;73-创建实体&#34;&gt;7.3 创建实体&lt;/h3&gt;
&lt;p&gt;@Document 指定实体类和索引对应关系&lt;br&gt;
indexName：索引名称&lt;br&gt;
type: 索引类型&lt;br&gt;
shards: 主分片数量&lt;br&gt;
replicas：复制分片数量&lt;br&gt;
@Id 指定主键&lt;br&gt;
@Field 指定普通属性&lt;br&gt;
type： 对应 Elasticsearch 中属性类型。使用 FiledType 枚举可以快速获取。测试发现没有 type 属性可能出现无法自动创建类型问题，所以一定要有 type 属性。&lt;br&gt;
text 类型能被分词&lt;br&gt;
keywords 不能被分词&lt;br&gt;
index： 是否创建索引。作为搜索条件时 index 必须为 true&lt;br&gt;
analyzer：指定分词器类型。&lt;br&gt;
fielddata：指定是否为 text 类型字段创建正向索引。默认为 false，设置为 true则可以使用此字段排序。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 自定义类型，商品。
 * 让自定义的类型和ElasticSearch中的一个索引产生关联。
 *
 * Document - spring data elasticsearch提供的注解， 描述类型，说明类型和索引的关系。
 *  indexName - 对应的索引的名称。 必要属性。
 *  shards - 创建索引时，设置的主分片数量。 默认5
 *  replicas - 创建索引时，设置的副本分片数量。 默认1
 *  type - 对应的类型的名称。
 */
@Document(indexName = &amp;quot;ego_item2&amp;quot;,shards = 2,replicas = 1,type = &amp;quot;item&amp;quot;)
public class Item implements Serializable {
    /**
     * Id注解是Spring Data核心工程提供的，是所有的Spring Data二级子工程通用的。
     * 代表主键字段。
     */
    @Id
    private String id;
    /**
     * Field注解，描述实体类型中属性和ES索引中字段的关系。
     * 且可以为这个字段配置自定义映射mapping
     * 这个自定义映射必须通过代码逻辑调用设置映射的API才能生效。
     *  name - 索引中对应的字段名称，默认和属性同名。
     *  type - 索引中字段的类型，默认是FieldType.Auto，代表ES自动映射类型。
     *  analyzer - 字段的分词器名称，默认是standard。
     *  fielddata - 是否开启正向索引。默认关闭。
     *   默认只为文本类型的字段创建反向索引，提供快速搜索逻辑。
     *   fielddata设置为true，则会额外创建一个正向索引，支持排序。
     *  index - 是否创建默认的反向索引或正向索引。 text文本类型字段默认创建反向索引，其他创建正向索引。
     *   没有索引，就不能作为搜索条件。
     */
    @Field(name = &amp;quot;title&amp;quot;,type = FieldType.Text,analyzer = &amp;quot;ik_max_word&amp;quot;,fielddata = true)
    private String title; // 商品名称，需要中文分词，且偶尔需要排序， 常用搜索条件之一
    @Field(name = &amp;quot;sellPoint&amp;quot;,type = FieldType.Text,analyzer = &amp;quot;ik_max_word&amp;quot;)
    private String sellPoint; // 卖点， 需要中文分词， 常用搜索条件之一
    @Field(type = FieldType.Long)
    private Long price; // 单价
    @Field(type = FieldType.Integer,index = false)
    private int num; // 库存

    public Item() {
    }

    @Override
    public String toString() {
        return &amp;quot;Item{&amp;quot; +
                &amp;quot;Id=&#39;&amp;quot; + id + &#39;\&#39;&#39; +
                &amp;quot;, title=&#39;&amp;quot; + title + &#39;\&#39;&#39; +
                &amp;quot;, sellPoint=&#39;&amp;quot; + sellPoint + &#39;\&#39;&#39; +
                &amp;quot;, price=&amp;quot; + price +
                &amp;quot;, num=&amp;quot; + num +
                &#39;}&#39;;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Item item = (Item) o;
        return num == item.num &amp;amp;&amp;amp;
                Objects.equals(id, item.id) &amp;amp;&amp;amp;
                Objects.equals(title, item.title) &amp;amp;&amp;amp;
                Objects.equals(sellPoint, item.sellPoint) &amp;amp;&amp;amp;
                Objects.equals(price, item.price);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id, title, sellPoint, price, num);
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getSellPoint() {
        return sellPoint;
    }

    public void setSellPoint(String sellPoint) {
        this.sellPoint = sellPoint;
    }

    public Long getPrice() {
        return price;
    }

    public void setPrice(Long price) {
        this.price = price;
    }

    public int getNum() {
        return num;
    }

    public void setNum(int num) {
        this.num = num;
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;74-初始化索引&#34;&gt;7.4 初始化索引&lt;/h3&gt;
&lt;p&gt;首先注入客户端对象&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
     * ES5.x以前，使用的客户端一般都是Transport客户端，数据交换客户端，通过端口9300，
     * 借助协议TCP，实现数据的交换访问。
     * Spring Data Elasticsearch 提供的客户端Template对象类型是 ElasticsearchTemplate
     * 配置是：
     * spring.data.elasticsearch.cluster-name = 集群名称
     * spring.data.elasticsearch.cluster-nodes = 集群每个节点的地址， ip:port,ip:port
     * &amp;lt;p&amp;gt;
     * ES6.x以后，官方推荐使用Rest客户端，通过端口9200，借助协议HTTP，实现数据访问控制
     * Spring Data Elasticsearch 提供的客户端Template对象类型是 ElasticsearchRestTemplate
     */
    // @Autowired
    //  private ElasticsearchTemplate elasticsearchTemplate;

    @Autowired
    private ElasticsearchRestTemplate elasticsearchRestTemplate;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;createIndex(): 创建索引，创建出来的索引是不带有 mapping 信息的。返回值表示是否创建成功&lt;/p&gt;
&lt;p&gt;putMapping():为已有的索引添加 mapping 信息。不具备创建索引的能力。返回值表示是否创建成功&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * 创建索引
     * 创建索引，不包括映射信息，因为只扫描类型上的Document注解。
     */
    @Test
    public void createIndexWithElasticsearchTemplate(){
        boolean isCreated = elasticsearchTemplate.createIndex(Item.class);
        System.out.println(&amp;quot;创建索引是否成功:&amp;quot;+isCreated);
    }
}

    /**
     * 创建索引，并设置映射。
     * 需要通过两次访问实现，1、创建索引；2、设置映射。
     */
    @Test
    public void testInitIndex() {
        // 创建索引，根据类型上的Document注解创建
        boolean isCreated = elasticsearchRestTemplate.createIndex(Item.class);
        // 设置映射，根据属性上的Field注解设置
        boolean isMapped = elasticsearchRestTemplate.putMapping(Item.class);
        System.out.println(&amp;quot;创建索引是否成功&amp;quot; + isCreated);
        System.out.println(&amp;quot;设置映射是否成功&amp;quot; + isMapped);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;75-删除索引&#34;&gt;7.5 删除索引&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 删除索引
 */
@Test
public void deleteIndex() {
    // 扫描Item类型上的Document注解，删除对应的索引。
    boolean isDeleted = elasticsearchRestTemplate.deleteIndex(Item.class);
    System.out.println(&amp;quot;删除Item对应索引是否成功&amp;quot; + isDeleted);
    // 直接删除对应名称的索引。
    isDeleted = elasticsearchRestTemplate.deleteIndex(&amp;quot;default_index&amp;quot;);
    System.out.println(&amp;quot;删除default_index索引是否成功&amp;quot; + isDeleted);

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;76-添加文档&#34;&gt;7.6 添加文档&lt;/h3&gt;
&lt;p&gt;如果索引和类型不存在，也可以执行进行新增，新增后自动创建索引和类型。但是 field通过动态 mapping 进行映射，elaticsearch 根据值类型进行判断每个属性类型，默认每个属性都是 standard 分词器，ik 分词器是不生效的。&lt;em&gt;&lt;strong&gt;所以一定要先通过代码进行初始化或直接在 elasticsearch 中通过命令创建所有 field 的 mapping&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h4 id=&#34;761-新增单个文档&#34;&gt;7.6.1 新增单个文档&lt;/h4&gt;
&lt;p&gt;如果对象的 id 属性没有赋值，让 ES 自动生成主键，存储时 id 属性没有值，_id 存储document 的主键值。&lt;/p&gt;
&lt;p&gt;如果对象的 id 属性明确设置值，存储时 id 属性为设置的值，ES 中 document 对象的_id 也是设置的值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * 新增数据到ES
     */
    @Test
    public void testInsert() {
        Item item = new Item();
        item.setId(&amp;quot;111222333&amp;quot;);
        item.setTitle(&amp;quot;Spring In Action VI&amp;quot;);
        item.setSellPoint(&amp;quot;Spring系列书籍，非常好的一本Spring框架学习手册。唯一缺点没有中文版。&amp;quot;);
        item.setPrice(9900L);
        item.setNum(999);

        IndexQuery indexQuery =
                new IndexQueryBuilder() // 创建一个IndexQuery的构建器
                        .withObject(item) // 设置要新增的Java对象
                        .build(); // 构建IndexQuery类型的对象

//        IndexQuery query = new IndexQuery();
//        query.setObject(item); //效果同上
        // index逻辑，相当于使用PUT请求，实现数据的新增。
        String result = elasticsearchRestTemplate.index(indexQuery);
        System.out.println(result);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;762-批量新增&#34;&gt;7.6.2 批量新增&lt;/h4&gt;
&lt;p&gt;下面代码中使用的 IndexQueryBuilder()进行构建，可以一行代码完成。也可以使用上面的 IndexQuery()。效果是完全相同的，只是需要写多行。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 批量新增
 * bulk操作
 */
@Test
public void testBatchInsert() {
    List&amp;lt;IndexQuery&amp;gt; queries = new ArrayList&amp;lt;&amp;gt;();
    for (int i = 0; i &amp;lt; 3; i++) {
        Item item = new Item();
        item.setId(&amp;quot;2000&amp;quot; + i);
        item.setTitle(&amp;quot;测试新增商品&amp;quot; + i);
        item.setSellPoint(&amp;quot;测试新增商品卖点&amp;quot; + i);
        item.setPrice(new Random().nextLong());
        item.setNum(9999 - i);
        queries.add(
                new IndexQueryBuilder().withObject(item).build()
        );
    }
    // 批量新增，使用的是bulk操作。
    elasticsearchRestTemplate.bulkIndex(queries);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;77-删除操作&#34;&gt;7.7.  删除操作&lt;/h3&gt;
&lt;p&gt;根据主键删除&lt;/p&gt;
&lt;p&gt;delete(String indexName,String typeName,String id); 通过字符串指定索引，类型和 id 值&lt;/p&gt;
&lt;p&gt;delete(Class,String id) 第一个参数传递实体类类类型，建议使用此方法，减少索引名和类型名由于手动编写出现错误的概率。&lt;/p&gt;
&lt;p&gt;返回值为 delete 方法第二个参数值（删除文档的主键值）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 删除数据
 */
@Test
public void testDelete() {
    //根据主键删除
    String result = elasticsearchRestTemplate.delete(Item.class, &amp;quot;epYDynEBHt6IU1hpAxvL&amp;quot;);
    System.out.println(result);

    // 根据查询结果，删除查到的数据。 应用较少。
    DeleteQuery deleteQuery = new DeleteQuery();
    //deleteQuery.setIndex(&amp;quot;ego_item&amp;quot;);
    //deleteQuery.setType(&amp;quot;item&amp;quot;);
    deleteQuery.setQuery(
            QueryBuilders.matchQuery(&amp;quot;title&amp;quot;, &amp;quot;Spring In Action VI&amp;quot;)
    );
    elasticsearchRestTemplate.delete(deleteQuery, Item.class);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;78-修改操作&#34;&gt;7.8 修改操作&lt;/h3&gt;
&lt;p&gt;修改操作就是新增代码，只要保证主键 id 已经存在，新增就是修改。&lt;/p&gt;
&lt;p&gt;如果使用部分更新，则需要通过 update 方法实现。具体如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * 修改数据
     * 如果是全量替换，可以使用index方法实现，只要主键在索引中存在，就是全量替换。
     * 如果是部分修改，则可以使用update实现。
     */
    @Test
    public void testUpdate() throws IOException {
        UpdateRequest request = new UpdateRequest();
        request.doc(
                XContentFactory.jsonBuilder()
                        .startObject()
                        .field(&amp;quot;name&amp;quot;, &amp;quot;测试update更新数据，商品名称&amp;quot;)
                        .endObject()
        );
        UpdateQuery updateQuery =
                new UpdateQueryBuilder()
                        .withUpdateRequest(request)
                        .withClass(Item.class)
                        .withId(&amp;quot;20200&amp;quot;)
                        .build();
        elasticsearchRestTemplate.update(updateQuery);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;79-搜索操作&#34;&gt;7.9 搜索操作&lt;/h3&gt;
&lt;h4 id=&#34;791-模糊搜索&#34;&gt;7.9.1  模糊搜索&lt;/h4&gt;
&lt;p&gt;去所有 field 中搜索指定条件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
void query(){
	// NativeSearchQuery 构造方法参数。
	// 北京去和所有 field 进行匹配，只要出现了北京就可以进行查询
	QueryStringQueryBuilder queryStringQueryBuilder = QueryBuilders.queryStringQuery(&amp;quot;北京&amp;quot;);
// 查询条件 SearchQuery 是接口，只能实例化实现类。
	SearchQuery searchQuery = new NativeSearchQuery(queryStringQueryBuilder);
	List&amp;lt;People&amp;gt; list = elasticsearchRestTemplate.queryForList(searchQuery,People.class);
	for(People people : list){
		System.out.println(people);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;792-使用-match_all-搜索所有文档&#34;&gt;7.9.2 使用 match_all 搜索所有文档&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * 搜素所有数据
     */
    @Test
    public void testMatchAll() {
        /**
         * SearchQuery - 是Spring Data Elasticsearch中定义的一个搜索接口
         * NativeSearchQuery - 是SearchQuery接口的实现类。
         *  构造的时候，需要提供一个QueryBuilder类型的对象，
         *  QueryBuilder是Elasticsearch的java客户端中定义的搜索条件类型。
         *
         * QueryBuilders - 是QueryBuilder类型的工具类，可以快速实现QueryBuilder类型对象的创建
         *  工具类中，提供了大量的静态方法，方法命名和DSL搜索中的条件关键字相关。
         *  如：match_all 对应 matchAllQuery()
         *  如：match 对应 matchQuery()
         *  如：range 对应 rangeQuery()
         */
        SearchQuery query = new NativeSearchQuery(
                QueryBuilders.matchAllQuery()
        );
        List&amp;lt;Item&amp;gt; items = elasticsearchRestTemplate.queryForList(query, Item.class);
        for (Item item : items) {
            System.out.println(item);
        }
    }

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;793-使用-match-搜索文档&#34;&gt;7.9.3  使用 match 搜索文档&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * 条件搜索
     */
    @Test
    public void testMatch() {
        SearchQuery query = new NativeSearchQuery(
                QueryBuilders.matchQuery(&amp;quot;title&amp;quot;, &amp;quot;华为荣耀&amp;quot;)
        );
        List&amp;lt;Item&amp;gt; items = elasticsearchRestTemplate.queryForList(query, Item.class);
        for (Item item : items) {
            System.out.println(item);
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;794-使用-match_phrase-搜索文档&#34;&gt;7.9.4 使用 match_phrase 搜索文档&lt;/h4&gt;
&lt;p&gt;短语搜索是对条件不分词，但是文档中属性根据配置实体类时指定的分词类型进行分词。&lt;/p&gt;
&lt;p&gt;如果属性使用 ik 分词器，从分词后的索引数据中进行匹配。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * 短语搜索
     */
    @Test
    public void testMatchPhrase() {
        SearchQuery query = new NativeSearchQuery(
                QueryBuilders.matchPhraseQuery(&amp;quot;title&amp;quot;, &amp;quot;华为荣耀&amp;quot;)
        );
        List&amp;lt;Item&amp;gt; items = elasticsearchRestTemplate.queryForList(query, Item.class);
        for (Item item : items) {
            System.out.println(item);
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;795-使用-term词组-搜索文档&#34;&gt;7.9.5 使用 Term词组 搜索文档&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * 词组搜索
     */
    @Test
    public void testTerm() {
        SearchQuery query = new NativeSearchQuery(
                QueryBuilders.termQuery(&amp;quot;title&amp;quot;, &amp;quot;华为荣耀&amp;quot;)
        );
        List&amp;lt;Item&amp;gt; items = elasticsearchRestTemplate.queryForList(query, Item.class);
        for (Item item : items) {
            System.out.println(item);
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;796-使用-range-搜索文档&#34;&gt;7.9.6 使用 range 搜索文档&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * 范围搜索 range
     */
    @Test
    public void testRange() {
        SearchQuery query = new NativeSearchQuery(
                QueryBuilders.rangeQuery(&amp;quot;price&amp;quot;).lte(800000L).gte(200000L)
        );
        List&amp;lt;Item&amp;gt; items = elasticsearchRestTemplate.queryForList(query, Item.class);
        for (Item item : items) {
            System.out.println(item);
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;797-多条件搜索&#34;&gt;7.9.7 多条件搜索&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 复合条件搜索
 */
@Test
public void testBool() {
    // 创建一个Bool搜索条件。 相当于定义 bool:{ must:[], should:[], must_not:[] }
    BoolQueryBuilder builder = QueryBuilders.boolQuery();
    List&amp;lt;QueryBuilder&amp;gt; mustList = builder.must();
    mustList.add(QueryBuilders.matchQuery(&amp;quot;title&amp;quot;, &amp;quot;华为&amp;quot;));
    mustList.add(QueryBuilders.rangeQuery(&amp;quot;price&amp;quot;).gte(300000L));
    SearchQuery query = new NativeSearchQuery(builder);
    List&amp;lt;Item&amp;gt; items = elasticsearchRestTemplate.queryForList(query, Item.class);
    for (Item item : items) {
        System.out.println(item);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;798-分页与排序&#34;&gt;7.9.8 分页与排序&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * 分页和排序
     * 所有的Spring Data子工程中的分页和排序逻辑使用的都是相似的方式。
     * 根据PageRequest和Sort实现分页或排序。
     */
    @Test
    public void testPageable() {
        SearchQuery query = new NativeSearchQuery(
                QueryBuilders.matchAllQuery()
        );
        // 设置分页 ，从第0页开始的两条
        query.setPageable(PageRequest.of(0, 2));
        // 设置排序
        query.addSort(Sort.by(Sort.Direction.DESC, &amp;quot;price&amp;quot;));
        // 设置分页的同时设置排序
        // query.setPageable(PageRequest.of(0,2,Sort.by(Sort.Direction.DESC,&amp;quot;price&amp;quot;)));
        List&amp;lt;Item&amp;gt; items = elasticsearchRestTemplate.queryForList(query, Item.class);
        for (Item item : items) {
            System.out.println(item);
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果实体类中主键只有@Id 注解，String id 对应 ES 中是 text 类型，text 类型是不允许被排序，所以如果必须按照主键进行排序时需要在实体类中设置主键类型&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Id
@Field(type = FieldType.Keyword)
private String id;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;799-高亮搜索&#34;&gt;7.9.9 高亮搜索&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
    /**
     * 高亮
     */
    @Test
    public void testHighlight(){
        HighlightBuilder.Field field = new HighlightBuilder.Field(&amp;quot;title&amp;quot;);
        field.preTags(&amp;quot;&amp;lt;em&amp;gt;&amp;quot;);
        field.postTags(&amp;quot;&amp;lt;/em&amp;gt;&amp;quot;);

        NativeSearchQuery query =
                new NativeSearchQueryBuilder()
                        // 排序
                        .withSort(SortBuilders.fieldSort(&amp;quot;price&amp;quot;).order(SortOrder.ASC))
                        // 分页
                        .withPageable(PageRequest.of(0, 2))
                        // 搜索条件
                        .withQuery(QueryBuilders.matchQuery(&amp;quot;title&amp;quot;, &amp;quot;华为&amp;quot;))
                        // 设置高亮字段
                        .withHighlightFields(field)
                        .build();

        AggregatedPage&amp;lt;? extends Item&amp;gt; pageResult =
                elasticsearchRestTemplate.queryForPage(query, Item.class, new SearchResultMapper() {
                    // 处理搜索结果，搜索的完整结果，也就是那个集合。
                    // response - 就是搜索的结果，相当于在Kibana中执行搜索的结果内容。
                    // clazz - 就是返回结果的具体类型
                    // pageable - 分页处理，就是queryForPage方法参数query中的pageable对象。
                    @Override
                    public &amp;lt;T&amp;gt; AggregatedPage&amp;lt;T&amp;gt; mapResults(SearchResponse response,
                                                            Class&amp;lt;T&amp;gt; clazz,
                                                            Pageable pageable) {
                        // 获取搜索的结果数据
                        SearchHit[] hits = response.getHits().getHits();
                        List&amp;lt;T&amp;gt; resultList = new ArrayList&amp;lt;&amp;gt;();
                        for(SearchHit hit : hits){
                            // 搜索的source源
                            Map&amp;lt;String, Object&amp;gt; map = hit.getSourceAsMap();
                            Item item = new Item();
                            item.setId(map.get(&amp;quot;id&amp;quot;).toString());
                            item.setSellPoint(map.get(&amp;quot;sellPoint&amp;quot;).toString());
                            item.setPrice(Long.parseLong(map.get(&amp;quot;price&amp;quot;).toString()));
                            item.setNum(Integer.parseInt(map.get(&amp;quot;num&amp;quot;).toString()));
                            // 高亮数据处理。key - 字段名， value - 是高亮数据结果
                            Map&amp;lt;String, HighlightField&amp;gt; highlightFieldMap = hit.getHighlightFields();
                            HighlightField highlightField = highlightFieldMap.get(&amp;quot;title&amp;quot;);
                            if (highlightField == null){ // 没有高亮的title
                                item.setTitle(map.get(&amp;quot;title&amp;quot;).toString());
                            }else{ // 有高亮的title
                                item.setTitle(highlightField.getFragments()[0].toString());
                            }
                            resultList.add((T)item);
                        }
                        // 返回处理后的结果

                        return new AggregatedPageImpl&amp;lt;&amp;gt;(
                                resultList, pageable, response.getHits().getTotalHits()
                        );
                    }

                    // 不提供实现，这个是处理每个搜索结果的方法
                    @Override
                    public &amp;lt;T&amp;gt; T mapSearchHit(SearchHit searchHit, Class&amp;lt;T&amp;gt; type) {
                        return null;
                    }
                });

        for(Item item : pageResult.getContent()){
            System.out.println(item);
        }
    }

&lt;/code&gt;&lt;/pre&gt;
">ElasticSearch</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jonchan1013.github.io/post/solr/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200716171735.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;1-solr-简介&#34;&gt;1、Solr 简介&lt;/h2&gt;
&lt;h3 id=&#34;11-为什么使用-solr&#34;&gt;1.1 为什么使用 Solr&lt;/h3&gt;
&lt;p&gt;在海量数据下，对 MySQL 或 Oracle 进行模糊查询或条件查询的效率是很低的。而搜索功能在绝大多数项目中都是必须的，如何提升搜索效率是很多互联网项目必须要考虑的问题。&lt;br&gt;
既然使用关系型数据库进行搜索效率比较低，最直接的解决方案就是使用专用搜索工具进行搜索，从而提升搜索效率。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;12-常见搜索解决方案&#34;&gt;1.2 常见搜索解决方案&lt;/h3&gt;
&lt;p&gt;基于 Apache Lucene（全文检索工具库）实现搜索。但是 Lucene 的使用对于绝大多数的程序员都是“噩梦级”的。&lt;/p&gt;
&lt;p&gt;基于谷歌 API 实现搜索。&lt;/p&gt;
&lt;p&gt;基于百度 API 实现搜索。&lt;/p&gt;
&lt;h3 id=&#34;13-solr-简介&#34;&gt;1.3 Solr 简介&lt;/h3&gt;
&lt;p&gt;Solr 是基于 Apache Lucene 构建的用于搜索和分析的开源解决方案。可提供可扩展索引、搜索功能、高亮显示和文字解析功能。&lt;/p&gt;
&lt;p&gt;Solr 本质就是一个 Java web 项目，且内嵌了 Jetty 服务器，所以安装起来非常方便。客户端操作 Solr 的过程和平时我们所写项目一样，就是请求 Solr 中控制器，处理完数据后把结果响应给客户端。&lt;/p&gt;
&lt;h3 id=&#34;14-正向索引和反向索引&#34;&gt;1.4 正向索引和反向索引&lt;/h3&gt;
&lt;p&gt;只要讨论搜索就不得不提的两个概念：正向索引（forward index）和反向索引(invertedindex)。&lt;/p&gt;
&lt;p&gt;正向索引：从文档内容到词组的过程。每次搜索的时候需要搜索所有文档，每个文档比较搜索条件和词组。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;文档&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;词组&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;I am a chinese&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;I,am,a,chinses&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;反向索引：是正向索引的逆向。建立词组和文档的映射关系。通过找到词组就能找到文档内容。（和新华字典找字很像）&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;词组&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;文档&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;I,am,a,chinses&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;I am a chinese&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;2-solr-搜索原理&#34;&gt;2、Solr 搜索原理&lt;/h2&gt;
&lt;h3 id=&#34;21-搜索原理&#34;&gt;2.1 搜索原理&lt;/h3&gt;
&lt;p&gt;Solr 能够提升检索效率的主要原因就是&lt;strong&gt;分词和索引（反向索引）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;分词：会对搜索条件/存储内容进行分词，分成日常所使用的词语。&lt;/p&gt;
&lt;p&gt;索引：存储在 Solr 中内容会按照程序员的要求来是否建立索引。如果要求建立索引会把存储内容中关键字（分词）建立索引。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200718221615.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;22-solr-中数据存储说明&#34;&gt;2.2 Solr 中数据存储说明&lt;/h3&gt;
&lt;p&gt;Solr 为了给内容建立索引，所以 Solr 就必须具备数据存储能力。所有需要被搜索的内容都需要存储在 Solr 中，在开发中需要把数据库中数据添加到 Solr 中进行初始化，每次修改数据库中数据还需要同步 Solr 中的数据。&lt;/p&gt;
&lt;p&gt;Solr 中数据存储是存储在 Document 对象中，对象中可以包含的属性和属性类型都定义在 schema.xml 中。如果需要自定义属性或自定义属性类型都需要修改 schema.xml 配置文件。从 Solr5 开始 schema.xml 更改名称为 managed-schema(没有扩展名)&lt;/p&gt;
&lt;h2 id=&#34;3-solr-单机版安装&#34;&gt;3、 Solr 单机版安装&lt;/h2&gt;
&lt;p&gt;Solr 是使用 Java 编写，所以必选先安装 JDK。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;上传并解压&lt;br&gt;
上传压缩包 solr-8.2.0.tgz 到/usr/local/tmp 中。&lt;/p&gt;
&lt;p&gt;解压&lt;/p&gt;
&lt;p&gt;cd /usr/local/tmp&lt;/p&gt;
&lt;p&gt;tar zxf solr-8.2.0.tgz&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;复制到/usr/local 中&lt;/p&gt;
&lt;p&gt;cp -r solr-8.2.0 ../solr&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改启动参数&lt;br&gt;
修改启动参数，否则启动时报警告。提示设置 SOLR_ULIMIT_CHECKS=false&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;cd /usr/local/solr/bin&lt;/p&gt;
&lt;p&gt;vim solr.in.sh&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200718221843.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;启动 Solr&lt;br&gt;
Solr 内嵌 Jetty，直接启动即可。默认监听 &lt;strong&gt;8983 端口。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Solr 默认不推荐 root 账户启动，如果是 root 账户启动需要添加-force 参数。&lt;/p&gt;
&lt;p&gt;./solr start -force&lt;/p&gt;
&lt;h2 id=&#34;4-可视化管理界面&#34;&gt;4、可视化管理界面&lt;/h2&gt;
&lt;p&gt;在关闭防火墙的前提下，可以在 windows 的浏览器中访问 Solr。&lt;/p&gt;
&lt;p&gt;输入: http://124.70.181.124:8983 就可以访问 Solr 的可视化管理界面。&lt;/p&gt;
&lt;p&gt;左侧有 5 个菜单。分别是：&lt;/p&gt;
&lt;p&gt;（1）Dashboard：面板显示 Solr 的总体信息。&lt;/p&gt;
&lt;p&gt;（2）Logging：日志&lt;/p&gt;
&lt;p&gt;（3）Core Admin：Solr 的核心。类似于数据的 Database&lt;/p&gt;
&lt;p&gt;（4）Java Perperties：所有 Java 相关属性。&lt;/p&gt;
&lt;p&gt;（5）Thread Dump：线程相关信息。&lt;/p&gt;
&lt;p&gt;（6）如果有 Core，将显示在此处。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200718222009.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;5-新建核心&#34;&gt;5、新建核心&lt;/h2&gt;
&lt;p&gt;Solr 安装完成后默认是没有核心的。需要手动配置。&lt;/p&gt;
&lt;p&gt;需要在 solr/server/solr 下新建文件夹，并给定配置文件，否则无法建立。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200718222032.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;新建目录&lt;br&gt;
在/usr/local/solr/server/solr 中新建自定义名称目录。此处示例名称为 testcore。&lt;/p&gt;
&lt;p&gt;cd /usr/local/solr/server/solr&lt;/p&gt;
&lt;p&gt;mkdir testcore&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;复制配置文件&lt;br&gt;
在 configsets 里面包含了_default 和 sample_techproducts_configs。里面都是配置文件示例。_default 属于默认配置，较纯净。sample_techproducts_configs 是带有了一些配置示例。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;cp -r configsets/_default/conf/ testcore/&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;填写 Core 信息&lt;br&gt;
在可视化管理界面中 Core Admin 中编写信息后点击 Add Core 后，短暂延迟后testcore 就会创建成功。schema 处不用更改。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200718222147.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;出现 testcore&lt;br&gt;
在客户端管理界面中，选择新建的 Core 后，就可以按照自己项目的需求进行操作了。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200718222200.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;6-分词-analysis&#34;&gt;6、 分词 Analysis&lt;/h2&gt;
&lt;p&gt;在 Solr 可 视 化 管 理 界 面 中 ， Core 的 管 理 菜 单 项 中 都 会 有 Analysis 。 表 示 根 据Scheme.xml(managed-schema)中配置要求进行解析。&lt;/p&gt;
&lt;p&gt;对英文解析就比较简单了，只要按照空格把英文语句拆分成英文单词即可。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200718222225.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;但是如果条件是中文时，把一句话按照字进行拆分就不是很合理了。正确的方式是按照合理的词组进行拆分。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200718222236.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;61-中文分词器安装及配置步骤&#34;&gt;6.1 中文分词器安装及配置步骤&lt;/h3&gt;
&lt;p&gt;上传 ik-analyzer.jar 到 webapps 中。&lt;/p&gt;
&lt;p&gt;去 https://search.maven.org/search?q=com.github.magese 下 载 对 应 版 本 的ik-analyzer。可以在&amp;quot;软件/Analyzer&amp;quot;中直接获取。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;上传 jar 到指定目录&lt;br&gt;
上传 ik-analyzer-8.2.0.jar 到&lt;/p&gt;
&lt;p&gt;/usr/local/solr/server/solr-webapp/webapp/WEB-INF/lib 目录中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改配置文件&lt;br&gt;
修改/usr/local/solr/server/solr/testcore/conf/managed-schema&lt;/p&gt;
&lt;p&gt;vim /usr/local/solr/server/solr/testcore/conf/managed-schema&lt;/p&gt;
&lt;p&gt;添加下面内容。&lt;/p&gt;
&lt;p&gt;排版：Esc 退出编辑状态下：gg=G&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;    &amp;lt;field name=&amp;quot;myfield&amp;quot; type=&amp;quot;text_ik&amp;quot; indexed=&amp;quot;true&amp;quot; stored=&amp;quot;true&amp;quot; /&amp;gt;

    &amp;lt;fieldType name=&amp;quot;text_ik&amp;quot; class=&amp;quot;solr.TextField&amp;quot;&amp;gt;
      &amp;lt;analyzer type=&amp;quot;index&amp;quot;&amp;gt;
        &amp;lt;tokenizer class=&amp;quot;org.wltea.analyzer.lucene.IKTokenizerFactory&amp;quot; 
          useSmart=&amp;quot;false&amp;quot; conf=&amp;quot;ik.conf&amp;quot;/&amp;gt;
        &amp;lt;filter class=&amp;quot;solr.LowerCaseFilterFactory&amp;quot;/&amp;gt;
      &amp;lt;/analyzer&amp;gt;
      &amp;lt;analyzer type=&amp;quot;query&amp;quot;&amp;gt;
        &amp;lt;tokenizer class=&amp;quot;org.wltea.analyzer.lucene.IKTokenizerFactory&amp;quot; 
          useSmart=&amp;quot;true&amp;quot; conf=&amp;quot;ik.conf&amp;quot;/&amp;gt;
        &amp;lt;filter class=&amp;quot;solr.LowerCaseFilterFactory&amp;quot;/&amp;gt;
      &amp;lt;/analyzer&amp;gt;
    &amp;lt;/fieldType&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重启&lt;/p&gt;
&lt;p&gt;cd /usr/local/solr/bin&lt;/p&gt;
&lt;p&gt;./solr stop -all&lt;/p&gt;
&lt;p&gt;./solr start -force&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;验证&lt;br&gt;
可以在可视化管理界面中找到 myfield 属性进行验证。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200718222452.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;62-managed-schema-配置说明&#34;&gt;6.2 managed-schema 配置说明&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;fieldType/&gt;
表 示 定 义 一 个 属 性 类 型 。 在 Solr 中 属 性 类 型 都 是 自 定 义 的 。 在 上 面 配 置 中name=&#34;text_ik&#34;为自定义类型。当某个属性取值为 text_ik 时 IK Analyzer 才能生效。
&lt;/li&gt;
&lt;li&gt;
&lt;field/&gt;
表示向 Document 中添加一个属性。
&lt;p&gt;常用属性：&lt;/p&gt;
&lt;p&gt;name: 属性名&lt;/p&gt;
&lt;p&gt;type:属性类型。所有类型都是 solr 使用&lt;fieldType&gt;配置的&lt;/p&gt;
&lt;p&gt;indexed: 是否建立索引&lt;/p&gt;
&lt;p&gt;stored: solr 是否把该属性值响应给搜索用户。&lt;/p&gt;
&lt;p&gt;required：该属性是否是必须的。默认 id 是必须的。&lt;/p&gt;
&lt;p&gt;multiValued：如果为 true，表示该属性为复合属性，此属性中包含了多个其他的属性。常用在多个列作为搜索条件时，把这些列定义定义成一个新的复合属性，通过搜索一个复合属性就可以实现搜索多个列。当设置为 true 时与&lt;copyField source=&#34;&#34; dest=&#34;&#34;/&gt;结合使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;uniqueKey&gt;
唯一主键，Solr 中默认定义 id 属性为唯一主键。ID 的值是不允许重复的。
&lt;/li&gt;
&lt;li&gt;
&lt;dynamicField&gt;
名称中允许*进行通配。代表满足特定名称要求的一组属性。
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;7-dataimport&#34;&gt;7、 Dataimport&lt;/h2&gt;
&lt;p&gt;可以使用 Solr 自带的 Dataimport 功能把数据库中数据快速导入到 solr 中.&lt;/p&gt;
&lt;p&gt;必须保证 managed-schema 和数据库中表的列对应。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;修改配置文件&lt;br&gt;
修改 solrconfig.xml，添加下面内容&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- 配置数据导入的处理器 --&amp;gt;

 &amp;lt;requestHandler name=&amp;quot;/dataimport&amp;quot; class=&amp;quot;org.apache.solr.handler.dataimport.DataImportHandler&amp;quot;&amp;gt;

	&amp;lt;lst name=&amp;quot;defaults&amp;quot;&amp;gt;

		&amp;lt;!-- 加载 data-config.xml --&amp;gt;

		&amp;lt;str name=&amp;quot;config&amp;quot;&amp;gt;data-config.xml&amp;lt;/str&amp;gt;

	&amp;lt;/lst&amp;gt;

 &amp;lt;/requestHandler&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新建 data-config.xml&lt;/p&gt;
&lt;p&gt;和 solrconfig.xml 同一目录下新建 data-config.xml&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;dataConfig&amp;gt;
	&amp;lt;dataSource 
		type=&amp;quot;JdbcDataSource&amp;quot;  
		driver=&amp;quot;com.mysql.jdbc.Driver&amp;quot;
		url=&amp;quot;jdbc:mysql://124.70.181.124:3306/ego2&amp;quot;
		user=&amp;quot;root&amp;quot;
		password=&amp;quot;Chenyong.123&amp;quot;/&amp;gt;&amp;lt;/dataSource&amp;gt;

&amp;lt;document&amp;gt;

	&amp;lt;entity name=&amp;quot;product&amp;quot; query=&amp;quot;SELECT id,title from tb_item&amp;quot;&amp;gt;

	&amp;lt;!--实现数据库的列和索引库的字段的映射
		column 指定数据库的列表
		name 指定索引库的字段名字，必须和 schema.xml 中定义的一样
	--&amp;gt;
	&amp;lt;field column=&amp;quot;id&amp;quot; name=&amp;quot;id&amp;quot;/&amp;gt;
	&amp;lt;field column=&amp;quot;title&amp;quot; name=&amp;quot;myfield&amp;quot;/&amp;gt;
&amp;lt;/entity&amp;gt;
&amp;lt;/document&amp;gt;

&amp;lt;/dataConfig&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;添加 jar&lt;br&gt;
向 solr-webapp 中添加三个 jar。在 dist 中两个还有一个数据库驱动。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200718222810.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;
&lt;p&gt;操作&lt;br&gt;
重启 solr 后，在可视化管理页面中进行数据导入。&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;点击导入按钮后，要记得点击刷新按钮。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;8-菜单项目-documents-使用办法&#34;&gt;8、菜单项目 Documents 使用办法&lt;/h2&gt;
&lt;p&gt;以 XML 格式举例&lt;/p&gt;
&lt;h3 id=&#34;81-新增修改&#34;&gt;8.1 新增/修改&lt;/h3&gt;
&lt;p&gt;当 id 不存在时新增，当 id 存在修改。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;doc&amp;gt;

&amp;lt;field name=&amp;quot;id&amp;quot;&amp;gt;8&amp;lt;/field&amp;gt;

&amp;lt;field name=&amp;quot;name&amp;quot;&amp;gt;明天更大卖&amp;lt;/field&amp;gt;

&amp;lt;field name=&amp;quot;price&amp;quot;&amp;gt;98&amp;lt;/field&amp;gt;

&amp;lt;/doc&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;82-删除&#34;&gt;8.2  删除&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;根据主键删除&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;delete&amp;gt;

&amp;lt;id&amp;gt;8&amp;lt;/id&amp;gt;

&amp;lt;/delete&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根据条件删除&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;delete&amp;gt;

&amp;lt;query&amp;gt;*:*&amp;lt;/query&amp;gt;

&amp;lt;/delete&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;9-菜单项目-query-查询使用办法&#34;&gt;9、菜单项目 query 查询使用办法&lt;/h2&gt;
&lt;h3 id=&#34;91-查询全部&#34;&gt;9.1  查询全部&lt;/h3&gt;
&lt;p&gt;只要在 q 参数中写入*:*既是搜索全部数据。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200718223217.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;92-条件查询&#34;&gt;9.2 条件查询&lt;/h3&gt;
&lt;p&gt;在 q 参数部分写入 字段名:搜索条件值， 既是条件搜索&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200718223236.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;93-分页查询&#34;&gt;9.3 分页查询&lt;/h3&gt;
&lt;p&gt;在条件 start,rows 中输入从第几条数据开始查询，查询多少条数据。下标从 0 开始。类似 MySQL 数据库中的 limit。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200718223256.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;94-查询排序&#34;&gt;9.4 查询排序&lt;/h3&gt;
&lt;p&gt;在 sort 条件中输入 字段名 排序规则。 排序规则包括 asc 和 desc。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200718223320.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;95-高亮查询&#34;&gt;9.5 高亮查询&lt;/h3&gt;
&lt;p&gt;选中 hl 高亮复选框，在 hl.fl 中输入高亮显示的字段名称，在 hl.simple.pre 中输入高亮前缀，在 hl.simple.post 中输入高亮后缀。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200718223339.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;10-使用-solrj-操作-solr&#34;&gt;10、使用 SolrJ 操作 Solr&lt;/h2&gt;
&lt;p&gt;SolrJ 是 Solr 提供的 Java 客户端 API。通过 SolrJ 可以实现 Java 程序对 Solr 中数据的操作。&lt;/p&gt;
&lt;p&gt;大前提：添加 SolrJ 依赖。依赖版本和 Solr 版本严格对应&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt; &amp;lt;dependencies&amp;gt;
     &amp;lt;dependency&amp;gt;
         &amp;lt;groupId&amp;gt;org.apache.solr&amp;lt;/groupId&amp;gt;
         &amp;lt;artifactId&amp;gt;solr-solrj&amp;lt;/artifactId&amp;gt;
         &amp;lt;version&amp;gt;8.2.0&amp;lt;/version&amp;gt;
     &amp;lt;/dependency&amp;gt;
 &amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 使用SolrJ访问Solr服务。
 */
public class FirstAccess {
    public static void main(String[] args) {
        search();
    }

    // 搜索数据
    public static void search(){
        HttpSolrClient client = null;
        try{
            String url = &amp;quot;http://124.70.181.124:8983/solr/testcore&amp;quot;;
            client = new HttpSolrClient.Builder(url).build();

            // 创建搜索条件对象。
            SolrQuery params = new SolrQuery();
            // 提供搜索关键字， q  *:*
            params.setQuery(&amp;quot;title_zh_cn:管理&amp;quot;);

            // 排序
            params.setSort(&amp;quot;id&amp;quot;, SolrQuery.ORDER.asc);

            // 分页
            params.setStart(0); // 第几行开始查询
            params.setRows(3); // 查询多少行

            // 高亮
            // 开启高亮
            params.setHighlight(true);
            // 设置高亮字段，如果有多个高亮字段，多次调用当前方法。
            params.addHighlightField(&amp;quot;title_zh_cn&amp;quot;);
            // 设置高亮前缀
            params.setHighlightSimplePre(&amp;quot;&amp;lt;span style=&#39;color:red&#39;&amp;gt;&amp;quot;);
            // 设置高亮后缀
            params.setHighlightSimplePost(&amp;quot;&amp;lt;/span&amp;gt;&amp;quot;);

            // 搜索数据
            QueryResponse response = client.query(params);

            // 从响应中获取高亮结果数据集合 {主键:{字段名:[&amp;quot;高亮数据&amp;quot;, &amp;quot;高亮数据&amp;quot;]}}
            Map&amp;lt;String, Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt;&amp;gt; highlightMap = response.getHighlighting();

            // 获取搜索返回结果集合  SolrDocumentList 是List接口的实现。 固定泛型是 SolrDocument
            SolrDocumentList docList = response.getResults();
            System.out.println(&amp;quot;本次查询返回数据行数&amp;quot; + docList.size());
            System.out.println(&amp;quot;本次搜索总计数据行数&amp;quot; + docList.getNumFound());
            for(SolrDocument doc : docList){
                System.out.print(doc + &amp;quot;【 id = &amp;quot; + doc.getFieldValue(&amp;quot;id&amp;quot;)
                        + &amp;quot;， title_zh_cn = &amp;quot; + doc.getFieldValue(&amp;quot;title_zh_cn&amp;quot;) + &amp;quot;】&amp;quot;);

                // 输出高亮
                // 根据当前文档主键查询高亮数据
                Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; entry = highlightMap.get(doc.getFieldValue(&amp;quot;id&amp;quot;));
                if(null != entry &amp;amp;&amp;amp; entry.size() &amp;gt; 0){
                    // 有高亮数据
                    List&amp;lt;String&amp;gt; hlStrList = entry.get(&amp;quot;title_zh_cn&amp;quot;);
                    System.out.println(&amp;quot; 高亮数据内容是：【&amp;quot; + hlStrList + &amp;quot;】&amp;quot;);
                }

                System.out.println();
            }
        }catch(Exception e){
            e.printStackTrace();
        }finally {
            try {
                client.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    // 删除数据
    public static void delete(){
        HttpSolrClient client = null;
        try{
            String url = &amp;quot;http://124.70.181.124:8983/solr/testcore&amp;quot;;
            client = new HttpSolrClient.Builder(url).build();

            // 删除数据
            client.deleteById(&amp;quot;2000&amp;quot;);  // 删除单数据

            client.deleteById(Arrays.asList(&amp;quot;100&amp;quot;, &amp;quot;101&amp;quot;, &amp;quot;102&amp;quot;, &amp;quot;103&amp;quot;)); // 批量删除

            client.deleteByQuery(&amp;quot;title_zh_cn:角色&amp;quot;); // 条件删除， 条件格式 -  字段名:条件数据

            client.commit();
        }catch(Exception e){
            e.printStackTrace();
        }finally {
            try {
                client.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    // 保存数据到Solr，如果主键字段id值唯一就是新增，不唯一就是覆盖（更新）
    public static void save(){
        HttpSolrClient client = null;
        try {
            // 创建客户端
            String url = &amp;quot;http://124.70.181.124:8983/solr/testcore&amp;quot;;
            client = new HttpSolrClient.Builder(url).build();

            // 创建要保存的数据对象
            SolrInputDocument doc = new SolrInputDocument();
            doc.addField(&amp;quot;id&amp;quot;, &amp;quot;2000&amp;quot;);
            doc.addField(&amp;quot;title_zh_cn&amp;quot;, &amp;quot;SolrJ保存数据-二次执行&amp;quot;);

            // 执行数据保存
            client.add(doc);

            // 事务管理
            client.commit(); // 提交当前url指向的core collection
            // client.commit(&amp;quot;testcore&amp;quot;);  // 提供core collection名称，指定提交事务

        }catch(Exception e){
            e.printStackTrace();
        }finally{
            // 回收资源
            try {
                client.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;11-spring-data-for-apache-solr&#34;&gt;11、 Spring Data for Apache Solr&lt;/h2&gt;
&lt;h3 id=&#34;111-spring-data-简介&#34;&gt;11.1 Spring Data 简介&lt;/h3&gt;
&lt;p&gt;Spring Data 是 Spring 的顶级项目。里面包含了 N 多个二级子项目，每个子项目对应一种技术或工具。其目的为了让数据访问更加简单，更加方便的和 Spring 进行整合。&lt;/p&gt;
&lt;p&gt;Spring Data 项目如果单独使用是还需要配置 XML 配置文件的，当和 Spring Boot整合后使用起来非常方便。spring-boot-starter-data-xx 就是对应的启动器。&lt;/p&gt;
&lt;h3 id=&#34;112-实现步骤&#34;&gt;11.2 实现步骤&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;添加依赖&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;    &amp;lt;dependencyManagement&amp;gt;
        &amp;lt;dependencies&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-dependencies&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;2.2.5.RELEASE&amp;lt;/version&amp;gt;
                &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
                &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt;
            &amp;lt;/dependency&amp;gt;
        &amp;lt;/dependencies&amp;gt;
    &amp;lt;/dependencyManagement&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-data-solr&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;编写配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;spring:
  data:
    solr:
      host: http://124.70.181.124:8983/solr # 配置solr服务器所在地址
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编写实体类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SolrDocument(collection = &amp;quot;testcore&amp;quot;)
public class Menu implements Serializable {
    // @Id - 代表当前字段是唯一主键字段。 在高亮查询的时候，需要检查。
    @Field(value = &amp;quot;id&amp;quot;)
    @Id
    private Long id;
    @Field(value = &amp;quot;myfield&amp;quot;)
    private String title;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public Menu(Long id, String title) {
        this.id = id;
        this.title = title;
    }

    public Menu() {
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Menu menu = (Menu) o;
        return Objects.equals(id, menu.id) &amp;amp;&amp;amp;
                Objects.equals(title, menu.title);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id, title);
    }

    @Override
    public String toString() {
        return &amp;quot;Menu{&amp;quot; +
                &amp;quot;id=&amp;quot; + id +
                &amp;quot;, title=&amp;quot; + title +
                &#39;}&#39;;
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编写测试类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * SpringBootTest测试类型
 */
@SpringBootTest(classes = {FirstSolrApp.class})
@RunWith(SpringRunner.class)
public class TestSolr {
    /**
     * SpringData的所有子工程，几乎都会提供一个XxxTemplate类型，
     * 这个Template是用来实现客户端服务器数据交互的对象。
     */
    @Autowired
    private SolrTemplate template;

    /**
     * 保存数据
     * 使用SpringData开发数据访问的时候，不要回收资源，因为SpringData会自动维护数据源连接池
     */
    @Test
    public void testSave() {
        //创建要保存的对象
        SolrInputDocument doc = new SolrInputDocument();
        doc.addField(&amp;quot;id&amp;quot;, &amp;quot;2000&amp;quot;);
        doc.addField(&amp;quot;myfield&amp;quot;, &amp;quot;使用SpringDataForApacheSolr实现数据保存&amp;quot;);
        //数据保存。主键唯一是新增，不是则为覆盖
        UpdateResponse response = template.saveBean(&amp;quot;testcore&amp;quot;, doc);

        System.out.println(response.getStatus() == 0 ? &amp;quot;保存成功&amp;quot; : &amp;quot;保存失败&amp;quot;);

        //提交事务
        template.commit(&amp;quot;testcore&amp;quot;);
    }

    /**
     * 输出数据
     */
    @Test
    public void testDelete() {
        //主键删除唯一数据
        UpdateResponse response = template.deleteByIds(&amp;quot;testcore&amp;quot;, &amp;quot;2000&amp;quot;);
        System.out.println(response.getStatus() == 0 ? &amp;quot;删除成功&amp;quot; : &amp;quot;删除失败&amp;quot;);

        //根据主键批量删除数据
        response = template.deleteByIds(&amp;quot;testcore&amp;quot;, Arrays.asList(&amp;quot;20001&amp;quot;, &amp;quot;2002&amp;quot;));
        System.out.println(response.getStatus() == 0 ? &amp;quot;批量删除成功&amp;quot; : &amp;quot;批量删除失败&amp;quot;);

        //根据查询条件删除
        SimpleQuery query = new SimpleQuery();
        // Criteria.where(&amp;quot;title_zh_cn&amp;quot;) - 提供一个搜索条件，对应的字段名是什么
        // criteria.is(&amp;quot;参数&amp;quot;) - 为这个搜索条件绑定具体的参数值
        query.addCriteria(Criteria.where(&amp;quot;myfield&amp;quot;).is(&amp;quot;Spring&amp;quot;));
        response = template.delete(&amp;quot;testcore&amp;quot;, query);
        System.out.println(response.getStatus() == 0 ? &amp;quot;条件删除成功&amp;quot; : &amp;quot;条件删除失败&amp;quot;);

        //提交事务
        template.commit(&amp;quot;testcore&amp;quot;);

    }

    /**
     * 搜索数据
     */
    @Test
    public void testSearch(){
        //创建搜索条件
        SimpleQuery query = new SimpleQuery();
        query.addCriteria(Criteria.where(&amp;quot;myfield&amp;quot;).is(&amp;quot;数据&amp;quot;));

        //分页
        query.setOffset(0L); //第几行开始查询
        query.setRows(3); //查询多少数据
        //排序
        query.addSort(Sort.by(Sort.Direction.DESC,&amp;quot;id&amp;quot;));

        //执行搜索
        // 参数 ：collection - 索引库名称， query - 搜索条件， Class - 实体类对象
        ScoredPage&amp;lt;Menu&amp;gt; scoredPage = template.queryForPage(&amp;quot;testcore&amp;quot;, query, Menu.class);

        //处理结果
        System.out.println(&amp;quot;总计数据行数:&amp;quot;+scoredPage.getTotalElements());
        System.out.println(&amp;quot;总计页码数:&amp;quot;+scoredPage.getTotalPages());
        //搜索的结果集合
        List&amp;lt;Menu&amp;gt; list = scoredPage.getContent();
        System.out.println(list);
    }

    /**
     * 高亮搜索
     */
    @Test
    public void testHighlightSearch(){
        SimpleHighlightQuery query = new SimpleHighlightQuery();
        query.addCriteria(Criteria.where(&amp;quot;myfield&amp;quot;).is(&amp;quot;数据&amp;quot;));
        // 设置高亮
        // 创建高亮设置对象
        HighlightOptions options = new HighlightOptions();
        // 设置高亮字段名
        options.addField(&amp;quot;myfield&amp;quot;);
        // 设置高亮前后缀
        options.setSimplePrefix(&amp;quot;&amp;lt;span&amp;gt;&amp;quot;);
        options.setSimplePostfix(&amp;quot;&amp;lt;/span&amp;gt;&amp;quot;);
        query.setHighlightOptions(options);

        // 搜索
        HighlightPage&amp;lt;Menu&amp;gt; page = template.queryForHighlightPage(&amp;quot;testcore&amp;quot;, query, Menu.class);
        List&amp;lt;Menu&amp;gt; result = new ArrayList&amp;lt;&amp;gt;();
        // 获取搜索结果中高亮处理过的结果。
        List&amp;lt;HighlightEntry&amp;lt;Menu&amp;gt;&amp;gt; list = page.getHighlighted();
        for(HighlightEntry&amp;lt;Menu&amp;gt; entry: list){
            // 获取entry中的高亮数据集合
            List&amp;lt;HighlightEntry.Highlight&amp;gt; highlights = entry.getHighlights();
            // 获取没有经过高亮处理的结果对象
            Menu menu = entry.getEntity();
            for (HighlightEntry.Highlight highlight : highlights){
                // 判断高亮数据的字段是否是自己需要的。
                if(highlight.getField().getName().equals(&amp;quot;myfield&amp;quot;)) {
                    // 获取高亮处理的字符串
                    String highlightString = highlight.getSnipplets().get(0);
                    // 把高亮处理的字符串赋值给对象。
                    menu.setTitle(highlightString);
                }
            }
            result.add(menu);
        }
        System.out.println(result);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;12-solrcloud&#34;&gt;12、SolrCloud&lt;/h2&gt;
&lt;p&gt;Solr 可以搭建具备容错能力和高可用的 Solr 集群。集群中集群配置、自动负载均衡和查询故障转移、Zookeeper 集群实现集群协调管理，这些全部功能统称为 SolrCloud。&lt;/p&gt;
&lt;p&gt;SolrCloud 是基于 Zookeeper 进行管理的。在 Solr 中已经内置了 Zookeeper 相关内容，当执行集群创建命令会自动创建 Zookeeper 相关内容。这个使用的是 Zookeeper 的集群管理功能实现的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建&lt;br&gt;
SolrCloud 已经包含在了 Solr 中，可以直接启动 Solr 集群。&lt;/p&gt;
&lt;p&gt;./solr -e cloud -noprompt -force&lt;/p&gt;
&lt;p&gt;此命令等同于# ./solr -e cloud -force 全部参数为默认值。&lt;/p&gt;
&lt;p&gt;运行成功后会在 example 文件夹多出 cloud 文件夹。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;停止&lt;/p&gt;
&lt;p&gt;./solr stop -all&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重新运行&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;./solr start -c -p 8983 -s ../example/cloud/node1/solr/ -force&lt;/p&gt;
&lt;p&gt;./solr start -c -p 7574 -z localhost:9983 -s ../example/cloud/node2/solr/ -force&lt;/p&gt;
">Solr</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jonchan1013.github.io/post/mycat/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200715172709.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;1-mycat-简介&#34;&gt;1、MyCat 简介&lt;/h2&gt;
&lt;h3 id=&#34;11-什么是-mycat&#34;&gt;1.1 什么是 MyCat&lt;/h3&gt;
&lt;p&gt;MyCat 是目前最流行的基于 java 语言编写的数据库中间件，是一个实现了 MySQL 协议的服务器，前端用户可以把它看作是一个数据库代理，用 MySQL 客户端工具和命令行访问，而其后端可以用 MySQL 原生协议与多个 MySQL 服务器通信，也可以用 JDBC 协议与大多数主流数据库服务器通信，其核心功能是分库分表。配合数据库的主从模式还可实现读写分离。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;MyCat 是基于阿里开源的 Cobar 产品而研发，Cobar 的稳定性、可靠性、优秀的架构和性能以及众多成熟的使用案例使得 MyCat 变得非常的强大。&lt;br&gt;
MyCat 发展到目前的版本，已经不是一个单纯的 MySQL 代理了，它的后端可以支持MySQL、SQL Server、Oracle、DB2、PostgreSQL 等主流数据库，也支持 MongoDB 这种新型NoSQL 方式的存储，未来还会支持更多类型的存储。而在最终用户看来，无论是那种存储方式，在 MyCat 里，都是一个传统的数据库表，支持标准的 SQL 语句进行数据的操作，这样一来，对前端业务系统来说，可以大幅降低开发难度，提升开发速度。&lt;br&gt;
MyCat 官网：http://www.mycat.io/&lt;/p&gt;
&lt;h3 id=&#34;12-使用-mycat-后的结构图&#34;&gt;1.2 使用 Mycat 后的结构图&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200716163049.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;13-使用-mycat-的优势&#34;&gt;1.3 使用 Mycat 的优势&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;数据量级&lt;/p&gt;
&lt;p&gt;单一的 MySQL 其数据存储量级和操作量级有限.&lt;br&gt;
Mycat 可以管理若干 MySQL 数据库,同时实现数据的存储和操作.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开源性质&lt;br&gt;
Mycat 是 java 编写的中间件. 开源,免费.&lt;br&gt;
有非常多的人和组织对 Mycat 实行开发,维护,管理,更新.&lt;br&gt;
Mycat 版本提升较快,可以跟随环境发展.如果有问题,可以快速解决.&lt;br&gt;
Mycat 有开源网站和开源社区.且有官方发布的电子书籍.&lt;br&gt;
Mycat 是阿里原应用 corba 转型而来的.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;市场应用&lt;br&gt;
2015 年左右,Mycat 在互联网应用中占比非常高.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-mycat-中的概念&#34;&gt;2、 MyCat 中的概念&lt;/h2&gt;
&lt;h3 id=&#34;21-切分&#34;&gt;2.1 切分&lt;/h3&gt;
&lt;p&gt;逻辑上的切分. 在物理层面,是使用多库[database],多表[table]实现的切分.&lt;/p&gt;
&lt;h4 id=&#34;211-纵向切分垂直切分&#34;&gt;2.1.1 纵向切分/垂直切分&lt;/h4&gt;
&lt;p&gt;就是把原本存储于一个库的数据存储到多个库上。&lt;br&gt;
由于对数据库的读写都是对同一个库进行操作，所以单库并不能解决大规模并发写入的问题。&lt;br&gt;
例如，我们会建立定义数据库 workDB、商品数据库 payDB、用户数据库 userDB、日志数据库 logDB 等，分别用于存储项目数据定义表、商品定义表、用户数据表、日志数据表等。&lt;br&gt;
优点&lt;br&gt;
1）减少增量数据写入时的锁对查询的影响。&lt;br&gt;
2）由于单表数量下降，常见的查询操作由于减少了需要扫描的记录，使得单表单次查询所需的检索行数变少，减少了磁盘 IO，时延变短。&lt;br&gt;
缺点：无法解决单表数据量太大的问题。&lt;/p&gt;
&lt;h4 id=&#34;212-横向切分水平切分&#34;&gt;2.1.2 横向切分/水平切分&lt;/h4&gt;
&lt;p&gt;把原本存储于一个表的数据分块存储到多个表上。当一个表中的数据量过大时，我们可以把该表的数据按照某种规则，进行划分，然后存储到多个结构相同的表，和不同的库上。&lt;br&gt;
例如，我们 userDB 中的 userTable 中数据量很大，那么可以把 userDB 切分为结构相同的多个 userDB：part0DB、part1DB 等，再将 userDB 上的 userTable，切分为很多 userTable：userTable0、userTable1 等，然后将这些表按照一定的规则存储到多个 userDB 上。&lt;br&gt;
优点&lt;br&gt;
1）单表的并发能力提高了，磁盘 I/O 性能也提高了。&lt;br&gt;
2）如果出现高并发的话，总表可以根据不同的查询，将并发压力分到不同的小表里面。&lt;br&gt;
缺点：无法实现表连接查询。&lt;/p&gt;
&lt;h3 id=&#34;22-逻辑库-schema&#34;&gt;2.2 逻辑库-Schema&lt;/h3&gt;
&lt;p&gt;Mycat 中定义的 database.是逻辑上存在的.但是物理上是不存在的.&lt;br&gt;
主要是针对纵向切分提供的概念.&lt;/p&gt;
&lt;h3 id=&#34;23-逻辑表-table&#34;&gt;2.3 逻辑表-table&lt;/h3&gt;
&lt;p&gt;Mycat 中定义的 table.是逻辑上存在,物理上是不存在的.&lt;br&gt;
主要是针对横向切分提供的概念.&lt;/p&gt;
&lt;h3 id=&#34;24-默认端口&#34;&gt;2.4  默认端口&lt;/h3&gt;
&lt;p&gt;MySQL 默认端口是 3306&lt;br&gt;
&lt;strong&gt;Mycat 默认端口是 8066&lt;/strong&gt;&lt;br&gt;
tomcat 默认端口是 8080&lt;br&gt;
Oracle 默认端口是 1521&lt;br&gt;
nginx 默认端口是 80&lt;br&gt;
http 协议默认端口 80&lt;br&gt;
redis 默认端口 6379&lt;/p&gt;
&lt;h3 id=&#34;25-数据主机-datahost&#34;&gt;2.5  数据主机 - dataHost&lt;/h3&gt;
&lt;p&gt;物理 MySQL 存放的主机地址.可以使用主机名,IP,域名定义.&lt;/p&gt;
&lt;h3 id=&#34;26-数据节点-datanode&#34;&gt;2.6 数据节点 - dataNode&lt;/h3&gt;
&lt;p&gt;配置物理的 database. 数据保存的物理节点.就是 database.&lt;/p&gt;
&lt;h3 id=&#34;27-分片规则&#34;&gt;2.7 分片规则&lt;/h3&gt;
&lt;p&gt;当控制数据的时候,如何访问物理 database 和 table.&lt;br&gt;
就是访问 dataHost 和 dataNode 的算法.&lt;br&gt;
在 Mycat 处理具体的数据 CRUD 的时候,如何访问 dataHost 和 dataNode 的算法.如:哈希算法,crc32 算法等&lt;/p&gt;
&lt;h2 id=&#34;3-mycat-的使用&#34;&gt;3、 MyCat 的使用&lt;/h2&gt;
&lt;h3 id=&#34;31-读写分离&#34;&gt;3.1 读写分离&lt;/h3&gt;
&lt;p&gt;原理：需要搭建主从模式，让主数据库（master）处理事务性增、改、删操作（INSERT、UPDATE、DELETE），而从数据库（slave）处理 SELECT 查询操作。&lt;br&gt;
Mycat 配合数据库本身的复制功能，可以解决读写分离的问题。&lt;/p&gt;
&lt;h3 id=&#34;32-主从备份概念&#34;&gt;3.2 主从备份概念&lt;/h3&gt;
&lt;p&gt;什么是主从备份: 就是一种主备模式的数据库应用.&lt;br&gt;
主库(Master)数据与备库(Slave)数据完全一致.&lt;br&gt;
实现数据的多重备份, 保证数据的安全.&lt;br&gt;
可以在 Master[InnoDB]和 Slave[MyISAM]中使用不同的数据库引擎,实现读写的分离&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MySQL5.5, 5.6 版本后本身支持主从备份&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在老旧版本的 MySQL 数据库系统中,不支持主从备份,需要安装额外的 RPM 包.&lt;br&gt;
如果需要安装 RPM,只能在一个位置节点安装.&lt;/p&gt;
&lt;h4 id=&#34;321-主从备份目的&#34;&gt;3.2.1 主从备份目的&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;实现主备模式&lt;/p&gt;
&lt;p&gt;保证数据的安全. 尽量避免数据丢失的可能.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现读写分离&lt;/p&gt;
&lt;p&gt;使用不同的数据库引擎,实现读写分离.提高所有的操作效率.&lt;br&gt;
InnoDB 使用 DML 语法操作. MyISAM 使用 DQL 语法操作.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;322-主从备份效果&#34;&gt;3.2.2 主从备份效果&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;主库操作同步到备库：&lt;/p&gt;
&lt;p&gt;所有对 Master 的操作,都会同步到 Slave 中.&lt;br&gt;
&lt;strong&gt;如果 Master 和 Salve 天生上环境不同,那么对 Master 的操作,可能会在 Slave 中出现错误如: 在创建主从模式之前,Master 有 database : db1, db2, db3. Slave 有 database: db1,db2.&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;创建主从模式.现在的情况 Master 和 Slave 天生不同.&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;主从模式创建成功后,在 Master 中 drop database db3. Slave 中抛出数据库 SQL 异常.后续所有的命令不能同步.&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;一旦出现错误. 只能重新实现主从模式.&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;323-主从模式下的逻辑图&#34;&gt;3.2.3  主从模式下的逻辑图&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200716164034.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;33-mysql-的主从模式搭建&#34;&gt;3.3  MySql 的主从模式搭建&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安装 MySQL&lt;br&gt;
已安装&lt;br&gt;
主库：192.168.70.148&lt;br&gt;
从库：192.168.70.149&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主从备份配置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Master[主库]配置&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;修改 Master 配置文件&lt;br&gt;
路径：/etc/my.cnf&lt;br&gt;
命令：vim /etc/my.cnf&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;server_id&lt;br&gt;
本环境中 server_id 是 1&lt;br&gt;
MySQL 服务唯一标识&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;配置要求：&lt;br&gt;
server_id 任意配置,只要是数字即可&lt;br&gt;
server_id Master 唯一标识数字必须小于 Slave 唯一标识数字.&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;log_bin&lt;br&gt;
本环境中 log_bin 值 : master_log&lt;br&gt;
开启日志功能以及日志文件命名,log_bin=master_log&lt;br&gt;
变量的值就是日志文件名称.是日志文件名称的主体.&lt;br&gt;
MySQL 数据库自动增加文件名后缀和文件类型.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重启 MySQL&lt;br&gt;
service mysqld restart&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置 Master&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;访问 MySQL&lt;br&gt;
mysql -uusername -ppassword&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建用户&lt;br&gt;
在 MySQL 数据库中,为不存在的用户授权,就是同步创建用户并授权.&lt;br&gt;
此用户是从库访问主库使用的用户&lt;br&gt;
ip 地址不能写为%. 因为主从备份中,当前创建的用户,是给从库 Slave 访问主库 Master使用的.用户必须有指定的访问地址.不能是通用地址.&lt;br&gt;
grant all privileges on &lt;em&gt;.&lt;/em&gt; to ‘username’@’ip’ identified by ‘password’ with grant option;&lt;br&gt;
flush privileges;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;grant all privileges on *.* to &#39;myslave&#39;@&#39;192.168.70.149&#39; identified by &#39;myslave&#39; with grant option;
flush privileges;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看用户&lt;/p&gt;
&lt;p&gt;use mysql;&lt;br&gt;
select host, name from user;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200716164332.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看 Master 信息&lt;br&gt;
show master status;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200716164351.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关闭防火墙或在防火墙中开放 3306 端口&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Slave[从库]配置&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;修改 Slave 配置文件&lt;br&gt;
/etc/my.cnf&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;server_id&lt;br&gt;
唯一标识, 本环境中配置为 : 2&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重启 MySQL 服务&lt;br&gt;
service mysqld restart&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置 Slave&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;访问 mysql&lt;br&gt;
mysql -uusername -ppassword&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;停止 Slave 功能&lt;/p&gt;
&lt;p&gt;stop slave&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置主库信息&lt;br&gt;
需要修改的数据是依据 Master 信息修改的. ip 是 Master 所在物理机 IP. 用户名和密码是Master 提供的 Slave 访问用户名和密码. 日志文件是在 Master 中查看的主库信息提供的.在Master 中使用命令 show master status 查看日志文件名称.&lt;br&gt;
change master to master_host=’ip’, master_user=’username’, master_password=’password’,master_log_file=’log_file_name’;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;change master to master_host=&#39;192.168.70.148&#39;,master_user=&#39;myslave&#39;,master_password=&#39;myslave&#39;,master_log_file=&#39;master_log.000001&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动 Slave 功能&lt;/p&gt;
&lt;p&gt;start slave;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看 Slave 配置&lt;br&gt;
show slave status \G;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200716164648.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200716164709.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;测试主从&lt;/p&gt;
&lt;p&gt;新建库&lt;/p&gt;
&lt;p&gt;create database demo1 default character set utf8;&lt;/p&gt;
&lt;p&gt;新建表&lt;/p&gt;
&lt;p&gt;CREATE TABLE &lt;code&gt;t_users&lt;/code&gt; (&lt;br&gt;
&lt;code&gt;id&lt;/code&gt; int(11) NOT NULL,&lt;br&gt;
&lt;code&gt;name&lt;/code&gt; varchar(30) DEFAULT NULL,&lt;br&gt;
PRIMARY KEY (&lt;code&gt;id&lt;/code&gt;)&lt;br&gt;
) ENGINE=InnoDB DEFAULT CHARSET=utf8;&lt;/p&gt;
&lt;p&gt;添加数据&lt;/p&gt;
&lt;p&gt;insert into users values(1,‘admin’)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;4-安装-mycat&#34;&gt;4、安装 MyCat&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安装环境&lt;br&gt;
192.168.70.150&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;需要配置 JDK&lt;br&gt;
已安装&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在主数据库和从数据库都需要完成&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;放开 3306 端口&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;保证 root 用户可以被 mycat 访问&lt;br&gt;
在 Mycat 中通过 Master 数据库的 root 用户访问 Master 数据库.&lt;/p&gt;
&lt;p&gt;grant all privileges on &lt;em&gt;.&lt;/em&gt; to &#39;root&#39;@&#39;%&#39; identified by &#39;root&#39; with grant option;&lt;/p&gt;
&lt;p&gt;flush privileges;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解压上传的 Mycat 压缩包&lt;br&gt;
tar -zxf Mycat-server-1.6-RELEASE-20161028204710-linux.tar.gz&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将解压后的文件夹复制到/usr/local/mycat&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MyCat 目录介绍&lt;br&gt;
bin 目录里是启动脚本&lt;br&gt;
conf 目录里是配置文件&lt;br&gt;
catlet 为 Mycat 的一个扩展功能&lt;/p&gt;
&lt;p&gt;lib 目录里是 Mycat 和它的依赖 jar&lt;br&gt;
logs 目录里是 console.log 用来保存控制台日志，和 mycat.log 用来保存 mycat 的 log4j日志&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;5-mycat-配置文件&#34;&gt;5、MyCat 配置文件&lt;/h2&gt;
&lt;p&gt;Mycat 的架构其实很好理解，Mycat 是代理，Mycat 后面就是物理数据库。和 Web 服务器的 Nginx 类似。对于使用者来说，访问的都是 Mycat，不会接触到后端的数据库。我们现在做一个主从、读写分离。结构如下图：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200716165236.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;Mycat 的配置文件都在 conf 目录里面，这里介绍几个常用的文件&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;文件&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;server.xml&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;MyCat 的配置文件，设置账号、参数等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;schema.xml&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;MyCat 对应的物理数据库和数据库表的配置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;rule.xml&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;MyCat 分片（分库分表）规则&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;51-serverxml&#34;&gt;5.1 server.xml&lt;/h3&gt;
&lt;p&gt;常见修改内容:&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200716165355.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;配置 Mycat 服务信息&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如: Mycat 中的用户,用户可以访问的逻辑库,可以访问的逻辑表,服务的端口号等&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;user&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;用户配置节点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;--name&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;登录的用户名，也就是连接 Mycat 的用户名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;--password&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;登录的密码，也就是连接 Mycat 的密码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;--schemas&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;逻辑库名，这里会和 schema.xml 中的配置关联，多个用逗号分开，例如需要这个用户管理两个数据库 db1,db2，则配置 db1,db2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;--privileges&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;配置用户针对表的增删改查的权限&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;默认配置了一个账号 root 密码也是 123456,针对数据库 TESTDB,读写权限都有，没有针对表做任何特殊的权限。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;配置权限&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200716165607.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;dml 权限顺序为：insert(新增),update(修改),select(查询),delete(删除),0000--&amp;gt; 1111,0 为禁止权限，1 为开启权限。&lt;/p&gt;
&lt;h3 id=&#34;52-schemaxml&#34;&gt;5.2  schema.xml&lt;/h3&gt;
&lt;p&gt;schema.xml 是最主要的配置文件，首先看默认的配置文件&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200716165647.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;521-用于定义逻辑库和逻辑表的配置文件&#34;&gt;5.2.1 用于定义逻辑库和逻辑表的配置文件&lt;/h4&gt;
&lt;p&gt;在配置文件中可以定义读写分离,逻辑库,逻辑表,dataHost,dataNode 等信息.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;schema&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;配置逻辑库，name 与 server.xml 中 schema 对应&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;dataNode&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;定义数据节点的标签，也就是分库相关配置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;dataHost&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;物理数据库，真正存储数据的数据库&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;522-节点与属性介绍&#34;&gt;5.2.2 节点与属性介绍&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;标签 schema&lt;/p&gt;
&lt;p&gt;配置逻辑库的标签&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;属性 name&lt;br&gt;
逻辑库名称&lt;/li&gt;
&lt;li&gt;属性 checkSQLschema&lt;br&gt;
是否检测 SQL 语法中的 schema 信息.&lt;br&gt;
如: Mycat 逻辑库名称 A, dataNode 名称 B&lt;br&gt;
SQL : select * from A.table;&lt;br&gt;
checkSQLschema 值是 true, Mycat 发送到数据库的 SQL 是 select * from table;&lt;br&gt;
checkSQLschema 只是 false,Mycat 发送的数据库的 SQL 是 select * from A.table;&lt;/li&gt;
&lt;li&gt;sqlMaxLimit&lt;br&gt;
Mycat 在执行 SQL 的时候,如果 SQL 语句中没有 limit 子句.自动增加 limit 子句. 避免一次&lt;br&gt;
性得到过多的数据,影响效率. limit 子句的限制数量默认配置为 100.如果 SQL 中有具体的 limit&lt;br&gt;
子句,当前属性失效.&lt;br&gt;
SQL : select * from table . mycat 解析后: select * from table limit 100&lt;br&gt;
SQL : select * from table limit 10 . mycat 不做任何操作修改.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;标签 table&lt;br&gt;
定义逻辑表的标签&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;属性 name&lt;br&gt;
逻辑表名&lt;/li&gt;
&lt;li&gt;属性 dataNode&lt;br&gt;
数据节点名称. 即物理数据库中的 database 名称.多个名称使用逗号分隔.&lt;/li&gt;
&lt;li&gt;属性 rule&lt;br&gt;
分片规则名称.具体的规则名称参考 rule.xml 配置文件.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;标签 dataNode&lt;br&gt;
定义数据节点的标签&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;属性 name&lt;br&gt;
数据节点名称, 是定义的逻辑名称,对应具体的物理数据库 database&lt;/li&gt;
&lt;li&gt;属性 dataHost&lt;br&gt;
引用 dataHost 标签的 name 值,代表使用的物理数据库所在位置和配置信息.&lt;/li&gt;
&lt;li&gt;属性 database&lt;br&gt;
在 dataHost 物理机中,具体的物理数据库 database 名称.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;dataHost 标签&lt;br&gt;
定义数据主机的标签&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;属性 name&lt;br&gt;
定义逻辑上的数据主机名称&lt;/li&gt;
&lt;li&gt;属性 maxCon/minCon&lt;br&gt;
最大连接数, max connections&lt;br&gt;
最小连接数, min connections&lt;/li&gt;
&lt;li&gt;属性 dbType&lt;br&gt;
数据库类型 : mysql 数据库&lt;/li&gt;
&lt;li&gt;属性 dbDriver&lt;br&gt;
数据库驱动类型, native,使用 mycat 提供的本地驱动.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;dataHost 子标签 writeHost&lt;br&gt;
写数据的数据库定义标签. 实现读写分离操作.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;属性 host&lt;br&gt;
数据库命名&lt;/li&gt;
&lt;li&gt;属性 url&lt;br&gt;
数据库访问路径&lt;/li&gt;
&lt;li&gt;属性 user&lt;br&gt;
数据库访问用户名&lt;/li&gt;
&lt;li&gt;属性 password&lt;br&gt;
访问用户密码&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;writeHost 子标签 readHost&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;属性 host&lt;br&gt;
数据库命名&lt;/li&gt;
&lt;li&gt;属性 url&lt;br&gt;
数据库访问路径&lt;/li&gt;
&lt;li&gt;属性 user&lt;br&gt;
数据库访问用户名&lt;/li&gt;
&lt;li&gt;属性 password&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;53-rulexml&#34;&gt;5.3  rule.xml&lt;/h3&gt;
&lt;p&gt;用于定义分片规则的配置文件.&lt;br&gt;
mycat 默认的分片规则: 以 500 万为单位,实现分片规则.&lt;br&gt;
逻辑库 A 对应 dataNode - db1 和 db2. 1-500 万保存在 db1 中, 500 万零 1 到 1000 万保存在 db2 中,1000 万零 1 到 1500 万保存在 db1 中.依次类推.&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200716170524.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;tableRule&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;name&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;属性指定唯一的名字，用于标识不同的分片规则。内嵌的 rule 标签则指定对物理表中的哪一列进行拆分和使用什么分片算法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;columns&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;指定要拆分的列名字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;algorithm&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;使用 function 标签中的 name 属性。连接表规则和具体分片算法。 table 标签内使用。让逻辑表使用这个规则进行分片&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;function&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200716170718.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;name&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;指定算法的名字&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;class&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;制定分片算法具体的类名字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;property&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;为具体算法需要用到的一些属性&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;6-实现读写分离&#34;&gt;6、 实现读写分离&lt;/h2&gt;
&lt;h3 id=&#34;61-配置读写分离&#34;&gt;6.1 配置读写分离&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Schema.xml&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200716170859.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;Server.xml&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200716170917.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200716170947.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;测试读写分离&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;启动 Mycat 命令&lt;br&gt;
bin/mycat start&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;停止命令&lt;br&gt;
bin/mycat stop&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重启命令&lt;br&gt;
bin/mycat restart&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看 MyCat 状态&lt;br&gt;
bin/mycat status&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;访问方式&lt;br&gt;
可以使用命令行访问或客户端软件访问.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;命令行访问方式&lt;br&gt;
mysql -u 用户名 -p 密码 -hmycat 主机 IP -P8066&lt;br&gt;
链接成功后,可以当做 MySQL 数据库使用.&lt;br&gt;
访问约束&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看 Mycat 日志&lt;br&gt;
logs/wrapper.log&lt;br&gt;
日志中记录的是所有的 mycat 操作. 查看的时候主要看异常信息 caused by 信息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;balance&lt;br&gt;
balance=”0”, 不开启读写分离机制，所有读操作都发送到当前可用的 writeHost 上&lt;br&gt;
balance=”1”，全部的 readHost 与 stand by writeHost 参与 select 语句的负载均衡&lt;br&gt;
balance=”2”，所有读操作都随机的在 writeHost、 readhost 上分发。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;balance=”3”， 所有读请求随机的分发到 writeHost 对应的 readhost 执行,writerHost不负担读压力&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;7、MyCat 分库&lt;/p&gt;
&lt;h3 id=&#34;71-分片规则&#34;&gt;7.1 分片规则&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;auto-sharding-long 范围约定&lt;/p&gt;
&lt;p&gt;以 500 万为单位,实现分片规则.&lt;br&gt;
逻辑库 A 对应 dataNode - db1 和 db2. 1-500 万保存在 db1 中, 500 万零 1 到 1000 万保存在 db2 中,1000 万零 1 到 1500 万保存在 db1 中.依次类推.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;crc32slot 规则&lt;br&gt;
在 CRUD 操作时,根据具体数据的 crc32 算法计算,数据应该保存在哪一个 dataNode 中&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;72-配置分片规则需要注意的地方&#34;&gt;7.2 配置分片规则需要注意的地方&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;1）&lt;columns&gt;id&lt;/columns&gt;中推荐配置主键列&lt;/em&gt;&lt;br&gt;
&lt;em&gt;2）所有的 tableRule 只能使用一次。如果需要为多个表配置相同的分片规则，那么需要在此重新定义该规则。&lt;/em&gt;&lt;br&gt;
&lt;em&gt;3）在 crc32Slot 算法中的分片数量一旦给定，MyCat 会将该分片数量和 slor 的取值范围保存到文件中。在次修改分片数量时是不会生效的，需要将该文件删除。文件位置位于 conf目录中的 ruledata 目录中。&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&#34;73-配置分库&#34;&gt;7.3 配置分库&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;需求：&lt;br&gt;
1）在 master 中创建 3 个数据库&lt;br&gt;
2）在 MyCat 中配置分库&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建数据库&lt;/p&gt;
&lt;p&gt;create database demo1 default character set utf8;&lt;br&gt;
create database demo2 default character set utf8;&lt;br&gt;
create database demo3 default character set utf8;&lt;/p&gt;
&lt;p&gt;创建 t_users 表：&lt;/p&gt;
&lt;p&gt;CREATE TABLE &lt;code&gt;t_users&lt;/code&gt; (&lt;/p&gt;
&lt;p&gt;&lt;code&gt;id&lt;/code&gt; int(11) NOT NULL,&lt;br&gt;
&lt;code&gt;name&lt;/code&gt; varchar(30) DEFAULT NULL,&lt;br&gt;
PRIMARY KEY (&lt;code&gt;id&lt;/code&gt;)&lt;br&gt;
) ENGINE=InnoDB DEFAULT CHARSET=utf8;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 Schema.xml&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200716171350.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;18&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200716171412.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;74-注意&#34;&gt;7.4 注意：&lt;/h3&gt;
&lt;p&gt;1）使用 MyCat 实现分库时，先在 MyCat 中定义逻辑库与逻辑表，然后在 MyCat 的链接中执行创建表的命令必须要在 MyCat 中运行。因为 MyCat 在创建表时，会在表中添加一个新的列，列名为_slot。&lt;br&gt;
2）使用 MyCat 插入数据时，语句中必须要指定所有的列。即便是一个完全项插入也不允许省略列名。&lt;/p&gt;
">MyCat</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jonchan1013.github.io/post/spring-bootlayui-kuai-su-da-jian-hou-tai-guan-li-xi-tong-dan-ti-ying-yong-qian-hou-duan-fen-chi/"" data-c="
          &lt;h2 id=&#34;1-layui&#34;&gt;1、Layui&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200710151802.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200710151954.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;table.html&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;
&lt;/code&gt;&lt;/pre&gt;
">后台管理系统（单体应用+前后端分离）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jonchan1013.github.io/post/mongodb/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200708172130.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;1-mongodb-简介&#34;&gt;1、MongoDB 简介&lt;/h2&gt;
&lt;h3 id=&#34;11-什么是-mongodb&#34;&gt;1.1 什么是 MongoDB&lt;/h3&gt;
&lt;p&gt;MongoDB 是一个基于分布式文件存储的数据库。由 C++语言编写。在为 WEB 应用提供可扩展的高性能数据存储解决方案。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;MongoDB 是一个介于关系数据库和非 关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。它支持的数据结构非常松散，是类似json 的bson 格式，因此可以存储比较复杂的数据类型。Mongo 最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。&lt;/p&gt;
&lt;h3 id=&#34;12-什么是nosql&#34;&gt;1.2 什么是NoSQL&lt;/h3&gt;
&lt;p&gt;NoSQL(NoSQL = Not Only SQL )，意即“不仅仅是SQL”，是一项全新的数据库革命性运动，早期就有人提出，发展至 2009 年趋势越发高涨。NoSQL 的拥护者们提倡运用非关系型的数据存储，相对于铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入。&lt;/p&gt;
&lt;h3 id=&#34;13-nosql-数据库的分类&#34;&gt;1.3 NoSQL 数据库的分类&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;键值(Key-Value)存储数据库&lt;/p&gt;
&lt;p&gt;这一类数据库主要会使用到一个哈希表，这个表中有一个特定的键和一个指针指向特定的数据。Key/value 模型对于 IT 系统来说的优势在于简单、易部署。但是如果 DBA 只对部分值进行查询或更新的时候，Key/value 就显得效率低下了。例如： Redis&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;列存储数据库&lt;br&gt;
这部分数据库通常是用来应对分布式存储的海量数据。键仍然存在，但是它们的特点是指向了多个列。这些列是由列家族来安排的。如：HBase。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;文档型数据库&lt;br&gt;
文档型数据库的灵感是来自于 Lotus Notes 办公软件的，而且它同第一种键值存储相类似。该类型的数据模型是版本化的文档，半结构化的文档以特定的格式存储，比如JSON。文档型数据库可 以看作是键值数据库的升级版，允许之间嵌套键值。而且文档型数据库比键值数据库的查询效率更高。如：CouchDB, MongoDB. 国内也有文档型数据库 SequoiaDB，已经开源。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;图形(Graph)数据库&lt;br&gt;
图形结构的数据库同其他行列以及刚性结构的 SQL 数据库不同，它是使用灵活的图形模型，并且能够扩展到多个服务器上。NoSQL 数据库没有标准的查询语言(SQL)，因此进行数据库查询需要制定数据模型。许多 NoSQL 数据库都有REST 式的数据接口或者查询API。如：Neo4J, InfoGrid。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-mongodb-与关系型数据库对比&#34;&gt;2、MongoDB 与关系型数据库对比&lt;/h2&gt;
&lt;h3 id=&#34;21-与关系型数据库术语对比&#34;&gt;2.1  与关系型数据库术语对比&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200708220755.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;22-存储数据对比&#34;&gt;2.2 存储数据对比&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200708220819.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;23-rdbms-与-mongodb-对应的术语&#34;&gt;2.3 RDBMS 与 MongoDB 对应的术语&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200708221436.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;3-mongodb-的数据类型&#34;&gt;3、 MongoDB 的数据类型&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200708221500.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200708221505.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;4-mongodb-的下载与安装&#34;&gt;4、MongoDB 的下载与安装&lt;/h2&gt;
&lt;h3 id=&#34;41-下载-mongodb&#34;&gt;4.1 下载 MongoDB&lt;/h3&gt;
&lt;p&gt;下载地址：https://www.mongodb.com/download-center/community&lt;/p&gt;
&lt;h3 id=&#34;42-安装-mongodb&#34;&gt;4.2 安装 MongoDB&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;下载 ForLinux 平台的 MongoDB&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200708221632.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Linux 安装&lt;br&gt;
在 Linux 平台的MongoDB 为解压版。我们只要解压 tgz 文件就可以使用。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;将下载的 tgz 包上传到Linux 环境中&lt;/p&gt;
&lt;p&gt;我将 tgz 包上传到了自己创建的 temp 目录中。该目录位于/root 目录中。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200708221830.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解压tgz 文件&lt;br&gt;
通过 tar 命令对tgz 文件做解压处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;移动 MongoDB&lt;br&gt;
我们将解压完的MongoDB 目录移动到/usr/local 目录中并改名为mongodb。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200708221855.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建数据库目录&lt;br&gt;
MongoDB 的数据存储在 data 目录的 db 目录下，但是这个目录在安装过程不会自动创建，需要手动创建data 目录，并在data 目录中创建db 目录。data 目录可以创建在任何位置。我们将data 目录创建在mongodb 的根目录下。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200708234940.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200708234949.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;至此 Linux 平台中的 MongoDB 就已经安装完毕。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;43-mongodb-的启动与关闭&#34;&gt;4.3 MongoDB 的启动与关闭&lt;/h3&gt;
&lt;h4 id=&#34;431-启动mongodb&#34;&gt;4.3.1 启动MongoDB&lt;/h4&gt;
&lt;p&gt;MongoDB 的启动方式分为两种&lt;br&gt;
1）前置启动&lt;br&gt;
2）后置启动&lt;br&gt;
无论哪种启动方式都需要执行 bin 目录中的 mongod 命令。MongoDB 在启动时默认的查找数据库的路径为/data/db。如果我们数据库路径有变化，需要在该命令中通过--dbpath 参数来指定db 目录的路径(该路径可以是绝对路径，也可是相对路径)。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;前置启动&lt;br&gt;
MongoDB 的默认启动方式为前置启动。所谓前置启动就是 MongoDB 启动进程后会占用当前终端窗口。&lt;br&gt;
进入到MongoDB 的bin 目录。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200708235039.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;执行 bin 目录中的 mongod 命令。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200708235055.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;由于我们的db 目录放在 mongodb 的根下，所以在执行该命令时需要通过 --dbpath 参数指定db 路径。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200708235122.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;启动后会在终端中输出一些启动信息。此时终端窗口已被启动进程所占用。我们通过启动信息可以看到MongoDB 默认的监听端口为27017&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200708235141.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;按 Ctrl+C 可结束启动进程关闭 MongoDB&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;后置启动&lt;br&gt;
所谓后置启动就是以守护进程的方式启动 MongoDB。我们需要在执行 mongod 命令中添加 --fork 参数。需要注意的是，--fork 参数需要配合着--logpath 或者是--syslog 参数使用。--logpath 与--syslog 参数是指定 MongoDB 的日志文件。MongoDB 的日志文件可以在系统中的任意位置，本视频中我们在 mongodb 目录下创建 log 目录，在该目录中创建一个名为mongodb.log 的日志文件。&lt;/p&gt;
&lt;p&gt;创建 log 目录&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200708235225.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在 log 目录中创建 mongodb.log 日志文件&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200708235238.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;后置启动MongoDB&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;18&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200708235258.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;常见的启动参数&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;--quiet&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;安静输出&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;--port&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;指定服务端口号，默认端口 27017&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;--bind&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;绑定服务IP，若绑定127.0.0.1，则只能本机访问&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;--logpath&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;指定 MongoDB 日志文件，注意是指定日志文件不是目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;--logappend&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;使用追加的方式写日志&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;--fork&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;守护进程的方式运行 MongoDB，创建服务器进程&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;--auth&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;启用验证&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;--config&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;指定配置文件的路径，注意是指定配置文件不是目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;--journal&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;启用日志选项，MongoDB 的数据操作将会写入到 journal 文件夹的文件里&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过配置文件加载启动参数&lt;br&gt;
如果觉得在启动MongoDB 时给定的参数项太多，那么我们也可以通过配置文件来配置启动参数，配置文件可以在任意目录中，配置文件的扩展名应为.conf，配置文件中使用key=value 结构。在执行 MongoDB 时通过--config 参数来指定需要加载的配置文件。&lt;/p&gt;
&lt;p&gt;我们在 mongodb 目录下创建一个 etc 目录，在该目录中创建一个名为 mongodb.conf 的配置文件。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;19&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200708235523.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;创建 mongodb.conf 配置文件&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;20&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200708235533.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;编辑配置文件，在配置文件中添加配置项：&lt;br&gt;
1）指定db 路径&lt;br&gt;
2）指定日志文件&lt;br&gt;
3）配置端口&lt;br&gt;
4）配置后端启动&lt;br&gt;
在配置文件中配置启动参数时需要注意的是，在参数前不在加--符号，直接以参数名作为 key 就可以。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;21&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200708235547.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;通过加载配置文件启动 MongoDB&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;22&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200708235601.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置环境变量&lt;br&gt;
为了能够在任何目录中执行 bin 目录中的命令，我们可以将 bin 目录添加到环境变量中。&lt;br&gt;
修 改 /etc/profile 文 件 ， 添 加 export PATH=/usr/local/mongodb/bin:$PATH 。/usr/local/monogdb/bin 为 MongoDB 的 bin 目录的绝对路径。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;23&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200708235631.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;重新加载/etc/profile 文件&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;24&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200708235643.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;测试结果&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;25&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200708235656.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;432-关闭mongodb&#34;&gt;4.3.2 关闭MongoDB&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用 Ctrl+C 关闭&lt;br&gt;
如果我们的启动方式是前置启动，那么直接使用快捷键Ctrl+C 就可以关闭 MongoDB。这种关闭方式会等待当前进行中的的操作完成，所以依然是安全的关闭方式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 kill 命令关闭&lt;br&gt;
我们可以通过 Linux 的 kill 命令结束 MongoDB 进程，然后删除 data/db 目录中的mongod.lock 文件，否则下次无法启动。但是此方法不建议使用，因为会造成数据损坏现象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 MongoDB 的函数关闭&lt;br&gt;
在 MongoDB 中提供了两个关闭数据库的函数：&lt;br&gt;
db.shutdownServer()&lt;br&gt;
db.runCommand(“shutdown”)&lt;br&gt;
如上两个方法都需要在 admin 库中执行，并且都是安全的关闭方式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 mongod 命令关闭 MongoDB&lt;br&gt;
mongod --shutdown --dbpath&amp;lt;数据库路径&amp;gt;&lt;/p&gt;
&lt;p&gt;./mongod --shutdown --dbpath /usr/local/mongodb/data/db/&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;26&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200709000025.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;mongod 命令的 shutdown 选项能安全的关闭 MongoDB 服务&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;5-mongodb-的用户与权限管理&#34;&gt;5、MongoDB 的用户与权限管理&lt;/h2&gt;
&lt;p&gt;Mongodb 作为时下最为热门的数据库，那么其安全验证也是必不可少的，否则一个没有验证的数据库暴露出去，任何人可随意操作，这将是非常危险的。我们可以通过创建用户的方式来降低风险。&lt;/p&gt;
&lt;h3 id=&#34;51-mongodb-用户权限列表&#34;&gt;5.1  Mongodb 用户权限列表&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Read&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;允许用户读取指定数据库&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;readWrite&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;允许用户读写指定数据库&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;dbAdmin&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;允许用户在指定数据库中执行管理函数，如索引创建、删除，查看统计或访问system.profile&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;userAdmin&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;允许用户向system.users 集合写入，可以找指定数据库里创建、删除和管理用户&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;clusterAdmin&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;只在admin 数据库中可用，赋予用户所有分片和复制集相关函数的管理权限&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;readAnyDatabase&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;只在admin 数据库中可用，赋予用户所有数据库的读权限&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;readWriteAnyDatabase&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;只在admin 数据库中可用，赋予用户所有数据库的读写权限&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;userAdminAnyDatabase&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;只在admin 数据库中可用，赋予用户所有数据库的userAdmin 权限&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;dbAdminAnyDatabase&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;只在admin 数据库中可用，赋予用户所有数据库的dbAdmin 权限&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;root&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;只在admin 数据库中可用。超级账号，超级权限&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;52-mongodb-用户使用&#34;&gt;5.2  MongoDB 用户使用&lt;/h3&gt;
&lt;h4 id=&#34;521-创建-db-管理用户&#34;&gt;5.2.1 创建 DB 管理用户&lt;/h4&gt;
&lt;p&gt;mongodb 有一个用户管理机制，简单描述为，有一个管理用户组，这个组的用户是专门为管理普通用户而设的，暂且称之为管理员。&lt;br&gt;
管理员通常没有数据库的读写权限，只有操作用户的权限, 因此我们只需要赋予管理员userAdminAnyDatabase 角色即可。&lt;br&gt;
另外管理员账户必须在 admin 数据库下创建。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;切换到 Admin 库&lt;/p&gt;
&lt;p&gt;管理员需要在admin 数据库下创建，所以我们需要切换到admin 数据库。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;27&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200709000410.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看admin 中的用户&lt;/p&gt;
&lt;p&gt;我们可以通过db.system.users.find()函数来查看admin 库中的所有用户信息。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;28&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200709000437.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;目前在admin 库中没有用户，所以查无结果。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;db.createUser 函数&lt;br&gt;
在 MongoDB 中可以使用 db.createUser({用户信息})函数创建用户。&lt;/p&gt;
&lt;p&gt;db.createUser({&lt;br&gt;
user: &amp;quot;&lt;name&gt;&amp;quot;,&lt;br&gt;
pwd: &amp;quot;&lt;cleartext password&gt;&amp;quot;,&lt;br&gt;
customData: { &lt;any information&gt; },&lt;br&gt;
roles: [&lt;br&gt;
{ role: &amp;quot;&lt;role&gt;&amp;quot;, db: &amp;quot;&lt;database&gt;&amp;quot; } | &amp;quot;&lt;role&gt;&amp;quot;,&lt;br&gt;
...&lt;br&gt;
]&lt;br&gt;
});&lt;/p&gt;
&lt;p&gt;1）user:新建用户名。&lt;br&gt;
2）pwd:新建用户密码。&lt;br&gt;
3）customData:存放一些用户相关的自定义数据，该属性也可忽略。&lt;br&gt;
4）roles:数组类型，配置用户的权限。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建管理员用户&lt;br&gt;
我们现在需要在admin 库中创建一个名为admin 的管理员用户，密码为admin。 db.createUser({user:&#39;admin&#39;,pwd:&#39;admin,roles:[{role:&#39;userAdminAnyDatabase&#39;,db:&#39;admin&#39;}]})&lt;/p&gt;
&lt;p&gt;创建成功后会看到如下提示：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;29&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200709000650.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重启 MongoDB&lt;/p&gt;
&lt;p&gt;在管理员账户创建完成后，我们需要重新启动 MongoDB，并开启验证。&lt;br&gt;
重新启动函数:db.shutdownServer()。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;30&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200709000714.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用权限方式启动 MongoDB&lt;br&gt;
在默认的情况下MongoDB 是不开启用户认证的。如果我们添加用户，那么需要开启用户认证机制。通过修改 mongodb.conf 配置文件，在文件中添加auth=true 即可。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;31&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200709000730.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;修改完成后启动MongoDB。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户认证&lt;br&gt;
创建管理员后，需要认证方可使用该用户，否则会提示需要认证。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;32&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200709001157.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;认证函数：db.auth(‘用户名’,’密码’)&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;33&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200709001217.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如果结果返回1，则表示认证成功，返回0 则表示认证失败。&lt;br&gt;
登录成功后可查询用户&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;34&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200709001248.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;522-创建普通用户&#34;&gt;5.2.2 创建普通用户&lt;/h4&gt;
&lt;p&gt;普通用户由管理员创建。通常需要指定操作某个数据库。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;需求&lt;br&gt;
我们创建一个test 数据库，给这个数据库添加一个用户，用户名为test,密码为 123。并授予该用户对test 数据库进行读写操作的权限。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用管理员用户登录&lt;br&gt;
普通用户需要由管理员创建并授权。所以，我们首先做的就是用管理员账户登录数据库。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建test 数据库&lt;br&gt;
use 命令切换数据库时如果该库不存在，那么则会创建该数据库。 （要让改用户操作哪个数据库，就切换到哪个数据库）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建普通用户&lt;/p&gt;
&lt;p&gt;db.createUser({user:&amp;quot;test&amp;quot;,pwd:&amp;quot;123&amp;quot;,roles:[{role:&amp;quot;readWrite&amp;quot;,db:&amp;quot;test&amp;quot;}]})&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;切换到test 数据库&lt;br&gt;
由于我们是在test 数据库中创建的test 用户，所以需要先切换到 test 库。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;登录普通用户&lt;br&gt;
如果我们不登录会发现无法对该数据库进行插入操作。因为缺少用户认证。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;35&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200709020628.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;通过认证函数对用户进行登录认证。&lt;/p&gt;
&lt;p&gt;db.auth(&amp;quot;test&amp;quot;,&amp;quot;123&amp;quot;)&lt;/p&gt;
&lt;p&gt;认证成功后操作通过该用户操作 test库。该用户对 test库具备读写操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;523-更新用户角色&#34;&gt;5.2.3 更新用户角色&lt;/h4&gt;
&lt;p&gt;​		如果我们需要对已存在的用户的角色做修改，那么我们可以使用 db.updateUser()函数来更新用户角色。注意，该函数需要当前用户具有userAdminAnyDatabase 或者更高的权限。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;更新角色语法格式&lt;/p&gt;
&lt;p&gt;db.updateUser(&amp;quot;用户名&amp;quot;, {&amp;quot;roles&amp;quot;:[{&amp;quot;role&amp;quot;:&amp;quot;角色名称&amp;quot;},{&amp;quot;更新项 2&amp;quot;:&amp;quot;更新内容&amp;quot;}]})&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;需求&lt;br&gt;
目前 admin 管理员用户只具备 userAdminAnyDatabase 用户管理角色，我们为该用户添加一个dbAdminAnyDatabase 数据库管理角色。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更新角色&lt;br&gt;
db.updateUser(&amp;quot;admin,{roles : [{&amp;quot;role&amp;quot; : &amp;quot;userAdminAnyDatabase&amp;quot;,&amp;quot;db&amp;quot; : &amp;quot;admin&amp;quot;},{&amp;quot;role&amp;quot; : &amp;quot;dbAdminAnyDatabase&amp;quot;,&amp;quot;db&amp;quot; : &amp;quot;admin&amp;quot;}]})&lt;/p&gt;
&lt;p&gt;如果没有提示任何信息则表示更新成功。退出当前客户端重新连接即可生效。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看用户信息&lt;/p&gt;
&lt;p&gt;通过 show users 命令查看到 bjsxt 用户的角色已经发生改变。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;524-更新用户密码&#34;&gt;5.2.4 更新用户密码&lt;/h4&gt;
&lt;p&gt;更新用户密码有两种方式：&lt;br&gt;
1）使用db.updateUser()函数更新密码。&lt;br&gt;
2）使用db.changeUserPassword()函数更新密码&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;更新密码方式一&lt;br&gt;
使用 db.upateUser()函数将xxx用户的密码修改为 xxx&lt;/p&gt;
&lt;p&gt;db.updateUser(&amp;quot;用户名&amp;quot;,{&amp;quot;pwd&amp;quot;:&amp;quot;新密码&amp;quot;})&lt;/p&gt;
&lt;p&gt;如果未提示任何信息则表示更新成功。退出当前客户端重新连接认证即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更新密码方式二&lt;br&gt;
使用 db.changeUserPassword()函数将xxx用户的密码修改为 xxx。&lt;/p&gt;
&lt;p&gt;db.changeUserPassword(&amp;quot;用户名&amp;quot;,&amp;quot;新密码&amp;quot;)&lt;/p&gt;
&lt;p&gt;如果未提示任何信息则表示更新成功。退出当前客户端重新连接认证即可。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;525-删除用户&#34;&gt;5.2.5 删除用户&lt;/h4&gt;
&lt;p&gt;通过 db.dropUser()函数可删除指定用户。删除成功后会返回true。在删除用户时需要切换到创建用户时所指定的数据库中才可以删除。注意：需要使用具有userAdminAnyDatabse角色管理员用户才可以删除其他用户。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;需求&lt;br&gt;
我们使用函数将test 用户删除。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;切换数据库&lt;br&gt;
test 用户在test 数据库中，所以需要先切换到 sxt 数据库。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过函数删除用户&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;36&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200709021400.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;函数返回了true，表示删除成功。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;6-mongodb-的数据库操作&#34;&gt;6、MongoDB 的数据库操作&lt;/h2&gt;
&lt;h3 id=&#34;61-创建数据库&#34;&gt;6.1 创建数据库&lt;/h3&gt;
&lt;p&gt;在 MongoDB 中创建数据库的命令使用的是 use 命令。该命令有两层含义：&lt;br&gt;
1）切换到指定数据库。&lt;br&gt;
2）如果切换的数据库不存在，则创建该数据库。&lt;br&gt;
我们使用use 命令创建一个名为 test01 的数据库。&lt;/p&gt;
&lt;h3 id=&#34;62-查看所有数据库&#34;&gt;6.2 查看所有数据库&lt;/h3&gt;
&lt;p&gt;我们可以通过show dbs 命令查看当前MongoDB 中的所有数据库。&lt;br&gt;
如果开启了用户认证，则需要先登录方可查看到结果，否则不显示任何信息。如果使用的是具备数据库管理员角色的用户，那么则可以看到 MongoDB 中的所有数据库，如果使用的普通用户登录的那么只能查询到该用户所拥有的数据库。&lt;/p&gt;
&lt;p&gt;用户未登录查询数据库。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;37&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200709021637.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在查询结果中并未包含我们刚刚创建的 test01数据库。因为，在show dbs 命令中不显示未含有任何信息的数据的库。&lt;/p&gt;
&lt;p&gt;使用具有数据库管理员角色的用户登录查询数据库。&lt;/p&gt;
&lt;p&gt;使用普通用户登录查询数据库。&lt;br&gt;
我们在test数据库中创建一个只具备读写权限的普通用户。&lt;/p&gt;
&lt;p&gt;使用普通用户登录并查询数据库。&lt;/p&gt;
&lt;h3 id=&#34;63-删除数据库&#34;&gt;6.3 删除数据库&lt;/h3&gt;
&lt;p&gt;在 MongoDB 中使用 db.dropDatabase()函数来删除数据库。在删除数据库之前，需要使用具备dbAdminAnyDatabase 角色的管理员用户登录，然后切换到需要删除的数据库，执行db.dropDatabase()函数即可。删除成功后会返回一个{ &amp;quot;ok&amp;quot; : 1 }的 JSON 字符串。&lt;/p&gt;
&lt;p&gt;我们现在将刚刚创建的test01 删除。&lt;/p&gt;
&lt;h2 id=&#34;7-mongodb-的集合操作&#34;&gt;7、MongoDB 的集合操作&lt;/h2&gt;
&lt;p&gt;MongoDB 中的集合是一组文档的集，相当于关系型数据库中的表。&lt;/p&gt;
&lt;h3 id=&#34;71-创建集合&#34;&gt;7.1 创建集合&lt;/h3&gt;
&lt;p&gt;MongoDB 使用db.createCollection()函数来创建集合。&lt;br&gt;
语法格式：db.createCollection(name, options)。&lt;br&gt;
name: 要创建的集合名称。&lt;br&gt;
options: 可选参数, 指定有关内存大小及索引的选项。&lt;/p&gt;
&lt;p&gt;options 可以是如下参数。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;字段&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;类型&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;capped&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;布尔&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;（可选）如果为 true，则创建固定集合。固定集合是指有着固定大小的集合，当达到最大值时，它会自动覆盖最早的文档。 &lt;br/&gt;&lt;strong&gt;当该值为 true 时，必须指定 size 参数&lt;/strong&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;autoindexid&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;布尔&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选）如为 true，自动在 _id 字段创建索引。默认为 false。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;size&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数值&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选）为固定集合指定一个最大值（以字节计）。 &lt;strong&gt;如果 capped 为 true，也需要指定该字段。&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;max&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数值&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;（可选）指定固定集合中包含文档的最大数量。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在插入文档时，MongoDB 首先检查固定集合的 size 字段，然后检查 max 字段。&lt;/p&gt;
&lt;h4 id=&#34;711-使用默认集合&#34;&gt;7.1.1 使用默认集合&lt;/h4&gt;
&lt;p&gt;在 MongoDB 中，我们也可以不用创建集合，当我们插入一些数据时，会自动创建集合，并且会使用数据库的名字作为集合的名称。&lt;br&gt;
创建一个新数据库，名为develop&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;38&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200709022302.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如果开启认证，需要为新数据库创建访问用户。新建用户名为 itsxt，密码为 itsxtpwd&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;39&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200709022320.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;使用 itsxt 用户登录 develop 库&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;40&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200709022337.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;向 develop 库中插入一条数据&lt;/p&gt;
&lt;p&gt;db.develop.insert({&amp;quot;name&amp;quot;,&amp;quot;cy&amp;quot;})&lt;/p&gt;
&lt;p&gt;查询集合&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;41&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200709022409.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;712-创建不带参数的集合&#34;&gt;7.1.2 创建不带参数的集合&lt;/h4&gt;
&lt;p&gt;我们也可以根据自己的情况创建集合。在 develop 数据库中创建一个名为 dev 的集合，该集合创建时不指定任何参数。如果开启认证，则需要使用具有数据库管理员权限的用户来创建集合。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;42&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200709022442.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;713-创建带参数的集合&#34;&gt;7.1.3 创建带参数的集合&lt;/h4&gt;
&lt;p&gt;在 develop 数据库中创建一个名为 dev2 的固定集合，整个集合空间大小为 2000000kb，文档最大个数为1000。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;43&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200709022641.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;72-查看集合&#34;&gt;7.2 查看集合&lt;/h3&gt;
&lt;p&gt;如果要查看已有集合，可以使用 show collections 或 show tables 命令。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;show collections&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;44&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200709093118.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;show tables&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;45&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200709093132.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;73-删除集合&#34;&gt;7.3 删除集合&lt;/h3&gt;
&lt;p&gt;​		如果我们要删除集合，需要先切换到需要删除集合所在的数据库，使用 drop()函数删除集合即可。&lt;br&gt;
​		删除集合的语法格式为:db.集合名称.drop()。&lt;/p&gt;
&lt;p&gt;​		删除 dev2 集合&lt;/p&gt;
&lt;p&gt;​	&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200709093212.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;8-mongodb-的文档操作&#34;&gt;8、 MongoDB 的文档操作&lt;/h2&gt;
&lt;p&gt;​		在 MongoDB 中文档是指多个键及其关联的值有序地放置在一起就是文档，其实指的就是数据，也是我们平时操作最多的部分。&lt;br&gt;
​		MongoDB 中的文档的数据结构和 JSON 基本一样。所有存储在集合中的数据都是 BSON 格式。&lt;br&gt;
​		BSON 是一种类似 JSON 的二进制形式的存储格式，是 Binary JSON 的简称。&lt;/p&gt;
&lt;h3 id=&#34;81-插入文档&#34;&gt;8.1  插入文档&lt;/h3&gt;
&lt;h4 id=&#34;811-插入单个文档&#34;&gt;8.1.1  插入单个文档&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;insert 函数&lt;/p&gt;
&lt;p&gt;语法格式为：db.COLLECTION_NAME.insert(document)。&lt;/p&gt;
&lt;p&gt;向 dev 集合中插入单个文档。&lt;br&gt;
db.dev.insert({title:&#39; baidu&#39;,description:&#39; 百度&#39;,url:&#39;www.baidu.com&#39;,tags:[&#39;java&#39;,&#39; 大数据&#39;,&#39;python&#39;]} )&lt;/p&gt;
&lt;p&gt;查看文档&lt;/p&gt;
&lt;p&gt;db.dev.find()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;save 函数&lt;br&gt;
向 dev 集合中插入单个文档。&lt;/p&gt;
&lt;p&gt;db.dev.save({title:&#39; baidu&#39;,description:&#39; 百度&#39;,url:&#39;www.baidu.com&#39;,tags:[&#39;java&#39;,&#39; 大数据&#39;,&#39;python&#39;]} )&lt;/p&gt;
&lt;p&gt;查看文档&lt;/p&gt;
&lt;p&gt;db.dev.find()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;insertOne 函数&lt;/p&gt;
&lt;p&gt;在 MongoDB3.2 以后的版本中，提供了 insertOne()函数用于插入文档。&lt;br&gt;
向 dev 集合中插入单个文档。&lt;/p&gt;
&lt;p&gt;db.dev.insertOne({title:&#39; baidu&#39;,description:&#39; 百度&#39;,url:&#39;www.baidu.com&#39;,tags:[&#39;java&#39;,&#39; 大数据&#39;,&#39;python&#39;]} )&lt;/p&gt;
&lt;p&gt;查看文档&lt;/p&gt;
&lt;p&gt;db.dev.find()&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;812-插入多个文档&#34;&gt;8.1.2  插入多个文档&lt;/h4&gt;
&lt;p&gt;向集合中批量插入多个文档时，需要使用数组来存放文档。&lt;br&gt;
语法格式：db.COLLECTION_NAME.insert([{},{},{}.....])。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;insert 或者save 函数&lt;/p&gt;
&lt;p&gt;db.dev.insert([{title:&#39;java&#39;,tags:[&#39;JavaSE&#39;,&#39;JavaEE&#39;,&#39;JavaME&#39;]},{title:&#39;ORM&#39;,tags:[&#39;Mybatis&#39;,&#39;Hibernate&#39;]},{title:&#39;Spring&#39;,tags:[&#39;SpringMVC&#39;,&#39;SpringBoot&#39;,&#39;SpringCloud&#39;]}] )&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;46&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200709095534.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;查看文档&lt;/p&gt;
&lt;p&gt;db.dev.find()&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;47&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200709095637.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;save函数同理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;insertMany 函数&lt;/p&gt;
&lt;p&gt;在 MongoDB3.2 以后的版本中，提供了 insertMany 函数用于插入文档。&lt;br&gt;
语法格式：db.COLLECTION_NAME.insertMany([{},{},{},.....])。&lt;/p&gt;
&lt;p&gt;向 dev 集合中批量插入多个文档&lt;br&gt;
db.dev.insertMany([{title:&#39;Web&#39;,tags:[&#39;JSP&#39;,&#39;Servlet&#39;]},{title:&#39;RPC&#39;,tags:[&#39;RMI&#39;,&#39;Dubbo&#39;]},{title:&#39;DataBase&#39;,tags:[&#39;Oracle&#39;,&#39;MySQL&#39;]}] )&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;48&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200709095754.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;查看文档&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;49&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200709095832.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;813-通过变量插入文档&#34;&gt;8.1.3 通过变量插入文档&lt;/h4&gt;
&lt;p&gt;Mongo Shell 工具允许我们定义变量。所有的变量类型为 var 类型。也可忽略变量类型。变量中赋值符号后侧需要使用小括号来表示变量中的值。我们可以将变量作为任意插入文档的函数的参数。&lt;br&gt;
语法格式：变量名=({变量值})&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;通过变量插入单个文档&lt;br&gt;
定义变量&lt;br&gt;
document=({title:&#39;SpringCloud&#39;,tags:[&#39;Spring Cloud Netflix&#39;,&#39;Spring Cloud Security&#39;,&#39;Spring Cloud Consul&#39;]})&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;50&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200709100123.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;插入文档&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;51&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200709100243.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过变量插入多个文档&lt;/p&gt;
&lt;p&gt;我们也可以在变量中定义多个文档。&lt;br&gt;
语法结构：变量名=([{},{},{},....])&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;52&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200709100333.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;插入文档&lt;/p&gt;
&lt;p&gt;我们现在将多个文档放入到了一个变量中，所以在插入数据时，可直接使用插入单个文档的函数。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;53&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200709103042.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;查询文档&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;54&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200709103054.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;82-更新文档&#34;&gt;8.2 更新文档&lt;/h3&gt;
&lt;p&gt;MongoDB 通过update 函数或者save 函数来更新集合中的文档。&lt;/p&gt;
&lt;h4 id=&#34;821-update-函数&#34;&gt;8.2.1  update 函数&lt;/h4&gt;
&lt;p&gt;update() 函数用于更新已存在的文档。&lt;br&gt;
语法格式：db.COLLECTION_NAME.update({查询条件},{更新内容},{更新参数(可选)})&lt;br&gt;
将 Spring Data 修改为 SpringData&lt;/p&gt;
&lt;p&gt;注：update函数在更新时，取决于所给的更新内容，更新内容是什么样的，就会把文档对象更新成什么样，如果在更新内容中没有包含的内容，则会把这些内容替换掉&lt;/p&gt;
&lt;p&gt;没更新前：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;55&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200709103850.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;更新后：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;56&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200709103256.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;822-更新操作符&#34;&gt;8.2.2 更新操作符&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;$set 操作符&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;$set 操作符：用来指定一个键并更新键值，若键不存在并创建。&lt;br&gt;
语法格式：db.COLLECTION_NAME.update({查询条件},{更新操作符:{更新内容}})&lt;br&gt;
将 Spring Security 修改为 SpringSecurity。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;57&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200709141029.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;修改后的结果&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;58&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200709141042.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;使用$set 在title 为 SpringData 的文档中添加一个属性为 num 值为1。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;59&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200709141109.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;查看结果&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;60&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200709141128.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;批量更新&lt;br&gt;
在更新文档时，可以使用multi 参数实现批量更新。&lt;br&gt;
添加测试数据&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;61&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200709141142.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;将 title 为dev 的文档的 size 更新为500&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;62&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200709141218.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;查看结果&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;63&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200709141229.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;$inc 操作符&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;$inc 操作符：可以对文档的某个值为数字型（只能为满足要求的数字）的键进行增减的操作。&lt;br&gt;
将 title 为SpringData 的文档中的num 值递增 1。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;64&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713131417.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;查看结果&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;65&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713131436.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;$unset 操作符&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;$unset 操作符：主要是用来删除键。&lt;br&gt;
删除 title 为 SpringData 的文档中的num 键。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;66&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713131528.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;查看结果&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;67&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713131539.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;
&lt;p&gt;$push 操作符&lt;/p&gt;
&lt;p&gt;$push 操作符：向文档的某个数组类型的键添加一个数组元素，不过滤重复的数据。添加时键存在，要求键值类型必须是数组；键不存在，则创建数组类型的键。&lt;br&gt;
向 title 为SpringData 的文档中添加一个数组键为tags 值为[“Spirng Data Redis”]&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;68&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713131603.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;查看结果&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;69&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713131615.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$pop 操作符&lt;/p&gt;
&lt;p&gt;$pop 操作符：删除数据元素。&lt;br&gt;
1 表示从数组的尾部删除&lt;br&gt;
删除 title 为 Spring 的文档中tags 数组中的Spring Cloud&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;70&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713131637.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;查看结果&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;71&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713131653.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;-1 表示从数组的头部删除元素&lt;br&gt;
删除 title 为 Spring 的文档中tags 数组中的SpringMVC&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;72&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713131705.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;查看结果&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;73&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713131715.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$pull 操作符&lt;/p&gt;
&lt;p&gt;$pull 操作符：从数组中删除满足条件的元素&lt;br&gt;
删除 title 为 Spring 的文档中tags 数组中的SpringBoot&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;74&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713132639.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;查看结果&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;75&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713132651.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$pullAll 操作符&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;$pullAll 操作符：从数组中删除满足条件的多个元素&lt;br&gt;
删除 title 为 java 的文档中tags 数组中的JavaSE、JavaEE&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;76&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713132729.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;注：键名tags可以加双引号也可以不加&lt;/p&gt;
&lt;p&gt;查看结果&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;77&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713132748.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;8&#34;&gt;
&lt;li&gt;$rename&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;$rename 操作符：对键进行重新命名。&lt;br&gt;
将 title 为Java 的文档中的tags 键修改为tag。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;78&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713132813.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;注：键名tags可以加双引号也可以不加&lt;/p&gt;
&lt;p&gt;查看结果&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;79&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713132823.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;823-使用save函数更新文档&#34;&gt;8.2.3 使用save()函数更新文档&lt;/h4&gt;
&lt;p&gt;save() 方法根据ObjectId，通过传入的文档来替换已有文档。&lt;br&gt;
语法格式：save({文档})&lt;br&gt;
更新 title 为 SpringData 的文档，将SpringData 修改为 Spring Data，并去掉 tags&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;80&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713132947.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;查看结果&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;81&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713132955.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;83-删除文档&#34;&gt;8.3  删除文档&lt;/h3&gt;
&lt;h4 id=&#34;831-remove函数&#34;&gt;8.3.1 remove()函数&lt;/h4&gt;
&lt;p&gt;使用 remove()函数可删除集合中的指定文档。&lt;br&gt;
语法格式：remove({指定删除条件},删除参数(可选参数))&lt;br&gt;
删除 title 为 Spring data 的文档，可使用该文档的ObjectId 作为删除条件&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;82&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713133029.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如果使用的条件在集合中可以匹配多条数据，那么 remove()函数会删除所有满足条件的数据。我们可以在 remove 函数中给定 justOne，表示只删除第一条，在 remove 函数中给定参数1 即可。&lt;br&gt;
向 dev 集合中插入三条拥有相同 title 的测试数据&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;83&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713133058.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;查看结果&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;84&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713133108.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;只删除第一条数据&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;85&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713133122.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;查看结果&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;86&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713133132.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;注意：remove() 方法 并不会真正释放空间。需要继续执行 db.repairDatabase() 来回收磁盘空间。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;87&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713133143.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;832-deleteone函数&#34;&gt;8.3.2 deleteOne()函数&lt;/h4&gt;
&lt;p&gt;deleteOne()函数是官方推荐删除文档的方法。该方法只删除满足条件的第一条文档。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;88&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713133521.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;查看结果&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;89&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713133529.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;833-deletemany函数&#34;&gt;8.3.3 deleteMany()函数&lt;/h4&gt;
&lt;p&gt;deleteMany 函数是官方推荐的删除方法。该方法删除满足条件的所有数据。&lt;br&gt;
再次插入两条测试数据&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;90&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713133550.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;查看结果&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;91&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713133557.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;删除所有title 为 dev 的文档&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;92&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713133609.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;834-删除集合中的所有文档&#34;&gt;8.3.4 删除集合中的所有文档&lt;/h4&gt;
&lt;p&gt;使用 remove 函数删除集合中的所有文档&lt;br&gt;
语法格式：remove({})&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;93&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713133635.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;使用 deleteMany 函数删除所有文档&lt;br&gt;
语法格式：deleteMany({})&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;94&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713133646.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;84-查询文档&#34;&gt;8.4 查询文档&lt;/h3&gt;
&lt;h4 id=&#34;841-find函数&#34;&gt;8.4.1 find()函数&lt;/h4&gt;
&lt;p&gt;在 MongoDB 中可以使用 find()函数查询文档。&lt;br&gt;
语法格式为：find({查询条件(可选)},{指定投影的键(可选)})&lt;br&gt;
如果未给定参数则表示查询所有数据。&lt;br&gt;
pretty()函数可以使用格式化的方式来显示所有文档。&lt;/p&gt;
&lt;p&gt;查询 dev 集合中的所有数据并格式化显示。&lt;/p&gt;
&lt;p&gt;db.dev.find().pretty()&lt;/p&gt;
&lt;p&gt;查询 title 为DataBase 的文档并格式化显示。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;95&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713133828.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;842-findone函数&#34;&gt;8.4.2 findOne()函数&lt;/h4&gt;
&lt;p&gt;indOne()函数只返回满足条件的第一条数据。如果未做投影操作该方法则自带格式化功能。&lt;/p&gt;
&lt;p&gt;语法格式：findOne({查询条件(可选)},{投影操作(可选)})&lt;/p&gt;
&lt;p&gt;db.dev.findOne()&lt;/p&gt;
&lt;p&gt;插入三条测试数据&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;96&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713133916.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;使用 findOne 查询文档，条件为 title 的值为 dev 的文档。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;97&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713133922.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;843-模糊查询&#34;&gt;8.4.3 模糊查询&lt;/h4&gt;
&lt;p&gt;在 MongoDB 中可以通过//与^ $实现模糊查询，注意使用模糊查询时查询条件不能放到双引号或单引号中。&lt;br&gt;
查询文档中title 的值含有a 的内容。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;98&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713133944.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;使用^表示起始位置。&lt;/p&gt;
&lt;p&gt;查询文档中title 的值以S 开头的内容。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;99&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713134138.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;使用$表示结尾位置。&lt;br&gt;
查询文档中title 的值以结尾的内容。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;100&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713134147.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;844-投影操作&#34;&gt;8.4.4 投影操作&lt;/h4&gt;
&lt;h5 id=&#34;8441-find函数投影操作&#34;&gt;8.4.4.1  find()函数投影操作&lt;/h5&gt;
&lt;p&gt;在 find 函数中我们可以指定投影键。&lt;br&gt;
语法格式为：find({查询条件},{投影键名:1(显示该列)|0(不显示该列),投影键名:1|0,......})&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;101&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713134640.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;_id 列默认为显示列。如果不显示_id 可在投影中通过 0 过滤。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;102&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713134855.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h5 id=&#34;8442-findone-函数投影操作&#34;&gt;8.4.4.2 findOne 函数投影操作&lt;/h5&gt;
&lt;p&gt;在 findOne 函数中我们可以指定投影列。&lt;br&gt;
语法格式为：findOne({查询条件},{投影键名:1(显示该列)|0(不显示该列)})&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;103&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713134921.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;85-条件操作符&#34;&gt;8.5  条件操作符&lt;/h3&gt;
&lt;h4 id=&#34;851-gt&#34;&gt;8.5.1 $gt&lt;/h4&gt;
&lt;p&gt;(&amp;gt;) 大于操作符&lt;br&gt;
我们可以使用$gt 操作做大于的条件判断。该操作符可以数字或日期进行判断。&lt;br&gt;
添加测试数据。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;104&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713135029.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;查询 size 大于300 的文档。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;105&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713135039.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;852-lt&#34;&gt;8.5.2  $lt&lt;/h4&gt;
&lt;p&gt;(&amp;lt;) 小于操作符&lt;br&gt;
我们可以使用$lt 操作做小于的条件判断。该操作符可以数字或日期进行判断。&lt;br&gt;
查询 size 小于300 的文档。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;106&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713135059.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;853-gte&#34;&gt;8.5.3 $gte&lt;/h4&gt;
&lt;p&gt;(&amp;gt;=)大于或等于操作符&lt;br&gt;
我们可以使用$gte 操作做大于或等于的条件判断。该操作符可以数字或日期进行判断。&lt;br&gt;
查询 size 大于或等于 300 的文档。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;107&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713135224.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;854-lte&#34;&gt;8.5.4 $lte&lt;/h4&gt;
&lt;p&gt;(&amp;lt;=)小于或等于操作符&lt;br&gt;
我们可以使用$lte 操作做小于或等于的条件判断。该操作符可以数字或日期进行判断。&lt;br&gt;
查询 size 小于或等于 300 的文档。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;108&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713135248.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;855-eq&#34;&gt;8.5.5 $eq&lt;/h4&gt;
&lt;p&gt;(==)等于操作符&lt;br&gt;
我们可以使用$eq 操作做相等的条件判断。&lt;br&gt;
查询 size 等于300 的文档。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;109&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713135308.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;856-ne&#34;&gt;8.5.6 $ne&lt;/h4&gt;
&lt;p&gt;(!=)不等操作符&lt;br&gt;
我们可以使用$ne 操作做不等的条件判断。&lt;br&gt;
查询 size 不等于300 的文档。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;110&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713135332.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;857-and&#34;&gt;8.5.7  $and&lt;/h4&gt;
&lt;p&gt;我们可以使用&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;}&amp;#039;, got &amp;#039;EOF&amp;#039; at end of input: …。 
语法格式为：find({&#39;&gt;and 操作符来表示多条件间的并且关系。 
语法格式为：find({&lt;/span&gt;and:[{条件一},{,条件二},.......]})&lt;br&gt;
插入测试数据&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;111&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713135358.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如果在查询中给定了多个查询条件，条件之间的关系默认为 and 关系。&lt;br&gt;
查询 size 大于100 并且小于300 的文档。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;112&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713135408.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;使用$and 指定多条件关系。&lt;br&gt;
查询 size 大于100 并且小于300 的文档。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;113&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713135420.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;858-or&#34;&gt;8.5.8  $or&lt;/h4&gt;
&lt;p&gt;我们可以使用&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;}&amp;#039;, got &amp;#039;EOF&amp;#039; at end of input: …。 
语法格式为：find({&#39;&gt;or 操作符来表示多条件间的或者关系。 
语法格式为：find({&lt;/span&gt;or:[{条件一},{条件二},.....]})&lt;br&gt;
查询 title 的值为test2 或者size 大于 300 的文档。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;114&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713135439.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;859-and-与or-联合使用&#34;&gt;8.5.9 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;与&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;and 与&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;与&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;or 联合使用&lt;/h4&gt;
&lt;p&gt;查询 title 为 test5 并且 size 等于500，或者size 小于 400 的文档。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;115&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713135507.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;8510-type-操作符&#34;&gt;8.5.10 $type 操作符&lt;/h4&gt;
&lt;p&gt;$type 操作符是基于 BSON 类型来检索集合中匹配的数据类型，并返回结果。&lt;br&gt;
插入测试数据&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;116&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713135530.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;查询 title 的值为number 类型。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;117&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713135539.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;86-limit-函数与-skip-函数&#34;&gt;8.6 Limit 函数与 Skip 函数&lt;/h3&gt;
&lt;h4 id=&#34;861-limit-函数&#34;&gt;8.6.1 Limit 函数&lt;/h4&gt;
&lt;p&gt;如果需要在MongoDB 中读取指定数量的数据记录，可以使用MongoDB 的 Limit 函数，limit()函数接受一个数字参数，该参数指定从 MongoDB 中读取的记录条数。&lt;br&gt;
语法格式：db.COLLECTION_NAME.find().limit(NUMBER)&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;118&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713135729.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;862-skip-函数&#34;&gt;8.6.2 Skip 函数&lt;/h4&gt;
&lt;p&gt;我们除了可以使用 limit()函数来读取指定数量的数据外，还可以使用 skip()函数来跳过指定数量的数据，skip 函数同样接受一个数字参数作为跳过的记录条数。&lt;br&gt;
语法格式：db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER)&lt;/p&gt;
&lt;p&gt;我们可以使用 skip 函数与 limit 函数实现 MongoDB 的分页查询，但是官方并不推荐这样做，因为会扫描全部文档然后在返回结果，效率过低。&lt;/p&gt;
&lt;h3 id=&#34;87-mongodb-排序&#34;&gt;8.7  MongoDB 排序&lt;/h3&gt;
&lt;p&gt;在 MongoDB 中使用 sort() 函数对查询到的文档进行排序，sort() 函数可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而 -1 是用于降序排列。&lt;br&gt;
语法格式：db.COLLECTION_NAME.find().sort({排序键:1})&lt;/p&gt;
&lt;h4 id=&#34;871-升序排序&#34;&gt;8.7.1 升序排序&lt;/h4&gt;
&lt;p&gt;查询 size 的值为number 类型的文档，显示title，size 的内容，并对size 做升序排序。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;119&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713140440.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;872-降序排序&#34;&gt;8.7.2 降序排序&lt;/h4&gt;
&lt;p&gt;查询 size 的值为number 类型的文档，显示title，size 的内容，并对size 做降序排序。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;120&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713140440.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;873-对字符串排序&#34;&gt;8.7.3 对字符串排序&lt;/h4&gt;
&lt;p&gt;对字符串排序的方式采用的是大小写分离排序。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;121&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713140612.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;88-mongodb-索引&#34;&gt;8.8  MongoDB 索引&lt;/h3&gt;
&lt;p&gt;索引通常能够极大的提高查询的效率，如果没有索引，MongoDB 在读取数据时必须扫描集合中的每个文件并选取那些符合查询条件的记录。这种扫描全集合的查询效率是非常低的，特别在处理大量的数据时，查询可以要花费几十秒甚至几分钟，这对系统的性能是非常致命的。索引是特殊的数据结构，索引存储在一个易于遍历读取的数据集合中，索引是对数据库表中一列或多列的值进行排序的一种结构&lt;/p&gt;
&lt;h4 id=&#34;881-创建索引&#34;&gt;8.8.1 创建索引&lt;/h4&gt;
&lt;p&gt;在 MongoDB 中会自动为文档中的_Id(文档的主键)键创建索引，与关系型数据的主键索引类似。&lt;br&gt;
我们可以使用createIndex()函数来为其他的键创建索引。在创建索引时需要指定排序规则。1 按照升序规则创建索引，-1 按照降序规则创建索引。&lt;br&gt;
在创建索引时，需要使用具有 dbAdmin 或者 dbAdminAnyDatabase 角色的用户。&lt;br&gt;
语法格式：db.COLLECTION_NAME.createIndex({创建索引的键:排序规则,......},{创建索引的参数(可选参数)})&lt;/p&gt;
&lt;p&gt;参数说明&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;122&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713140800.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;为 dev 集合中的title 键创建索引，并让创建工作在后台运行。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;123&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713140811.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;882-查看索引&#34;&gt;8.8.2 查看索引&lt;/h4&gt;
&lt;h5 id=&#34;8821-查看集合索引&#34;&gt;8.8.2.1  查看集合索引&lt;/h5&gt;
&lt;p&gt;我们可以通过getIndexes()或者getIndexSpecs()函数查看集合中的所有索引信息。&lt;br&gt;
语法格式：db.COLLECTION_NAME.getIndexse()&lt;br&gt;
语法格式：db.COLLECTION_NAME.getIndexSpecs()&lt;br&gt;
使用 getIndexes()函数查看当前 dev 集合中的索引&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;124&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713140925.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;使用 getIndexSpecs()函数查看当前dev 集合中的索引&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;125&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713140958.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h5 id=&#34;8822-查看索引键&#34;&gt;8.8.2.2 查看索引键&lt;/h5&gt;
&lt;p&gt;我们可以通过使用 getIndexKeys()函数查看集合的索引键。&lt;br&gt;
语法格式：db.COLLECTION_NAME.getIndexKeys();&lt;br&gt;
查看 dev 集合中的索引键&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;126&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713141018.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h5 id=&#34;8823-查看索引大小&#34;&gt;8.8.2.3 查看索引大小&lt;/h5&gt;
&lt;p&gt;我们可以通过totalIndexSize()函数来查看当前集合中索引的大小，单位为字节。&lt;br&gt;
语法格式：db.COLLECTION_NAME.totalIndexSize(&lt;a href=&#34;%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0&#34;&gt;detail&lt;/a&gt;)&lt;br&gt;
参数解释：detail 可选参数，传入除 0 或 false 外的任意数据，那么会显示该集合中每个索引的大小及集合中索引的总大小。如果传入 0 或 false 则只显示该集合中所有索引的总大小。默认值为false。&lt;/p&gt;
&lt;p&gt;查看 dev 集合中所有索引的总大小。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;127&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713141048.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;查看 dev 集合中的每个索引的大小以及总大小&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;128&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713141652.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;883-修改索引&#34;&gt;8.8.3 修改索引&lt;/h4&gt;
&lt;p&gt;MongoDB 没有单独的修改索引函数，如果要修改某个索引，需要先删除旧的索引，再创建新的索引。&lt;/p&gt;
&lt;h4 id=&#34;884-删除索引&#34;&gt;8.8.4 删除索引&lt;/h4&gt;
&lt;h5 id=&#34;8841-删除集合中的指定索引&#34;&gt;8.8.4.1  删除集合中的指定索引&lt;/h5&gt;
&lt;p&gt;我们可以通过dropIndex()函数来删除指定索引。&lt;br&gt;
语法格式：db.COLLECTION_NAME.dropIndex(&amp;quot;索引名称&amp;quot;)。&lt;/p&gt;
&lt;p&gt;删除 title 键的索引&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;129&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713142208.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h5 id=&#34;8842-删除集合中的全部索引&#34;&gt;8.8.4.2 删除集合中的全部索引&lt;/h5&gt;
&lt;p&gt;我们可以使用dropIndexes()函数删除集合中的全部索引，_id 键的索引除外。&lt;br&gt;
语法格式：db.COLLECTION_NAME.dropIndexes()&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;130&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713142227.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;885-重建索引&#34;&gt;8.8.5 重建索引&lt;/h4&gt;
&lt;p&gt;我可以使用reIndex()函数重建索引。重建索引可以减少索引存储空间，减少索引碎片，优化索引查询效率。一般在数据大量变化后，会使用重建索引来提升索引性能。重建索引是删除原索引重新创建的过程，不建议反复使用。&lt;br&gt;
语法格式：db.COLLECTION_NAME.reIndex()&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;131&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713142255.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;886-mongodb-中的索引类型&#34;&gt;8.8.6 MongoDB 中的索引类型&lt;/h4&gt;
&lt;p&gt;在 MongoDB 中支持多种类型的索引，包括单字段索引、复合索引、多 key 索引、文本索引等，每种类型的索引有不同的使用场合。&lt;/p&gt;
&lt;h5 id=&#34;8861-单字段索引single-field-index&#34;&gt;8.8.6.1 单字段索引（Single Field Index）&lt;/h5&gt;
&lt;p&gt;所谓单字段索引是指在索引中只包含了一个键。查询时，可加速对该字段的各种查询请求，是最常见的索引形式。MongoDB 默认创建的_Id 索引也是这种类型。我们可以使用createIndexes({索引键：排序规则})函数来创建单字段索引。&lt;/p&gt;
&lt;p&gt;语法格式：db.COLLECTION_NAME.createIndexes({索引键名:排序规则})&lt;br&gt;
为 dev 集合中的title 键创建单字段索引&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;132&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713142349.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h5 id=&#34;8862-交叉索引&#34;&gt;8.8.6.2 交叉索引&lt;/h5&gt;
&lt;p&gt;所谓交叉索引就是为一个集合的多个字段分别建立索引，在查询的时候通过多个字段作为查询条件，这种情况称为交叉索引。&lt;br&gt;
在查询文档时，在查询条件中包含一个交叉索引键或者在一次查询中使用多个交叉索引键作为查询条件都会触发交叉索引。&lt;br&gt;
为 dev 集合中的size 键创建交叉索引。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;133&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713142439.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h5 id=&#34;8863-复合索引compound-index&#34;&gt;8.8.6.3 复合索引（Compound Index）&lt;/h5&gt;
&lt;p&gt;复合索引是Single Field Index 的升级版本，它针对多个字段联合创建索引，先按第一个字段排序，第一个字段相同的文档按第二个字段排序，依次类推。&lt;br&gt;
语法格式：db.COLLECTION_NAME.createIndex({索引键名:排序规则, 索引键名:排序规则,......});&lt;br&gt;
复合索引能满足的查询场景比单字段索引更丰富，不光能满足多个字段组合起来的查询，也能满足所以能匹配符合索引前缀的查询。&lt;/p&gt;
&lt;p&gt;删除 dev 中的交叉索引。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;134&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713142531.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;创建 title 与 size 的符合索引&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;135&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713142553.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;查看索引&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;136&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713142601.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h5 id=&#34;8864-多-key-索引-multikey-index&#34;&gt;8.8.6.4 多 key 索引 （Multikey Index）&lt;/h5&gt;
&lt;p&gt;当索引的字段为数组时，创建出的索引称为多 key 索引，多 key 索引会为数组的每个元素建立一条索引。&lt;br&gt;
语法格式：db.COLLECTION_NAME.createIndex({数组键名:排序规则});&lt;/p&gt;
&lt;p&gt;为 dev 集合中tags 键创建多Key 索引&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;137&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713142627.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;查看索引&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;138&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713142644.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;887-索引额外属性&#34;&gt;8.8.7 索引额外属性&lt;/h4&gt;
&lt;p&gt;MongoDB 除了支持多种不同类型的索引，还能对索引定制一些特殊的属性。&lt;/p&gt;
&lt;h5 id=&#34;8871-唯一索引-unique-index&#34;&gt;8.8.7.1 唯一索引 (unique index)&lt;/h5&gt;
&lt;p&gt;唯一索引会保证索引对应的键不会出现相同的值，比如_id 索引就是唯一索引&lt;br&gt;
语法格式：db.COLLECTION_NAME.createIndex({索引键名:排序规则},{unique:true})&lt;br&gt;
如果唯一索引所在字段有重复数据写入时，抛出异常。&lt;/p&gt;
&lt;p&gt;删除 dev 集合中的索引。为 dev 集合中的title 键建立唯一索引&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;139&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713142725.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;插入 title 相同的值测试唯一索引&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;140&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713142734.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h5 id=&#34;8872-部分索引-partial-index&#34;&gt;8.8.7.2 部分索引 (partial index):&lt;/h5&gt;
&lt;p&gt;部分索引是只针对符合某个特定条件的文档建立索引，3.2 版本才支持该特性。&lt;br&gt;
MongoDB 部分索引只为那些在一个集合中，满足指定的筛选条件的文档创建索引。由于部分索引是一个集合文档的一个子集，因此部分索引具有较低的存储需求，并降低了索引创建和维护的性能成本。部分索引通过指定过滤条件来创建，可以为 MongoDB 支持的所有索引类型使用部分索引。&lt;br&gt;
简单点说：部分索引就是带有过滤条件的索引，即索引只存在与某些文档之上&lt;br&gt;
语 法 格 式 ： db.COLLECTION_NAME.createIndex({ 索 引 键 名 : 排 序 规&lt;br&gt;
则},{partialFilterExpression:{键名:{匹配条件:条件值}}})&lt;/p&gt;
&lt;p&gt;为 dev 集合中的size 键创建部分索引。条件为大于300&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;141&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713142812.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;查看索引&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;142&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713142822.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;注意：部分索引只为集合中那些满足指定的筛选条件的文档创建索引。如果你指定的partialFilterExpression 和唯一约束、那么唯一性约束只适用于满足筛选条件的文档。具有唯一约束的部分索引不会阻止不符合唯一约束且不符合过滤条件的文档的插入。&lt;/p&gt;
&lt;h5 id=&#34;8873-稀疏索引sparse-index&#34;&gt;8.8.7.3 稀疏索引(sparse index)&lt;/h5&gt;
&lt;p&gt;稀疏索引仅包含具有索引字段的文档的条目，即使索引字段包含空值也是如此。索引会跳过缺少索引字段的任何文档。索引是“稀疏的”，因为它不包含集合的所有文档。相反，非稀疏索引包含集合中的所有文档，为那些不包含索引字段的文档存储空值。&lt;br&gt;
语法格式：db.COLLECTION_NAME.createIndex({索引键名:排序规则},{sparse:true})&lt;/p&gt;
&lt;p&gt;为 dev 集合中的tag 键创建稀疏索引&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;143&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713142859.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;查看索引&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;144&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713143051.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;注意：从MongoDB 3.2 开始，MongoDB 提供了创建部分索引的选项 。部分索引提供了稀疏索引功能的超集。如果您使用的是 MongoDB 3.2 或更高版本，则部分索引应优先于稀疏索引。&lt;/p&gt;
&lt;h4 id=&#34;888-覆盖索引查询&#34;&gt;8.8.8 覆盖索引查询&lt;/h4&gt;
&lt;p&gt;官方的MongoDB 的文档中说明，覆盖查询是以下的查询：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;所有的查询字段是索引的一部分&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有的查询返回字段在同一个索引中&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于所有出现在查询中的字段是索引的一部分， MongoDB 无需在整个数据文档中检&lt;br&gt;
索匹配查询条件和返回使用相同索引的查询结果。&lt;br&gt;
因为索引存在于RAM 中，从索引中获取数据比通过扫描文档读取数据要快得多。&lt;br&gt;
如有如下索引：&lt;br&gt;
db.stu.createIndex({title:1,:size:1})&lt;br&gt;
那么执行如下查询时，该索引会覆盖查询：&lt;br&gt;
db.stu.find({title:&amp;quot;dev&amp;quot;},{size:1,_id:0})&lt;br&gt;
也就是说，对于上述查询，MongoDB 的不会去数据库文件中查找。相反，它会从索引中提取数据，这是非常快速的数据查询。&lt;br&gt;
由于我们的索引中不包括 _id 字段，_id 在查询中会默认返回，我们可以在 MongoDB的查询结果集中排除它。&lt;/p&gt;
&lt;h4 id=&#34;889-查询计划&#34;&gt;8.8.9 查询计划&lt;/h4&gt;
&lt;p&gt;在 MongoDB 中通过 explain()函数启动执行计划，我们可以使用查询计划分析索引的使用情况，可通过查看详细的查询计划来决定如何优化。&lt;br&gt;
语法结构：db.COLLECTION_NAME.find().explain()&lt;br&gt;
删除 dev 集合中的所有索引。通过查询计划查看查询size 键的值大于200 的查询结果&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;145&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713143244.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;为 size 键创建单字段索引。再次查看查询结果。&lt;br&gt;
创建索引&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;146&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713143257.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;查看执行结果&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;147&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713143315.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;8810-使用索引注意事项&#34;&gt;8.8.10 使用索引注意事项&lt;/h4&gt;
&lt;p&gt;既然索引可以加快查询速度，那么是不是只要是查询语句，就创建索引呢？答案是否定的。因为索引虽然加快了查询速度，但索引也是有代价的：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，数据库在运行时也要消耗资源维护索引，因此索引并不是越多越好。&lt;br&gt;
那么什么情况不建议创建索引呢？例如一两千条甚至只有几百条记录的表，没必要建索引，让查询做全集合扫描就好了。至于多少条记录才算多？我个人建议以2000 作为分界线，记录数不超过 2000 可以考虑不建索引，超过 2000 条可以酌情考虑创建索引。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;建立合适的索引&lt;/strong&gt;&lt;br&gt;
为每一个常用查询结构建立合适的索引。&lt;br&gt;
复合索引是创建的索引由多个字段组成，例如：&lt;br&gt;
db.test.createIndex({&amp;quot;username&amp;quot;:1, &amp;quot;age&amp;quot;:-1})&lt;br&gt;
交叉索引是每个字段单独建立索引，但是在查询的时候组合查找，例如：&lt;br&gt;
db.test.createIndex({&amp;quot;username&amp;quot;:1})&lt;br&gt;
db.test.createIndex({&amp;quot;age&amp;quot;:-1})&lt;br&gt;
db.test.find({&amp;quot;username&amp;quot;:&amp;quot;kaka&amp;quot;, &amp;quot;age&amp;quot;: 30})&lt;br&gt;
交叉索引的查询效率较低，在使用时，当查询使用到多个字段的时候，尽量使用复合索引，而不是交叉索引。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;复合索引的字段排列顺序&lt;/strong&gt;&lt;br&gt;
当我们的组合索引内容包含匹配条件以及范围条件的时候，比如包含用户名(匹配条件)以及年龄(范围条件)，那么匹配条件应该放在范围条件之前&lt;br&gt;
比如需要查询：&lt;br&gt;
db.test.find({&amp;quot;username&amp;quot;:&amp;quot;kaka&amp;quot;, &amp;quot;age&amp;quot;: {$gt: 30}})&lt;br&gt;
那么复合索引应该这样创建：&lt;br&gt;
db.test.ensureIndex({&amp;quot;username&amp;quot;:1, &amp;quot;age&amp;quot;:-1})&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**查询时尽可能仅查询出索引字段 **&lt;br&gt;
有时候仅需要查询少部分的字段内容，而且这部分内容刚好都建立了索引，那么尽可能只查询出这些索引内容，需要用到的字段显式声明（_id 字段需要显式忽略！）。因为这些数据需要把原始数据文档从磁盘读入内存，造成一定的损耗。&lt;br&gt;
比如说我们的表有三个字段：&lt;br&gt;
name, age, mobile&lt;br&gt;
索引是这样建立的：&lt;br&gt;
db.stu.createIndex({&amp;quot;name&amp;quot;:1,&amp;quot;age&amp;quot;:-1})&lt;br&gt;
我们仅需要查到某个用户的年龄(age)，那可以这样写：&lt;br&gt;
db.stu.find({&amp;quot;name&amp;quot;:&amp;quot;kaka&amp;quot;}, {&amp;quot;_id&amp;quot;:0, &amp;quot;age&amp;quot;:1})&lt;br&gt;
注意到上面的语句，我们除了”age”:1 外，还加了”_id”:0，因为默认情况下，_id都是会被一并查询出来的，当不需要_id 的时候记得直接忽略，避免不必要的磁盘操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;对现有的数据大表建立索引的时候，采用后台运行方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在对数据集合建立索引的过程中，数据库会停止该集合的所有读写操作，因此如果建立索引的数据量大，建立过程慢的情况下，建议采用后台运行的方式，避免影响正常业务流程。&lt;br&gt;
db.stu.ensureIndex({&amp;quot;name&amp;quot;:1,&amp;quot;age&amp;quot;:-1},{&amp;quot;background&amp;quot;:true})&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;8811-索引限制&#34;&gt;8.8.11 索引限制&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;额外开销&lt;/strong&gt;&lt;br&gt;
每个索引占据一定的存储空间，在进行插入，更新和删除操作时也需要对索引进行操作。&lt;br&gt;
所以，如果你很少对集合进行读取操作，建议不使用索引。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;内存使用&lt;/strong&gt;&lt;br&gt;
由于索引是存储在内存(RAM)中,你应该确保该索引的大小不超过内存的限制。&lt;br&gt;
如果索引的大小大于内存的限制，MongoDB 会删除一些索引，这将导致性能下降。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;查询限制&lt;/strong&gt;&lt;br&gt;
索引不能被以下的查询使用：&lt;br&gt;
正则表达式（最左匹配除外）及非操作符，如 $nin, $not, 等。&lt;br&gt;
算术运算符，如 $mod, 等。&lt;br&gt;
所以，检测你的语句是否使用索引是一个好的习惯，可以用 explain 来查看。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;最大范围&lt;/strong&gt;&lt;br&gt;
集合中索引不能超过 64 个&lt;br&gt;
索引名的长度不能超过 128 个字符&lt;br&gt;
一个复合索引最多可以有31 个字段&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;8812-正则查询&#34;&gt;8.8.12 正则查询&lt;/h4&gt;
&lt;p&gt;MongoDB 中查询条件也可以使用正则表达式作为匹配约束。&lt;br&gt;
语法格式：db.COLLECTION_NAME.find({字段名:正则表达式}); 或&lt;br&gt;
db.COLLECTION_NAME.find({字段名:{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;正&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;则&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;表&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;达&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;式&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;regex:正则表达式,&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.3em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;正&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;则&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;表&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;达&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;式&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;options:正则选项}});&lt;/p&gt;
&lt;p&gt;正则表达式格式：/xxx/&lt;br&gt;
正则选项：&lt;br&gt;
i - 不区分大小写以匹配大小写的情况。&lt;br&gt;
m - 多行查找，如果内容里面不存在换行符号（例如 \n）或者条件上没有（start/end），该选项没有任何效果&lt;br&gt;
x - 设置x 选项后，正则表达式中的非转义的空白字符将被忽略。需要&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;与&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;regex 与&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;与&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;options 语法&lt;br&gt;
s - 允许点字符（即.）匹配包括换行符在内的所有字符。需要&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;与&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;regex 与&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;与&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;options 语法&lt;br&gt;
i，m，x，s 可以组合使用。&lt;/p&gt;
&lt;p&gt;查询 dev 集合中 title 字段以&#39;S&#39;开头的数据&lt;br&gt;
db.dev.find({title:/^S/})&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;148&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713143941.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;db.dev.find({title:{$regex:/^S/}})&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;149&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713144005.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;查询 dev 集合中 title 字段以&#39;g&#39;结尾的数据&lt;br&gt;
db.stu.find({title:/g$/})&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;150&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713144019.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;db.stu.find({title:{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;/&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;regex:/g&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;/}});&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;151&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713144030.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;查询 dev 集合中dev 字段中包含&#39;ing&#39;的数据&lt;br&gt;
db.stu.find({title:/ing/});&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;152&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713144121.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;db.stu.find({title:{$regex:/ing/}});&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;153&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713144133.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;查询 dev 集合中 title 字段以&#39;L&#39;开头的数据，且忽略大小写&lt;br&gt;
db.dev.find({title:/^S/i});&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;154&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713144143.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;db.dev.find({title:{$regex:/^S/i}});&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;155&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713144152.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;db.dev.find({title:{$regex:/^S/, $options:&amp;quot;i&amp;quot;}});&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;156&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713144203.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;查询 dev 集合中 title 字段已&#39;S&#39;开头、&#39;g&#39;结尾的数据&lt;br&gt;
db.dev.find({title:/^S.*g$/});&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;157&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713144212.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;db.dev.find({title:{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;msup&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;/&lt;/mi&gt;&lt;mi&gt;z&lt;/mi&gt;&lt;/msup&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;regex:/^z.*n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.664392em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.04398em;&#34;&gt;z&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;/}});&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;158&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713144658.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;查询 dev 集合中 title 字段以&#39;S&#39;或&#39;t&#39;开头的数据&lt;br&gt;
db.dev.find({title:{$in:[/^S/, /^t/]}});&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;159&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713145555.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;查询 dev 集合中 title 字段不以&#39;S&#39;开头的数据&lt;br&gt;
db.dev.find({title:{$not:/^S/}});&lt;/p&gt;
&lt;p&gt;查询 dev 集合中 title 字段不以&#39;S&#39;或&#39;t&#39;开头的数据&lt;br&gt;
db.stu.find({title:{$nin:[/^S/, /^t/]}});&lt;/p&gt;
&lt;h3 id=&#34;89-mongodb-聚合查询&#34;&gt;8.9 MongoDB 聚合查询&lt;/h3&gt;
&lt;p&gt;在 MongoDB 中我们可以通过 aggregate()函数来完成一些聚合查询，aggregate()函数主要用于处理诸如统计,平均值,求和等，并返回计算后的数据结果。&lt;br&gt;
语法格式：&lt;br&gt;
db.COLLECTION_NAME.aggregate([{&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;}&amp;#039;, got &amp;#039;EOF&amp;#039; at end of input: group:{_id:&amp;quot;&#39;&gt;group:{_id:&amp;quot;&lt;/span&gt;分组键名&amp;quot;,&amp;quot;&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;}&amp;#039;, got &amp;#039;EOF&amp;#039; at end of input: …....,别名:{聚合运算:&amp;quot;&#39;&gt;分组键名&amp;quot;,.....,别名:{聚合运算:&amp;quot;&lt;/span&gt;运算列&amp;quot;}}},{条件筛选:{键名:{运算条件:运算值}}}])&lt;br&gt;
常见的mongo 的聚合操作和 mysql 的查询做类比&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;160&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713145720.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;891-求和-sum&#34;&gt;8.9.1 求和 - $sum&lt;/h4&gt;
&lt;p&gt;查询 dev 集合中一共有多少个文档。&lt;/p&gt;
&lt;p&gt;相当于sql 语句：SELECT count(*) AS count FROM dev&lt;br&gt;
db.dev.aggregate([{&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;}&amp;#039;, got &amp;#039;EOF&amp;#039; at end of input: …id:null,count:{&#39;&gt;group:{_id:null,count:{&lt;/span&gt;sum:1}}}])&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;：&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;分&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;组&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;，&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;代&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;表&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;聚&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;合&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;分&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;组&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;条&lt;/mi&gt;&lt;msub&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;件&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;：&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;分&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;组&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;字&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;段&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;。&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;相&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;当&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;于&lt;/mi&gt;&lt;mi&gt;S&lt;/mi&gt;&lt;mi&gt;Q&lt;/mi&gt;&lt;mi&gt;L&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;分&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;组&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;语&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;法&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;中&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;的&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;部&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;分&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;。&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;如&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;果&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;根&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;据&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;某&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;字&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;段&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;值&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;分&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;组&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;，&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;则&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;定&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;义&lt;/mi&gt;&lt;msub&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;为&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;msup&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mo mathvariant=&#34;normal&#34;&gt;′&lt;/mo&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;group：分组，代表聚合的分组条件 
_id：分组的字段。相当于SQL 分组语法group by column_name 中的 column_name 部分。
如果根据某字段的值分组，则定义为_id:&amp;#x27;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.946332em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;：&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;分&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;组&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;代&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;表&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;聚&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;合&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;的&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;分&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;组&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;条&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;件&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;：&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;分&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;组&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;的&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;字&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;段&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;。&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;相&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;当&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;于&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;Q&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;分&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;组&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;语&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;法&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;中&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;的&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;部&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;分&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;。&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;如&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;果&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;根&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;据&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;某&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;字&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;段&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;的&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;值&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;分&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;组&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;则&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;定&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;义&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;为&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.751892em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;′&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;字段名&#39;。所以此案例中的 null 代表一个固定的字面值&#39;null&#39;。&lt;br&gt;
count：返回结果字段名。可以自定义，类似SQL 中的字段别名。&lt;br&gt;
$sum：求和表达式。相当于 SQL 中的 sum()。&lt;br&gt;
1：累加值。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;161&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713145816.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;查询 dev 集合中的所有 size 键中的值的总和。&lt;br&gt;
相当于sql 语句：SELECT sum(size) AS totalSize FROM dev&lt;br&gt;
db.dev.aggregate([{&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;}&amp;#039;, got &amp;#039;EOF&amp;#039; at end of input: …ull,totalSize:{&#39;&gt;group:{_id:null,totalSize:{&lt;/span&gt;sum:&amp;quot;&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;EOF&amp;#039;, got &amp;#039;}&amp;#039; at position 6: size&amp;quot;}̲}}]) 
&amp;quot;&#39;&gt;size&amp;quot;}}}]) 
&amp;quot;&lt;/span&gt;size&amp;quot;：代表文档中的 szie 字段的值。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;162&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713145837.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;对每一个title 进行分组并计算每组中的 size 的总和&lt;br&gt;
相当于sql 语句：SELECT title AS _id , sum(size) AS totalSize FROM dev GROUP BY title db.dev.aggregate([{&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;}&amp;#039;, got &amp;#039;EOF&amp;#039; at end of input: group:{_id:&amp;quot;&#39;&gt;group:{_id:&amp;quot;&lt;/span&gt;title&amp;quot;,totalSize:{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;sum:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;size&amp;quot;}}}])&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;163&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713145912.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;892-条件筛选-match&#34;&gt;8.9.2 条件筛选 - $match&lt;/h4&gt;
&lt;p&gt;查询 dev 集合有多少文档的 size 大于200。&lt;br&gt;
db.dev.aggregate([{&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;}&amp;#039;, got &amp;#039;EOF&amp;#039; at end of input: match:{size:{&#39;&gt;match:{size:{&lt;/span&gt;gt:200}}},{&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;}&amp;#039;, got &amp;#039;EOF&amp;#039; at end of input: …ull,totalSize:{&#39;&gt;group:{_id:null,totalSize:{&lt;/span&gt;sum:1}}}])&lt;br&gt;
相当于SQL 语句：SELECT count(*) FROM dev WHERE size &amp;gt; 200&lt;br&gt;
$match：匹配条件，相当于 SQL 中的 where 子句，代表聚合之前进行条件筛选。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;164&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713145938.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;查询 dev 集合，根据 title 分组计算出每组的 size 的总和，并过滤掉总和小于等于 200的文档。&lt;br&gt;
db.dev.aggregate([{&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;}&amp;#039;, got &amp;#039;EOF&amp;#039; at end of input: group:{_id:&amp;quot;&#39;&gt;group:{_id:&amp;quot;&lt;/span&gt;title&amp;quot;,totalSize:{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;sum:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;size&amp;quot;}}},{&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;}&amp;#039;, got &amp;#039;EOF&amp;#039; at end of input: …ch:{totalSize:{&#39;&gt;match:{totalSize:{&lt;/span&gt;gt:200}}}])&lt;br&gt;
相当于 SQL 语句：SELECT sum(size) AS totalSize FROM dev GROUP BY title HAVING totalSize &amp;gt; 200&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;165&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200713150011.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;893-最大值-max&#34;&gt;8.9.3 最大值 - $max&lt;/h4&gt;
&lt;p&gt;查询 dev 集合中 size 最大的文档。&lt;br&gt;
db.dev.aggregate([{&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;}&amp;#039;, got &amp;#039;EOF&amp;#039; at end of input: …:null,maxSize:{&#39;&gt;group:{_id:null,maxSize:{&lt;/span&gt;max:&amp;quot;&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;EOF&amp;#039;, got &amp;#039;}&amp;#039; at position 6: size&amp;quot;}̲}}]) 
&#39;&gt;size&amp;quot;}}}]) 
&lt;/span&gt;max:&amp;quot;$size&amp;quot;：计算 size 键中的最大值。&lt;br&gt;
相当于SQL 语句：SELECT max(size) FROM dev&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;166&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200715021541.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;894-最小值-min&#34;&gt;8.9.4 最小值 - $min&lt;/h4&gt;
&lt;p&gt;查询 dev 集合中 size 最小的文档。&lt;br&gt;
db.dev.aggregate([{&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;}&amp;#039;, got &amp;#039;EOF&amp;#039; at end of input: …:null,minSize:{&#39;&gt;group:{_id:null,minSize:{&lt;/span&gt;min:&amp;quot;&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;EOF&amp;#039;, got &amp;#039;}&amp;#039; at position 6: size&amp;quot;}̲}}]) 
&#39;&gt;size&amp;quot;}}}]) 
&lt;/span&gt;min:&amp;quot;$size&amp;quot;：计算 size 键中的最小值。&lt;br&gt;
相当于SQL 语句：SELECT min(size) FROM dev&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;167&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200715021605.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;895-平均值-avg&#34;&gt;8.9.5  平均值 - $avg&lt;/h4&gt;
&lt;p&gt;查询 dev 集合中 size 的平均值&lt;br&gt;
db.dev.aggregate([{&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;}&amp;#039;, got &amp;#039;EOF&amp;#039; at end of input: …:null,sizeAvg:{&#39;&gt;group:{_id:null,sizeAvg:{&lt;/span&gt;avg:&amp;quot;&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;EOF&amp;#039;, got &amp;#039;}&amp;#039; at position 6: size&amp;quot;}̲}}]) 
&#39;&gt;size&amp;quot;}}}]) 
&lt;/span&gt;avg:&amp;quot;$size&amp;quot;：计算 size 键的平均值。&lt;br&gt;
相当于SQL 语句：SELECT avg(size) FROM dev&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;168&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200715021626.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;896-统计结果返回数组-push&#34;&gt;8.9.6 统计结果返回数组 - $push&lt;/h4&gt;
&lt;p&gt;查询 dev 集合，按照 size 分组并返回他们的title，如果size 相同则使用数组返回他们的title。&lt;br&gt;
db.dev.aggregate([{&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;}&amp;#039;, got &amp;#039;EOF&amp;#039; at end of input: group:{_id:&amp;quot;&#39;&gt;group:{_id:&amp;quot;&lt;/span&gt;size&amp;quot;,title:{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;push:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;title&amp;quot;}}}])&lt;br&gt;
&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;push:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;title&amp;quot;：如果 size 相同则使用数组返回他们不同的title&lt;/p&gt;
&lt;h4 id=&#34;897-数组字段拆分-unwind&#34;&gt;8.9.7 数组字段拆分 - $unwind&lt;/h4&gt;
&lt;p&gt;查询 dev 集合，将数组中的内容拆分显示。&lt;br&gt;
db.dev.aggregate([{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;unwind:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;tags&amp;quot;}])&lt;br&gt;
&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;unwind:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;tags&amp;quot;：对数组中的元素进行拆分显示。&lt;/p&gt;
&lt;h4 id=&#34;898-管道操作&#34;&gt;8.9.8 管道操作&lt;/h4&gt;
&lt;p&gt;什么是管道操作：&lt;br&gt;
管道在Unix 和Linux 中一般用于将当前命令的输出结果作为下一个命令的参数。&lt;br&gt;
MongoDB 的聚合管道将 MongoDB 文档在一个管道处理完毕后将结果传递给下一个管道处理。管道操作是可以重复的。&lt;br&gt;
管道操作符是按照书写的顺序依次执行的，每个操作符都会接受一连串的文档，对这些文档做一些类型转换，最后将转换后的文档作为结果传递给下一个操作符（对于最后一个管道操作符，是将结果返回给客户端），称为流式工作方式。&lt;br&gt;
管道操作符：&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;、&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;match、&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;group、&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;、&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;sort、&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.61508em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;limit、&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;、&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;skip、&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;unwind&lt;br&gt;
管道操作符，只能用于计算当前聚合管道的文档，不能处理其它的文档。&lt;/p&gt;
&lt;h5 id=&#34;8981-project-聚合投影约束&#34;&gt;8.9.8.1 $project-聚合投影约束&lt;/h5&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;操&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;作&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;符&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;：&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;我&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;们&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;可&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;以&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;使&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;用&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;project 操作符：我们可以使用&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.85396em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;操&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;作&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;符&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;：&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;我&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;们&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;可&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;以&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;使&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;用&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;project 操作符做聚合投影操作。&lt;br&gt;
查询 dev 集合，将数组中的内容拆分显示，并只显示 title 键与 tags 键的值。&lt;br&gt;
db.dev.aggregate([{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;unwind:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;tags&amp;quot;},{&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;}&amp;#039;, got &amp;#039;EOF&amp;#039; at end of input: …t:{_id:0,tags:&amp;quot;&#39;&gt;project:{_id:0,tags:&amp;quot;&lt;/span&gt;tags&amp;quot;,title:&amp;quot;&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;EOF&amp;#039;, got &amp;#039;}&amp;#039; at position 7: title&amp;quot;}̲}]) 
tags:&amp;quot;&#39;&gt;title&amp;quot;}}]) 
tags:&amp;quot;&lt;/span&gt;tags&amp;quot;:显示tags 的值，字段名为tags。&lt;br&gt;
title:&amp;quot;$title&amp;quot;:显示title 的值，字段名为title。&lt;/p&gt;
&lt;p&gt;查询 dev 集合，将数组中的内容拆分显示。要求只显示 title 键与 tags 键的值并将 title键修改为Title。&lt;br&gt;
db.dev.aggregate([{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;unwind:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;tags&amp;quot;},{&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;}&amp;#039;, got &amp;#039;EOF&amp;#039; at end of input: …t:{_id:0,tags:&amp;quot;&#39;&gt;project:{_id:0,tags:&amp;quot;&lt;/span&gt;tags&amp;quot;,Title:&amp;quot;&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;EOF&amp;#039;, got &amp;#039;}&amp;#039; at position 7: title&amp;quot;}̲}]) 
Title:&amp;quot;&#39;&gt;title&amp;quot;}}]) 
Title:&amp;quot;&lt;/span&gt;title&amp;quot;:显示 title 的值，字段名为Title。&lt;/p&gt;
&lt;h5 id=&#34;8982-project-字符串处理&#34;&gt;8.9.8.2  $project-字符串处理&lt;/h5&gt;
&lt;p&gt;在&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;}&amp;#039;, got &amp;#039;EOF&amp;#039; at end of input: …ev.aggregate([{&#39;&gt;project 中我们可以通过 MongoDB 的字符串操作符对投影的内容做字符串处理。 
查询 dev 集合，将数组中的内容拆分显示。将 title 中的值换为小写并命名为New_Title，将tags 的值转换为大写并命名为 New_Tags。 
db.dev.aggregate([{&lt;/span&gt;unwind:&amp;quot;&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;EOF&amp;#039;, got &amp;#039;}&amp;#039; at position 6: tags&amp;quot;}̲,{&#39;&gt;tags&amp;quot;},{&lt;/span&gt;project:{_id:0,New_Title:{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;L&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;toLower:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;title&amp;quot;},New_tags:{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;U&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;toUpper:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8777699999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;U&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;tags&amp;quot;}}}])&lt;br&gt;
New_Title:{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;L&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;toLower:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;title&amp;quot;}:将 title 的值转换为小写，显示字段名为New_Title。&lt;br&gt;
New_tags:{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;U&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;toUpper:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8777699999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;U&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;tags&amp;quot;}:将 tags 的值转换为大写，显示字段名为New_Tags。&lt;/p&gt;
&lt;p&gt;查询 dev 集合，将数组中的内容拆分显示。将 title 字段和 tags 字段的值拼接为一个完整字符串并在Title_Tags 字段中显示。&lt;br&gt;
db.dev.aggregate([{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;unwind:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;tags&amp;quot;},{&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;}&amp;#039;, got &amp;#039;EOF&amp;#039; at end of input: …:0,Title_Tags:{&#39;&gt;project:{_id:0,Title_Tags:{&lt;/span&gt;concat:[&amp;quot;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;title&amp;quot;,&amp;quot;-&amp;quot;,&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;tags&amp;quot;]}}}])&lt;br&gt;
Title_Tags:{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;concat:[&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.61508em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;title&amp;quot;,&amp;quot;-&amp;quot;,&amp;quot;$tags&amp;quot;]}:将字段 title 与字符串&#39;-&#39;和字段 tags 的值拼接为新的字符串，并显示字段名为Title_Tags&lt;/p&gt;
&lt;p&gt;查询 dev 集合，将数组中的内容拆分显示。只显示 title 字段的前 3 个字符，并命名为Title_Prefix&lt;br&gt;
db.dev.aggregate([{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;unwind:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;tags&amp;quot;},{&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;}&amp;#039;, got &amp;#039;EOF&amp;#039; at end of input: …,Title_Prefix:{&#39;&gt;project:{_id:0,Title_Prefix:{&lt;/span&gt;substr:[&amp;quot;&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;EOF&amp;#039;, got &amp;#039;}&amp;#039; at position 12: title&amp;quot;,0,3]}̲}}]) 
Title_Pre…&#39;&gt;title&amp;quot;,0,3]}}}]) 
Title_Prefix:{&lt;/span&gt;substr:[&amp;quot;$title&amp;quot;,0,3]}:将title 的值从0 开始截取截3 位，并命名为Title_Prefix&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;169&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200715022052.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;我们可以看到对于汉字部分并未截取三位，原因是&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;只&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;能&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;匹&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;配&lt;/mi&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mi&gt;S&lt;/mi&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mi&gt;I&lt;/mi&gt;&lt;mi&gt;I&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;数&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;据&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;，&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;对&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;于&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;中&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;文&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;要&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;使&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;用&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;substr 只能匹配 ASCII 的数据，对于中文要使用&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;只&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;能&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;匹&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;配&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;I&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;I&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;的&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;数&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;据&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;对&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;于&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;中&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;文&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;要&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;使&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;用&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;substrCP&lt;/p&gt;
&lt;h5 id=&#34;8983-project-算术运算&#34;&gt;8.9.8.3 $project-算术运算&lt;/h5&gt;
&lt;p&gt;在&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;}&amp;#039;, got &amp;#039;EOF&amp;#039; at end of input: …ev.aggregate([{&#39;&gt;project 中我们可以通过 MongoDB 的算数作符对投影的内容做运算处理。 
查询 dev 集合中数据，显示 title 和 size 字段，为 size 字段数据做加 1 操作，显示字段命名为New_Size。 
db.dev.aggregate([{&lt;/span&gt;project:{_id:0,title:1,New_Size:{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;add:[&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;size&amp;quot;,1]}}}])&lt;br&gt;
New_Size:{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;add:[&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;size&amp;quot;,1]}:在查询结果中，对size 的值做加1 处理，并命名为New_Size。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;170&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200715022255.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;排除那些没有size 键的文档。&lt;br&gt;
db.dev.aggregate([{&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;}&amp;#039;, got &amp;#039;EOF&amp;#039; at end of input: match:{size:{&#39;&gt;match:{size:{&lt;/span&gt;ne:null}}},{&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;}&amp;#039;, got &amp;#039;EOF&amp;#039; at end of input: …le:1,New_Size:{&#39;&gt;project:{_id:0,title:1,New_Size:{&lt;/span&gt;add:[&amp;quot;&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;EOF&amp;#039;, got &amp;#039;}&amp;#039; at position 9: size&amp;quot;,1]}̲}}]) 
&#39;&gt;size&amp;quot;,1]}}}]) 
&lt;/span&gt;match:{size:{$ne:null}:排除那些没有 size 的文档。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;171&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200715022309.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;查询 dev 集合中数据，显示 title 和 size 字段，为 size 字段数据做减 1 操作，显示字段命名为New_Size。&lt;br&gt;
db.dev.aggregate([{&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;}&amp;#039;, got &amp;#039;EOF&amp;#039; at end of input: match:{size:{&#39;&gt;match:{size:{&lt;/span&gt;ne:null}}},{&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;}&amp;#039;, got &amp;#039;EOF&amp;#039; at end of input: …le:1,New_Size:{&#39;&gt;project:{_id:0,title:1,New_Size:{&lt;/span&gt;subtract:[&amp;quot;&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;EOF&amp;#039;, got &amp;#039;}&amp;#039; at position 9: size&amp;quot;,1]}̲}}]) 
New_Size:…&#39;&gt;size&amp;quot;,1]}}}]) 
New_Size:{&lt;/span&gt;subtract:[&amp;quot;$size&amp;quot;,1]}:在查询结果中，对 size 的值做减 1 处理，并命名为New_Size。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;172&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200715022324.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;查询 dev 集合中数据，显示 title 和 size 字段，为 size 字段数据做乘 2 操作，显示字段命名为New_Size。&lt;br&gt;
db.dev.aggregate([{&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;}&amp;#039;, got &amp;#039;EOF&amp;#039; at end of input: match:{size:{&#39;&gt;match:{size:{&lt;/span&gt;ne:null}}},{&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;}&amp;#039;, got &amp;#039;EOF&amp;#039; at end of input: …le:1,New_Size:{&#39;&gt;project:{_id:0,title:1,New_Size:{&lt;/span&gt;multiply:[&amp;quot;&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;EOF&amp;#039;, got &amp;#039;}&amp;#039; at position 9: size&amp;quot;,2]}̲}}]) 
New_Size:…&#39;&gt;size&amp;quot;,2]}}}]) 
New_Size:{&lt;/span&gt;multiply:[&amp;quot;$size&amp;quot;,2]}:在查询结果中，对 size 的值做乘 2 处理，并命名为New_Size.&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;173&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200715022347.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;查询 dev 集合中数据，显示 title 和 size 字段，为 size 字段数据做除 2 操作，显示字段命名为New_Size。&lt;br&gt;
db.dev.aggregate([{&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;}&amp;#039;, got &amp;#039;EOF&amp;#039; at end of input: match:{size:{&#39;&gt;match:{size:{&lt;/span&gt;ne:null}}},{&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;}&amp;#039;, got &amp;#039;EOF&amp;#039; at end of input: …le:1,New_Size:{&#39;&gt;project:{_id:0,title:1,New_Size:{&lt;/span&gt;divide:[&amp;quot;&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;EOF&amp;#039;, got &amp;#039;}&amp;#039; at position 9: size&amp;quot;,2]}̲}}]) 
New_Size:…&#39;&gt;size&amp;quot;,2]}}}]) 
New_Size:{&lt;/span&gt;divide:[&amp;quot;$size&amp;quot;,2]}:在查询结果中，对 size 的值做除 2 处理，并命名为New_Size.&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;174&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200715022402.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;查询 dev 集合中数据，显示 title 和 size 字段，为 size 字段数据做模 2 操作，显示字段命名为New_Size。&lt;br&gt;
db.dev.aggregate([{&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;}&amp;#039;, got &amp;#039;EOF&amp;#039; at end of input: match:{size:{&#39;&gt;match:{size:{&lt;/span&gt;ne:null}}},{&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;}&amp;#039;, got &amp;#039;EOF&amp;#039; at end of input: …le:1,New_Size:{&#39;&gt;project:{_id:0,title:1,New_Size:{&lt;/span&gt;mod:[&amp;quot;&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;EOF&amp;#039;, got &amp;#039;}&amp;#039; at position 9: size&amp;quot;,2]}̲}}]) 
New_Size:…&#39;&gt;size&amp;quot;,2]}}}]) 
New_Size:{&lt;/span&gt;mod:[&amp;quot;$size&amp;quot;,2]}:在查询结果中，对size 的值做模2处理，并命名为New_Size.&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;175&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200715022421.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h5 id=&#34;8984-project-日期操作&#34;&gt;8.9.8.4 $project-日期操作&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;MongoDB 中的日期处理&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;插入当前时间db.dev.insert({date:new Date()})&lt;br&gt;
MongoDB 中的时间会比系统当前时间少 8 个小时。因为他的时间是 UTC 的时间，而中国的时区是东八区，比UTC 快8 个小时，所以会比当前时间少8 个小时。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;176&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200715022507.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;插入指定日期&lt;br&gt;
方式一：&lt;br&gt;
db.dev.insert({time:new Date(&amp;quot;2018-05-01T14:20:23Z&amp;quot;)})&lt;br&gt;
new Date(&amp;quot;2018-05-01T14:20:23Z&amp;quot;):创建时间对象，日期格式为 yyyy-MM-ddThh:mm:ss&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;177&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200715022528.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;方式二：&lt;br&gt;
db.dev.insert({time:ISODate(&amp;quot;2019-06-01T16:30:00Z&amp;quot;)})&lt;br&gt;
ISODate(&amp;quot;2019-06-01T16:30:00Z&amp;quot;):&lt;/p&gt;
&lt;p&gt;注：这种方式对日期格式要求较低&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;178&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200715022557.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;查询时间&lt;br&gt;
db.dev.find({time:{$eq:new Date(&amp;quot;2018-05-01T14:20:23&amp;quot;)}})&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;179&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200715022612.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;或者&lt;br&gt;
db.dev.find({time:{$gt:new Date(&amp;quot;2018-04-01&amp;quot;)}})&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;180&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200715022630.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;181&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200715022640.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;$project-日期处理&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;向 dev 集合中插入一个文档，该文档包含 name:”admin” birth:”1990-05-01T13:30:00Z”&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;182&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200715022706.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;查询 dev 集合中数据，显示 birth 字段的各部分数据，包括：年、月、日等信息。&lt;/p&gt;
&lt;p&gt;显示年月日&lt;br&gt;
db.dev.aggregate([{&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;EOF&amp;#039;, got &amp;#039;}&amp;#039; at position 21: …:{name:&amp;quot;admin&amp;quot;}}̲,{&#39;&gt;match:{name:&amp;quot;admin&amp;quot;}},{&lt;/span&gt;project:{ 年 份 :{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;year:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;birth&amp;quot;}, 月份:{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;month:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;birth&amp;quot;},日:{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;dayOfMonth:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;M&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;birth&amp;quot;}}}])&lt;br&gt;
{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;year:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;birth&amp;quot;}年份&lt;br&gt;
{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;month:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;birth&amp;quot;}月份&lt;br&gt;
{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;dayOfMonth:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;M&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;birth&amp;quot;}日期&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;183&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200715022727.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;显示小时、分钟、秒、毫秒&lt;br&gt;
db.dev.aggregate([{&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;EOF&amp;#039;, got &amp;#039;}&amp;#039; at position 21: …:{name:&amp;quot;admin&amp;quot;}}̲,{&#39;&gt;match:{name:&amp;quot;admin&amp;quot;}},{&lt;/span&gt;project:{ 年 份 :{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;year:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;birth&amp;quot;}, 月份:{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;month:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;birth&amp;quot;}, 日:{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;dayOfMonth:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;M&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;birth&amp;quot;}, 时:{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;hour:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;birth&amp;quot;}, 分:{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;minute:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.65952em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;birth&amp;quot;},秒:{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;second:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;birth&amp;quot;},毫秒:{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;millisecond:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;birth&amp;quot;}}}])&lt;br&gt;
{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;hour:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;birth&amp;quot;}:小时&lt;br&gt;
{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;minute:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.65952em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;birth&amp;quot;}:分钟&lt;br&gt;
{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;second:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;birth&amp;quot;}:秒&lt;br&gt;
{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;millisecond:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;birth&amp;quot;}:毫秒&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;184&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200715022746.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;显示星期、全年的第几周、全年中的第几天&lt;br&gt;
db.dev.aggregate([{&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;EOF&amp;#039;, got &amp;#039;}&amp;#039; at position 21: …:{name:&amp;quot;admin&amp;quot;}}̲,{&#39;&gt;match:{name:&amp;quot;admin&amp;quot;}},{&lt;/span&gt;project:{ 年 份 :{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;year:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;birth&amp;quot;}, 月份:{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;month:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;birth&amp;quot;}, 日:{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;dayOfMonth:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;M&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;birth&amp;quot;}, 时:{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;hour:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;birth&amp;quot;}, 分:{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;minute:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.65952em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;birth&amp;quot;},秒:{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;second:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;birth&amp;quot;},毫秒:{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;millisecond:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;birth&amp;quot;},星期:{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;W&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;dayOfWeek:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;W&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;birth&amp;quot;},全年的第几周:{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;week:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;birth&amp;quot;},全年中的第几天:{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;Y&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;dayOfYear:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.22222em;&#34;&gt;Y&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;birth&amp;quot;}}}])&lt;br&gt;
{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;W&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;dayOfWeek:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;W&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;birth&amp;quot;}:星期日为1，星期六为7。&lt;br&gt;
{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;week:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;birth&amp;quot;}:全年的周计数从 0 开始。&lt;br&gt;
{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;Y&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;dayOfYear:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.22222em;&#34;&gt;Y&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;birth&amp;quot;}:全年中的第几天。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;185&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200715022815.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;显示自定义日期格式&lt;br&gt;
db.dev.aggregate([{&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;EOF&amp;#039;, got &amp;#039;}&amp;#039; at position 21: …:{name:&amp;quot;admin&amp;quot;}}̲,{&#39;&gt;match:{name:&amp;quot;admin&amp;quot;}},{&lt;/span&gt;project:{ 年 份 :{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;year:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;birth&amp;quot;}, 月份:{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;month:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;birth&amp;quot;}, 日:{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;dayOfMonth:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;M&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;birth&amp;quot;}, 时:{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;hour:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;birth&amp;quot;}, 分:{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;minute:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.65952em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;birth&amp;quot;},秒:{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;second:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;birth&amp;quot;},毫秒:{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;millisecond:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;birth&amp;quot;},星期:{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;W&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;dayOfWeek:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;W&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;birth&amp;quot;},全年的第几周 :{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;week:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;birth&amp;quot;}, 全 年 中 的 第 几 天 :{&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;Y&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;dayOfYear:&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.22222em;&#34;&gt;Y&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;birth&amp;quot;}, 自 定 义 日 期 格式:{&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;}&amp;#039;, got &amp;#039;EOF&amp;#039; at end of input: …H:%M:%S&amp;quot;,date:&amp;quot;&#39;&gt;dateToString:{format:&amp;quot;%Y 年%m 月%d 日 H:%M:%S&amp;quot;,date:&amp;quot;&lt;/span&gt;birth&amp;quot;}}}}])&lt;br&gt;
{&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;}&amp;#039;, got &amp;#039;EOF&amp;#039; at end of input: …H:%M:%S&amp;quot;,date:&amp;quot;&#39;&gt;dateToString:{format:&amp;quot;%Y 年%m 月%d 日 %H:%M:%S&amp;quot;,date:&amp;quot;&lt;/span&gt;birth&amp;quot;}:自定义日期格式&lt;br&gt;
具体格式如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;186&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200715022856.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;187&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200715022903.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;9-java-访问-mongodb&#34;&gt;9、 Java 访问 MongoDB&lt;/h2&gt;
&lt;h3 id=&#34;91-连接-mongodb-数据库&#34;&gt;9.1 连接 MongoDB 数据库&lt;/h3&gt;
&lt;h4 id=&#34;911-创建工程&#34;&gt;9.1.1 创建工程&lt;/h4&gt;
&lt;p&gt;在POM 文件中添加 MongoDB 驱动坐标&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- https://mvnrepository.com/artifact/org.mongodb/mongo-java-driver --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.mongodb&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mongo-java-driver&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;3.8.2&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;912-创建mongodb-连接&#34;&gt;9.1.2 创建MongoDB 连接&lt;/h4&gt;
&lt;p&gt;封装 MongoDBUtil&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MongoDBUtil {
    private static MongoClient mongoClient = null;

    static {
        if (mongoClient == null) {
            mongoClient=new MongoClient(&amp;quot;124.70.181.124&amp;quot;,27017);
        }
    }

    //获取数据库
    public static MongoDatabase getDatabase(String dbName){
       return mongoClient.getDatabase(dbName);
    }

    //获取集合
    public static MongoCollection getCollection(String dbName,String collName){
        return mongoClient.getDatabase(dbName).getCollection(collName);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;913-创建mongodb-的认证连接&#34;&gt;9.1.3 创建MongoDB 的认证连接&lt;/h4&gt;
&lt;p&gt;封装 MongoDBAuthUtil&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 创建MongoDB拦截-使用用户认证
 */
public class MongoDBAuthUtil {
    ////创建连接对象
    private static MongoClient mongoClient = null;

    static {
        if (mongoClient==null){
            /**
             *创建一个封装用户认证信息
             * createCredential(userName,database,password)
             */
            MongoCredential credential = MongoCredential.createCredential(&amp;quot;root&amp;quot;, &amp;quot;admin&amp;quot;, &amp;quot;root&amp;quot;.toCharArray());
            //封装MongoDB的地址与端口
            ServerAddress serverAddress = new ServerAddress(&amp;quot;124.70.181.124&amp;quot;,27017);
            mongoClient=new MongoClient(serverAddress, Arrays.asList(credential));
        }
    }

    //获取数据库
    public static MongoDatabase getDatabase(String dbName){
        return mongoClient.getDatabase(dbName);
    }

    //获取集合
    public static MongoCollection getCollection(String dbName,String collName){
        return mongoClient.getDatabase(dbName).getCollection(collName);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;914-创建mongodb-的池连&#34;&gt;9.1.4 创建MongoDB 的池连&lt;/h4&gt;
&lt;p&gt;封装 MongoDBPoolUtil&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 使用池连的方式
 */
public class MongoDBPoolUtil {
    private static MongoClient mongoClient = null;

    static {
        if (mongoClient == null) {
            //连接池参数
            MongoClientOptions.Builder builder=new MongoClientOptions.Builder();
            builder.connectionsPerHost(10);//每个地址最大连接数
            builder.connectTimeout(5000);//设置连接超时时间
            builder.socketTimeout(5000);//设置读写操作超时时间
            ServerAddress serverAddress = new ServerAddress(&amp;quot;124.70.181.124&amp;quot;, 27017);
            mongoClient=new MongoClient(serverAddress,builder.build());
        }
    }

    //获取数据库
    public static MongoDatabase getDatabase(String dbName){
        return mongoClient.getDatabase(dbName);
    }

    //获取集合
    public static MongoCollection getCollection(String dbName, String collName){
        return mongoClient.getDatabase(dbName).getCollection(collName);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;915-创建mongodb-的认证池连&#34;&gt;9.1.5 创建MongoDB 的认证池连&lt;/h4&gt;
&lt;p&gt;封装 MongoDBAuthPoolUtil&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 *支持用户认证的池连
 */
public class MongoDBPoolAuthUtil {
    private static MongoClient mongoClient = null;

    static {
        if (mongoClient == null) {
            //连接池参数
            MongoClientOptions.Builder builder=new MongoClientOptions.Builder();
            builder.connectionsPerHost(10);//每个地址最大连接数
            builder.connectTimeout(5000);//设置连接超时时间
            builder.socketTimeout(5000);//设置读写操作超时时间

            MongoCredential mongoCredential = MongoCredential.createCredential(&amp;quot;root&amp;quot;, &amp;quot;admin&amp;quot;, &amp;quot;root&amp;quot;.toCharArray());

            ServerAddress serverAddress = new ServerAddress(&amp;quot;124.70.181.124&amp;quot;, 27017);
            mongoClient=new MongoClient(serverAddress,mongoCredential,builder.build());
        }
    }

    //获取数据库
    public static MongoDatabase getDatabase(String dbName){
        return mongoClient.getDatabase(dbName);
    }

    //获取集合
    public static MongoCollection getCollection(String dbName, String collName){
        return mongoClient.getDatabase(dbName).getCollection(collName);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;92-操作集合&#34;&gt;9.2  操作集合&lt;/h3&gt;
&lt;h4 id=&#34;921-创建集合&#34;&gt;9.2.1 创建集合&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 *支持用户认证的池连
 */
public class MongoDBPoolAuthUtil {
    private static MongoClient mongoClient = null;

    static {
        if (mongoClient == null) {
            //连接池参数
            MongoClientOptions.Builder builder=new MongoClientOptions.Builder();
            builder.connectionsPerHost(10);//每个地址最大连接数
            builder.connectTimeout(5000);//设置连接超时时间
            builder.socketTimeout(5000);//设置读写操作超时时间

            MongoCredential mongoCredential = MongoCredential.createCredential(&amp;quot;root&amp;quot;, &amp;quot;admin&amp;quot;, &amp;quot;root&amp;quot;.toCharArray());

            ServerAddress serverAddress = new ServerAddress(&amp;quot;124.70.181.124&amp;quot;, 27017);
            mongoClient=new MongoClient(serverAddress,mongoCredential,builder.build());
        }
    }

    //获取数据库
    public static MongoDatabase getDatabase(String dbName){
        return mongoClient.getDatabase(dbName);
    }

    //获取集合
    public static MongoCollection getCollection(String dbName, String collName){
        return mongoClient.getDatabase(dbName).getCollection(collName);
    }

    //创建集合
    public static void createCollection(String dbName,String collName){
        mongoClient.getDatabase(dbName).createCollection(collName);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;922-获取集合&#34;&gt;9.2.2 获取集合&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//获取集合
public static MongoCollection getCollection(String dbName, String collName){
    return mongoClient.getDatabase(dbName).getCollection(collName);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;923-删除集合&#34;&gt;9.2.3 删除集合&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 *支持用户认证的池连
 */
public class MongoDBPoolAuthUtil {
    private static MongoClient mongoClient = null;

    static {
        if (mongoClient == null) {
            //连接池参数
            MongoClientOptions.Builder builder=new MongoClientOptions.Builder();
            builder.connectionsPerHost(10);//每个地址最大连接数
            builder.connectTimeout(5000);//设置连接超时时间
            builder.socketTimeout(5000);//设置读写操作超时时间

            MongoCredential mongoCredential = MongoCredential.createCredential(&amp;quot;root&amp;quot;, &amp;quot;admin&amp;quot;, &amp;quot;root&amp;quot;.toCharArray());

            ServerAddress serverAddress = new ServerAddress(&amp;quot;124.70.181.124&amp;quot;, 27017);
            mongoClient=new MongoClient(serverAddress,mongoCredential,builder.build());
        }
    }

    //获取数据库
    public static MongoDatabase getDatabase(String dbName){
        return mongoClient.getDatabase(dbName);
    }

    //获取集合
    public static MongoCollection getCollection(String dbName, String collName){
        return mongoClient.getDatabase(dbName).getCollection(collName);
    }

    //创建集合
    public static void createCollection(String dbName,String collName){
        mongoClient.getDatabase(dbName).createCollection(collName);
    }

    //删除集合
    public static void dropCollection(MongoCollection coll){
        coll.drop();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;93-操作文档&#34;&gt;9.3  操作文档&lt;/h3&gt;
&lt;h4 id=&#34;931-添加文档&#34;&gt;9.3.1 添加文档&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 插入文档
 */
public class InsertDocument {
    public static void main(String[] args) {
        InsertDocument insertDocument = new InsertDocument();
        //insertDocument.insertSingleDocument();
        insertDocument.insertManyDocument();
    }

    /**
     * 插入单个文档
     */
    public void insertSingleDocument() {
        //获取集合
        MongoCollection collection = MongoDBPoolAuthUtil.getCollection(&amp;quot;develop&amp;quot;, &amp;quot;dev&amp;quot;);

        Document doc = new Document();
        doc.append(&amp;quot;name&amp;quot;, &amp;quot;张三&amp;quot;).append(&amp;quot;sex&amp;quot;, &amp;quot;男&amp;quot;).append(&amp;quot;userdesc&amp;quot;, &amp;quot;Very Good&amp;quot;).append(&amp;quot;userlike&amp;quot;, Arrays.asList(new String[]{&amp;quot;Music&amp;quot;, &amp;quot;Sport&amp;quot;}));
        collection.insertOne(doc);
    }

    /**
     * 插入多个文档
     */
    public void insertManyDocument() {
        //获取集合
        MongoCollection collection = MongoDBPoolAuthUtil.getCollection(&amp;quot;develop&amp;quot;, &amp;quot;dev&amp;quot;);
        List&amp;lt;Document&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        for (int i = 0; i &amp;lt; 5; i++) {
            Document doc = new Document();
            doc.append(&amp;quot;name&amp;quot;,&amp;quot;zhangsan&amp;quot;+i);
            doc.append(&amp;quot;sex&amp;quot;,&amp;quot;男&amp;quot;+i);
            doc.append(&amp;quot;userdesc&amp;quot;,&amp;quot;OK&amp;quot;+i);
            doc.append(&amp;quot;userlike&amp;quot;,Arrays.asList(new String[]{&amp;quot;Music&amp;quot;,&amp;quot;Sport&amp;quot;}));
            list.add(doc);
        }
        collection.insertMany(list);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;188&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200715025104.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;932-更新文档&#34;&gt;9.3.2 更新文档&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 更新文档
 */
public class UpdateDocument {
    public static void main(String[] args) {
        UpdateDocument updateDocument = new UpdateDocument();
        //updateDocument.updateSingleDocumentOneKey();
        //updateDocument.updateSingleDocumentManyKey();
        //updateDocument.updateManyDocumentOneKey();
        //updateDocument.updateManyDocumentOneKey();
        updateDocument.updateDocumentArray();
    }

    /**
     *更新单个文档单个键
     */
    public void updateSingleDocumentOneKey(){
        MongoCollection collection = MongoDBPoolAuthUtil.getCollection(&amp;quot;develop&amp;quot;, &amp;quot;dev&amp;quot;);
        //更新文档
        //Filters封装了条件的一个工具类{$set:{userage:28}}
        //一个{}对应java中的一个document
        collection.updateOne(Filters.eq(&amp;quot;name&amp;quot;,&amp;quot;张三&amp;quot;),new Document(&amp;quot;$set&amp;quot;,new Document(&amp;quot;sex&amp;quot;,&amp;quot;女&amp;quot;)));
    }

    /**
     * 更新单个文档多个键
     */
    public void updateSingleDocumentManyKey(){
        MongoCollection collection = MongoDBPoolAuthUtil.getCollection(&amp;quot;develop&amp;quot;, &amp;quot;dev&amp;quot;);

        collection.updateOne(Filters.eq(&amp;quot;name&amp;quot;,&amp;quot;zhangsan0&amp;quot;),new Document(&amp;quot;$set&amp;quot;,new Document(&amp;quot;sex&amp;quot;,&amp;quot;女&amp;quot;).append(&amp;quot;userdesc&amp;quot;,&amp;quot;very good&amp;quot;)));
    }

    /**
     *更新多个文档单个键
     */
    public void updateManyDocumentOneKey(){
        MongoCollection collection = MongoDBPoolAuthUtil.getCollection(&amp;quot;develop&amp;quot;, &amp;quot;dev&amp;quot;);

        collection.updateMany(Filters.ne(&amp;quot;name&amp;quot;,null),new Document(&amp;quot;$set&amp;quot;,new Document(&amp;quot;userdesc&amp;quot;,&amp;quot;very good&amp;quot;)));
    }

    /**
     *更新多个文档多个键
     */
    public void updateManyDocumentManyKey(){
        MongoCollection collection = MongoDBPoolAuthUtil.getCollection(&amp;quot;develop&amp;quot;, &amp;quot;dev&amp;quot;);

        collection.updateMany(Filters.ne(&amp;quot;name&amp;quot;,null),new Document(&amp;quot;$set&amp;quot;,new Document(&amp;quot;userdesc&amp;quot;,&amp;quot;very good&amp;quot;).append(&amp;quot;sex&amp;quot;,&amp;quot;女&amp;quot;)));
    }

    /**
     * 更新文档中的数组
     * {$push:{}}
     */
    public void updateDocumentArray(){
        MongoCollection collection = MongoDBPoolAuthUtil.getCollection(&amp;quot;develop&amp;quot;,&amp;quot;dev&amp;quot;);
        collection.updateOne(Filters.eq(&amp;quot;name&amp;quot;,&amp;quot;李四&amp;quot;),new Document(&amp;quot;$push&amp;quot;,new Document(&amp;quot;userlike&amp;quot;,&amp;quot;Art&amp;quot;)));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;933-查询文档&#34;&gt;9.3.3 查询文档&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 查询文档
 */
public class SelectDocument {
    public static void main(String[] args){
        SelectDocument docu= new SelectDocument();
        //docu.selectDocumentAll();
        //docu.selectDocumentById();
        //docu.selectDocumentConditionByGt();
        //docu.selectDocumentConditionByType();
        // docu.selectDocumentConditionByIn();
        // docu.selectDocumentConditionByNin();
        // docu.selectDocumentConditionByRegex();
        //docu.selectDocumentConditionUseAnd();
        //docu.selectDocumentConditionUseOr();
        //docu.selectDocumentConditionAndOr();
        docu.selectDocumentSorting();
    }

    /**
     * 查询全部文档
     */
    public void selectDocumentAll(){
        MongoCollection collection = MongoDBPoolAuthUtil.getCollection(&amp;quot;develop&amp;quot;,&amp;quot;dev&amp;quot;);
        //返回的是一个文档的迭代器
        FindIterable&amp;lt;Document&amp;gt; iterable = collection.find();
        MongoCursor&amp;lt;Document&amp;gt; cursor = iterable.iterator();
        while(cursor.hasNext()){
            Document docu = cursor.next();
            System.out.println(docu.get(&amp;quot;username&amp;quot;)+&amp;quot;\t&amp;quot;+docu.get(&amp;quot;userage&amp;quot;)+&amp;quot;\t&amp;quot;+docu.get(&amp;quot;userdesc&amp;quot;)+&amp;quot;\t&amp;quot;+docu.get(&amp;quot;userlike&amp;quot;));
        }
    }

    /**
     * 根据_id查询文档
     */
    public void selectDocumentById(){
        MongoCollection collection = MongoDBPoolAuthUtil.getCollection(&amp;quot;develop&amp;quot;,&amp;quot;dev&amp;quot;);
        FindIterable&amp;lt;Document&amp;gt; iterable = collection.find(Filters.eq(&amp;quot;_id&amp;quot;,new ObjectId(&amp;quot;5d398cd64b022206d87d168e&amp;quot;)));
        MongoCursor&amp;lt;Document&amp;gt; cursor = iterable.iterator();
        while(cursor.hasNext()){
            Document docu = cursor.next();
            System.out.println(docu.get(&amp;quot;username&amp;quot;)+&amp;quot;\t&amp;quot;+docu.get(&amp;quot;userage&amp;quot;)+&amp;quot;\t&amp;quot;+docu.get(&amp;quot;userdesc&amp;quot;)+&amp;quot;\t&amp;quot;+docu.get(&amp;quot;userlike&amp;quot;));
        }
    }


    /**
     * 根据年龄查询文档，条件是年龄大于19
     */
    public void selectDocumentConditionByGt(){
        MongoCollection collection = MongoDBPoolAuthUtil.getCollection(&amp;quot;develop&amp;quot;,&amp;quot;dev&amp;quot;);
        FindIterable iterable = collection.find(Filters.gt(&amp;quot;userage&amp;quot;,19));
        MongoCursor&amp;lt;Document&amp;gt; cursor = iterable.iterator();
        while(cursor.hasNext()){
            Document docu = cursor.next();
            System.out.println(docu.get(&amp;quot;username&amp;quot;)+&amp;quot;\t&amp;quot;+docu.get(&amp;quot;userage&amp;quot;)+&amp;quot;\t&amp;quot;+docu.get(&amp;quot;userdesc&amp;quot;)+&amp;quot;\t&amp;quot;+docu.get(&amp;quot;userlike&amp;quot;));
        }
    }

    /**
     * 根据年龄查询文档，添加是年龄的值是整数类型(number)
     */
    public void selectDocumentConditionByType(){
        MongoCollection collection = MongoDBPoolAuthUtil.getCollection(&amp;quot;develop&amp;quot;,&amp;quot;dev&amp;quot;);
        FindIterable iterable = collection.find(Filters.type(&amp;quot;userage&amp;quot;,&amp;quot;number&amp;quot;));
        MongoCursor&amp;lt;Document&amp;gt; cursor = iterable.iterator();
        while(cursor.hasNext()){
            Document docu = cursor.next();
            System.out.println(docu.get(&amp;quot;username&amp;quot;)+&amp;quot;\t&amp;quot;+docu.get(&amp;quot;userage&amp;quot;)+&amp;quot;\t&amp;quot;+docu.get(&amp;quot;userdesc&amp;quot;)+&amp;quot;\t&amp;quot;+docu.get(&amp;quot;userlike&amp;quot;));
        }
    }
    /**
     * 查询用户的名字为 zhangsan1,zhangsan2
     */
    public void selectDocumentConditionByIn(){
        MongoCollection collection = MongoDBPoolAuthUtil.getCollection(&amp;quot;develop&amp;quot;,&amp;quot;dev&amp;quot;);
        FindIterable iterable = collection.find(Filters.in(&amp;quot;username&amp;quot;,&amp;quot;zhangsan1&amp;quot;,&amp;quot;zhangsan2&amp;quot;));
        MongoCursor&amp;lt;Document&amp;gt; cursor = iterable.iterator();
        while(cursor.hasNext()){
            Document docu = cursor.next();
            System.out.println(docu.get(&amp;quot;username&amp;quot;)+&amp;quot;\t&amp;quot;+docu.get(&amp;quot;userage&amp;quot;)+&amp;quot;\t&amp;quot;+docu.get(&amp;quot;userdesc&amp;quot;)+&amp;quot;\t&amp;quot;+docu.get(&amp;quot;userlike&amp;quot;));
        }
    }

    /**
     * 查询用户的名字不是 zhangsan1,zhangsan2
     */
    public void selectDocumentConditionByNin(){
        MongoCollection collection = MongoDBPoolAuthUtil.getCollection(&amp;quot;develop&amp;quot;,&amp;quot;dev&amp;quot;);
        FindIterable iterable = collection.find(Filters.nin(&amp;quot;username&amp;quot;,&amp;quot;zhangsan1&amp;quot;,&amp;quot;zhangsan2&amp;quot;));
        MongoCursor&amp;lt;Document&amp;gt; cursor = iterable.iterator();
        while(cursor.hasNext()){
            Document docu = cursor.next();
            System.out.println(docu.get(&amp;quot;username&amp;quot;)+&amp;quot;\t&amp;quot;+docu.get(&amp;quot;userage&amp;quot;)+&amp;quot;\t&amp;quot;+docu.get(&amp;quot;userdesc&amp;quot;)+&amp;quot;\t&amp;quot;+docu.get(&amp;quot;userlike&amp;quot;));
        }
    }

    /**
     * 查询用户的名字是z开头2结尾的。
     */
    public void selectDocumentConditionByRegex(){
        MongoCollection collection = MongoDBPoolAuthUtil.getCollection(&amp;quot;develop&amp;quot;,&amp;quot;dev&amp;quot;);
        FindIterable iterable = collection.find(Filters.regex(&amp;quot;username&amp;quot;, Pattern.compile(&amp;quot;^z.*2$&amp;quot;)));
        MongoCursor&amp;lt;Document&amp;gt; cursor = iterable.iterator();
        while(cursor.hasNext()){
            Document docu = cursor.next();
            System.out.println(docu.get(&amp;quot;username&amp;quot;)+&amp;quot;\t&amp;quot;+docu.get(&amp;quot;userage&amp;quot;)+&amp;quot;\t&amp;quot;+docu.get(&amp;quot;userdesc&amp;quot;)+&amp;quot;\t&amp;quot;+docu.get(&amp;quot;userlike&amp;quot;));
        }
    }

    /**
     * 查询用户username是zhangsan1并且年龄为20岁的用户
     */
    public void selectDocumentConditionUseAnd(){
        MongoCollection collection = MongoDBPoolAuthUtil.getCollection(&amp;quot;develop&amp;quot;,&amp;quot;dev&amp;quot;);
        FindIterable iterable = collection.find(Filters.and(Filters.eq(&amp;quot;username&amp;quot;,&amp;quot;zhangsan1&amp;quot;),Filters.eq(&amp;quot;userage&amp;quot;,21),Filters.eq(&amp;quot;userdesc&amp;quot;,&amp;quot;Very Good&amp;quot;)));
        MongoCursor&amp;lt;Document&amp;gt; cursor = iterable.iterator();
        while(cursor.hasNext()){
            Document docu = cursor.next();
            System.out.println(docu.get(&amp;quot;username&amp;quot;)+&amp;quot;\t&amp;quot;+docu.get(&amp;quot;userage&amp;quot;)+&amp;quot;\t&amp;quot;+docu.get(&amp;quot;userdesc&amp;quot;)+&amp;quot;\t&amp;quot;+docu.get(&amp;quot;userlike&amp;quot;));
        }
    }

    /**
     * 查询用户要求username是list，或者userage是20 或者 userdesc是Very Good
     */
    public void selectDocumentConditionUseOr(){
        MongoCollection collection = MongoDBPoolAuthUtil.getCollection(&amp;quot;develop&amp;quot;,&amp;quot;dev&amp;quot;);
        FindIterable iterable = collection.find(Filters.or(Filters.eq(&amp;quot;username&amp;quot;,&amp;quot;lisi&amp;quot;),Filters.eq(&amp;quot;userage&amp;quot;,20),Filters.eq(&amp;quot;userdesc&amp;quot;,&amp;quot;Very Good&amp;quot;)));
        MongoCursor&amp;lt;Document&amp;gt; cursor = iterable.iterator();
        while(cursor.hasNext()){
            Document docu = cursor.next();
            System.out.println(docu.get(&amp;quot;username&amp;quot;)+&amp;quot;\t&amp;quot;+docu.get(&amp;quot;userage&amp;quot;)+&amp;quot;\t&amp;quot;+docu.get(&amp;quot;userdesc&amp;quot;)+&amp;quot;\t&amp;quot;+docu.get(&amp;quot;userlike&amp;quot;));
        }
    }
    /**
     * 查询文档中username为lisi并且年龄为20岁，或者userdesc为Very Good
     */
    public void selectDocumentConditionAndOr(){
        MongoCollection collection = MongoDBPoolAuthUtil.getCollection(&amp;quot;develop&amp;quot;,&amp;quot;dev&amp;quot;);
        FindIterable iterable = collection.find(Filters.or(Filters.and(Filters.eq(&amp;quot;username&amp;quot;,&amp;quot;lisi&amp;quot;),Filters.eq(&amp;quot;userage&amp;quot;,20)),Filters.eq(&amp;quot;userdesc&amp;quot;,&amp;quot;Very Good&amp;quot;)));
        MongoCursor&amp;lt;Document&amp;gt; cursor = iterable.iterator();
        while(cursor.hasNext()){
            Document docu = cursor.next();
            System.out.println(docu.get(&amp;quot;username&amp;quot;)+&amp;quot;\t&amp;quot;+docu.get(&amp;quot;userage&amp;quot;)+&amp;quot;\t&amp;quot;+docu.get(&amp;quot;userdesc&amp;quot;)+&amp;quot;\t&amp;quot;+docu.get(&amp;quot;userlike&amp;quot;));
        }
    }
    /**
     * 查询文档中username是z开头的，根据username对结果做降序排序。1升序排序， -1降序排序规则  $sort:{username,-1}
     */
    public void selectDocumentSorting(){
        MongoCollection collection = MongoDBPoolAuthUtil.getCollection(&amp;quot;develop&amp;quot;,&amp;quot;dev&amp;quot;);
        FindIterable iterable = collection.find(Filters.regex(&amp;quot;username&amp;quot;,Pattern.compile(&amp;quot;^z&amp;quot;))).sort(new Document(&amp;quot;username&amp;quot;,-1));
        MongoCursor&amp;lt;Document&amp;gt; cursor = iterable.iterator();
        while(cursor.hasNext()){
            Document docu = cursor.next();
            System.out.println(docu.get(&amp;quot;username&amp;quot;)+&amp;quot;\t&amp;quot;+docu.get(&amp;quot;userage&amp;quot;)+&amp;quot;\t&amp;quot;+docu.get(&amp;quot;userdesc&amp;quot;)+&amp;quot;\t&amp;quot;+docu.get(&amp;quot;userlike&amp;quot;));
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;934-日期操作&#34;&gt;9.3.4 日期操作&lt;/h4&gt;
&lt;p&gt;创建日期处理工具类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class DateUtil {

    /**
     * Date To String
     */
    public static String dateToString(String pattern, Date date){
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(pattern);
       return  simpleDateFormat.format(date);
    }

    /**
     * String To Date
     */
    public static Date stringToDate(String pattern, String date){
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(pattern);
        Date d = null;
        try{
            d = simpleDateFormat.parse(date);
        }catch(Exception e){
            e.printStackTrace();
        }
        return d;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;日期操作&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 日期操作
 */
public class DateOperation {
    public static void main(String[] args){
        DateOperation operation = new DateOperation();
        //operation.insertDocumentSystemDate();
        //operation.insertDocumentCustoDate();
        //operation.selectDocumentDateUseEq();
        operation.selectDocumentDateUseGt();
    }

    /**
     * 插入系统当前日期
     */
    public void insertDocumentSystemDate(){
        MongoCollection collection = MongoDBPoolAuthUtil.getCollection(&amp;quot;develop&amp;quot;,&amp;quot;dev&amp;quot;);
        Document docu = new Document();
        docu.put(&amp;quot;username&amp;quot;,&amp;quot;wangwu&amp;quot;);
        docu.put(&amp;quot;userage&amp;quot;,22);
        docu.put(&amp;quot;userdesc&amp;quot;,&amp;quot;Very Good&amp;quot;);
        docu.put(&amp;quot;userlike&amp;quot;, Arrays.asList(new String[]{&amp;quot;Music&amp;quot;,&amp;quot;Art&amp;quot;}));
        docu.put(&amp;quot;userbirth&amp;quot;,new Date());
        collection.insertOne(docu);
    }

    /**
     * 插入指定日期
     */
    public void insertDocumentCustoDate(){
        MongoCollection collection = MongoDBPoolAuthUtil.getCollection(&amp;quot;develop&amp;quot;,&amp;quot;dev&amp;quot;);
        Date date= DateUtil.stringToDate(&amp;quot;yyyy-MM-dd HH:mm:ss&amp;quot;,&amp;quot;2019-05-01 13:32:13&amp;quot;);
        Document docu = new Document();
        docu.put(&amp;quot;username&amp;quot;,&amp;quot;zhaoliu&amp;quot;);
        docu.put(&amp;quot;userage&amp;quot;,24);
        docu.put(&amp;quot;userdesc&amp;quot;,&amp;quot;Very Good&amp;quot;);
        docu.put(&amp;quot;userlike&amp;quot;, Arrays.asList(new String[]{&amp;quot;Music&amp;quot;,&amp;quot;Art&amp;quot;}));
        docu.put(&amp;quot;userbirth&amp;quot;,date);
        collection.insertOne(docu);
    }

    /**
     * 查询日期：查询用的生日为2019-05-01 13:32:13的用户信息
     */
    public void selectDocumentDateUseEq(){
        MongoCollection collection = MongoDBPoolAuthUtil.getCollection(&amp;quot;develop&amp;quot;,&amp;quot;dev&amp;quot;);
        Date date = DateUtil.stringToDate(&amp;quot;yyyy-MM-dd HH:mm:ss&amp;quot;,&amp;quot;2019-05-01 13:32:13&amp;quot;);
        FindIterable iterable = collection.find(Filters.eq(&amp;quot;userbirth&amp;quot;,date));
        MongoCursor&amp;lt;Document&amp;gt; cursor = iterable.iterator();
        while(cursor.hasNext()){
            Document docu = cursor.next();
            String temp = DateUtil.dateToString(&amp;quot;yyyy-MM-dd HH:mm:ss&amp;quot;,(Date) docu.get(&amp;quot;userbirth&amp;quot;));
            System.out.println(docu.get(&amp;quot;username&amp;quot;)+&amp;quot;\t&amp;quot;+docu.get(&amp;quot;userage&amp;quot;)+&amp;quot;\t&amp;quot;+docu.get(&amp;quot;userdesc&amp;quot;)+&amp;quot;\t&amp;quot;+docu.get(&amp;quot;userlike&amp;quot;)+&amp;quot;\t&amp;quot;+temp);
        }
    }

    /**
     * 查询日期：查询用的生日大于2019-01-01 00:00:00的用户信息
     */
    public void selectDocumentDateUseGt(){
        MongoCollection collection = MongoDBPoolAuthUtil.getCollection(&amp;quot;develop&amp;quot;,&amp;quot;dev&amp;quot;);
        Date date = DateUtil.stringToDate(&amp;quot;yyyy-MM-dd HH:mm:ss&amp;quot;,&amp;quot;2019-01-01 00:00:00&amp;quot;);
        FindIterable iterable = collection.find(Filters.gt(&amp;quot;userbirth&amp;quot;,date));
        MongoCursor&amp;lt;Document&amp;gt; cursor = iterable.iterator();
        while(cursor.hasNext()){
            Document docu = cursor.next();
            String temp = DateUtil.dateToString(&amp;quot;yyyy-MM-dd HH:mm:ss&amp;quot;,(Date) docu.get(&amp;quot;userbirth&amp;quot;));
            System.out.println(docu.get(&amp;quot;username&amp;quot;)+&amp;quot;\t&amp;quot;+docu.get(&amp;quot;userage&amp;quot;)+&amp;quot;\t&amp;quot;+docu.get(&amp;quot;userdesc&amp;quot;)+&amp;quot;\t&amp;quot;+docu.get(&amp;quot;userlike&amp;quot;)+&amp;quot;\t&amp;quot;+temp);
        }
    }

}

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;935-聚合操作&#34;&gt;9.3.5 聚合操作&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 聚合操作
 */
public class AggergateOper {

    public static void main(String[] args) {
        AggergateOper oper = new AggergateOper();
        //oper.selectDocumentAggregateCount();
        //oper.selectDocumentAggregateSum();
        //oper.selectDocumentAggregateGroupBySum();
        // oper.selectDocumentAggregateGroupByWhere();
        oper.selectDocumentAggregateGroupByHaving();
    }

    /**
     * 需求：查询集合中的文档数量
     * Mongo Shell:db.dev.aggregate([{$group:{_id:null,count:{$sum:1}}}])
     */
    public void selectDocumentAggregateCount() {
        MongoCollection collection = MongoDBPoolAuthUtil.getCollection(&amp;quot;develop&amp;quot;, &amp;quot;dev&amp;quot;);

        Document sum = new Document();
        sum.put(&amp;quot;$sum&amp;quot;, 1);

        Document count = new Document();
        count.put(&amp;quot;_id&amp;quot;, null);
        count.put(&amp;quot;count&amp;quot;, sum);

        Document group = new Document();
        group.put(&amp;quot;$group&amp;quot;, count);

        List&amp;lt;Document&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        list.add(group);

        AggregateIterable iterable = collection.aggregate(list);
        MongoCursor&amp;lt;Document&amp;gt; cursor = iterable.iterator();
        while (cursor.hasNext()) {
            Document docu = cursor.next();
            System.out.println(docu.get(&amp;quot;count&amp;quot;));
        }
    }

    /**
     * 需求：查询集合中所有size键中的值的总和
     * Mongo Shell:db.dev.aggregate([{$group:{_id:null,totalSize:{$sum:&amp;quot;$size&amp;quot;}}}])
     */
    public void selectDocumentAggregateSum() {
        MongoCollection collection = MongoDBPoolAuthUtil.getCollection(&amp;quot;develop&amp;quot;, &amp;quot;dev&amp;quot;);
        Document sum = new Document();
        sum.put(&amp;quot;$sum&amp;quot;, &amp;quot;$size&amp;quot;);

        Document totalSize = new Document();
        totalSize.put(&amp;quot;_id&amp;quot;, null);
        totalSize.put(&amp;quot;totalSize&amp;quot;, sum);

        Document group = new Document();
        group.put(&amp;quot;$group&amp;quot;, totalSize);

        List&amp;lt;Document&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        list.add(group);

        AggregateIterable iterable = collection.aggregate(list);
        MongoCursor&amp;lt;Document&amp;gt; cursor = iterable.iterator();
        while (cursor.hasNext()) {
            Document docu = cursor.next();
            System.out.println(docu.get(&amp;quot;totalSize&amp;quot;));
        }

    }

    /**
     * 需求：对title进行分组，计算每组中的size的总和
     * Mongo Shell:db.dev.aggregate([{$group:{_id:&amp;quot;$title&amp;quot;,totalSize:{$sum:&amp;quot;$size&amp;quot;}}}])
     */
    public void selectDocumentAggregateGroupBySum() {
        MongoCollection collection = MongoDBPoolAuthUtil.getCollection(&amp;quot;develop&amp;quot;, &amp;quot;dev&amp;quot;);
        Document sum = new Document();
        sum.put(&amp;quot;$sum&amp;quot;, &amp;quot;$size&amp;quot;);

        Document totalSize = new Document();
        totalSize.put(&amp;quot;_id&amp;quot;, &amp;quot;$title&amp;quot;);
        totalSize.put(&amp;quot;totalSize&amp;quot;, sum);

        Document group = new Document();
        group.put(&amp;quot;$group&amp;quot;, totalSize);

        List&amp;lt;Document&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        list.add(group);

        AggregateIterable iterable = collection.aggregate(list);
        MongoCursor&amp;lt;Document&amp;gt; cursor = iterable.iterator();
        while (cursor.hasNext()) {
            Document docu = cursor.next();
            System.out.println(docu.get(&amp;quot;totalSize&amp;quot;));
        }
    }

    /**
     * 需求：查询dev集合有多少文档的size大于200。
     * Mongo Shell：
     * db.dev.aggregate([{$match:{size:{$gt:200}}},{$group:{_id:null,totalSize:{$sum:1}}}])
     */
    public void selectDocumentAggregateGroupByWhere() {
        MongoCollection collection = MongoDBPoolAuthUtil.getCollection(&amp;quot;develop&amp;quot;, &amp;quot;dev&amp;quot;);
        Document gt = new Document();
        gt.put(&amp;quot;$gt&amp;quot;, 200);

        Document size = new Document();
        size.put(&amp;quot;size&amp;quot;, gt);

        Document match = new Document();
        match.put(&amp;quot;$match&amp;quot;, size);


        Document sum = new Document();
        sum.put(&amp;quot;$sum&amp;quot;, 1);

        Document totalSize = new Document();
        totalSize.put(&amp;quot;_id&amp;quot;, null);
        totalSize.put(&amp;quot;totalSize&amp;quot;, sum);

        Document group = new Document();
        group.put(&amp;quot;$group&amp;quot;, totalSize);

        List&amp;lt;Document&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        list.add(match);
        list.add(group);

        AggregateIterable iterable = collection.aggregate(list);
        MongoCursor&amp;lt;Document&amp;gt; cursor = iterable.iterator();
        while (cursor.hasNext()) {
            Document docu = cursor.next();
            System.out.println(docu.get(&amp;quot;totalSize&amp;quot;));
        }
    }

    /**
     * 需求：查询dev集合，根据title分组计算出每组的size的总和，并过滤掉总和小于200的文档。
     * Mongo Shell：
     * db.dev.aggregate([{$group:{_id:&amp;quot;$title&amp;quot;,totalSize:{$sum:&amp;quot;$size&amp;quot;}}},{$match:{totalSize:{$gt:200}}}])
     */
    public void selectDocumentAggregateGroupByHaving() {
        MongoCollection collection = MongoDBPoolAuthUtil.getCollection(&amp;quot;develop&amp;quot;, &amp;quot;dev&amp;quot;);
        Document sum = new Document();
        sum.put(&amp;quot;$sum&amp;quot;, &amp;quot;$size&amp;quot;);

        Document totalSize = new Document();
        totalSize.put(&amp;quot;_id&amp;quot;, &amp;quot;$title&amp;quot;);
        totalSize.put(&amp;quot;totalSize&amp;quot;, sum);

        Document group = new Document();
        group.put(&amp;quot;$group&amp;quot;, totalSize);

        //{$match:{totalSize:{$gt:200}}}
        Document gt = new Document();
        gt.put(&amp;quot;$gt&amp;quot;, 200);

        Document mtotalSize = new Document();
        mtotalSize.put(&amp;quot;totalSize&amp;quot;, gt);

        Document match = new Document();
        match.put(&amp;quot;$match&amp;quot;, mtotalSize);

        List&amp;lt;Document&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        list.add(group);
        list.add(match);
        AggregateIterable iterable = collection.aggregate(list);
        MongoCursor&amp;lt;Document&amp;gt; cursor = iterable.iterator();
        while (cursor.hasNext()) {
            Document docu = cursor.next();
            System.out.println(docu.get(&amp;quot;totalSize&amp;quot;));
        }
    }

    /**
     * 需求：查询 dev 集合，将数组中的内容拆分显示，并只显示 title 键与tags键的值。
     * Mongo Shell：
     * db.dev.aggregate([{$unwind:&amp;quot;$tags&amp;quot;},{$project:{_id:0,tags:&amp;quot;$tags&amp;quot;,title:&amp;quot;$title&amp;quot;}}])
     */
    public void selectDocumentProject() {
        MongoCollection collection = MongoDBPoolAuthUtil.getCollection(&amp;quot;develop&amp;quot;, &amp;quot;dev&amp;quot;);
        Document unwind = new Document();
        unwind.put(&amp;quot;$unwind&amp;quot;, &amp;quot;$tags&amp;quot;);

        Document pro = new Document();
        pro.put(&amp;quot;_id&amp;quot;, 0);
        pro.put(&amp;quot;tags&amp;quot;, &amp;quot;$tags&amp;quot;);
        pro.put(&amp;quot;title&amp;quot;, &amp;quot;$title&amp;quot;);

        Document project = new Document();
        project.put(&amp;quot;$project&amp;quot;, pro);

        List&amp;lt;Document&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        list.add(unwind);
        list.add(project);
        AggregateIterable iterable =
                collection.aggregate(list);
        MongoCursor&amp;lt;Document&amp;gt; cursor = iterable.iterator();
        while (cursor.hasNext()) {
            System.out.println(cursor.next());
        }
    }

    /**
     * 需求：查询 dev 集合，将数组中的内容拆分显示。将 title字段和 tags字段的值拼接为一个完整字符串并在 Title_Tags 字段中显示。
     * Mongo Shell：
     * db.dev.aggregate([{$unwind:&amp;quot;$tags&amp;quot;},{$project:{_id:0,Title_Tags:{$concat:[&amp;quot;$title&amp;quot;,&amp;quot;-&amp;quot;,&amp;quot;$tags&amp;quot;]}}}])
     */
    public void selectDocumentProjectConcat() {
        MongoCollection collection = MongoDBPoolAuthUtil.getCollection(&amp;quot;develop&amp;quot;, &amp;quot;dev&amp;quot;);
        Document unwind = new Document();
        unwind.put(&amp;quot;$unwind&amp;quot;, &amp;quot;$tags&amp;quot;);

        Document concat = new Document();
        concat.put(&amp;quot;$concat&amp;quot;, Arrays.asList(new String[]{&amp;quot;$title&amp;quot;, &amp;quot;-&amp;quot;, &amp;quot;$tags&amp;quot;}));

        Document title = new Document();
        title.put(&amp;quot;_id&amp;quot;, 0);
        title.put(&amp;quot;Title_Tags&amp;quot;, concat);

        Document project = new Document();
        project.put(&amp;quot;$project&amp;quot;, title);

        List&amp;lt;Document&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        list.add(unwind);
        list.add(project);
        AggregateIterable iterable = collection.aggregate(list);
        MongoCursor&amp;lt;Document&amp;gt; cursor = iterable.iterator();
        while (cursor.hasNext()) {
            System.out.println(cursor.next());
        }
    }

    /**
     * 需求：查询 dev 集合中数据，显示 title 和size字段，为 size 字段数据做加1操作，显示字段命名为 New_Size。排除那些没有size键的文档。
     * Mongo Shell：
     * db.dev.aggregate([{$match:{size:{$ne:null}}},{$project:{_id:0,title:1,New_Size:{$add:[&amp;quot;$size&amp;quot;,1]}}}])
     */
    public void selectDocumentProjectAdd() {
        MongoCollection collection = MongoDBPoolAuthUtil.getCollection(&amp;quot;develop&amp;quot;, &amp;quot;dev&amp;quot;);

        Document ne = new Document();
        ne.put(&amp;quot;$ne&amp;quot;, null);

        Document size = new Document();
        size.put(&amp;quot;size&amp;quot;, ne);
        Document match = new Document();
        match.put(&amp;quot;$match&amp;quot;, size);

        //{$project:{_id:0,title:1,New_Size:{$add:[&amp;quot;$size&amp;quot;,1]}}}
        Document add = new Document();
        add.put(&amp;quot;$add&amp;quot;, Arrays.asList(new
                Object[]{&amp;quot;$size&amp;quot;, 1}));

        Document new_Size = new Document();
        new_Size.put(&amp;quot;_id&amp;quot;, 0);
        new_Size.put(&amp;quot;title&amp;quot;, 1);
        new_Size.put(&amp;quot;New_Size&amp;quot;, add);

        Document project = new Document();
        project.put(&amp;quot;$project&amp;quot;, new_Size);

        List&amp;lt;Document&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        list.add(match);
        list.add(project);
        AggregateIterable iterable = collection.aggregate(list);
        MongoCursor&amp;lt;Document&amp;gt; cursor = iterable.iterator();
        while (cursor.hasNext()) {
            System.out.println(cursor.next());
        }
    }

    /**
     * 需求：查询 devtest 集合查询那些有生日的用户，并按照 YYYY 年 mm月 dd日 HH:MM:SS 格式显示日期。
     * 注意：如果直接在 MongoDB 中做日期的格式化处理，那么是按照表示 UTC时间来处理的，会少 8 个小时。建议在程序中通过 java.util.Date 来做日期的转换。
     * Mongo Shell：
     * db.devtest.aggregate([{$match:{userbirth:{$ne:null}}},{$project:{自定义日期格式:{$dateToString:{format:&amp;quot;%Y 年%m 月%d日 %H:%M:%S&amp;quot;,date:&amp;quot;$userbirth&amp;quot;}}}}])
     */
    public void selectDocumentProjectDate() {
        MongoCollection collection = MongoDBPoolAuthUtil.getCollection(&amp;quot;develop&amp;quot;, &amp;quot;devtest&amp;quot;);

        Document ne = new Document();
        ne.put(&amp;quot;$ne&amp;quot;, null);

        Document birth = new Document();
        birth.put(&amp;quot;userbirth&amp;quot;, ne);

        Document match = new Document();
        match.put(&amp;quot;$match&amp;quot;, birth);

        //{$project:{自定义日期格式:{$dateToString:{format:&amp;quot;%Y 年%m 月%d 日 %H:%M:%S&amp;quot;,date:&amp;quot;$userbirth&amp;quot;}}}}
        Document format = new Document();
        format.put(&amp;quot;format&amp;quot;, &amp;quot;%Y 年%m 月%d 日 %H:%M:%S&amp;quot;);
        format.put(&amp;quot;date&amp;quot;, &amp;quot;$userbirth&amp;quot;);

        Document dateToString = new Document();
        dateToString.put(&amp;quot;$dateToString&amp;quot;, format);

        Document custoDate = new Document();
        custoDate.put(&amp;quot;自定义日期格式&amp;quot;, dateToString);

        Document project = new Document();
        project.put(&amp;quot;$project&amp;quot;, custoDate);
        
        List&amp;lt;Document&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        list.add(match);
        list.add(project);
        AggregateIterable iterable = collection.aggregate(list);
        MongoCursor&amp;lt;Document&amp;gt; cursor = iterable.iterator();
        while (cursor.hasNext()) {
            System.out.println(cursor.next());
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;936-分页查询&#34;&gt;9.3.6 分页查询&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * MongoDB分页查询
 */
public class SelectDocumentByPage {
    public static void main(String[] args){
        SelectDocumentByPage page = new SelectDocumentByPage();
        //page.selectDocumentByPageUseSkipAndLimit(1);
        page.selectDocumentByPageUseCondition(2,2,&amp;quot;5d30753b4e3d27202fd768fa&amp;quot;);
    }

    /**
     * 通过skip与limit方法实现分页
     */
    public void selectDocumentByPageUseSkipAndLimit(int pageIndex){
        int page = (pageIndex-1)*2;
        MongoCollection collection = MongoDBPoolAuthUtil.getCollection(&amp;quot;develop&amp;quot;,&amp;quot;dev&amp;quot;);
        Document condition = new Document(&amp;quot;size&amp;quot;,new Document(&amp;quot;$ne&amp;quot;,null));
        long countNum =  collection.countDocuments(condition);
        System.out.println(countNum);
        FindIterable iterable = collection.find(condition).skip(page).limit(2);
        MongoCursor&amp;lt;Document&amp;gt; cursor = iterable.iterator();
        while(cursor.hasNext()){
            Document docu = cursor.next();
            System.out.println(docu);
        }
    }

    /**
     * 通过条件判断实现分页,替代skip
     */
    public void selectDocumentByPageUseCondition(int pageIndex,int pageSize,String lastId){
        MongoCollection collection = MongoDBPoolAuthUtil.getCollection(&amp;quot;develop&amp;quot;,&amp;quot;dev&amp;quot;);
        Document condition = new Document(&amp;quot;size&amp;quot;,new Document(&amp;quot;$ne&amp;quot;,null));
        long countNum =  collection.countDocuments(condition);
        System.out.println(countNum);
        FindIterable iterable = null;
        if(pageIndex == 1){
          iterable = collection.find(condition).limit(pageSize);
        }else{
            if(lastId != null){
                condition.append(&amp;quot;_id&amp;quot;,new Document(&amp;quot;$gt&amp;quot;,new ObjectId(lastId)));
                iterable = collection.find(condition).limit(pageSize);
            }
        }
        MongoCursor&amp;lt;Document&amp;gt; cursor = iterable.iterator();
        while(cursor.hasNext()){
            Document docu = cursor.next();
            System.out.println(docu);
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
">MongoDB</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jonchan1013.github.io/post/redis/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200707163549.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;1-redis-介绍&#34;&gt;1、Redis 介绍&lt;/h2&gt;
&lt;h3 id=&#34;11-redis-简介&#34;&gt;1.1 Redis 简介&lt;/h3&gt;
&lt;p&gt;​		&lt;strong&gt;Remote Dictionary Server(Redis)是一个开源的使用 ANSI C 语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库，并提供多种语言的 API。&lt;/strong&gt;&lt;br&gt;
​		它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Map),列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;12-redis-的特点&#34;&gt;1.2 Redis 的特点&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;支持多种数据结构，如 string(字符串)、 list(双向链表)、dict(hash 表)、set(集合)、zset(排序 set)、hyperloglog(基数估算)&lt;/li&gt;
&lt;li&gt;支持持久化操作，可以进行 aof 及 rdb 数据持久化到磁盘，从而进行数据备份或数据恢复等操作，较好的防止数据丢失的手段。&lt;/li&gt;
&lt;li&gt;支持通过 Replication 进行数据复制，通过 master-slave 机制，可以实时进行数据的同步复制，支持多级复制和增量复制，master-slave 机制是 Redis 进行 HA 的重要手段。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;单进程&lt;/strong&gt;请求，所有命令串行执行，并发情况下不需要考虑数据一致性问题。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-安装-redis-单机版&#34;&gt;2、安装 Redis 单机版&lt;/h2&gt;
&lt;p&gt;第一步 需要在 linux 系统中安装 gcc&lt;br&gt;
命令：yum install -y gcc-c++&lt;br&gt;
第二步 需要将下载好的 redis 压缩包添加到 linux 服务器中&lt;br&gt;
版本：redis-3.0.0.tar.gz&lt;br&gt;
redis 的版本：&lt;strong&gt;副版本号奇数版本号是测试版，不建议在生产环境中使用。&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;偶数版本时稳定版建议在生产环境中使用。&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;3.0 版本更新比较大。集成了集群技术&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第三步 解压压缩包&lt;br&gt;
命令：tar -zxvf redis......&lt;/p&gt;
&lt;p&gt;第四步 编译 redis&lt;br&gt;
命令：进入 redis 的解压完毕的根目录下 执行命令：make&lt;/p&gt;
&lt;p&gt;第五步 安装 redis&lt;br&gt;
命 令 ： 进 入 redis 的 解 压 完 毕 的 根 目 录 下 ， 执 行 命 令 ： make install&lt;br&gt;
PREFIX=/usr/local/redis&lt;/p&gt;
&lt;p&gt;第六步：启动 redis&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200707170241.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;1）前端启动&lt;br&gt;
在 bin 目录下执行命令： ./redis-server （ctrl+c）退出 redis&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200707170339.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;2)修改拷贝过来的 redis.conf 配置文件&lt;br&gt;
命令：vim redis.conf&lt;br&gt;
将 daemonize no 改为 yes&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200707170910.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;(3)启动 redis&lt;br&gt;
在 bin 目录下执行命令：./redis-server redis.conf&lt;/p&gt;
&lt;p&gt;(4)查看 redis 启动是否成功&lt;br&gt;
输入命令：ps aux|grep redis&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;关闭 redis 的命令&lt;br&gt;
./redis-cli shutdown&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第七步：测试 redis&lt;br&gt;
在 bin 目录下启动 redis 自带的客户端 ./redis-cli&lt;br&gt;
常见 redis 命令：&lt;br&gt;
ping---&amp;gt;pong&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200707171333.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;3-redis-数据类型&#34;&gt;3、Redis 数据类型&lt;/h2&gt;
&lt;h3 id=&#34;31-string字符串&#34;&gt;3.1 String(字符串)&lt;/h3&gt;
&lt;p&gt;Redis 字符串是字节序列。Redis 字符串是二进制安全的，这意味着他们有一个已知的长度没有任何特殊字符终止，所以你可以存储任何东西，512 兆为上限&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;
redis 127.0.0.1:6379&amp;gt; set name kevin&lt;br&gt;
OK&lt;br&gt;
redis 127.0.0.1:6379&amp;gt; get name&lt;br&gt;
&amp;quot;kevin&amp;quot;&lt;/p&gt;
&lt;p&gt;incr 让当前键值以 1 的数量递增，并返回递增后的值&lt;br&gt;
incrby 可以指定参数一次增加的数值，并返回递增后的值&lt;br&gt;
decr 让当前键值以 1 的数量递减 并返回递减后的值&lt;br&gt;
decrby 可以指定参数一次递减的数值，并返回递减后的值&lt;br&gt;
incrbyfloat 可以递增一个双精度浮点数&lt;br&gt;
append 作用是向键值的末尾追加 value。如果键不存在则将该键的值设置为 value。返&lt;br&gt;
回值是追加后字符串的总长度。&lt;br&gt;
mget/mset 作用与 get/set 相似，不过 mget/mset 可以同时获得/设置多个键的键值&lt;br&gt;
del 根据 key 来删除 value&lt;br&gt;
flushdb 清除当前库的所有数据&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200707172641.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;32-hashhash-表&#34;&gt;3.2 Hash(hash 表)&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200707173524.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;Redis 的哈希是键值对的集合。 Redis 的哈希值是字符串字段和字符串值之间的映射，因此它们被用来表示对象&lt;br&gt;
示例：&lt;br&gt;
redis 127.0.0.1:6379&amp;gt; hset key field value&lt;br&gt;
OK&lt;br&gt;
redis 127.0.0.1:6379&amp;gt; hget key field&lt;br&gt;
value&lt;br&gt;
hset 存储一个哈希键值对的集合&lt;br&gt;
hset key field value&lt;/p&gt;
&lt;p&gt;hget 获取一个哈希键的值&lt;br&gt;
hget key field&lt;/p&gt;
&lt;p&gt;hmset 存储一个或多个哈希是键值对的集合&lt;br&gt;
hmset key field1 value1 ......fieldN keyN&lt;/p&gt;
&lt;p&gt;hmget 获取多个指定的键的值&lt;br&gt;
hmget key field1 ... fieldN&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200707173657.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;33-list链表&#34;&gt;3.3  List(链表)&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200707220524.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;Redis 的链表是简单的字符串列表，排序插入顺序。您可以添加元素到 Redis 的列表的&lt;br&gt;
头部或尾部&lt;br&gt;
示例：&lt;br&gt;
redis 127.0.0.1:6379&amp;gt; lpush tutoriallist redis&lt;br&gt;
(integer) 1&lt;br&gt;
redis 127.0.0.1:6379&amp;gt; lpush tutoriallist mongodb&lt;br&gt;
(integer) 2&lt;br&gt;
redis 127.0.0.1:6379&amp;gt; lpush tutoriallist rabitmq&lt;br&gt;
(integer) 3&lt;br&gt;
redis 127.0.0.1:6379&amp;gt; lrange tutoriallist 0 10&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&amp;quot;rabitmq&amp;quot;&lt;/li&gt;
&lt;li&gt;&amp;quot;mongodb&amp;quot;&lt;/li&gt;
&lt;li&gt;&amp;quot;redis&lt;br&gt;
lpush key value 向链表左侧添加&lt;br&gt;
rpush key value 向链表右侧添加&lt;br&gt;
lpop key 从左边移出一个元素&lt;br&gt;
rpop key 从右边移出一个元素&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200707222122.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;llen key 返回链表中元素的个数 相当于关系型数据库中 select count(*)&lt;br&gt;
lrange key start end lrange 命令将返回索引从 start 到 stop 之间的所有元素。Redis 的列表起始索引为 0。&lt;br&gt;
lrange 也支持负索引 lrange nn -2 -1 如 -1 表示最右边第一个元素 -2 表示最右边第二个元素，依次类推。&lt;br&gt;
lindex key indexnumber 如果要将列表类型当做数组来用，lindex 命令是必不可少的。&lt;br&gt;
lindex 命令用来返回指定索引的元素，索引从 0 开始，如果是负数表示从右边开始计算的索引，最右边元素的索引是-1。&lt;br&gt;
Lset key indexnumber value 是另一个通过索引操作列表的命令，它会将索引为 index的元素赋值为 value。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200707222706.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;34-set集合&#34;&gt;3.4 Set(集合)&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200707223508.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;Redis 的集合是字符串的无序不重复集合。&lt;br&gt;
示例：&lt;br&gt;
redis 127.0.0.1:6379&amp;gt; sadd tutoriallist redis&lt;br&gt;
(integer) 1&lt;br&gt;
redis 127.0.0.1:6379&amp;gt; sadd tutoriallist mongodb&lt;br&gt;
(integer) 1&lt;br&gt;
redis 127.0.0.1:6379&amp;gt; sadd tutoriallist rabitmq&lt;br&gt;
(integer) 1&lt;br&gt;
redis 127.0.0.1:6379&amp;gt; sadd tutoriallist rabitmq&lt;br&gt;
(integer) 0&lt;br&gt;
redis 127.0.0.1:6379&amp;gt; smembers tutoriallist&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&amp;quot;rabitmq&amp;quot;&lt;/li&gt;
&lt;li&gt;&amp;quot;mongodb&amp;quot;&lt;/li&gt;
&lt;li&gt;&amp;quot;redis&amp;quot;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;sadd key value 添加一个 string 元素到,key 对应的 set 集合中，成功返回 1,如果元素已经在集合中返回 0&lt;br&gt;
scard key 返回 set 的元素个数，如果 set 是空或者 key 不存在返回 0&lt;br&gt;
smembers key 返回 key 对应 set 的所有元素，结果是无序的&lt;br&gt;
sismember key value 判断 value 是否在 set 中，存在返回 1，0 表示不存在或者 key 不存在&lt;br&gt;
srem key value 从 key 对应 set 中移除给定元素，成功返回 1，如果 value 在集合中不存在或者 key 不存在返回 0&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200707223554.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;35-sortedset有序集合zset&#34;&gt;3.5  SortedSet(有序集合)zset&lt;/h3&gt;
&lt;p&gt;Redis 的有序集合类似于 Redis 的集合，字符串不重复的集合。&lt;br&gt;
示例：&lt;br&gt;
redis 127.0.0.1:6379&amp;gt; zadd tutoriallist 0 redis&lt;br&gt;
(integer) 1&lt;br&gt;
redis 127.0.0.1:6379&amp;gt; zadd tutoriallist 0 mongodb&lt;br&gt;
(integer) 1&lt;br&gt;
redis 127.0.0.1:6379&amp;gt; zadd tutoriallist 0 rabitmq&lt;br&gt;
(integer) 1&lt;br&gt;
redis 127.0.0.1:6379&amp;gt; zadd tutoriallist 0 rabitmq&lt;br&gt;
(integer) 0&lt;br&gt;
redis 127.0.0.1:6379&amp;gt; ZRANGEBYSCORE tutoriallist 0 1000&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&amp;quot;redis&amp;quot;&lt;/li&gt;
&lt;li&gt;&amp;quot;mongodb&amp;quot;&lt;/li&gt;
&lt;li&gt;&amp;quot;rabitmq&amp;quot;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;zadd key score value 将一个或多个 value 及其 socre 加入到 set 中&lt;br&gt;
zrange key start end 0 和-1 表示从索引为 0 的元素到最后一个元素（同 LRANGE 命令相似）&lt;/p&gt;
&lt;p&gt;zrange key 0 -1 withscores 也可以连同 score 一块输出，使用 WITHSCORES 参数&lt;br&gt;
zremrangebyscore key start end 可用于范围删除操作&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200707224101.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;36-redis-中的其他命令&#34;&gt;3.6 Redis 中的其他命令&lt;/h3&gt;
&lt;p&gt;ping 测试 redis 是否链接 如果已链接返回 PONG&lt;br&gt;
echo value 测试 redis 是否链接 如果已链接返回 echo 命令后给定的值&lt;br&gt;
keys * 返回所有的 key 可以加*通配&lt;br&gt;
exists key 判断 string 类型一个 key 是否存在 如果存在返回 1 否则返回 0&lt;br&gt;
expire key time(s) 设置一个 key 的过期时间 单位秒。时间到达后会删除 key 及 value&lt;br&gt;
ttl key 查询已设置过期时间的 key 的剩余时间 如果返回-2 表示该键值对已经被删除&lt;br&gt;
persist 移除给定 key 的过期时间&lt;br&gt;
select dbindex 选择数据库(0-15)&lt;br&gt;
move key dbIndex 将当前数据库中的 key 转移到其他数据库中&lt;br&gt;
dbsize 返回当前数据库中的 key 的数目&lt;br&gt;
info 获取服务器的信息和统计&lt;br&gt;
flushdb 删除当前选择的数据库中的 key&lt;br&gt;
flushall 删除所有数据库中的所有 key&lt;br&gt;
quit 退出连接&lt;/p&gt;
&lt;h2 id=&#34;4-redis-的配置以及持久化方案&#34;&gt;4、Redis 的配置以及持久化方案&lt;/h2&gt;
&lt;h3 id=&#34;41-redisconf-文件&#34;&gt;4.1 redis.conf 文件&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;#redis.conf
# Redis configuration file example.
# ./redis-server /path/to/redis.conf
################################## INCLUDES
###################################
#这在你有标准配置模板但是每个 redis 服务器又需要个性设置的时候很有用。
# include /path/to/local.conf
# include /path/to/other.conf
################################ GENERAL #####################################
#是否在后台执行，yes：后台运行；no：不是后台运行（老版本默认）
daemonize yes
#3.2 里的参数，是否开启保护模式，默认开启。要是配置里没有指定 bind 和密码。开启该参数后，redis只会本地进行访问，拒绝外部访问。要是开启了密码 和 bind，可以开启。否 则最好关闭，设置为no。
protected-mode yes
#redis 的进程文件
pidfile /var/run/redis/redis-server.pid
#redis 监听的端口号。
port 6379
#此参数确定了 TCP 连接中已完成队列(完成三次握手之后)的长度， 当然此值必须不大于 Linux 系统定
义的/proc/sys/net/core/somaxconn 值，默认是 511，而 Linux 的默认参数值是 128。当系统并发量大并且客户端速度缓慢的时候，可以将这二个参数一起参考设定。该内核参数默认值一般是 128，对于负载很大的服务程序来说大大的不够。一般会将它修改为 2048 或者更大。在/etc/sysctl.conf 中添加:net.core.somaxconn = 2048，然后在终端中执行 sysctl -p。
tcp-backlog 511
#指定 redis 只接收来自于该 IP 地址的请求，如果不进行设置，那么将处理所有请求
#bind 127.0.0.1
#配置 unix socket 来让 redis 支持监听本地连接。
# unixsocket /var/run/redis/redis.sock
#配置 unix socket 使用文件的权限
# unixsocketperm 700
# 此参数为设置客户端空闲超过 timeout，服务端会断开连接，为 0 则服务端不会主动断开连接，不能小于 0。
timeout 0
#tcp keepalive 参数。如果设置不为 0，就使用配置 tcp 的 SO_KEEPALIVE 值，使用 keepalive 有两个好处:检测挂掉的对端。降低中间设备出问题而导致网络看似连接却已经与对端端口的问题。在 Linux内核中，设置了 keepalive，redis 会定时给对端发送 ack。检测到对端关闭需要两倍的设置值。
tcp-keepalive 0
#指定了服务端日志的级别。级别包括：debug（很多信息，方便开发、测试），verbose（许多有用的信息，但是没有 debug 级别信息多），notice（适当的日志级别，适合生产环境），warn（只有非常重要的信息）
loglevel notice
#指定了记录日志的文件。空字符串的话，日志会打印到标准输出设备。后台运行的 redis 标准输出是/dev/null。
logfile /var/log/redis/redis-server.log
#是否打开记录 syslog 功能
# syslog-enabled no
#syslog 的标识符。
# syslog-ident redis
#日志的来源、设备
# syslog-facility local0
#数据库的数量，默认使用的数据库是 DB 0。可以通过”SELECT “命令选择一个 db
databases 16
################################ SNAPSHOTTING ################################
# 快照配置
# 注释掉“save”这一行配置项就可以让保存数据库功能失效
# 设置 sedis 进行数据库镜像的频率。
# 900 秒（15 分钟）内至少 1 个 key 值改变（则进行数据库保存--持久化）
# 300 秒（5 分钟）内至少 10 个 key 值改变（则进行数据库保存--持久化）
# 60 秒（1 分钟）内至少 10000 个 key 值改变（则进行数据库保存--持久化）
save 900 1
save 300 10
save 60 10000
#当 RDB 持久化出现错误后，是否依然进行继续进行工作，yes：不能进行工作，no：可以继续进行工作，可以通过 info 中的 rdb_last_bgsave_status 了解 RDB 持久化是否有错误
stop-writes-on-bgsave-error yes
#使用压缩 rdb 文件，rdb 文件压缩使用 LZF 压缩算法，yes：压缩，但是需要一些 cpu 的消耗。no：不压缩，需要更多的磁盘空间
rdbcompression yes
#是否校验 rdb 文件。从 rdb 格式的第五个版本开始，在 rdb 文件的末尾会带上 CRC64 的校验和。这跟有利于文件的容错性，但是在保存 rdb 文件的时候，会有大概 10%的性能损耗，所以如果你追求高性能，可以关闭该配置。
rdbchecksum yes
#rdb 文件的名称
dbfilename dump.rdb
#数据目录，数据库的写入会在这个目录。rdb、aof 文件也会写在这个目录
dir /root/temp
################################# REPLICATION
#################################
#复制选项，slave 复制对应的 master。
# slaveof &amp;lt;masterip&amp;gt; &amp;lt;masterport&amp;gt;
#如果 master 设置了 requirepass，那么 slave 要连上 master，需要有 master 的密码才行。
masterauth 就是用来配置 master 的密码，这样可以在连上 master 后进行认证。
# masterauth &amp;lt;master-password&amp;gt;
#当从库同主机失去连接或者复制正在进行，从机库有两种运行方式：1) 如果slave-serve-stale-data 设置为 yes(默认设置)，从库会继续响应客户端的请求。2) 如果slave-serve-stale-data 设置为 no，除去 INFO 和 SLAVOF 命令之外的任何请求都会返回一个错误”SYNC with master in progress”。
slave-serve-stale-data yes
#作为从服务器，默认情况下是只读的（yes），可以修改成 NO，用于写（不建议）。
slave-read-only yes
#是否使用 socket 方式复制数据。目前 redis 复制提供两种方式，disk 和 socket。如果新的 slave连上来或者重连的 slave 无法部分同步，就会执行全量同步，master 会生成 rdb 文件。有 2 种方式：disk 方式是 master 创建一个新的进程把 rdb 文件保存到磁盘，再把磁盘上的 rdb 文件传递给 slave。socket 是 master 创建一个新的进程，直接把 rdb 文件以 socket 的方式发给 slave。disk 方式的时候，当一个 rdb 保存的过程中，多个 slave 都能共享这个 rdb 文件。socket 的方式就的一个个 slave顺序复制。在磁盘速度缓慢，网速快的情况下推荐用 socket 方式。
repl-diskless-sync no
#diskless 复制的延迟时间，防止设置为 0。一旦复制开始，节点不会再接收新 slave 的复制请求直到下一个 rdb 传输。所以最好等待一段时间，等更多的 slave 连上来。
repl-diskless-sync-delay 5
#slave 根据指定的时间间隔向服务器发送 ping 请求。时间间隔可以通过repl_ping_slave_period来设置，默认 10 秒。
# repl-ping-slave-period 10
#复制连接超时时间。master 和 slave 都有超时时间的设置。master 检测到 slave 上次发送的时间超过 repl-timeout，即认为 slave 离线，清除该 slave 信息。slave 检测到上次和 master 交互的时间超过 repl-timeout，则认为 master 离线。需要注意的是 repl-timeout 需要设置一个比repl-ping-slave-period 更大的值，不然会经常检测到超时。
# repl-timeout 60
#是否禁止复制 tcp 链接的 tcp nodelay 参数，可传递 yes 或者 no。默认是 no，即使用 tcp nodelay。如果 master 设置了 yes 来禁止 tcp nodelay 设置，在把数据复制给 slave 的时候，会减少包的数量和更小的网络带宽。但是这也可能带来数据的延迟。默认我们推荐更小的延迟，但是在数据量传输很大的场景下，建议选择 yes。
repl-disable-tcp-nodelay no
#复制缓冲区大小，这是一个环形复制缓冲区，用来保存最新复制的命令。这样在 slave 离线的时候，不需要完全复制 master 的数据，如果可以执行部分同步，只需要把缓冲区的部分数据复制给 slave，就能恢复正常复制状态。缓冲区的大小越大，slave 离线的时间可以更长，复制缓冲区只有在有 slave 连接的时候才分配内存。没有 slave 的一段时间，内存会被释放出来，默认 1m。
# repl-backlog-size 5mb
#master 没有 slave 一段时间会释放复制缓冲区的内存，repl-backlog-ttl 用来设置该时间长度。
单位为秒。
# repl-backlog-ttl 3600
#当 master 不可用，Sentinel 会根据 slave 的优先级选举一个 master。最低的优先级的 slave，当选 master。而配置成 0，永远不会被选举。
slave-priority 100
#redis 提供了可以让 master 停止写入的方式，如果配置了 min-slaves-to-write，健康的 slave的个数小于 N，mater 就禁止写入。master 最少得有多少个健康的 slave 存活才能执行写命令。这个配置虽然不能保证 N 个 slave 都一定能接收到 master 的写操作，但是能避免没有足够健康的 slave 的时候，master 不能写入来避免数据丢失。设置为 0 是关闭该功能。
# min-slaves-to-write 3
#延迟小于 min-slaves-max-lag 秒的 slave 才认为是健康的 slave。
# min-slaves-max-lag 10
# 设置 1 或另一个设置为 0 禁用这个特性。
# Setting one or the other to 0 disables the feature.
# By default min-slaves-to-write is set to 0 (feature disabled) and
# min-slaves-max-lag is set to 10.
################################## SECURITY
###################################
#requirepass 配置可以让用户使用 AUTH 命令来认证密码，才能使用其他命令。这让 redis 可以使用在不受信任的网络中。为了保持向后的兼容性，可以注释该命令，因为大部分用户也不需要认证。使用requirepass 的时候需要注意，因为 redis 太快了，每秒可以认证 15w 次密码，简单的密码很容易被攻破，所以最好使用一个更复杂的密码。
# requirepass foobared
#把危险的命令给修改成其他名称。比如 CONFIG 命令可以重命名为一个很难被猜到的命令，这样用户不能使用，而内部工具还能接着使用。
# rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52
#设置成一个空的值，可以禁止一个命令
# rename-command CONFIG &amp;quot;&amp;quot;
################################### LIMITS
####################################
# 设置能连上 redis 的最大客户端连接数量。默认是 10000 个客户端连接。由于 redis 不区分连接是客户端连接还是内部打开文件或者和 slave 连接等，所以 maxclients 最小建议设置到 32。如果超过了maxclients，redis 会给新的连接发送’max number of clients reached’，并关闭连接。
# maxclients 10000
#redis 配置的最大内存容量。当内存满了，需要配合 maxmemory-policy 策略进行处理。注意 slave的输出缓冲区是不计算在 maxmemory 内的。所以为了防止主机内存使用完，建议设置的 maxmemory 需要更小一些。
# maxmemory &amp;lt;bytes&amp;gt;
#内存容量超过 maxmemory 后的处理策略。
#volatile-lru：利用 LRU 算法移除设置过过期时间的 key。
#volatile-random：随机移除设置过过期时间的 key。
#volatile-ttl：移除即将过期的 key，根据最近过期时间来删除（辅以 TTL）
#allkeys-lru：利用 LRU 算法移除任何 key。
#allkeys-random：随机移除任何 key。
#noeviction：不移除任何 key，只是返回一个写错误。
#上面的这些驱逐策略，如果 redis 没有合适的 key 驱逐，对于写命令，还是会返回错误。redis 将不再接收写请求，只接收 get 请求。写命令包括：set setnx setex append incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby getset mset msetnx exec sort。
# maxmemory-policy noeviction
#lru 检测的样本数。使用 lru 或者 ttl 淘汰算法，从需要淘汰的列表中随机选择 sample 个 key，选出闲置时间最长的 key 移除。
# maxmemory-samples 5
############################## APPEND ONLY MODE ###############################
#默认 redis 使用的是 rdb 方式持久化，这种方式在许多应用中已经足够用了。但是 redis 如果中途宕机，会导致可能有几分钟的数据丢失，根据 save 来策略进行持久化，Append Only File 是另一种持久化方式，可以提供更好的持久化特性。Redis 会把每次写入的数据在接收后都写入 appendonly.aof文件，每次启动时 Redis 都会先把这个文件的数据读入内存里，先忽略 RDB 文件。
appendonly no
#aof 文件名
appendfilename &amp;quot;appendonly.aof&amp;quot;
#aof 持久化策略的配置
#no 表示不执行 fsync，由操作系统保证数据同步到磁盘，速度最快。
#always 表示每次写入都执行 fsync，以保证数据同步到磁盘。
#everysec 表示每秒执行一次 fsync，可能会导致丢失这 1s 数据。
appendfsync everysec
# 在 aof 重写或者写入 rdb 文件的时候，会执行大量 IO，此时对于everysec 和 always 的 aof 模式来说，执行 fsync 会造成阻塞过长时间，no-appendfsync-on-rewrite 字段设置为默认设置为 no。如果对延迟要求很高的应用，这个字段可以设置为 yes，否则还是设置为 no，这样对持久化特性来说这是更安全的选择。设置为 yes 表示 rewrite 期间对新写操作不 fsync,暂时存在内存中,等 rewrite 完成后再写入，默认为 no，建议 yes。Linux 的默认 fsync 策略是 30 秒。可能丢失 30 秒数据。
no-appendfsync-on-rewrite no
#aof 自动重写配置。当目前 aof 文件大小超过上一次重写的 aof 文件大小的百分之多少进行重写，即当aof 文件增长到一定大小的时候 Redis 能够调用 bgrewriteaof 对日志文件进行重写。当前 AOF 文件大小是上次日志重写得到 AOF 文件大小的二倍（设置为 100）时，自动启动新的日志重写过程。
auto-aof-rewrite-percentage 100
#设置允许重写的最小 aof 文件大小，避免了达到约定百分比但尺寸仍然很小的情况还要重写
auto-aof-rewrite-min-size 64mb
#aof 文件可能在尾部是不完整的，当 redis 启动的时候，aof 文件的数据被载入内存。重启可能发生在redis 所在的主机操作系统宕机后，尤其在 ext4 文件系统没有加上 data=ordered 选项（redis 宕机或者异常终止不会造成尾部不完整现象。）出现这种现象，可以选择让 redis 退出，或者导入尽可能多的数据。如果选择的是 yes，当截断的 aof 文件被导入的时候，会自动发布一个 log 给客户端然后 load。如果是 no，用户必须手动 redis-check-aof 修复 AOF 文件才可以。
aof-load-truncated yes
################################ LUA SCRIPTING ###############################
# 如果达到最大时间限制（毫秒），redis 会记个 log，然后返回 error。当一个脚本超过了最大时限。只有 SCRIPT KILL 和 SHUTDOWN NOSAVE 可以用。第一个可以杀没有调 write 命令的东西。要是已经调用了 write，只能用第二个命令杀。
lua-time-limit 5000
################################ REDIS CLUSTER ###############################
#集群开关，默认是不开启集群模式。
# cluster-enabled yes
#集群配置文件的名称，每个节点都有一个集群相关的配置文件，持久化保存集群的信息。这个文件并不需要手动配置，这个配置文件有 Redis 生成并更新，每个 Redis 集群节点需要一个单独的配置文件，请确保与实例运行的系统中配置文件名称不冲突
# cluster-config-file nodes-6379.conf
#节点互连超时的阀值。集群节点超时毫秒数
# cluster-node-timeout 15000
#在进行故障转移的时候，全部 slave 都会请求申请为 master，但是有些 slave 可能与 master 断开连接一段时间了，导致数据过于陈旧，这样的 slave 不应该被提升为 master。该参数就是用来判断 slave节点与 master 断线的时间是否过长。判断方法是：
#比较 slave 断开连接的时间和(node-timeout * slave-validity-factor) +
repl-ping-slave-period
#如果节点超时时间为三十秒, 并且 slave-validity-factor 为 10,假设默认的repl-ping-slave-period 是 10 秒，即如果超过 310 秒 slave 将不会尝试进行故障转移
# cluster-slave-validity-factor 10
#master 的 slave 数量大于该值，slave 才能迁移到其他孤立 master 上，如这个参数若被设为 2，那么只有当一个主节点拥有 2 个可工作的从节点时，它的一个从节点会尝试迁移。
# cluster-migration-barrier 1
#默认情况下，集群全部的 slot 有节点负责，集群状态才为 ok，才能提供服务。设置为 no，可以在 slot没有全部分配的时候提供服务。不建议打开该配置，这样会造成分区的时候，小分区的 master 一直在接受写请求，而造成很长时间数据不一致。
# cluster-require-full-coverage yes
################################## SLOW LOG
###################################
###slog log 是用来记录 redis 运行中执行比较慢的命令耗时。当命令的执行超过了指定时间，就记录在 slow log 中，slog log 保存在内存中，所以没有 IO 操作。
#执行时间比 slowlog-log-slower-than 大的请求记录到 slowlog 里面，单位是微秒，所以 1000000就是 1 秒。注意，负数时间会禁用慢查询日志，而 0 则会强制记录所有命令。
slowlog-log-slower-than 10000
#慢查询日志长度。当一个新的命令被写进日志的时候，最老的那个记录会被删掉。这个长度没有限制。只要有足够的内存就行。你可以通过 SLOWLOG RESET 来释放内存。
slowlog-max-len 128
################################ LATENCY MONITOR
##############################
#延迟监控功能是用来监控 redis 中执行比较缓慢的一些操作，用 LATENCY 打印 redis 实例在跑命令时的耗时图表。只记录大于等于下边设置的值的操作。0 的话，就是关闭监视。默认延迟监控功能是关闭的，如果你需要打开，也可以通过 CONFIG SET 命令动态设置。
latency-monitor-threshold 0
############################# EVENT NOTIFICATION
##############################
#键空间通知使得客户端可以通过订阅频道或模式，来接收那些以某种方式改动了 Redis 数据集的事件。因为开启键空间通知功能需要消耗一些 CPU ，所以在默认配置下，该功能处于关闭状态。
#notify-keyspace-events 的参数可以是以下字符的任意组合，它指定了服务器该发送哪些类型的通知：
##K 键空间通知，所有通知以 __keyspace@__ 为前缀
##E 键事件通知，所有通知以 __keyevent@__ 为前缀
##g DEL 、 EXPIRE 、 RENAME 等类型无关的通用命令的通知
##$ 字符串命令的通知
##l 列表命令的通知
##s 集合命令的通知
##h 哈希命令的通知
##z 有序集合命令的通知
##x 过期事件：每当有过期键被删除时发送
##e 驱逐(evict)事件：每当有键因为 maxmemory 政策而被删除时发送
##A 参数 g$lshzxe 的别名
#输入的参数中至少要有一个 K 或者 E，否则的话，不管其余的参数是什么，都不会有任何 通知被分发。详细使用可以参考 http://redis.io/topics/notifications
notify-keyspace-events &amp;quot;&amp;quot;
############################### ADVANCED CONFIG
###############################
#数据量小于等于 hash-max-ziplist-entries 的用 ziplist，大于 hash-max-ziplist-entries用 hash
hash-max-ziplist-entries 512 #value 大小小于等于 hash-max-ziplist-value 的用ziplist，大于 hash-max-ziplist-value 用 hash。
hash-max-ziplist-value 64
#数据量小于等于 list-max-ziplist-entries 用 ziplist，大于 list-max-ziplist-entries用 list。
list-max-ziplist-entries 512#value 大小小于等于 list-max-ziplist-value 的用ziplist，大于 list-max-ziplist-value 用 list。
list-max-ziplist-value 64
#数据量小于等于 set-max-intset-entries 用 iniset，大于 set-max-intset-entries 用 set。
set-max-intset-entries 512
#数据量小于等于 zset-max-ziplist-entries 用 ziplist，大于 zset-max-ziplist-entries用 zset。
zset-max-ziplist-entries 128#value 大小小于等于 zset-max-ziplist-value 用 ziplist，大于 zset-max-ziplist-value 用 zset。
zset-max-ziplist-value 64
#value 大小小于等于 hll-sparse-max-bytes 使用稀疏数据结构（sparse），大于hll-sparse-max-bytes 使用稠密的数据结构（dense）。一个比 16000 大的 value 是几乎没用的，建议的 value 大概为 3000。如果对 CPU 要求不高，对空间要求较高的，建议设置到 10000 左右。
hll-sparse-max-bytes 3000
#Redis 将在每 100 毫秒时使用 1 毫秒的 CPU 时间来对 redis 的 hash 表进行重新 hash，可以降低内存的使用。当你的使用场景中，有非常严格的实时性需要，不能够接受 Redis 时不时的对请求有 2 毫秒的延迟的话，把这项配置为 no。如果没有这么严格的实时性要求，可以设置为 yes，以便能够尽可能快的释放内存。
activerehashing yes
##对客户端输出缓冲进行限制可以强迫那些不从服务器读取数据的客户端断开连接，用来强制关闭传输缓慢的客户端。
#对于 normal client，第一个 0 表示取消 hard limit，第二个 0 和第三个 0 表示取消 soft limit，normal client 默认取消限制，因为如果没有寻问，他们是不会接收数据的。
client-output-buffer-limit normal 0 0 0#对于 slave client 和 MONITER client，如果client-output-buffer 一旦超过 256mb，又或者超过 64mb 持续 60 秒，那么服务器就会立即断开客户端连接。
client-output-buffer-limit slave 256mb 64mb 60#对于 pubsub client，如果client-output-buffer 一旦超过 32mb，又或者超过 8mb 持续 60 秒，那么服务器就会立即断开客户端连接。
client-output-buffer-limit pubsub 32mb 8mb 60
#redis 执行任务的频率为 1s 除以 hz。
hz 10
#在 aof 重写的时候，如果打开了 aof-rewrite-incremental-fsync 开关，系统会每 32MB 执行一次 fsync。这对于把文件写入磁盘是有帮助的，可以避免过大的延迟峰值。
aof-rewrite-incremental-fsync yes
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;42-redis-的数据持久化&#34;&gt;4.2 Redis 的数据持久化&lt;/h3&gt;
&lt;h4 id=&#34;421-rdb-方式&#34;&gt;4.2.1 RDB 方式&lt;/h4&gt;
&lt;p&gt;对内存中数据库状态进行快照&lt;br&gt;
RDB 方式：将 Redis 在内存中的数据库状态保存到磁盘里面，RDB 文件是一个经过压缩的二进制文件，通过该文件可以还原生成 RDB 文件时的数据库状态（默认下，持久化到dump.rdb 文件，并且在 redis 重启后，自动读取其中文件，据悉，通常情况下一千万的字符串类型键，1GB 的快照文件，同步到内存中的 时间是 20-30 秒）&lt;br&gt;
RDB 的生成方式：&lt;br&gt;
1）执行命令手动生成&lt;br&gt;
有两个 Redis 命令可以用于生成 RDB 文件，一个是 SAVE，另一个是 BGSAVE SAVE命令会阻塞 Redis 服务器进程，直到 RDB 文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求，BGSAVE 命令会派生出一个子进程，然后由子进程负责创建RDB 文件，服务器进程（父进程）继续处理命令请求，创建 RDB 文件结束之前，客户端发送的 BGSAVE 和 SAVE 命令会被服务器拒绝&lt;br&gt;
2）通过配置自动生成&lt;br&gt;
可以设置服务器配置的 save 选项，让服务器每隔一段时间自动执行一次 &lt;strong&gt;BGSAVE&lt;/strong&gt; 命令，可以通过 save 选项设置多个保存条件，但只要其中任意一个条件被满足，服务器就会执行 BGSAVE 命令&lt;br&gt;
例如：&lt;br&gt;
save 900 1&lt;br&gt;
save 300 10&lt;br&gt;
save 60 10000&lt;br&gt;
那么只要满足以下三个条件中的任意一个，BGSAVE 命令就会被执行&lt;br&gt;
服务器在 900 秒之内，对数据库进行了至少 1 次修改&lt;br&gt;
服务器在 300 秒之内，对数据库进行了至少 10 次修改&lt;br&gt;
服务器在 60 秒之内，对数据库进行了至少 10000 次修改&lt;/p&gt;
&lt;h4 id=&#34;422-aof-方式&#34;&gt;4.2.2 AOF 方式&lt;/h4&gt;
&lt;p&gt;AOF 持久化方式在 redis 中默认是关闭的，需要修改配置文件开启该方式。&lt;br&gt;
AOF：把每条命令都写入文件，类似 mysql 的 binlog 日志&lt;br&gt;
AOF 方式：是通过保存 Redis 服务器所执行的写命令来记录数据库状态的文件。&lt;br&gt;
AOF 文件刷新的方式，有三种：&lt;br&gt;
appendfsync always - 每提交一个修改命令都调用 fsync 刷新到 AOF 文件，非常非常慢，但也非常安全&lt;br&gt;
appendfsync everysec - 每秒钟都调用 fsync 刷新到 AOF 文件，很快，但可能会丢失一秒以内的数据&lt;br&gt;
appendfsync no - 依靠 OS 进行刷新，redis 不主动刷新 AOF，这样最快，但安全性就差&lt;br&gt;
默认并推荐每秒刷新，这样在速度和安全上都做到了兼顾&lt;/p&gt;
&lt;p&gt;AOF 数据恢复方式&lt;br&gt;
服务器在启动时，通过载入和执行 AOF 文件中保存的命令来还原服务器关闭之前的数据库状态，具体过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;载入 AOF 文件&lt;/li&gt;
&lt;li&gt;创建模拟客户端&lt;/li&gt;
&lt;li&gt;从 AOF 文件中读取一条命令&lt;/li&gt;
&lt;li&gt;使用模拟客户端执行命令&lt;/li&gt;
&lt;li&gt;循环读取并执行命令，直到全部完成&lt;/li&gt;
&lt;li&gt;如果同时启用了 RDB 和 AOF 方式，AOF 优先，启动时只加载 AOF 文件恢复数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;5-安装-redis-集群&#34;&gt;5、安装 Redis 集群&lt;/h2&gt;
&lt;h3 id=&#34;51-redis-集群介绍&#34;&gt;5.1 Redis 集群介绍&lt;/h3&gt;
&lt;p&gt;​		Redis3.0 版本之后支持 Cluster。&lt;strong&gt;集群要求集群节点中必须要支持主备模式，也就说集中的主节点(Master)至少要有一个从节点(Slave)&lt;/strong&gt;&lt;br&gt;
​		每一个蓝色的圈都代表着一个 redis 集群中的主节点。它们任何两个节点之间都是相互连通的。客户端可以与任何一个节点相连接，然后就可以访问集群中的任何一个节点。对其进行存取和其他操作&lt;/p&gt;
&lt;h4 id=&#34;511-redis-cluster-架构图&#34;&gt;5.1.1 Redis-Cluster 架构图&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200708010154.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;512-redis-cluster-选举容错&#34;&gt;5.1.2 Redis-Cluster 选举:容错&lt;/h4&gt;
&lt;p&gt;​		Redis 之间通过互相的 ping-pong 判断是否节点可以连接上。如果有一半以上的节点去ping 一个节点的时候没有回应，集群就认为这个节点宕机了，然后去连接它的从节点。如果某个节点和所有从节点全部挂掉，我们集群就进入 fail 状态。还有就是如果有一半以上的主节点宕机，那么我们集群同样进入 fail 了状态。这就是我们的 redis 的投票机制，具体原理如下图所示：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200708010227.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;投票过程是集群中所有 master 参与,如果半数以上 master 节点与 master 节点通信超时(cluster-node-timeout),认为当前 master 节点挂掉.&lt;br&gt;
什么时候整个集群不可用(cluster_state:fail)?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果集群任意 master 挂掉,且当前 master 没有 slave。此时集群进入 fail 状态,也可以理解成集群的 slot 映射[0-16383]不完整时进入 fail 状态。&lt;/li&gt;
&lt;li&gt;如果集群超过半数以上 master 挂掉，无论是否有 slave，集群进入 fail 状态.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;513-redis-cluster-数据存储&#34;&gt;5.1.3 Redis-Cluster 数据存储&lt;/h4&gt;
&lt;p&gt;​		当我们的存取的 key 到达的时候，redis 会根据 crc16 的算法得出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点，然后直接自动跳转到这个对应的节点上进行存取操作。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200708010312.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;例如：在 Node1 执行 set name kevin&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用 CRC16 算法对 key 进行计算，得到一个数字，然后对数字进行取余。&lt;br&gt;
CRC16 : name = 26384&lt;br&gt;
26384%16384 = 10000&lt;/li&gt;
&lt;li&gt;查找到包含 10000 插槽的节点，比如是 node2，自动跳转到 node2&lt;/li&gt;
&lt;li&gt;在 node2 上执行 set name kevin 命令完成数据的插入&lt;/li&gt;
&lt;li&gt;如果在 node1 上执行 get name，先使用 CRC16 算法对 key 进行计算，在使用16384 取余，得到插槽的下标，然后跳到拥有该插槽的 node2 中执行 get name 命令，并返回结果。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;52-安装集群&#34;&gt;5.2 安装集群&lt;/h3&gt;
&lt;h4 id=&#34;521-需求&#34;&gt;5.2.1 需求&lt;/h4&gt;
&lt;p&gt;搭建一个 Redis 的最小集群，使用伪集群方式。&lt;br&gt;
Redis 中最小的集群三对主从。&lt;br&gt;
在 192.168.0.179 中安装 6 个 redis 实例。&lt;br&gt;
如果使用已经使用过的单机版创建集群时，需要删除 dump.rdb 与 apeendonly.aof 文件。&lt;br&gt;
6 个 redis 实例的端口分配：8001、8002、8003、8004、8005、8006&lt;/p&gt;
&lt;h4 id=&#34;522-集群步骤&#34;&gt;5.2.2 集群步骤&lt;/h4&gt;
&lt;p&gt;redis 集群时需要使用一个 ruby 的脚本来完成集群。&lt;/p&gt;
&lt;p&gt;第一步 安装 ruby 环境&lt;br&gt;
命令： yum install ruby&lt;/p&gt;
&lt;p&gt;第二步 安装 ruby 的包管理器&lt;br&gt;
命令：yum install rubygems&lt;/p&gt;
&lt;p&gt;第三步 进入到 redis 的安装目录下的 src 目录下找到到 redis-trib.rb 这个文件 这是集群时需要的脚本&lt;/p&gt;
&lt;p&gt;第四步 这个脚本的执行需要依赖于一些其他的 ruby 包 所以我们还要下载一个&lt;br&gt;
redis-3.0.0.gem&lt;br&gt;
将这个文件上传到 linux 服务器中&lt;/p&gt;
&lt;p&gt;第五步 安装这个 ruby 包&lt;br&gt;
命令：gem install redis-3.0.0.gem&lt;/p&gt;
&lt;p&gt;第六步 先启动 redis 的 6 个实例&lt;br&gt;
先在 local 目录下创建一个目录名称为：redis-cluster&lt;br&gt;
命令：mkdir redis-cluster&lt;/p&gt;
&lt;p&gt;第七步 将安装好的 redis 下的 bin 目录拷贝到 redis-cluster 目录下 并起名为 redis01&lt;br&gt;
命令：进入到 redis 目录下执行：cp -r bin ../redis-cluster/redis01&lt;/p&gt;
&lt;p&gt;第九步 修改 redis.conf 配置文件&lt;br&gt;
命令：vim redis.conf&lt;br&gt;
(1)修改端口：默认的为 6379 将六个 redis 实例的端口改成从 7001-7006 在配置文件&lt;br&gt;
的 port 属性中。&lt;br&gt;
(2)修改开启集群 在配置文件中搜索 cluster 找到后 将默认为注释的 cluster-enabled yes 去掉注释&lt;/p&gt;
&lt;p&gt;第十步 将这个 redis01 拷贝 6 份到当前这个目录下&lt;br&gt;
命令：cp -r redis01/ redis02&lt;br&gt;
cp -r redis01/ redis03&lt;br&gt;
cp -r redis01/ redis04&lt;br&gt;
cp -r redis01/ redis05&lt;br&gt;
cp -r redis01/ redis06&lt;/p&gt;
&lt;p&gt;第十一步 修改拷贝的这些 redis 的端口&lt;br&gt;
命令：&lt;br&gt;
[root@localhost redis-cluster]# vim redis02/redis.conf&lt;br&gt;
[root@localhost redis-cluster]# vim redis03/redis.conf&lt;br&gt;
[root@localhost redis-cluster]# vim redis04/redis.conf&lt;br&gt;
[root@localhost redis-cluster]# vim redis05/redis.conf&lt;br&gt;
[root@localhost redis-cluster]# vim redis06/redis.conf&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200708011226.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;第十二步 把创建集群的 ruby 脚本复制到 redis-cluster 中&lt;br&gt;
命令：[root@localhost src]# cp *.rb /usr/local/redis-cluster/&lt;/p&gt;
&lt;p&gt;第十二步 创建一个能够批量启动的脚本程序&lt;br&gt;
命令：vim startall.sh&lt;/p&gt;
&lt;p&gt;第十三步 在脚本文件中添加命令&lt;br&gt;
命令：&lt;/p&gt;
&lt;p&gt;cd redis01&lt;br&gt;
./redis-server redis.conf&lt;br&gt;
cd ..&lt;br&gt;
cd redis02&lt;br&gt;
./redis-server redis.conf&lt;br&gt;
cd ..&lt;br&gt;
cd redis03&lt;br&gt;
./redis-server redis.conf&lt;br&gt;
cd ..&lt;br&gt;
cd redis04&lt;br&gt;
./redis-server redis.conf&lt;br&gt;
cd ..&lt;br&gt;
cd redis05&lt;br&gt;
./redis-server redis.conf&lt;br&gt;
cd ..&lt;br&gt;
cd redis06&lt;br&gt;
./redis-server redis.conf&lt;br&gt;
cd ..&lt;/p&gt;
&lt;p&gt;第十四步 将批量启动脚本设置为可执行权限&lt;br&gt;
命令:chmod +x startall.sh&lt;/p&gt;
&lt;p&gt;第十五步 执行这个批量启动的脚本&lt;br&gt;
命令：[root@localhost redis-cluster]# ./startall.sh&lt;/p&gt;
&lt;p&gt;第十六步 查看 redis 是否启动成功&lt;br&gt;
命令：ps aux|grep redis&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;18&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200708013049.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;第十七步 创建集群&lt;br&gt;
命 令 ： ./redis-trib.rb create --replicas 1 192.168.0.179:8001 192.168.0.179:8002 192.168.0.179:8003 192.168.0.179:8004 192.168.0.179:8005 192.168.0.179:8006&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;19&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200708013922.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如果控制台输出如下信息表集群成功&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;20&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200708014103.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;测试 Redis 集群&lt;br&gt;
测试 Redis 集群：可以连接集群中的任意一个节点进行测试 注意一定要有-c 参数，否则能连上，但是无法操作 redis 集群&lt;br&gt;
命令：[root@localhost redis-cluster]# ./redis01/redis-cli -h 192.168.0.179 -p 8001 -c&lt;/p&gt;
&lt;p&gt;关闭 Redis 集群&lt;br&gt;
命令：./redis-cli -h 192.168.0.179 -p 8001 shutdown&lt;/p&gt;
&lt;p&gt;也可以编写一个批量关闭的脚本&lt;br&gt;
命令：vim shutdown.sh&lt;br&gt;
redis01 /redis-cli -h 192.168.0.179 -p 8001 shutdown&lt;br&gt;
redis02 /redis-cli -h 192.168.0.179 -p 8002 shutdown&lt;br&gt;
redis03 /redis-cli -h 192.168.0.179 -p 8003 shutdown&lt;br&gt;
redis04 /redis-cli -h 192.168.0.179 -p 8004 shutdown&lt;br&gt;
redis05 /redis-cli -h 192.168.0.179 -p 8005 shutdown&lt;br&gt;
redis06 /redis-cli -h 192.168.0.179 -p 8006 shutdown&lt;/p&gt;
&lt;h2 id=&#34;6-使用-jedisapi-操作-redis&#34;&gt;6、使用 JedisAPI 操作 Redis&lt;/h2&gt;
&lt;p&gt;Jedis 集成了 redis 的一些命令操作，封装了对 redis 命令的 Java 客户端。&lt;/p&gt;
&lt;h3 id=&#34;61-使用-jedis-操作-redis-单机版&#34;&gt;6.1 使用 Jedis 操作 Redis 单机版&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;创建工程&lt;/li&gt;
&lt;li&gt;修改 POM 文件添加 Jedis 坐标&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot;
         xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
         xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;JedisDemo&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;redis.clients&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;jedis&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.9.0&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;测试 Jedis 操作 Redis 单机版&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	/**
     * Jedis单机版测试
     */
    public static void testJedisSingle(){
        //创建一个Jedis对象
        Jedis jedis = new Jedis(&amp;quot;124.70.181.124&amp;quot;,6379);
        //调用Jedis的API完成对Redis的操作。在jedis中方法的命名与操作Redis的命令相同
        String result = jedis.set(&amp;quot;key1&amp;quot;, &amp;quot;hello&amp;quot;);
        System.out.println(result);
        String str = jedis.get(&amp;quot;key1&amp;quot;);
        System.out.println(str);
        System.out.println(&amp;quot;--------------------------&amp;quot;);
        Long rel = jedis.hset(&amp;quot;user&amp;quot;, &amp;quot;username&amp;quot;, &amp;quot;cy&amp;quot;);
        System.out.println(rel);
        String hrel = jedis.hget(&amp;quot;user&amp;quot;, &amp;quot;username&amp;quot;);
        System.out.println(hrel);
        jedis.close();

    }
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;测试使用连接池操作 Redis 单机版&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	/**
     * 使用连接池
     */
    public static void testJedisPool(){
        //创建连接池
        JedisPool pool = new JedisPool(&amp;quot;124.70.181.124&amp;quot;,6379);
        //取出实例
        Jedis jedis = pool.getResource();
        String s = jedis.hget(&amp;quot;user&amp;quot;, &amp;quot;username&amp;quot;);
        System.out.println(s);
        jedis.close();
    }

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;62-使用-jedis-操作-redis-集群&#34;&gt;6.2 使用 Jedis 操作 Redis 集群&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt; 	/**
     * 集群测试
     */
    public static void testJedisCluster() throws IOException {
        //创建HostAndPort:集群中的的一个节点
        Set&amp;lt;HostAndPort&amp;gt; nodes=new HashSet&amp;lt;&amp;gt;();
        nodes.add(new HostAndPort(&amp;quot;124.70.181.124&amp;quot;,8001));
        nodes.add(new HostAndPort(&amp;quot;124.70.181.124&amp;quot;,8002));
        nodes.add(new HostAndPort(&amp;quot;124.70.181.124&amp;quot;,8003));
        nodes.add(new HostAndPort(&amp;quot;124.70.181.124&amp;quot;,8004));
        nodes.add(new HostAndPort(&amp;quot;124.70.181.124&amp;quot;,8005));
        nodes.add(new HostAndPort(&amp;quot;124.70.181.124&amp;quot;,8006));
        // 创建操作集群的jedis对象
        JedisCluster jedisCluster = new JedisCluster(nodes);
        //在jedisCluster中方法的命名与操作Redis的命令相同
        jedisCluster.set(&amp;quot;name&amp;quot;,&amp;quot;cy&amp;quot;);
        String name = jedisCluster.get(&amp;quot;name&amp;quot;);
        System.out.println(name);
        jedisCluster.close();
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;7-spring-整合-jedis&#34;&gt;7、Spring 整合 Jedis&lt;/h2&gt;
&lt;h3 id=&#34;71-整合单机版&#34;&gt;7.1 整合单机版&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;创建工程&lt;/li&gt;
&lt;li&gt;修改 POM 文件添加 Jedis 与 Spring 的坐标&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
  &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
  &amp;lt;groupId&amp;gt;com.bjsxt&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;springJedisDemo&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
  
  &amp;lt;dependencies&amp;gt;
		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;redis.clients&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;jedis&amp;lt;/artifactId&amp;gt;
			&amp;lt;version&amp;gt;2.9.0&amp;lt;/version&amp;gt;
		&amp;lt;/dependency&amp;gt;
		
		&amp;lt;dependency&amp;gt;
		        &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
				&amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;
				&amp;lt;version&amp;gt;4.1.3.RELEASE&amp;lt;/version&amp;gt;
			&amp;lt;/dependency&amp;gt;
			&amp;lt;dependency&amp;gt;
				&amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
				&amp;lt;artifactId&amp;gt;spring-beans&amp;lt;/artifactId&amp;gt;
				&amp;lt;version&amp;gt;4.1.3.RELEASE&amp;lt;/version&amp;gt;
			&amp;lt;/dependency&amp;gt;
	&amp;lt;/dependencies&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;创建 JedisDao 接口与接口实现类&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;JedisDao&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface JedisDao {
	
	public String set(String key,String value);
	public String get(String key);
	public Long hset(String hkey,String key,String value);
	public String hget(String hkey,String key);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JedisDaoImplSingle&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class JedisDaoImplSingle implements JedisDao {
	
	@Autowired
	private JedisPool jedisPool;
	

	@Override
	public String set(String key, String value) {
		Jedis jedis = this.jedisPool.getResource();
		return jedis.set(key, value);
	}

	@Override
	public String get(String key) {
		Jedis jedis = this.jedisPool.getResource();
		return jedis.get(key);
	}

	@Override
	public Long hset(String hkey, String key, String value) {
		Jedis jedis = this.jedisPool.getResource();
		return jedis.hset(hkey, key, value);
	}

	@Override
	public String hget(String hkey, String key) {
		Jedis jedis = this.jedisPool.getResource();
		return jedis.hget(hkey, key);
	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;在 Spring 配置文件中整合 Jedis&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
	xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xmlns:p=&amp;quot;http://www.springframework.org/schema/p&amp;quot;
	xmlns:context=&amp;quot;http://www.springframework.org/schema/context&amp;quot;
	xmlns:mvc=&amp;quot;http://www.springframework.org/schema/mvc&amp;quot;
	xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&amp;quot;&amp;gt;
	&amp;lt;context:component-scan base-package=&amp;quot;com.cy.jedisdao&amp;quot;/&amp;gt;
	&amp;lt;!-- jedisPool的配置 --&amp;gt;
	&amp;lt;bean id=&amp;quot;poolconfig&amp;quot; class=&amp;quot;redis.clients.jedis.JedisPoolConfig&amp;quot;&amp;gt;
	        &amp;lt;!-- 最大连接数 --&amp;gt;
		&amp;lt;property name=&amp;quot;maxTotal&amp;quot; value=&amp;quot;30&amp;quot; /&amp;gt;
		&amp;lt;!-- 最大空闲连接数 --&amp;gt;
		&amp;lt;property name=&amp;quot;maxIdle&amp;quot; value=&amp;quot;10&amp;quot; /&amp;gt;
		&amp;lt;!-- 每次释放连接的最大数目 --&amp;gt;
		&amp;lt;property name=&amp;quot;numTestsPerEvictionRun&amp;quot; value=&amp;quot;1024&amp;quot; /&amp;gt;
		&amp;lt;!-- 释放连接的扫描间隔（毫秒） --&amp;gt;
		&amp;lt;property name=&amp;quot;timeBetweenEvictionRunsMillis&amp;quot; value=&amp;quot;30000&amp;quot; /&amp;gt;
		&amp;lt;!-- 连接最小空闲时间 --&amp;gt;
		&amp;lt;property name=&amp;quot;minEvictableIdleTimeMillis&amp;quot; value=&amp;quot;1800000&amp;quot; /&amp;gt;
		&amp;lt;!-- 连接空闲多久后释放, 当空闲时间&amp;gt;该值 且 空闲连接&amp;gt;最大空闲连接数 时直接释放 --&amp;gt;
		&amp;lt;property name=&amp;quot;softMinEvictableIdleTimeMillis&amp;quot; value=&amp;quot;10000&amp;quot; /&amp;gt;
		&amp;lt;!-- 获取连接时的最大等待毫秒数,小于零:阻塞不确定的时间,默认-1 --&amp;gt;
		&amp;lt;property name=&amp;quot;maxWaitMillis&amp;quot; value=&amp;quot;1500&amp;quot; /&amp;gt;
		&amp;lt;!-- 在获取连接的时候检查有效性, 默认false --&amp;gt;
		&amp;lt;property name=&amp;quot;testOnBorrow&amp;quot; value=&amp;quot;true&amp;quot; /&amp;gt;
		&amp;lt;!-- 在空闲时检查有效性, 默认false --&amp;gt;
		&amp;lt;property name=&amp;quot;testWhileIdle&amp;quot; value=&amp;quot;true&amp;quot; /&amp;gt;
		&amp;lt;!-- 连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true --&amp;gt;
		&amp;lt;property name=&amp;quot;blockWhenExhausted&amp;quot; value=&amp;quot;false&amp;quot; /&amp;gt;
	&amp;lt;/bean&amp;gt;
	&amp;lt;!-- 配置JedidesPool --&amp;gt;
	&amp;lt;bean id=&amp;quot;jedisPool&amp;quot; class=&amp;quot;redis.clients.jedis.JedisPool&amp;quot;&amp;gt;
		&amp;lt;constructor-arg name=&amp;quot;poolConfig&amp;quot;&amp;gt;
			&amp;lt;ref bean=&amp;quot;poolconfig&amp;quot;/&amp;gt;
		&amp;lt;/constructor-arg&amp;gt;
		&amp;lt;constructor-arg name=&amp;quot;host&amp;quot;&amp;gt;
			&amp;lt;value&amp;gt;124.70.181.124&amp;lt;/value&amp;gt;
		&amp;lt;/constructor-arg&amp;gt;
		&amp;lt;constructor-arg name=&amp;quot;port&amp;quot;&amp;gt;
			&amp;lt;value&amp;gt;6379&amp;lt;/value&amp;gt;
		&amp;lt;/constructor-arg&amp;gt;
	&amp;lt;/bean&amp;gt;
    	&amp;lt;!-- JedisDaoImplSingle --&amp;gt;
	&amp;lt;bean id=&amp;quot;jedisDaoImplSingle&amp;quot; class=&amp;quot;com.cy.jedisdao.impl.JedisDaoImplSingle&amp;quot;&amp;gt;&amp;lt;/bean&amp;gt; 
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;测试单机版&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;public class Test {&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void main(String[] args) {
	Test.testJedisSingle();
}

/**
 * 测试单机版Jedis
 */
public static void testJedisSingle(){
	ApplicationContext ac = new ClassPathXmlApplicationContext(&amp;quot;applicationContext-Jedis.xml&amp;quot;);
	JedisDao jd = (JedisDao)ac.getBean(&amp;quot;jedisDaoImplSingle&amp;quot;);
	String str = jd.set(&amp;quot;hello&amp;quot;, &amp;quot;Redis&amp;quot;);
	System.out.println(str);
	String result = jd.get(&amp;quot;hello&amp;quot;);
	System.out.println(result);
}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;72-整合集群版&#34;&gt;7.2 整合集群版&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;添加 JedisDao 实现类。基于 JedisCluster 的实现&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class JedisDaoImplCluster implements JedisDao {

	@Autowired
	private JedisCluster jedisCluster;
	
	@Override
	public String set(String key, String value) {
		return this.jedisCluster.set(key, value);
	}

	@Override
	public String get(String key) {
		return this.jedisCluster.get(key);
	}

	@Override
	public Long hset(String hkey, String key, String value) {
		return this.jedisCluster.hset(hkey, key, value);
	}

	@Override
	public String hget(String hkey, String key) {
		return this.jedisCluster.hget(hkey, key);
	}

}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;在 Spring 配置文件中整合 JedisCluster&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
	xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xmlns:p=&amp;quot;http://www.springframework.org/schema/p&amp;quot;
	xmlns:context=&amp;quot;http://www.springframework.org/schema/context&amp;quot;
	xmlns:mvc=&amp;quot;http://www.springframework.org/schema/mvc&amp;quot;
	xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&amp;quot;&amp;gt;
	&amp;lt;context:component-scan base-package=&amp;quot;com.cy.jedisdao&amp;quot;/&amp;gt;
	&amp;lt;!-- jedisPool的配置 --&amp;gt;
	&amp;lt;bean id=&amp;quot;poolconfig&amp;quot; class=&amp;quot;redis.clients.jedis.JedisPoolConfig&amp;quot;&amp;gt;
	        &amp;lt;!-- 最大连接数 --&amp;gt;
		&amp;lt;property name=&amp;quot;maxTotal&amp;quot; value=&amp;quot;30&amp;quot; /&amp;gt;
		&amp;lt;!-- 最大空闲连接数 --&amp;gt;
		&amp;lt;property name=&amp;quot;maxIdle&amp;quot; value=&amp;quot;10&amp;quot; /&amp;gt;
		&amp;lt;!-- 每次释放连接的最大数目 --&amp;gt;
		&amp;lt;property name=&amp;quot;numTestsPerEvictionRun&amp;quot; value=&amp;quot;1024&amp;quot; /&amp;gt;
		&amp;lt;!-- 释放连接的扫描间隔（毫秒） --&amp;gt;
		&amp;lt;property name=&amp;quot;timeBetweenEvictionRunsMillis&amp;quot; value=&amp;quot;30000&amp;quot; /&amp;gt;
		&amp;lt;!-- 连接最小空闲时间 --&amp;gt;
		&amp;lt;property name=&amp;quot;minEvictableIdleTimeMillis&amp;quot; value=&amp;quot;1800000&amp;quot; /&amp;gt;
		&amp;lt;!-- 连接空闲多久后释放, 当空闲时间&amp;gt;该值 且 空闲连接&amp;gt;最大空闲连接数 时直接释放 --&amp;gt;
		&amp;lt;property name=&amp;quot;softMinEvictableIdleTimeMillis&amp;quot; value=&amp;quot;10000&amp;quot; /&amp;gt;
		&amp;lt;!-- 获取连接时的最大等待毫秒数,小于零:阻塞不确定的时间,默认-1 --&amp;gt;
		&amp;lt;property name=&amp;quot;maxWaitMillis&amp;quot; value=&amp;quot;1500&amp;quot; /&amp;gt;
		&amp;lt;!-- 在获取连接的时候检查有效性, 默认false --&amp;gt;
		&amp;lt;property name=&amp;quot;testOnBorrow&amp;quot; value=&amp;quot;true&amp;quot; /&amp;gt;
		&amp;lt;!-- 在空闲时检查有效性, 默认false --&amp;gt;
		&amp;lt;property name=&amp;quot;testWhileIdle&amp;quot; value=&amp;quot;true&amp;quot; /&amp;gt;
		&amp;lt;!-- 连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true --&amp;gt;
		&amp;lt;property name=&amp;quot;blockWhenExhausted&amp;quot; value=&amp;quot;false&amp;quot; /&amp;gt;
	&amp;lt;/bean&amp;gt;
	&amp;lt;!-- 配置JedidesPool --&amp;gt;
	&amp;lt;bean id=&amp;quot;jedisPool&amp;quot; class=&amp;quot;redis.clients.jedis.JedisPool&amp;quot;&amp;gt;
		&amp;lt;constructor-arg name=&amp;quot;poolConfig&amp;quot;&amp;gt;
			&amp;lt;ref bean=&amp;quot;poolconfig&amp;quot;/&amp;gt;
		&amp;lt;/constructor-arg&amp;gt;
		&amp;lt;constructor-arg name=&amp;quot;host&amp;quot;&amp;gt;
			&amp;lt;value&amp;gt;124.70.181.124&amp;lt;/value&amp;gt;
		&amp;lt;/constructor-arg&amp;gt;
		&amp;lt;constructor-arg name=&amp;quot;port&amp;quot;&amp;gt;
			&amp;lt;value&amp;gt;6379&amp;lt;/value&amp;gt;
		&amp;lt;/constructor-arg&amp;gt;
	&amp;lt;/bean&amp;gt;
	&amp;lt;!-- JedisDaoImplSingle --&amp;gt;
	&amp;lt;!-- &amp;lt;bean id=&amp;quot;jedisDaoImplSingle&amp;quot; class=&amp;quot;com.bjsxt.jedisdao.impl.JedisDaoImplSingle&amp;quot;&amp;gt;&amp;lt;/bean&amp;gt; --&amp;gt;
	
	
	&amp;lt;!-- JedislCluster --&amp;gt;
     &amp;lt;!-- 这里等同于做了
        创建HostAndPort:集群中的的一个节点
        Set&amp;lt;HostAndPort&amp;gt; nodes=new HashSet&amp;lt;&amp;gt;();
        nodes.add(new HostAndPort(&amp;quot;124.70.181.124&amp;quot;,8001));
        nodes.add(new HostAndPort(&amp;quot;124.70.181.124&amp;quot;,8002));
        nodes.add(new HostAndPort(&amp;quot;124.70.181.124&amp;quot;,8003));
        nodes.add(new HostAndPort(&amp;quot;124.70.181.124&amp;quot;,8004));
        nodes.add(new HostAndPort(&amp;quot;124.70.181.124&amp;quot;,8005));
        nodes.add(new HostAndPort(&amp;quot;124.70.181.124&amp;quot;,8006));
        创建操作集群的jedis对象
        JedisCluster jedisCluster = new JedisCluster(nodes);
        --&amp;gt; 
	&amp;lt;bean id=&amp;quot;jedisCluster&amp;quot; class=&amp;quot;redis.clients.jedis.JedisCluster&amp;quot;&amp;gt;
		&amp;lt;constructor-arg name=&amp;quot;nodes&amp;quot;&amp;gt;
			&amp;lt;set&amp;gt;
				&amp;lt;bean class=&amp;quot;redis.clients.jedis.HostAndPort&amp;quot;&amp;gt;
					&amp;lt;constructor-arg name=&amp;quot;host&amp;quot;&amp;gt;
					 &amp;lt;value&amp;gt;124.70.181.124&amp;lt;/value&amp;gt;
					&amp;lt;/constructor-arg&amp;gt;
					&amp;lt;constructor-arg name=&amp;quot;port&amp;quot;&amp;gt;
					  &amp;lt;value&amp;gt;8001&amp;lt;/value&amp;gt;
					&amp;lt;/constructor-arg&amp;gt;
				&amp;lt;/bean&amp;gt;
				&amp;lt;bean class=&amp;quot;redis.clients.jedis.HostAndPort&amp;quot;&amp;gt;
					&amp;lt;constructor-arg name=&amp;quot;host&amp;quot;&amp;gt;
					 &amp;lt;value&amp;gt;124.70.181.124&amp;lt;/value&amp;gt;
					&amp;lt;/constructor-arg&amp;gt;
					&amp;lt;constructor-arg name=&amp;quot;port&amp;quot;&amp;gt;
					  &amp;lt;value&amp;gt;8002&amp;lt;/value&amp;gt;
					&amp;lt;/constructor-arg&amp;gt;
				&amp;lt;/bean&amp;gt;
				&amp;lt;bean class=&amp;quot;redis.clients.jedis.HostAndPort&amp;quot;&amp;gt;
					&amp;lt;constructor-arg name=&amp;quot;host&amp;quot;&amp;gt;
					 &amp;lt;value&amp;gt;124.70.181.124&amp;lt;/value&amp;gt;
					&amp;lt;/constructor-arg&amp;gt;
					&amp;lt;constructor-arg name=&amp;quot;port&amp;quot;&amp;gt;
					  &amp;lt;value&amp;gt;8003&amp;lt;/value&amp;gt;
					&amp;lt;/constructor-arg&amp;gt;
				&amp;lt;/bean&amp;gt;
				&amp;lt;bean class=&amp;quot;redis.clients.jedis.HostAndPort&amp;quot;&amp;gt;
					&amp;lt;constructor-arg name=&amp;quot;host&amp;quot;&amp;gt;
					 &amp;lt;value&amp;gt;124.70.181.124&amp;lt;/value&amp;gt;
					&amp;lt;/constructor-arg&amp;gt;
					&amp;lt;constructor-arg name=&amp;quot;port&amp;quot;&amp;gt;
					  &amp;lt;value&amp;gt;8004&amp;lt;/value&amp;gt;
					&amp;lt;/constructor-arg&amp;gt;
				&amp;lt;/bean&amp;gt;
				&amp;lt;bean class=&amp;quot;redis.clients.jedis.HostAndPort&amp;quot;&amp;gt;
					&amp;lt;constructor-arg name=&amp;quot;host&amp;quot;&amp;gt;
					 &amp;lt;value&amp;gt;124.70.181.124&amp;lt;/value&amp;gt;
					&amp;lt;/constructor-arg&amp;gt;
					&amp;lt;constructor-arg name=&amp;quot;port&amp;quot;&amp;gt;
					  &amp;lt;value&amp;gt;8005&amp;lt;/value&amp;gt;
					&amp;lt;/constructor-arg&amp;gt;
				&amp;lt;/bean&amp;gt;
				&amp;lt;bean class=&amp;quot;redis.clients.jedis.HostAndPort&amp;quot;&amp;gt;
					&amp;lt;constructor-arg name=&amp;quot;host&amp;quot;&amp;gt;
					 &amp;lt;value&amp;gt;124.70.181.124&amp;lt;/value&amp;gt;
					&amp;lt;/constructor-arg&amp;gt;
					&amp;lt;constructor-arg name=&amp;quot;port&amp;quot;&amp;gt;
					  &amp;lt;value&amp;gt;8006&amp;lt;/value&amp;gt;
					&amp;lt;/constructor-arg&amp;gt;
				&amp;lt;/bean&amp;gt;
			&amp;lt;/set&amp;gt;
		&amp;lt;/constructor-arg&amp;gt;
		&amp;lt;constructor-arg name=&amp;quot;poolConfig&amp;quot;&amp;gt;
			&amp;lt;ref bean=&amp;quot;poolconfig&amp;quot;/&amp;gt;
		&amp;lt;/constructor-arg&amp;gt;
	&amp;lt;/bean&amp;gt;
	
	&amp;lt;!-- JedisDaoImplCluster --&amp;gt;
	&amp;lt;bean id=&amp;quot;jedisDaoImplCluster&amp;quot; class=&amp;quot;com.cy.jedisdao.impl.JedisDaoImplCluster&amp;quot;&amp;gt;&amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;测试集群版&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {

	public static void main(String[] args) {
		//Test.testJedisSingle();
		Test.testJedisCluster();
	}

	/**
	 * 测试单机版Jedis
	 */
	public static void testJedisSingle(){
		ApplicationContext ac = new ClassPathXmlApplicationContext(&amp;quot;applicationContext-Jedis.xml&amp;quot;);
		JedisDao jd = (JedisDao)ac.getBean(&amp;quot;jedisDaoImplSingle&amp;quot;);
		String str = jd.set(&amp;quot;hello&amp;quot;, &amp;quot;Redis&amp;quot;);
		System.out.println(str);
		String result = jd.get(&amp;quot;hello&amp;quot;);
		System.out.println(result);
	}
	
	/**
	 * 测试集群版Jedis
	 */
	public static void testJedisCluster(){
		ApplicationContext ac = new ClassPathXmlApplicationContext(&amp;quot;applicationContext-Jedis.xml&amp;quot;);
		JedisDao jd = (JedisDao)ac.getBean(&amp;quot;jedisDaoImplCluster&amp;quot;);
		String str = jd.set(&amp;quot;name&amp;quot;, &amp;quot;cy&amp;quot;);
		System.out.println(str);
		String result = jd.get(&amp;quot;name&amp;quot;);
		System.out.println(result);
	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;8-redis-desktop-manager-的使用&#34;&gt;8、Redis Desktop Manager 的使用&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;21&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200708143600.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;22&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200708143629.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;23&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200708143700.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;9-实战案例&#34;&gt;9、实战案例&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;需求&lt;br&gt;
1）实现用户添加功能。&lt;br&gt;
2）实现用户查询功能，并使用 Redis 作为查询缓存。&lt;br&gt;
3）实现用户更新功能，同步缓存。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据库的表结构&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;CREATE TABLE `users` (
`userid` int(11) NOT NULL AUTO_INCREMENT,
`username` varchar(30) DEFAULT NULL,
`userage` int(11) DEFAULT NULL,
PRIMARY KEY (`userid`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;创建项目&lt;/li&gt;
&lt;li&gt;修改 POM 文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;

&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
         xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;usermanger&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;packaging&amp;gt;war&amp;lt;/packaging&amp;gt;

    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;redis-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;/parent&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;redis.clients&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;jedis&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!-- 单元测试 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!-- 日志处理 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;slf4j-log4j12&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!-- Mybatis --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mybatis-spring&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!-- MySql --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!-- 连接池 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;druid&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!-- Spring --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-beans&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-jdbc&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-aspects&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!-- JSP相关 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;jstl&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;jstl&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;servlet-api&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;jsp-api&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!-- Jackson Json处理工具包 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;jackson-databind&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${jackson.version}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;resources&amp;gt;
            &amp;lt;resource&amp;gt;
                &amp;lt;directory&amp;gt;src/main/java&amp;lt;/directory&amp;gt;
                &amp;lt;includes&amp;gt;
                    &amp;lt;include&amp;gt;**/*.xml&amp;lt;/include&amp;gt;
                &amp;lt;/includes&amp;gt;
            &amp;lt;/resource&amp;gt;
            &amp;lt;resource&amp;gt;
                &amp;lt;directory&amp;gt;src/main/resources&amp;lt;/directory&amp;gt;
                &amp;lt;includes&amp;gt;
                    &amp;lt;include&amp;gt;**/*.xml&amp;lt;/include&amp;gt;
                    &amp;lt;include&amp;gt;**/*.properties&amp;lt;/include&amp;gt;
                &amp;lt;/includes&amp;gt;
            &amp;lt;/resource&amp;gt;
        &amp;lt;/resources&amp;gt;
        &amp;lt;!-- tomcat插件，由于子项目不一定每个都是web项目，所以该插件只是声明，并未开启 --&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;!-- 配置Tomcat插件 --&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.apache.tomcat.maven&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;tomcat7-maven-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;configuration&amp;gt;
                    &amp;lt;path&amp;gt;/&amp;lt;/path&amp;gt;
                    &amp;lt;port&amp;gt;8080&amp;lt;/port&amp;gt;
                &amp;lt;/configuration&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;框架整合&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;24&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200708164009.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;
&lt;p&gt;添加用户&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根据用户 ID 查询用户&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建 findUser.jsp&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;%@ page language=&amp;quot;java&amp;quot; contentType=&amp;quot;text/html; charset=UTF-8&amp;quot;
    pageEncoding=&amp;quot;UTF-8&amp;quot;%&amp;gt;
&amp;lt;!DOCTYPE html PUBLIC &amp;quot;-//W3C//DTD HTML 4.01 Transitional//EN&amp;quot; &amp;quot;http://www.w3.org/TR/html4/loose.dtd&amp;quot;&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta http-equiv=&amp;quot;Content-Type&amp;quot; content=&amp;quot;text/html; charset=UTF-8&amp;quot;&amp;gt;
&amp;lt;title&amp;gt;Insert title here&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
	&amp;lt;form action=&amp;quot;/user/findUserById&amp;quot; method=&amp;quot;post&amp;quot;&amp;gt;
		用户ID:&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;userid&amp;quot;/&amp;gt;
		&amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;OKOK&amp;quot;/&amp;gt;
	&amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;UserMapper 与 UserMapper 映射配置文件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;UserMapper 接口&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface UserMapper {

	public void insertUser(Users user);
	
	public List&amp;lt;Users&amp;gt; selectUserAll();
	
	Users findUserById(int userid);
	
	void updateUser(Users users);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;映射配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper PUBLIC &amp;quot;-//mybatis.org//DTD Mapper 3.0//EN&amp;quot; &amp;quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&amp;quot; &amp;gt;
&amp;lt;mapper namespace=&amp;quot;com.bjsxt.mapper.UserMapper&amp;quot; &amp;gt;

  &amp;lt;insert id=&amp;quot;insertUser&amp;quot; parameterType=&amp;quot;com.bjsxt.pojo.Users&amp;quot;&amp;gt;
  		insert into users(username,userage) values(#{username},#{userage})
  &amp;lt;/insert&amp;gt;
  
  &amp;lt;select id=&amp;quot;selectUserAll&amp;quot; resultType=&amp;quot;com.bjsxt.pojo.Users&amp;quot;&amp;gt;
  		select * from users
  &amp;lt;/select&amp;gt;
  
  &amp;lt;select id=&amp;quot;findUserById&amp;quot; resultType=&amp;quot;com.bjsxt.pojo.Users&amp;quot;&amp;gt;
  		select * from users where userid = #{userid}
  &amp;lt;/select&amp;gt;
  
  &amp;lt;select id=&amp;quot;updateUser&amp;quot; parameterType=&amp;quot;com.bjsxt.pojo.Users&amp;quot;&amp;gt;
  		update users set username = #{username},userage = #{userage} where userid=#{userid}
  &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;实现业务&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
public class UserServiceImpl implements UserService {

	@Autowired
	private UserMapper userMapper;

	@Autowired
	private JedisDao jedisDao;

	@Value(&amp;quot;${REDIS_USERS_PRIFX}&amp;quot;)
	private String REDIS_USERS_PRIFX;

	@Override
	public void addUser(Users users) {
		this.userMapper.insertUser(users);
	}

	@Override
	public Users findUserById(int userid) {
        //先在redis中查询，如果没有再从数据库中查询并将查询结果放入redis中，并且返回user到controller
		try {
			// 查询缓存
			String json = this.jedisDao.get(this.REDIS_USERS_PRIFX + &amp;quot;:&amp;quot; + userid);
			// 在缓存中是否命中
			if (json != null &amp;amp;&amp;amp; json.length() &amp;gt; 0) {
				System.out.println(&amp;quot;.........................&amp;quot;);
				Users user = JsonUtils.jsonToPojo(json, Users.class);
				return user;
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		// 查询数据库
		Users user = this.userMapper.findUserById(userid);
		System.out.println(&amp;quot;,,,,,,,,,,,,,,,,,,,,,,,,,,,,,&amp;quot;);
		try {
			// 放入到redis中
			String res = JsonUtils.objectToJson(user);
			this.jedisDao.set(this.REDIS_USERS_PRIFX + &amp;quot;:&amp;quot; + userid, res);
			this.jedisDao.expire(this.REDIS_USERS_PRIFX + &amp;quot;:&amp;quot; + userid, 60);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return user;
	}

	@Override
	public void updateUser(Users users) {
		this.userMapper.updateUser(users);
		try{
			//同步redis
			this.jedisDao.del(this.REDIS_USERS_PRIFX+&amp;quot;:&amp;quot;+users.getUserid());
		}catch(Exception e){
			e.printStackTrace();
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;controller&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Controller
@RequestMapping(&amp;quot;/user&amp;quot;)
public class UserController {

	@Autowired
	private UserService userService;
	/**
	 * 添加用户
	 */
	@RequestMapping(&amp;quot;/addUser&amp;quot;)
	public String addUser(Users user){
		this.userService.addUser(user);
		return &amp;quot;ok&amp;quot;;
	}
	
	/**
	 * 根据用户ID查询用户
	 */
	@RequestMapping(&amp;quot;/findUserById&amp;quot;)
	public String showUser(Model model,int userid){
		Users users = this.userService.findUserById(userid);
		model.addAttribute(&amp;quot;users&amp;quot;, users);
		return &amp;quot;showUser&amp;quot;;
	}
	
	/**
	 * 更新用户
	 */
	@RequestMapping(&amp;quot;/updateUser&amp;quot;)
	public String updateUser(Users users){
		this.userService.updateUser(users);
		return &amp;quot;ok&amp;quot;;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
">Redis</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jonchan1013.github.io/post/rabbitmq/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200707162914.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;1-amqp-简介&#34;&gt;1、AMQP 简介&lt;/h2&gt;
&lt;h3 id=&#34;11-amqp-是什么&#34;&gt;1.1 AMQP 是什么?&lt;/h3&gt;
&lt;p&gt;AMQP(Advanced Message Queuing Protocol,高级消息队列协议)是进程之间传递异步消息的网络协议。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;12-amqp-工作过程&#34;&gt;1.2 AMQP 工作过程&lt;/h3&gt;
&lt;p&gt;发布者(Publisher)发布消息(Message),经过交换机(Exchange)，交换机根据路由规则将收到消息分发给交换机绑定的队列(Queue)，最后 AMQP 代理会将消息投递给订阅了此队列的消费者，或者消费者按照需求自行获取。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200706171158.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;13-队列&#34;&gt;1.3 队列&lt;/h3&gt;
&lt;p&gt;队列是数据结构中概念。数据存储在一个队列中，数据是有顺序的，先进的先出，后进后出。其中一侧负责进数据，另一次负责出数据。&lt;/p&gt;
&lt;p&gt;MQ（消息队列）很多功能都是基于此队列结构实现的&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200706171229.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;2-rabbitmq-简介&#34;&gt;2、RabbitMQ 简介&lt;/h2&gt;
&lt;h3 id=&#34;21-rabbitmq-介绍&#34;&gt;2.1 RabbitMQ 介绍&lt;/h3&gt;
&lt;p&gt;RabbitMQ 是由 Erlang 语言编写的基于 AMQP 的消息中间件。而消息中间件作为分布式系统重要组件之一，可以解决应用耦合，异步消息，流量削峰等问题。&lt;/p&gt;
&lt;h4 id=&#34;211-解决应用耦合&#34;&gt;2.1.1 解决应用耦合&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;不使用 MQ 时&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200706171358.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;使用 MQ 解决耦合&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200706171415.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;22-rabbitmq-适用场景&#34;&gt;2.2 RabbitMQ 适用场景&lt;/h3&gt;
&lt;p&gt;排队算法、秒杀活动、消息分发、异步处理、数据同步、处理耗时任务、流量销峰等。&lt;/p&gt;
&lt;h2 id=&#34;3-rabbitmq-原理&#34;&gt;3、RabbitMQ 原理&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200706171458.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;31-message&#34;&gt;3.1 Message&lt;/h3&gt;
&lt;p&gt;消息。消息是不具名的，它由消息头消息体组成。消息体是不透明的，而消息头则由一系列可选属性组成，这些属性包括：routing-key(路由键)、priority(相对于其他消息的优先权)、delivery-mode(指出消息可能持久性存储)等。&lt;/p&gt;
&lt;h3 id=&#34;32-publisher&#34;&gt;3.2 Publisher&lt;/h3&gt;
&lt;p&gt;消息的生产者。也是一个向交换器发布消息的客户端应用程序。&lt;/p&gt;
&lt;h3 id=&#34;33-consumer&#34;&gt;3.3 Consumer&lt;/h3&gt;
&lt;p&gt;消息的消费者。表示一个从消息队列中取得消息的客户端应用程序。&lt;/p&gt;
&lt;h3 id=&#34;34-exchange&#34;&gt;3.4 Exchange&lt;/h3&gt;
&lt;p&gt;交换器。用来接收生产者发送的消息并将这些消息路由给服务器中的队列。&lt;/p&gt;
&lt;p&gt;三种常用的交换器类型&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;direct(发布与订阅 完全匹配)&lt;/li&gt;
&lt;li&gt;fanout(广播)&lt;/li&gt;
&lt;li&gt;topic(主题，规则匹配)&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;35-binding&#34;&gt;3.5 Binding&lt;/h3&gt;
&lt;p&gt;绑定。用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。&lt;/p&gt;
&lt;h3 id=&#34;36-queue&#34;&gt;3.6 Queue&lt;/h3&gt;
&lt;p&gt;消息队列。用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者链接到这个队列将其取走。&lt;/p&gt;
&lt;h3 id=&#34;37-routing-key&#34;&gt;3.7 Routing-key&lt;/h3&gt;
&lt;p&gt;路由键。RabbitMQ 决定消息该投递到哪个队列的规则。（也可以理解为队列的名称，路由键是 key，队列是 value）&lt;/p&gt;
&lt;p&gt;队列通过路由键绑定到交换器。&lt;/p&gt;
&lt;p&gt;消息发送到 MQ 服务器时，消息将拥有一个路由键，即便是空的，RabbitMQ 也会将其和绑定使用的路由键进行匹配。&lt;/p&gt;
&lt;p&gt;如果相匹配，消息将会投递到该队列。&lt;/p&gt;
&lt;p&gt;如果不匹配，消息将会进入黑洞。&lt;/p&gt;
&lt;h3 id=&#34;38-connection&#34;&gt;3.8 Connection&lt;/h3&gt;
&lt;p&gt;链接。指 rabbit 服务器和服务建立的 TCP 链接。&lt;/p&gt;
&lt;h3 id=&#34;39-channel&#34;&gt;3.9 Channel&lt;/h3&gt;
&lt;p&gt;信道。&lt;/p&gt;
&lt;p&gt;1，Channel 中文叫做信道，是 TCP 里面的虚拟链接。例如：电缆相当于 TCP，信道是一个独立光纤束，一条 TCP 连接上创建多条信道是没有问题的。&lt;/p&gt;
&lt;p&gt;2，TCP 一旦打开，就会创建 AMQP 信道。&lt;/p&gt;
&lt;p&gt;3，无论是发布消息、接收消息、订阅队列，这些动作都是通过信道完成的。&lt;/p&gt;
&lt;h3 id=&#34;310-virtual-host&#34;&gt;3.10 Virtual Host&lt;/h3&gt;
&lt;p&gt;虚拟主机。表示一批交换器，消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在链接时指定，RabbitMQ 默认的 vhost 是/&lt;/p&gt;
&lt;h3 id=&#34;311-borker&#34;&gt;3.11 Borker&lt;/h3&gt;
&lt;p&gt;表示消息队列服务器实体。&lt;/p&gt;
&lt;h3 id=&#34;312-交换器和队列的关系&#34;&gt;3.12 交换器和队列的关系&lt;/h3&gt;
&lt;p&gt;交换器是通过路由键和队列绑定在一起的，如果消息拥有的路由键跟队列和交换器的路由键匹配，那么消息就会被路由到该绑定的队列中。&lt;/p&gt;
&lt;p&gt;也就是说，消息到队列的过程中，消息首先会经过交换器，接下来交换器在通过路由键匹配分发消息到具体的队列中。&lt;/p&gt;
&lt;p&gt;路由键可以理解为匹配的规则。&lt;/p&gt;
&lt;h3 id=&#34;313-rabbitmq-为什么需要信道为什么不是-tcp-直接通信&#34;&gt;3.13 RabbitMQ 为什么需要信道？为什么不是 TCP 直接通信？&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;TCP 的创建和销毁开销特别大。创建需要 3 次握手，销毁需要 4 次分手。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果不用信道，那应用程序就会以 TCP 链接 Rabbit，高峰时每秒成千上万条链接会造成资源巨大的浪费，而且操作系统每秒处理 TCP 链接数也是有限制的，必定造成性能瓶颈。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信道的原理是一条线程一条通道，多条线程多条通道同用一条 TCP 链接。一条 TCP链接可以容纳无限的信道，即使每秒成千上万的请求也不会成为性能的瓶颈。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;4-erlang-安装&#34;&gt;4、Erlang 安装&lt;/h2&gt;
&lt;p&gt;RabbitMQ 是使用 Erlang 语言编写的，所以需要先配置 Erlang&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;修改主机名&lt;br&gt;
RabbitMQ 是通过主机名进行访问的，必须指定能访问的主机名。&lt;/p&gt;
&lt;p&gt;vim /etc/sysconfig/network&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200706172227.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;vim /etc/hosts&lt;/p&gt;
&lt;p&gt;新添加了一行，前面为服务器 ip，空格后面添加计算机主机名&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200706172349.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装依赖&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;yum -y install make gcc gcc-c++ kernel-devel m4 ncurses-devel openssl-devel unixODBC unixODBC-devel&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;上传并解压&lt;br&gt;
上传 otp_src_22.0.tar.gz 到/usr/local/tmp 目录中，进入目录并解压。&lt;br&gt;
&lt;strong&gt;解压时注意，此压缩包不具有 gzip 属性，解压参数没有 z，只有 xf&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;cd /usr/local/tmp&lt;/p&gt;
&lt;p&gt;tar xf otp_src_22.0.tar.gz&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置参数&lt;/p&gt;
&lt;p&gt;先新建/usr/local/erlang 文件夹，作为安装文件夹&lt;/p&gt;
&lt;p&gt;#mkdir -p /usr/local/erlang&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​	进入文件夹&lt;/p&gt;
&lt;p&gt;​	cd otp_src_22.0&lt;/p&gt;
&lt;p&gt;​	配置参数&lt;/p&gt;
&lt;p&gt;​	./configure --prefix=/usr/local/erlang --with-ssl --enable-threads --enable-smp-support --enable-kernel-poll --enable-hipe --without-javac&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200706172649.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;
&lt;p&gt;编译并安装&lt;/p&gt;
&lt;p&gt;编译&lt;/p&gt;
&lt;p&gt;make&lt;/p&gt;
&lt;p&gt;安装&lt;/p&gt;
&lt;p&gt;make install&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200706173422.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;
&lt;p&gt;修改环境变量&lt;/p&gt;
&lt;p&gt;修改/etc/profile 文件&lt;/p&gt;
&lt;p&gt;#vim /etc/profile&lt;/p&gt;
&lt;p&gt;在文件中添加下面代码&lt;/p&gt;
&lt;p&gt;export PATH=$PATH:/usr/local/erlang/bin&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200706173629.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200706173647.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;5-安装-rabbitmq&#34;&gt;5、安装 RabbitMQ&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;上传并解压&lt;br&gt;
上传 rabbitmq-server-generic-unix-3.7.17.tar.xz 到/usr/loca/tmp 中&lt;/p&gt;
&lt;p&gt;cd /usr/local/tmp&lt;/p&gt;
&lt;p&gt;tar xf rabbitmq-server-generic-unix-3.7.17.tar.xz&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;复制到 local 下&lt;br&gt;
复制解压文件到/usr/local 下，命名为 rabbitmq&lt;/p&gt;
&lt;p&gt;cp -r rabbitmq_server-3.7.17 /usr/local/rabbitmq&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置环境变量&lt;/p&gt;
&lt;p&gt;vim /etc/profile&lt;/p&gt;
&lt;p&gt;在文件中添加&lt;/p&gt;
&lt;p&gt;export PATH=$PATH:/usr/local/rabbitmq/sbin&lt;/p&gt;
&lt;p&gt;解析文件&lt;/p&gt;
&lt;p&gt;source /etc/profile&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开启 web 管理插件&lt;br&gt;
进入 rabbitmq/sbin 目录&lt;/p&gt;
&lt;p&gt;cd /usr/local/rabbitmq/sbin&lt;/p&gt;
&lt;p&gt;查看插件列表&lt;/p&gt;
&lt;p&gt;./rabbitmq-plugins list&lt;/p&gt;
&lt;p&gt;生效管理插件&lt;/p&gt;
&lt;p&gt;./rabbitmq-plugins enable rabbitmq_management&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;后台运行&lt;br&gt;
启动 rabbitmq。&lt;/p&gt;
&lt;p&gt;./rabbitmq-server（前台）&lt;/p&gt;
&lt;p&gt;./rabbitmq-server -detached（后台）&lt;/p&gt;
&lt;p&gt;停止命令，如果无法停止，使用 kill -9 进程号进行关闭&lt;/p&gt;
&lt;p&gt;./rabbitmqctl stop_app&lt;/p&gt;
&lt;p&gt;启动成功信息如下：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200707031245.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;
&lt;p&gt;查看 web 管理界面&lt;/p&gt;
&lt;p&gt;默认可以在安装 rabbitmq 的电脑上通过用户名：guest 密码 guest 进行访问 web 管理界面&lt;/p&gt;
&lt;p&gt;端口号：15672（放行端口，或关闭防火墙）&lt;/p&gt;
&lt;p&gt;在浏览器中输入：http://124.70.181.124:15672/&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200707031918.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;6-rabbitmq-账户管理&#34;&gt;6、RabbitMq 账户管理&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;创建账户&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;语法：./rabbitmqctl add_user username password&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd /usr/local/rabbitmq/sbin

./rabbitmqctl add_user admin admin123
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;给用户授予管理员角色&lt;br&gt;
其中 smallming 为新建用户的用户名&lt;/p&gt;
&lt;p&gt;./rabbitmqctl set_user_tags admin administrator&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;给用户授权&lt;br&gt;
“/” 表示 RabbitMQ 根虚拟主机&lt;/p&gt;
&lt;p&gt;admin 表示用户名&lt;/p&gt;
&lt;p&gt;&amp;quot;.&lt;em&gt;&amp;quot; &amp;quot;.&lt;/em&gt;&amp;quot; &amp;quot;.*&amp;quot; 表示完整权限&lt;/p&gt;
&lt;p&gt;./rabbitmqctl set_permissions -p &amp;quot;/&amp;quot; admin &amp;quot;.&lt;em&gt;&amp;quot; &amp;quot;.&lt;/em&gt;&amp;quot; &amp;quot;.*&amp;quot;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;登录&lt;br&gt;
使用新建账户和密码在 windows 中访问 rabbitmq 并登录&lt;/p&gt;
&lt;p&gt;在浏览器地址栏输入：&lt;/p&gt;
&lt;p&gt;http://ip:15672/&lt;/p&gt;
&lt;p&gt;用户名：admin&lt;/p&gt;
&lt;p&gt;密码：admin&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200707094930.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;7-exchange-交换器交换机&#34;&gt;7、Exchange 交换器（交换机）&lt;/h2&gt;
&lt;p&gt;交换器负责接收客户端传递过来的消息，并转发到对应的队列中。在 RabbitMQ 中支持四种交换器&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Direct Exchange：直连交换器（默认）&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Fanout Exchange：扇形交换器&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Topic Exchange：主题交换器&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Header Exchange：首部交换器。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 RabbitMq 的 Web 管理界面中 Exchanges 选项卡就可以看见这四个交换器。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200707110332.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200707162639.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;71-direct-交换器&#34;&gt;7.1 direct 交换器&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;18&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200707110359.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;direct 交换器是 RabbitMQ 默认交换器。默认会进行&lt;strong&gt;公平调度&lt;/strong&gt;。所有接受者依次从消息队列中获取值。Publisher 给哪个队列发消息，就一定是给哪个队列发送消息。对交换器&lt;/p&gt;
&lt;p&gt;绑定的其他队列没有任何影响。&lt;/p&gt;
&lt;p&gt;（代码演示）一个队列需要绑定多个消费者&lt;/p&gt;
&lt;p&gt;需要使用注解/API：&lt;/p&gt;
&lt;p&gt;org.springframework.amqp.core.Queue:队列&lt;/p&gt;
&lt;p&gt;AmqpTemplate：操作 RabbitMQ 的接口。负责发送或接收消息&lt;/p&gt;
&lt;p&gt;@RabbitListener(queues = &amp;quot;&amp;quot;) 注解某个方法为接收消息方法&lt;/p&gt;
&lt;h4 id=&#34;711-代码&#34;&gt;7.1.1 代码&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;父项目添加依赖&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot;
         xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
         xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;amqp_rabbit&amp;lt;/artifactId&amp;gt;
    &amp;lt;packaging&amp;gt;pom&amp;lt;/packaging&amp;gt;
    &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;modules&amp;gt;
        &amp;lt;module&amp;gt;amqp_rabbit_consumer&amp;lt;/module&amp;gt;
    &amp;lt;/modules&amp;gt;

    &amp;lt;dependencyManagement&amp;gt;
        &amp;lt;dependencies&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-dependencies&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;2.2.5.RELEASE&amp;lt;/version&amp;gt;
                &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt;
                &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
            &amp;lt;/dependency&amp;gt;
        &amp;lt;/dependencies&amp;gt;
    &amp;lt;/dependencyManagement&amp;gt;


    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!-- Spring Boot提供的关于AMQP协议实现的启动器。可以使用AMQP协议快速的访问MQ消息中间件。 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-amqp&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;编写日志消息消费者（只消费Info日志）&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import org.springframework.amqp.rabbit.annotation.*;
import org.springframework.stereotype.Component;

/**
 * 日志消息消费者，只消费Info日志。
 * 日志消息存储在队列 log-info-queue
 * 使用的交换器名称是 log-ex-direct
 * 交换器类型是 direct
 * 队列的路由键是 direct-rk-info
 * &amp;lt;p&amp;gt;
 * 注解RabbitListener - 监听注解。可以描述类型和方法。
 * 类型 - 当前类型监听某个队列。
 * 方法 - 当前方法监听某个队列。
 * 属性 -
 * bindings - QueueBinding[]类型，代表这个类型或方法监听的队列、交换器、路由键的绑定方式
 * 注解QueueBinding -
 * 属性 -
 * value - 绑定监听的队列是什么
 * exchange - 队列对应的交换器是什么
 * key - 队列的路由键是什么
 * 注解Queue - 描述一个队列
 * 属性 -
 * value|name - 队列名称
 * autoDelete - 是否自动删除。默认为&amp;quot;&amp;quot;, 如果队列名称定义，不自动删除；队列名称不定义，队列为自动删除队列。
 * 如果是自动删除，代表所有的consumer关闭后，队列自动删除。
 * 注解Exchange - 描述一个交换器
 * 属性 -
 * value|name - 交换器名称
 * type - 交换器的类型，可选direct|fanout|topic， 默认direct
 * autoDelete - 是否自动删除，默认为false。不自动删除。
 */
@RabbitListener(bindings = {
        @QueueBinding(
                value = @Queue(value = &amp;quot;log-info-queue&amp;quot;, autoDelete = &amp;quot;false&amp;quot;),
                exchange = @Exchange(value = &amp;quot;log-ex-direct&amp;quot;, type = &amp;quot;direct&amp;quot;, autoDelete = &amp;quot;false&amp;quot;),
                key = &amp;quot;direct-rk-info&amp;quot;
        )
})
@Component
public class InfoLogConsumer {
    /**
     * 消息消费的方法。当队列log-info-queue中出现消息，立刻消费。
     * &amp;lt;p&amp;gt;
     * RabbitHandler注解 - 配合类型上的RabbitListener注解，标记当前的方法，是一个监听消息队列，消费消息的方法。
     *如果RabbitListener注解在方法上，此注解就不需要了
     * @param msg 消息内容。
     */
    @RabbitHandler
    public void onMessage(String msg) {
        System.out.println(&amp;quot;InfoLogConsumer 消费消息：&amp;quot; + msg);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;创建springboot启动类&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SpringBootApplication
public class RabbitConsumerApplication {
    public static void main(String[] args) {
        SpringApplication.run(RabbitConsumerApplication.class, args);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;编写配置文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;spring:
  rabbitmq:
    host: 124.70.181.124  # RabbitMQ服务的地址，默认localhost
    port: 5672  # RabbitMQ的端口，默认5672。
    username: admin # 访问RabbitMQ的用户名，默认guest
    password: admin # 访问RabbitMQ的密码，默认guest
    virtual-host: /  # 访问RabbitMQ的哪一个虚拟主机，默认为 /
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;19&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200707111159.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;20&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200707111241.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;编写日志消息消费者（只消费error和warn日志）&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import org.springframework.amqp.rabbit.annotation.Exchange;
import org.springframework.amqp.rabbit.annotation.Queue;
import org.springframework.amqp.rabbit.annotation.QueueBinding;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Component;

/**
 * 日志消息消费者，消费error和warn日志。
 * error日志消息存储在队列 log-error-queue
 * warn日志消息存储在队列 log-warn-queue
 * 使用的交换器名称是 log-ex-direct
 * 交换器类型是 direct
 * error队列的路由键是 direct-rk-error
 * warn队列的路由键是 direct-rk-warn
 */
@Component
public class LogConsumer {
    @RabbitListener(bindings = {
            @QueueBinding(value = @Queue(value = &amp;quot;log-error-queue&amp;quot;, autoDelete = &amp;quot;false&amp;quot;),
                    exchange = @Exchange(value = &amp;quot;log-ex-direct&amp;quot;, type = &amp;quot;direct&amp;quot;, autoDelete = &amp;quot;false&amp;quot;),
                    key = &amp;quot;direct-rk-error&amp;quot;
            )
    })
    public void onLogErrorMessage(String msg) {
        System.out.println(&amp;quot;错误日志信息：&amp;quot; + msg);
    }

    @RabbitListener(bindings = {
            @QueueBinding(value = @Queue(value = &amp;quot;log-warn-queue&amp;quot;, autoDelete = &amp;quot;false&amp;quot;),
                    exchange = @Exchange(value = &amp;quot;log-ex-direct&amp;quot;, type = &amp;quot;direct&amp;quot;, autoDelete = &amp;quot;false&amp;quot;),
                    key = &amp;quot;direct-rk-warn&amp;quot;
            )
    })
    public void onLogWarnMessage(String msg) {
        System.out.println(&amp;quot;警告日志信息:&amp;quot; + msg);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;21&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200707114704.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;22&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200707114913.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;编写publisher配置信息&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;spring:
  rabbitmq:
    host: 124.70.181.124  # RabbitMQ服务的地址，默认localhost
    port: 5672  # RabbitMQ的端口，默认5672。
    username: admin # 访问RabbitMQ的用户名，默认guest
    password: admin # 访问RabbitMQ的密码，默认guest
    virtual-host: /  # 访问RabbitMQ的哪一个虚拟主机，默认为 /
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;编写测试类&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 消息发送者测试类型
 */
@SpringBootTest(classes = RabbitPublisherApplication.class)
@RunWith(SpringRunner.class)
public class TestPublisher {

    @Autowired
    private LogMessageSender sender;

    private String exchange = &amp;quot;log-ex-direct&amp;quot;;
    private String rkInfo = &amp;quot;direct-rk-info&amp;quot;;
    private String rkError = &amp;quot;direct-rk-error&amp;quot;;
    private String rkWarn = &amp;quot;direct-rk-warn&amp;quot;;

    @Test
    public void testSend(){
        Random r = new Random();
        // 发送10条消息。
        for(int i = 0 ; i &amp;lt; 10; i++){
            // rInt%3 - 0：投递消息到info；1：投递消息到error；2：投递消息到warn
            int rInt = r.nextInt(100);
            if(rInt%3 == 0){
                this.sender.sendMessage(exchange, rkInfo, &amp;quot;发送Info日志消息 - index=&amp;quot;+i+&amp;quot;；rInt=&amp;quot;+rInt);
            }else if(rInt%3 == 1){
                this.sender.sendMessage(exchange, rkError, &amp;quot;发送error日志消息 - index=&amp;quot;+i+&amp;quot;；rInt=&amp;quot;+rInt);
            }else{
                this.sender.sendMessage(exchange, rkWarn, &amp;quot;发送warn日志消息 - index=&amp;quot;+i+&amp;quot;；rInt=&amp;quot;+rInt);
            }
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;先启动consumer再启动publisher测试类：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;23&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200707133200.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;8&#34;&gt;
&lt;li&gt;消费者集群搭建&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;先复制一个消费者启动类，然后启动，集群就搭建完成了&lt;/p&gt;
&lt;p&gt;编写测试类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    @Test
    public void testSend2Consumers(){
        for(int i = 0; i &amp;lt; 10; i++){
            this.sender.sendMessage(exchange, rkInfo, &amp;quot;info消息&amp;quot;+i);
            this.sender.sendMessage(exchange, rkError, &amp;quot;error消息&amp;quot;+i);
            this.sender.sendMessage(exchange, rkWarn, &amp;quot;warn消息&amp;quot;+i);
        }
    }

&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;24&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200707135016.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;25&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200707135031.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;26&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200707135214.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;72-fanout-交换器&#34;&gt;7.2 fanout 交换器&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;27&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200707141028.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;扇形交换器，实际上做的事情就是广播，fanout 会把消息发送给所有的绑定在当前交换器上的队列。&lt;strong&gt;对应 Consumer 依然采用公平调度方式。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注：不再需要routing-key&lt;/p&gt;
&lt;p&gt;（代码演示）一个交换器需要绑定多个队列&lt;/p&gt;
&lt;p&gt;需要使用注解/API：&lt;/p&gt;
&lt;p&gt;FanoutExchange：fanout 交换器&lt;/p&gt;
&lt;p&gt;Binding：绑定交换器和队列&lt;/p&gt;
&lt;p&gt;BindingBuilder：Binding 的构建器&lt;/p&gt;
&lt;p&gt;amq.fanout:内置 fanout 交换器名称&lt;/p&gt;
&lt;h4 id=&#34;721-代码&#34;&gt;7.2.1 代码&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;编写实体类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 实体类型
public class User implements Serializable {
    // 定义一个序列化唯一ID。
    public static final long serialVersionUID = 1L;
    private Long id;
    private String name;
    private int age;

    public User(){}

    @Override
    public String toString() {
        return &amp;quot;User{&amp;quot; +
                &amp;quot;id=&amp;quot; + id +
                &amp;quot;, name=&#39;&amp;quot; + name + &#39;\&#39;&#39; +
                &amp;quot;, age=&amp;quot; + age +
                &#39;}&#39;;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        User user = (User) o;
        return age == user.age &amp;amp;&amp;amp;
                Objects.equals(id, user.id) &amp;amp;&amp;amp;
                Objects.equals(name, user.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id, name, age);
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;编写consumer&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第二个参数 routingKey 对于 fanout 没有意义的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 广播交换器，消费者。
 */
@Component
public class FanoutConsumers {
    /**
     * 消费消息的方法。
     * 不再需要Routing-key
     * @param user 消息体内容。
     */
    @RabbitListener(bindings = {
            @QueueBinding(
                    value = @Queue(value = &amp;quot;queue-user-1&amp;quot;, autoDelete = &amp;quot;false&amp;quot;),
                    exchange = @Exchange(value = &amp;quot;ex-fanout&amp;quot;, type = &amp;quot;fanout&amp;quot;, autoDelete = &amp;quot;false&amp;quot;)
            )
    })
    public void onMessage1(User user){
        System.out.println(&amp;quot;onMessage1 run : &amp;quot; + user);
    }

    @RabbitListener(bindings = {
            @QueueBinding(
                    value = @Queue(value = &amp;quot;queue-user-2&amp;quot;, autoDelete = &amp;quot;false&amp;quot;),
                    exchange = @Exchange(value = &amp;quot;ex-fanout&amp;quot;, type = &amp;quot;fanout&amp;quot;)
            )
    })
    public void onMessage2(User user){
        System.out.println(&amp;quot;onMessage2 run : &amp;quot; + user);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;编写publisher&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 发送消息类型。消息发送到fanout交换器中。
 * 交换器名称是： ex-fanout
 */
@Component
public class UserMessageSender {
    @Autowired
    private AmqpTemplate template;

    /**
     * 发送消息方法。
     * @param user
     */
    public void send(User user){
        this.template.convertAndSend(&amp;quot;ex-fanout&amp;quot;, &amp;quot;&amp;quot;, user);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;编写测试类&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Autowired
    private UserMessageSender userMessageSender;

   @Test
    public void testSendUserMessage2Fanout(){
        for(int i = 0; i &amp;lt; 3; i++){
            User user = new User();
            user.setId((long) i);
            user.setName(&amp;quot;姓名 - &amp;quot; + i);
            user.setAge(20+i);

            this.userMessageSender.send(user);
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;73-topic-交换器&#34;&gt;7.3 topic 交换器&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;28&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200707150313.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;允许在路由键（RoutingKey）中出现匹配规则。&lt;/p&gt;
&lt;p&gt;路由键的写法和包写法相同。com.cy.xxxx.xxx 格式。&lt;/p&gt;
&lt;p&gt;在绑定时可以带有下面特殊符号，中间可以出现:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;*: 代表一个单词（两个.之间内容）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;#: 0 个或多个字符&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接收方依然是公平调度，同一个队列中内容轮换获取值。&lt;/p&gt;
&lt;p&gt;需要使用注解/API：&lt;/p&gt;
&lt;p&gt;TopicExchange：Topic 交换器&lt;/p&gt;
&lt;p&gt;amq.topic:内置 topic 交换器名称&lt;/p&gt;
&lt;h4 id=&#34;731-代码&#34;&gt;7.3.1 代码&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;编写consumer&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 主题消息消费者。
 */
@Component
public class TopicConsumers {
    /**
     * 短信消息消费者，对应的routingKey是 user.rk.sms | order.rk.sms | pay.rk.sms | reg.rk.sms 等。
     * 分别代表，用户登录短信|订单下订成功通知短信|支付成功通知短信|注册码通知短信 等。
     */
    @RabbitListener(bindings = {
            @QueueBinding(
                    value = @Queue(value = &amp;quot;queue-sms-topic&amp;quot;, autoDelete = &amp;quot;false&amp;quot;),
                    exchange = @Exchange(value = &amp;quot;ex-topic&amp;quot;, type = &amp;quot;topic&amp;quot;),
                    key = &amp;quot;*.rk.sms&amp;quot;
            )
    })
    public void onUserSMSMessage(String message){
        System.out.println(&amp;quot;用户短信消息内容是：&amp;quot; + message);
    }

    /**
     * 路由键包括： user.rk.email | reg.rk.email | pay.rk.email
     * @param message
     */
    @RabbitListener(bindings = {
            @QueueBinding(
                    value = @Queue(value = &amp;quot;queue-email-topic&amp;quot;, autoDelete = &amp;quot;false&amp;quot;),
                    exchange = @Exchange(value = &amp;quot;ex-topic&amp;quot;, type = &amp;quot;topic&amp;quot;),
                    key = &amp;quot;*.rk.email&amp;quot;
            )
    })
    public void onUserEmailMessage(String message){
        System.out.println(&amp;quot;用户邮件消息内容是：&amp;quot; + message);
    }

    /**
     * 所有的和 rk相关的消息，统一处理消费。
     * 包含的路由键有： user.rk.sms | user.rk.email | reg.rk.sms | reg.rk.email 等。
     * 不发短信，不发邮件，作为一个日志记录工具存在。
     * @param message
     */
    @RabbitListener(bindings = {
            @QueueBinding(
                    value = @Queue(value = &amp;quot;queue-all-topic&amp;quot;, autoDelete = &amp;quot;false&amp;quot;),
                    exchange = @Exchange(value = &amp;quot;ex-topic&amp;quot;, type = &amp;quot;topic&amp;quot;),
                    key = &amp;quot;*.rk.*&amp;quot;
            )
    })
    public void onUserServiceMessage(String message){
        System.out.println(&amp;quot;执行的消息处理逻辑是：&amp;quot; + message);
    }
}


&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;编写publisher&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 发送消息到主题交换器
 */
@Component
public class TopicMessageSender {
    @Autowired
    private AmqpTemplate template;

    /**
     * 发送消息的方法
     * @param exchange
     * @param routingKey
     * @param message
     */
    public void send(String exchange, String routingKey, String message){
        template.convertAndSend(exchange, routingKey, message);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;编写测试类&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Autowired
private TopicMessageSender topicMessageSender;


@Test
    public void testSendMessage2Topic(){
        // 随机数%6
        // 0 rk - user.rk.sms *.rk.*  *.rk.sms
        // 1 rk - user.rk.email   *.rk.* *.rk.email
        // 2 rk - order.rk.sms *.rk.*  *.rk.sms
        // 3 rk - order.rk.email  *.rk.* *.rk.email
        // 4 rk - reg.rk.sms *.rk.*  *.rk.sms
        // 5 rk - reg.rk.qq  *.rk.*
        Random r = new Random();
        for(int i = 0; i &amp;lt; 10; i++){
            int rInt = r.nextInt(100);
            if(rInt%6 == 0){
                this.topicMessageSender.send(&amp;quot;ex-topic&amp;quot;,
                        &amp;quot;user.rk.sms&amp;quot;,
                        &amp;quot;用户登录验证码是123456 - 发送短信&amp;quot;);
            }else if(rInt%6 == 1){
                this.topicMessageSender.send(&amp;quot;ex-topic&amp;quot;,
                        &amp;quot;user.rk.email&amp;quot;,
                        &amp;quot;用户登录验证码是123456 - 发送到邮箱&amp;quot;);
            }else if(rInt%6 == 2){
                this.topicMessageSender.send(&amp;quot;ex-topic&amp;quot;,
                        &amp;quot;order.rk.sms&amp;quot;,
                        &amp;quot;订单下订成功 - 发送短信&amp;quot;);
            }else if(rInt%6 == 3){
                this.topicMessageSender.send(&amp;quot;ex-topic&amp;quot;,
                        &amp;quot;order.rk.email&amp;quot;,
                        &amp;quot;订单下订成功 - 发送到邮箱&amp;quot;);
            }else if(rInt%6 == 4){
                this.topicMessageSender.send(&amp;quot;ex-topic&amp;quot;,
                        &amp;quot;reg.rk.sms&amp;quot;,
                        &amp;quot;注册验证码是654321 - 发送短信&amp;quot;);
            }else if(rInt%6 == 5){
                this.topicMessageSender.send(&amp;quot;ex-topic&amp;quot;,
                        &amp;quot;reg.rk.qq&amp;quot;,
                        &amp;quot;注册验证码是654321 - 发送QQ信息&amp;quot;);
            }
        }
    }

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;29&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200707162555.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;30&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200707162450.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">RabbitMQ</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jonchan1013.github.io/post/activemq/"" data-c="
          &lt;h2 id=&#34;1-activemq-简介&#34;&gt;1、 ActiveMQ 简介&lt;/h2&gt;
&lt;h3 id=&#34;11-什么是-activemq&#34;&gt;1.1 什么是 ActiveMQ&lt;/h3&gt;
&lt;p&gt;​		ActiveMQ 是 Apache 出品，最流行的，能力强劲的开源消息总线。ActiveMQ 是一个完全支持 JMS1.1 和 J2EE 1.4 规范的 JMS Provider 实现，尽管 JMS 规范出台已经是很久的事情了，但是 JMS 在当今的 J2EE 应用中间仍然扮演着特殊的地位。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;12-什么是消息&#34;&gt;1.2 什么是消息&lt;/h3&gt;
&lt;p&gt;​	“消息”是在两台计算机间传送的数据单位。消息可以非常简单，例如只包含文本字符串；也可以更复杂，可能包含嵌入对象。&lt;/p&gt;
&lt;h3 id=&#34;13-什么是队列&#34;&gt;1.3 什么是队列&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200702112943.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;14-什么是消息队列&#34;&gt;1.4 什么是消息队列&lt;/h3&gt;
&lt;p&gt;“消息队列”是在消息的传输过程中保存消息的容器。&lt;/p&gt;
&lt;h3 id=&#34;15-常用消息服务应用&#34;&gt;1.5 常用消息服务应用&lt;/h3&gt;
&lt;h4 id=&#34;151-activemq&#34;&gt;1.5.1 ActiveMQ&lt;/h4&gt;
&lt;p&gt;ActiveMQ 是 Apache 出品，最流行的，能力强劲的开源消息总线。ActiveMQ 是一个完全支持 JMS1.1 和 J2EE 1.4 规范的 JMS Provider 实现。&lt;/p&gt;
&lt;h4 id=&#34;152-rabbitmq&#34;&gt;1.5.2 RabbitMQ&lt;/h4&gt;
&lt;p&gt;RabbitMQ 是一个在 AMQP 基础上完成的，可复用的企业消息系统。他遵循 Mozilla Public License 开源协议。开发语言为 Erlang。&lt;/p&gt;
&lt;h4 id=&#34;153-rocketmq&#34;&gt;1.5.3 RocketMQ&lt;/h4&gt;
&lt;p&gt;由阿里巴巴定义开发的一套消息队列应用服务。&lt;/p&gt;
&lt;h2 id=&#34;2-消息服务的应用场景&#34;&gt;2、 消息服务的应用场景&lt;/h2&gt;
&lt;p&gt;消息队列的主要特点是&lt;strong&gt;异步处理&lt;/strong&gt;，主要目的是&lt;strong&gt;减少请求响应时间和解耦&lt;/strong&gt;。所以主要的使用场景就是将比较耗时而且**不需要即时（同步）**返回结果的操作作为消息放入消息队列。同时由于使用了消息队列，只要保证消息格式不变，消息的发送方和接收方并不需要彼此联系，也不需要受对方的影响，即解耦和。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200702113244.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;21-异步处理&#34;&gt;2.1 异步处理&lt;/h3&gt;
&lt;p&gt;例如： &lt;strong&gt;用户注册:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用户注册流程：&lt;br&gt;
1）注册处理以及写数据库&lt;br&gt;
2）发送注册成功的手机短信&lt;br&gt;
3）发送注册成功的邮件信息&lt;/p&gt;
&lt;p&gt;如果用消息中间件：则可以创建两个线程来做这些事情，直接发送消息给消息中间件，然后让邮件服务和短信服务自己去消息中间件里面去取消息，然后取到消息后再自己做对应的业务操作。就是这么方便&lt;/p&gt;
&lt;h3 id=&#34;22-应用的解耦&#34;&gt;2.2 应用的解耦&lt;/h3&gt;
&lt;p&gt;例如：&lt;strong&gt;订单处理：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;生成订单流程：&lt;br&gt;
1）在购物车中点击结算&lt;br&gt;
2）完成支付&lt;br&gt;
3）创建订单&lt;br&gt;
4）调用库存系统&lt;br&gt;
订单完成后，订单系统并不去直接调用库存系统，而是发送消息到消息中间件，写入一个订单信息。库存系统自己去消息中间件上去获取，然后做发货处理，并更新库存，这样能够实现互联网型应用追求的快这一个属性。而库存系统读取订单后库存应用这个操作也是非常快的，所以有消息中间件对解耦来说也是一个不错的方向。&lt;/p&gt;
&lt;h3 id=&#34;23-流量的削峰&#34;&gt;2.3 流量的削峰&lt;/h3&gt;
&lt;p&gt;例如：&lt;strong&gt;秒杀功能：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;秒杀流程：&lt;br&gt;
1）用户点击秒杀&lt;br&gt;
2）发送请求到秒杀应用&lt;br&gt;
3）在请求秒杀应用之前将请求放入到消息队列&lt;br&gt;
4）秒杀应用从消息队列中获取请求并处理。&lt;br&gt;
比如，系统举行秒杀活动，热门商品。流量蜂拥而至 100 件商品，10 万人挤进来怎么办？10 万秒杀的操作，放入消息队列。秒杀应用处理消息队列中的 10 万个请求中的前 100个，其他的打回，通知失败。流量峰值控制在消息队列处，秒杀应用不会瞬间被怼死.&lt;/p&gt;
&lt;h2 id=&#34;3-jms&#34;&gt;3、JMS&lt;/h2&gt;
&lt;h3 id=&#34;31-什么是-jms&#34;&gt;3.1 什么是 JMS&lt;/h3&gt;
&lt;p&gt;JMS（Java Messaging Service）是 Java 平台上有关面向消息中间件的技术规范，它便于消息系统中的 Java 应用程序进行消息交换,并且通过提供标准的产生、发送、接收消息的接口，简化企业应用的开发。&lt;/p&gt;
&lt;h3 id=&#34;32-jms-模型&#34;&gt;3.2 JMS 模型&lt;/h3&gt;
&lt;h4 id=&#34;321-点对点模型point-to-point&#34;&gt;3.2.1 点对点模型(Point To Point)&lt;/h4&gt;
&lt;p&gt;生产者发送一条消息到 queue，只有一个消费者能收到。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200702113738.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;322-发布订阅模型publishsubscribe&#34;&gt;3.2.2 发布订阅模型(Publish/Subscribe)&lt;/h4&gt;
&lt;p&gt;发布者发送到 topic 的消息，只有订阅了 topic 的订阅者才会收到消息。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200702113806.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;4-activemq-安装&#34;&gt;4、ActiveMQ 安装&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;下载activemq，下载地址：http://archive.apache.org/dist/activemq。测试版本为apache-activemq-5.15.8。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在/ursr/local/目录下新建activemq文件夹，并进入该文件夹，执行如下命令解压文件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;cd /usr/local
mkdir activemq
tar -xzvf apache-activemq-5.15.8-bin.tar.gz
mv apache-activemq-5.15.8 /usr/local/activemq/
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;检查权限&lt;/p&gt;
&lt;p&gt;ls -al apache-activemq-5.15.8/bin&lt;br&gt;
如果权限不足,则无法执行,需要修改文件权限:&lt;br&gt;
chmod 755 activemq&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200702114351.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;
&lt;p&gt;启动 ActiveMQ&lt;/p&gt;
&lt;p&gt;./activemq start&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200702114519.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;
&lt;p&gt;测试 ActiveMQ&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;检查进程&lt;/p&gt;
&lt;p&gt;ps aux | grep activemq&lt;br&gt;
见到下述内容即代表启动成功&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200702114848.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;管理界面&lt;/p&gt;
&lt;p&gt;使用浏览器访问 ActiveMQ 管理应用, 地址如下:&lt;br&gt;
http://ip:8161/admin/&lt;br&gt;
用户名: admin&lt;br&gt;
密码: admin&lt;br&gt;
ActiveMQ 使用的是 jetty 提供 HTTP 服务.启动稍慢,建议短暂等待再访问测试.&lt;br&gt;
见到如下界面代表服务启动成功&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200702115054.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;修改访问端口&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;修改 ActiveMQ 配置文件: /usr/local/activemq/conf/jetty.xml&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200702115133.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;配置文件修改完毕，保存并重新启动 ActiveMQ 服务。&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;修改用户名和密码&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;修改 conf/users.properties 配置文件.内容为: 用户名=密码&lt;br&gt;
保存并重启 ActiveMQ 服务即可.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重启 ActiveMQ&lt;br&gt;
/usr/local/activemq/apache-activemq-5.15.8/bin/activemq restart&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关闭 ActiveMQ&lt;br&gt;
/usr/local/activemq/bin/activemq stop&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置文件 activemq.xml&lt;br&gt;
配置文件中,配置的是 ActiveMQ 的核心配置信息. 是提供服务时使用的配置. 可以修改启动的访问端口. 即 java 编程中访问 ActiveMQ 的访问端口.&lt;br&gt;
默认端口为 61616.&lt;br&gt;
使用协议是: tcp 协议.&lt;br&gt;
修改端口后, 保存并重启 ActiveMQ 服务即可.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ActiveMQ 目录介绍&lt;br&gt;
从它的目录来说,还是很简单的:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;bin 存放的是脚本文件&lt;/li&gt;
&lt;li&gt;conf 存放的是基本配置文件&lt;/li&gt;
&lt;li&gt;data 存放的是日志文件&lt;/li&gt;
&lt;li&gt;docs 存放的是说明文档&lt;/li&gt;
&lt;li&gt;examples 存放的是简单的实例&lt;/li&gt;
&lt;li&gt;lib 存放的是 activemq 所需 jar 包&lt;/li&gt;
&lt;li&gt;webapps 用于存放项目的目录&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;5-activemq-术语&#34;&gt;5、ActiveMQ 术语&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Destination&lt;br&gt;
目的地，JMS Provider（消息中间件）负责维护，用于对 Message 进行管理的对象。MessageProducer 需要指定 Destination 才能发送消息，MessageReceiver 需要指定 Destination才能接收消息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Producer&lt;br&gt;
消息生成者，负责发送 Message 到目的地。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Consumer | Receiver&lt;br&gt;
消息消费者，负责从目的地中消费【处理|监听|订阅】Message。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Message&lt;br&gt;
消息，消息封装一次通信的内容。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;6-activemq-应用&#34;&gt;6、 ActiveMQ 应用&lt;/h2&gt;
&lt;h3 id=&#34;61-activemq-常用-api-简介&#34;&gt;6.1 ActiveMQ 常用 API 简介&lt;/h3&gt;
&lt;p&gt;下述 API 都是接口类型,由定义在 javax.jms 包中.&lt;br&gt;
是 JMS 标准接口定义.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;ConnectionFactory&lt;br&gt;
链接工厂, 用于创建链接的工厂类型.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Connection&lt;br&gt;
链接. 用于建立访问 ActiveMQ 连接的类型, 由链接工厂创建.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Session&lt;br&gt;
会话, 一次持久有效有状态的访问. 由链接创建.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Destination &amp;amp; Queue&lt;br&gt;
目的地, 用于描述本次访问 ActiveMQ 的消息访问目的地. 即 ActiveMQ 服务中的具体队列. 由会话创建.&lt;br&gt;
interface Queue extends Destination&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MessageProducer&lt;br&gt;
消息生成者, 在一次有效会话中, 用于发送消息给 ActiveMQ 服务的工具. 由会话创建.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MessageConsumer&lt;br&gt;
消息消费者【消息订阅者，消息处理者】, 在一次有效会话中, 用于从 ActiveMQ 服务中获取消息的工具. 由会话创建.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Message&lt;br&gt;
消息, 通过消息生成者向 ActiveMQ 服务发送消息时使用的数据载体对象或消息消费者从 ActiveMQ 服务中获取消息时使用的数据载体对象. 是所有消息【文本消息，对象消息等】具体类型的顶级接口. 可以通过会话创建或通过会话从 ActiveMQ 服务中获取.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;62-jms-helloworld&#34;&gt;6.2 JMS-HelloWorld&lt;/h3&gt;
&lt;h4 id=&#34;621-处理文本消息&#34;&gt;6.2.1 处理文本消息&lt;/h4&gt;
&lt;h5 id=&#34;6211-创建消息生产者&#34;&gt;6.2.1.1 创建消息生产者&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;修改 POM 文件添加 ActiveMQ 坐标&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.apache.activemq&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;activemq-all&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;5.15.8&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;编写消息的生产者&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class HelloWorldProducer {
    /**
     * 生产消息
     */
    public void sendHelloWorldActiveMQ(String msg) {

        //定义链接工厂
        ConnectionFactory connectionFactory = null;

        //定义链接对象
        Connection connection = null;

        //定义会话
        Session session = null;

        //定义目的地
        Destination destination = null;

        //定义消息的发送者
        MessageProducer messageProducer = null;

        //定义消息
        Message message = null;

        try {
            /**
             * userName:访问 ActiveMQ 服务的用户名。用户密码。默认的为 admin。用户名可以通过jetty-ream.properties 文件进行修改
             * password:访问 ActiveMQ 服务的用户名。用户密码。默认的为 admin。用户名可以通过jetty-ream.properties 文件进行修改
             * brokerURL:访问 ActiveMQ 服务的路径地址。 路径结构为:协议名://主机地址:端口号
             */
            connectionFactory = new ActiveMQConnectionFactory(&amp;quot;admin&amp;quot;, &amp;quot;admin&amp;quot;, &amp;quot;tcp://124.70.181.124:61616&amp;quot;);

            //创建连接对象
            connection = connectionFactory.createConnection();
            //启动连接
            connection.start();

            /**
             * transacted:是否使用事务 可选值为：   true|false
             * true:使用事务 当设置次变量值。  Session.SESSION_TRANSACTED
             * false:不适用事务,设置次变量 则 acknowledgeMode 参数必须设置
             * acknowledgeMode:
             * Session.AUTO_ACKNOWLEDGE:自动消息确认机制
             * Session.CLIENT_ACKNOWLEDGE:客户端确认机制
             * Session.DUPS_OK_ACKNOWLEDGE:有副本的客户端确认消息机制
             */
            session = connection.createSession(false, session.AUTO_ACKNOWLEDGE);
            //创建目的地，目的地名称即队列的名称。消息的消费者需要通过此名称访问对应的队列
            destination = session.createQueue(&amp;quot;HelloWorld-destination&amp;quot;);
            //创建消息的生产者
            messageProducer = session.createProducer(destination);
            //创建消息对象
            message = session.createTextMessage(msg);
            //发送消息
            messageProducer.send(message);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (messageProducer != null) {
                try {
                    messageProducer.close();
                } catch (JMSException e) {
                    e.printStackTrace();
                }
            }
            if (session != null) {
                try {
                    session.close();
                } catch (JMSException e) {
                    e.printStackTrace();
                }
            }
            if (connection != null) {
                try {
                    connection.close();
                } catch (JMSException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;6212-创建消息消费者&#34;&gt;6.2.1.2 创建消息消费者&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;修改 POM 文件添加 ActiveMQ 坐标&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.apache.activemq&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;activemq-all&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;5.15.8&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;编写消息的消费者&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class HelloWorldConsumer {
    /**
     * 消费消息
     */
    public void receiveHelloWorldActiveMQ() {

        //定义链接工厂
        ConnectionFactory connectionFactory = null;

        //定义链接对象
        Connection connection = null;

        //定义会话
        Session session = null;

        //定义目的地
        Destination destination = null;

        //定义消息的接收者
        MessageConsumer messageConsumer = null;

        //定义消息
        Message message = null;

        try {
            /**
             * userName:访问 ActiveMQ 服务的用户名。用户密码。默认的为 admin。用户名可以通过jetty-ream.properties 文件进行修改
             * password:访问 ActiveMQ 服务的用户名。用户密码。默认的为 admin。用户名可以通过jetty-ream.properties 文件进行修改
             * brokerURL:访问 ActiveMQ 服务的路径地址。 路径结构为:协议名://主机地址:端口号
             */
            connectionFactory = new ActiveMQConnectionFactory(&amp;quot;admin&amp;quot;, &amp;quot;admin&amp;quot;, &amp;quot;tcp://124.70.181.124:61616&amp;quot;);

            //创建连接对象
            connection = connectionFactory.createConnection();
            //启动连接
            connection.start();

            /**
             * transacted:是否使用事务 可选值为：   true|false
             * true:使用事务 当设置次变量值。  Session.SESSION_TRANSACTED
             * false:不适用事务,设置次变量 则 acknowledgeMode 参数必须设置
             * acknowledgeMode:
             * Session.AUTO_ACKNOWLEDGE:自动消息确认机制
             * Session.CLIENT_ACKNOWLEDGE:客户端确认机制
             * Session.DUPS_OK_ACKNOWLEDGE:有副本的客户端确认消息机制
             */
            session = connection.createSession(false, session.AUTO_ACKNOWLEDGE);
            //创建目的地，目的地名称即队列的名称。消息的消费者需要通过此名称访问对应的队列
            destination = session.createQueue(&amp;quot;HelloWorld-destination&amp;quot;);
            //创建消息的消费者
            messageConsumer = session.createConsumer(destination);
            //创建消息对象
            message = messageConsumer.receive();
            //处理消息
            String msg=((TextMessage)message).getText();
            System.out.println(&amp;quot;从ActiveMQ中取得的文本信息：&amp;quot;+msg);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (messageConsumer != null) {
                try {
                    messageConsumer.close();
                } catch (JMSException e) {
                    e.printStackTrace();
                }
            }
            if (session != null) {
                try {
                    session.close();
                } catch (JMSException e) {
                    e.printStackTrace();
                }
            }
            if (connection != null) {
                try {
                    connection.close();
                } catch (JMSException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;6213-测试&#34;&gt;6.2.1.3 测试&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;producer&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        HelloWorldProducer helloWorldProducer = new HelloWorldProducer();
        helloWorldProducer.sendHelloWorldActiveMQ(&amp;quot;HelloActiveMQ!&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200702151912.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Consumer&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        HelloWorldConsumer helloWorldConsumer = new HelloWorldConsumer();
        helloWorldConsumer.receiveHelloWorldActiveMQ();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200702152153.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200702152322.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;由于我们消息确认机制使用的是自动的，所以ActiveMQ会自动从队列中将消息移除。&lt;/p&gt;
&lt;h4 id=&#34;622-处理对象消息&#34;&gt;6.2.2 处理对象消息&lt;/h4&gt;
&lt;h5 id=&#34;6221-定义消息对象&#34;&gt;6.2.2.1 定义消息对象&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Users implements Serializable {
    private int userid;
    private String username;
    private int userage;

    public int getUserid() {
        return userid;
    }

    public void setUserid(int userid) {
        this.userid = userid;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public int getUserage() {
        return userage;
    }

    public void setUserage(int userage) {
        this.userage = userage;
    }

    @Override
    public String toString() {
        return &amp;quot;Users{&amp;quot; +
                &amp;quot;userid=&amp;quot; + userid +
                &amp;quot;, username=&#39;&amp;quot; + username + &#39;\&#39;&#39; +
                &amp;quot;, userage=&amp;quot; + userage +
                &#39;}&#39;;
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;6222-创建生产者&#34;&gt;6.2.2.2 创建生产者&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UsersProducer {
    /**
     * 生产消息
     */
    public void sendHelloWorldActiveMQ(Users users) {

        //定义链接工厂
        ConnectionFactory connectionFactory = null;

        //定义链接对象
        Connection connection = null;

        //定义会话
        Session session = null;

        //定义目的地
        Destination destination = null;

        //定义消息的发送者
        MessageProducer messageProducer = null;

        //定义消息
        Message message = null;

        try {
            /**
             * userName:访问 ActiveMQ 服务的用户名。用户密码。默认的为 admin。用户名可以通过jetty-ream.properties 文件进行修改
             * password:访问 ActiveMQ 服务的用户名。用户密码。默认的为 admin。用户名可以通过jetty-ream.properties 文件进行修改
             * brokerURL:访问 ActiveMQ 服务的路径地址。 路径结构为:协议名://主机地址:端口号
             */
            connectionFactory = new ActiveMQConnectionFactory(&amp;quot;admin&amp;quot;, &amp;quot;admin&amp;quot;, &amp;quot;tcp://124.70.181.124:61616&amp;quot;);

            //创建连接对象
            connection = connectionFactory.createConnection();
            //启动连接
            connection.start();

            /**
             * transacted:是否使用事务 可选值为：   true|false
             * true:使用事务 当设置次变量值。  Session.SESSION_TRANSACTED
             * false:不适用事务,设置次变量 则 acknowledgeMode 参数必须设置
             * acknowledgeMode:
             * Session.AUTO_ACKNOWLEDGE:自动消息确认机制
             * Session.CLIENT_ACKNOWLEDGE:客户端确认机制
             * Session.DUPS_OK_ACKNOWLEDGE:有副本的客户端确认消息机制
             */
            session = connection.createSession(false, session.AUTO_ACKNOWLEDGE);
            //创建目的地，目的地名称即队列的名称。消息的消费者需要通过此名称访问对应的队列
            destination = session.createQueue(&amp;quot;my-users&amp;quot;);
            //创建消息的生产者
            messageProducer = session.createProducer(destination);
            //创建消息对象
            message = session.createObjectMessage(users);
            //发送消息
            messageProducer.send(message);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (messageProducer != null) {
                try {
                    messageProducer.close();
                } catch (JMSException e) {
                    e.printStackTrace();
                }
            }
            if (session != null) {
                try {
                    session.close();
                } catch (JMSException e) {
                    e.printStackTrace();
                }
            }
            if (connection != null) {
                try {
                    connection.close();
                } catch (JMSException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;6223-定义消息消费者&#34;&gt;6.2.2.3  定义消息消费者&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UsersConsumer {
    /**
     * 消费消息
     */
    public void receiveHelloWorldActiveMQ() {

        //定义链接工厂
        ConnectionFactory connectionFactory = null;

        //定义链接对象
        Connection connection = null;

        //定义会话
        Session session = null;

        //定义目的地
        Destination destination = null;

        //定义消息的接收者
        MessageConsumer messageConsumer = null;

        //定义消息
        Message message = null;

        try {
            /**
             * userName:访问 ActiveMQ 服务的用户名。用户密码。默认的为 admin。用户名可以通过jetty-ream.properties 文件进行修改
             * password:访问 ActiveMQ 服务的用户名。用户密码。默认的为 admin。用户名可以通过jetty-ream.properties 文件进行修改
             * brokerURL:访问 ActiveMQ 服务的路径地址。 路径结构为:协议名://主机地址:端口号
             */
            connectionFactory = new ActiveMQConnectionFactory(&amp;quot;admin&amp;quot;, &amp;quot;admin&amp;quot;, &amp;quot;tcp://124.70.181.124:61616&amp;quot;);

            //创建连接对象
            connection = connectionFactory.createConnection();
            //启动连接
            connection.start();

            /**
             * transacted:是否使用事务 可选值为：   true|false
             * true:使用事务 当设置次变量值。  Session.SESSION_TRANSACTED
             * false:不适用事务,设置次变量 则 acknowledgeMode 参数必须设置
             * acknowledgeMode:
             * Session.AUTO_ACKNOWLEDGE:自动消息确认机制
             * Session.CLIENT_ACKNOWLEDGE:客户端确认机制
             * Session.DUPS_OK_ACKNOWLEDGE:有副本的客户端确认消息机制
             */
            session = connection.createSession(false, session.AUTO_ACKNOWLEDGE);
            //创建目的地，目的地名称即队列的名称。消息的消费者需要通过此名称访问对应的队列
            destination = session.createQueue(&amp;quot;my-users&amp;quot;);
            //创建消息的消费者
            messageConsumer = session.createConsumer(destination);
            //创建消息对象
            message = messageConsumer.receive();
            //处理消息
            ObjectMessage objectMessage = (ObjectMessage) message;
            Users users = (Users) objectMessage.getObject();

            System.out.println(&amp;quot;从ActiveMQ中取得的对象信息：&amp;quot;+users.toString());
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (messageConsumer != null) {
                try {
                    messageConsumer.close();
                } catch (JMSException e) {
                    e.printStackTrace();
                }
            }
            if (session != null) {
                try {
                    session.close();
                } catch (JMSException e) {
                    e.printStackTrace();
                }
            }
            if (connection != null) {
                try {
                    connection.close();
                } catch (JMSException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;6224-测试&#34;&gt;6.2.2.4 测试&lt;/h5&gt;
&lt;p&gt;producer：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        /*HelloWorldProducer helloWorldProducer = new HelloWorldProducer();
        helloWorldProducer.sendHelloWorldActiveMQ(&amp;quot;HelloActiveMQ!&amp;quot;);*/
        UsersProducer usersProducer = new UsersProducer();
        Users users = new Users();
        users.setUserid(1);
        users.setUsername(&amp;quot;张三&amp;quot;);
        users.setUserage(18);
        usersProducer.sendHelloWorldActiveMQ(users);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200702164028.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;consumer：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
/*        HelloWorldConsumer helloWorldConsumer = new HelloWorldConsumer();
        helloWorldConsumer.receiveHelloWorldActiveMQ();*/
        UsersConsumer usersConsumer = new UsersConsumer();
        usersConsumer.receiveHelloWorldActiveMQ();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;623-jms-实现队列服务监听&#34;&gt;6.2.3 JMS - 实现队列服务监听&lt;/h4&gt;
&lt;p&gt;队列服务监听使用的观察者设计模式&lt;/p&gt;
&lt;p&gt;这样做的目的是，每次producer发送消息到ActiveMQ中，不必每次重启consumer&lt;/p&gt;
&lt;h5 id=&#34;6231-创建消息生产者&#34;&gt;6.2.3.1 创建消息生产者&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class HelloWorldProducer2 {
    /**
     * 生产消息
     */
    public void sendHelloWorldActiveMQ(String msg) {

        //定义链接工厂
        ConnectionFactory connectionFactory = null;

        //定义链接对象
        Connection connection = null;

        //定义会话
        Session session = null;

        //定义目的地
        Destination destination = null;

        //定义消息的发送者
        MessageProducer messageProducer = null;

        //定义消息
        Message message = null;

        try {
            /**
             * userName:访问 ActiveMQ 服务的用户名。用户密码。默认的为 admin。用户名可以通过jetty-ream.properties 文件进行修改
             * password:访问 ActiveMQ 服务的用户名。用户密码。默认的为 admin。用户名可以通过jetty-ream.properties 文件进行修改
             * brokerURL:访问 ActiveMQ 服务的路径地址。 路径结构为:协议名://主机地址:端口号
             */
            connectionFactory = new ActiveMQConnectionFactory(&amp;quot;admin&amp;quot;, &amp;quot;admin&amp;quot;, &amp;quot;tcp://124.70.181.124:61616&amp;quot;);

            //创建连接对象
            connection = connectionFactory.createConnection();
            //启动连接
            connection.start();

            /**
             * transacted:是否使用事务 可选值为：   true|false
             * true:使用事务 当设置次变量值。  Session.SESSION_TRANSACTED
             * false:不适用事务,设置次变量 则 acknowledgeMode 参数必须设置
             * acknowledgeMode:
             * Session.AUTO_ACKNOWLEDGE:自动消息确认机制
             * Session.CLIENT_ACKNOWLEDGE:客户端确认机制
             * Session.DUPS_OK_ACKNOWLEDGE:有副本的客户端确认消息机制
             */
            session = connection.createSession(false, session.AUTO_ACKNOWLEDGE);
            //创建目的地，目的地名称即队列的名称。消息的消费者需要通过此名称访问对应的队列
            destination = session.createQueue(&amp;quot;my-destination&amp;quot;);
            //创建消息的生产者
            messageProducer = session.createProducer(destination);
            //创建消息对象
            message = session.createTextMessage(msg);
            //发送消息
            messageProducer.send(message);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (messageProducer != null) {
                try {
                    messageProducer.close();
                } catch (JMSException e) {
                    e.printStackTrace();
                }
            }
            if (session != null) {
                try {
                    session.close();
                } catch (JMSException e) {
                    e.printStackTrace();
                }
            }
            if (connection != null) {
                try {
                    connection.close();
                } catch (JMSException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;6232-消息消费者&#34;&gt;6.2.3.2 消息消费者&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class HelloWorldConsumer2 {
    /**
     * 消费消息
     */
    public void receiveHelloWorldActiveMQ() {

        //定义链接工厂
        ConnectionFactory connectionFactory = null;

        //定义链接对象
        Connection connection = null;

        //定义会话
        Session session = null;

        //定义目的地
        Destination destination = null;

        //定义消息的接收者
        MessageConsumer messageConsumer = null;

        //定义消息
        Message message = null;

        try {
            /**
             * userName:访问 ActiveMQ 服务的用户名。用户密码。默认的为 admin。用户名可以通过jetty-ream.properties 文件进行修改
             * password:访问 ActiveMQ 服务的用户名。用户密码。默认的为 admin。用户名可以通过jetty-ream.properties 文件进行修改
             * brokerURL:访问 ActiveMQ 服务的路径地址。 路径结构为:协议名://主机地址:端口号
             */
            connectionFactory = new ActiveMQConnectionFactory(&amp;quot;admin&amp;quot;, &amp;quot;admin&amp;quot;, &amp;quot;tcp://124.70.181.124:61616&amp;quot;);

            //创建连接对象
            connection = connectionFactory.createConnection();
            //启动连接
            connection.start();

            /**
             * transacted:是否使用事务 可选值为：   true|false
             * true:使用事务 当设置次变量值。  Session.SESSION_TRANSACTED
             * false:不适用事务,设置次变量 则 acknowledgeMode 参数必须设置
             * acknowledgeMode:
             * Session.AUTO_ACKNOWLEDGE:自动消息确认机制
             * Session.CLIENT_ACKNOWLEDGE:客户端确认机制
             * Session.DUPS_OK_ACKNOWLEDGE:有副本的客户端确认消息机制
             */
            session = connection.createSession(false, session.AUTO_ACKNOWLEDGE);
            //创建目的地，目的地名称即队列的名称。消息的消费者需要通过此名称访问对应的队列
            destination = session.createQueue(&amp;quot;my-destination&amp;quot;);
            //创建消息的消费者
            messageConsumer = session.createConsumer(destination);

            messageConsumer.setMessageListener(new MessageListener() {
                public void onMessage(Message message) {
                    /**
                     * ActiveMQ 回调的方法。通过该方法将消息传递到 consumer
                     */
                    String msg= null;
                    try {
                        msg = ((TextMessage)message).getText();
                    } catch (JMSException e) {
                        e.printStackTrace();
                    }
                    System.out.println(&amp;quot;从ActiveMQ中取得的文本信息：&amp;quot;+msg);
                }
            });

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;6233-测试&#34;&gt;6.2.3.3 测试&lt;/h5&gt;
&lt;p&gt;consumer&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
/*        HelloWorldConsumer helloWorldConsumer = new HelloWorldConsumer();
        helloWorldConsumer.receiveHelloWorldActiveMQ();*/
       /* UsersConsumer usersConsumer = new UsersConsumer();
        usersConsumer.receiveHelloWorldActiveMQ();*/

        HelloWorldConsumer2 helloWorldConsumer2 = new HelloWorldConsumer2();
        helloWorldConsumer2.receiveHelloWorldActiveMQ();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;producer&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        /*HelloWorldProducer helloWorldProducer = new HelloWorldProducer();
        helloWorldProducer.sendHelloWorldActiveMQ(&amp;quot;HelloActiveMQ!&amp;quot;);*/
       /* UsersProducer usersProducer = new UsersProducer();
        Users users = new Users();
        users.setUserid(1);
        users.setUsername(&amp;quot;张三&amp;quot;);
        users.setUserage(18);
        usersProducer.sendHelloWorldActiveMQ(users);*/

        HelloWorldProducer2 helloWorldProducer2 = new HelloWorldProducer2();
        helloWorldProducer2.sendHelloWorldActiveMQ(&amp;quot;Hello ActiveMQ1&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200706095439.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;producer&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;helloWorldProducer2.sendHelloWorldActiveMQ(&amp;quot;Hello ActiveMQ2&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200706095835.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;期间没有重启consumer&lt;/p&gt;
&lt;h4 id=&#34;624-topic-模型&#34;&gt;6.2.4 Topic 模型&lt;/h4&gt;
&lt;h5 id=&#34;6241-publishsubscribe-处理模式topic&#34;&gt;6.2.4.1 Publish/Subscribe 处理模式（Topic）&lt;/h5&gt;
&lt;p&gt;消息生产者（发布）将消息发布到 topic 中，同时有多个消息消费者（订阅）消费该消息。&lt;br&gt;
和点对点方式不同，发布到 topic 的消息会被所有订阅者消费。&lt;br&gt;
当生产者发布消息，不管是否有消费者。都不会保存消息&lt;br&gt;
一定要先有消息的消费者，后有消息的生产者。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200706101359.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h5 id=&#34;6242-创建生产者&#34;&gt;6.2.4.2 创建生产者&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class HelloWorldProducerTopic {
    /**
     * 生产消息
     */
    public void sendHelloWorldActiveMQ(String msg) {

        //定义链接工厂
        ConnectionFactory connectionFactory = null;

        //定义链接对象
        Connection connection = null;

        //定义会话
        Session session = null;

        //定义目的地
        Destination destination = null;

        //定义消息的发送者
        MessageProducer messageProducer = null;

        //定义消息
        Message message = null;

        try {
            /**
             * userName:访问 ActiveMQ 服务的用户名。用户密码。默认的为 admin。用户名可以通过jetty-ream.properties 文件进行修改
             * password:访问 ActiveMQ 服务的用户名。用户密码。默认的为 admin。用户名可以通过jetty-ream.properties 文件进行修改
             * brokerURL:访问 ActiveMQ 服务的路径地址。 路径结构为:协议名://主机地址:端口号
             */
            connectionFactory = new ActiveMQConnectionFactory(&amp;quot;admin&amp;quot;, &amp;quot;admin&amp;quot;, &amp;quot;tcp://124.70.181.124:61616&amp;quot;);

            //创建连接对象
            connection = connectionFactory.createConnection();
            //启动连接
            connection.start();

            /**
             * transacted:是否使用事务 可选值为：   true|false
             * true:使用事务 当设置次变量值。  Session.SESSION_TRANSACTED
             * false:不适用事务,设置次变量 则 acknowledgeMode 参数必须设置
             * acknowledgeMode:
             * Session.AUTO_ACKNOWLEDGE:自动消息确认机制
             * Session.CLIENT_ACKNOWLEDGE:客户端确认机制
             * Session.DUPS_OK_ACKNOWLEDGE:有副本的客户端确认消息机制
             */
            session = connection.createSession(false, session.AUTO_ACKNOWLEDGE);
            //创建目的地，目的地名称即队列的名称。消息的消费者需要通过此名称访问对应的队列
            destination = session.createTopic(&amp;quot;test-topic&amp;quot;);
            //创建消息的生产者
            messageProducer = session.createProducer(destination);
            //创建消息对象
            message = session.createTextMessage(msg);
            //发送消息
            messageProducer.send(message);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (messageProducer != null) {
                try {
                    messageProducer.close();
                } catch (JMSException e) {
                    e.printStackTrace();
                }
            }
            if (session != null) {
                try {
                    session.close();
                } catch (JMSException e) {
                    e.printStackTrace();
                }
            }
            if (connection != null) {
                try {
                    connection.close();
                } catch (JMSException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;6243-创建消费者&#34;&gt;6.2.4.3 创建消费者&lt;/h5&gt;
&lt;p&gt;HelloWorldConsumerTopic:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class HelloWorldConsumerTopic implements Runnable{
    /**
     * 消费消息
     */
    public void receiveHelloWorldActiveMQ() {

        //定义链接工厂
        ConnectionFactory connectionFactory = null;

        //定义链接对象
        Connection connection = null;

        //定义会话
        Session session = null;

        //定义目的地
        Destination destination = null;

        //定义消息的接收者
        MessageConsumer messageConsumer = null;

        //定义消息
        Message message = null;

        try {
            /**
             * userName:访问 ActiveMQ 服务的用户名。用户密码。默认的为 admin。用户名可以通过jetty-ream.properties 文件进行修改
             * password:访问 ActiveMQ 服务的用户名。用户密码。默认的为 admin。用户名可以通过jetty-ream.properties 文件进行修改
             * brokerURL:访问 ActiveMQ 服务的路径地址。 路径结构为:协议名://主机地址:端口号
             */
            connectionFactory = new ActiveMQConnectionFactory(&amp;quot;admin&amp;quot;, &amp;quot;admin&amp;quot;, &amp;quot;tcp://124.70.181.124:61616&amp;quot;);

            //创建连接对象
            connection = connectionFactory.createConnection();
            //启动连接
            connection.start();

            /**
             * transacted:是否使用事务 可选值为：   true|false
             * true:使用事务 当设置次变量值。  Session.SESSION_TRANSACTED
             * false:不适用事务,设置次变量 则 acknowledgeMode 参数必须设置
             * acknowledgeMode:
             * Session.AUTO_ACKNOWLEDGE:自动消息确认机制
             * Session.CLIENT_ACKNOWLEDGE:客户端确认机制
             * Session.DUPS_OK_ACKNOWLEDGE:有副本的客户端确认消息机制
             */
            session = connection.createSession(false, session.AUTO_ACKNOWLEDGE);
            //创建目的地，目的地名称即队列的名称。消息的消费者需要通过此名称访问对应的队列
            destination = session.createTopic(&amp;quot;test-topic&amp;quot;);
            //创建消息的消费者
            messageConsumer = session.createConsumer(destination);

            messageConsumer.setMessageListener(new MessageListener() {
                public void onMessage(Message message) {
                    /**
                     * ActiveMQ 回调的方法。通过该方法将消息传递到 consumer
                     */
                    String msg= null;
                    try {
                        msg = ((TextMessage)message).getText();
                    } catch (JMSException e) {
                        e.printStackTrace();
                    }
                    System.out.println(&amp;quot;从ActiveMQ中取得的文本信息Topic1:&amp;quot;+msg);
                }
            });

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public void run() {
        this.receiveHelloWorldActiveMQ();
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;HelloWorldConsumerTopic2:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class HelloWorldConsumerTopic2 implements Runnable{
    /**
     * 消费消息
     */
    public void receiveHelloWorldActiveMQ() {

        //定义链接工厂
        ConnectionFactory connectionFactory = null;

        //定义链接对象
        Connection connection = null;

        //定义会话
        Session session = null;

        //定义目的地
        Destination destination = null;

        //定义消息的接收者
        MessageConsumer messageConsumer = null;

        //定义消息
        Message message = null;

        try {
            /**
             * userName:访问 ActiveMQ 服务的用户名。用户密码。默认的为 admin。用户名可以通过jetty-ream.properties 文件进行修改
             * password:访问 ActiveMQ 服务的用户名。用户密码。默认的为 admin。用户名可以通过jetty-ream.properties 文件进行修改
             * brokerURL:访问 ActiveMQ 服务的路径地址。 路径结构为:协议名://主机地址:端口号
             */
            connectionFactory = new ActiveMQConnectionFactory(&amp;quot;admin&amp;quot;, &amp;quot;admin&amp;quot;, &amp;quot;tcp://124.70.181.124:61616&amp;quot;);

            //创建连接对象
            connection = connectionFactory.createConnection();
            //启动连接
            connection.start();

            /**
             * transacted:是否使用事务 可选值为：   true|false
             * true:使用事务 当设置次变量值。  Session.SESSION_TRANSACTED
             * false:不适用事务,设置次变量 则 acknowledgeMode 参数必须设置
             * acknowledgeMode:
             * Session.AUTO_ACKNOWLEDGE:自动消息确认机制
             * Session.CLIENT_ACKNOWLEDGE:客户端确认机制
             * Session.DUPS_OK_ACKNOWLEDGE:有副本的客户端确认消息机制
             */
            session = connection.createSession(false, session.AUTO_ACKNOWLEDGE);
            //创建目的地，目的地名称即队列的名称。消息的消费者需要通过此名称访问对应的队列
            destination = session.createTopic(&amp;quot;test-topic&amp;quot;);
            //创建消息的消费者
            messageConsumer = session.createConsumer(destination);

            messageConsumer.setMessageListener(new MessageListener() {
                public void onMessage(Message message) {
                    /**
                     * ActiveMQ 回调的方法。通过该方法将消息传递到 consumer
                     */
                    String msg= null;
                    try {
                        msg = ((TextMessage)message).getText();
                    } catch (JMSException e) {
                        e.printStackTrace();
                    }
                    System.out.println(&amp;quot;从ActiveMQ中取得的文本信息Topic2:&amp;quot;+msg);
                }
            });

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public void run() {
        this.receiveHelloWorldActiveMQ();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;HelloWorldConsumerTopic3:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class HelloWorldConsumerTopic3 implements Runnable{
    /**
     * 消费消息
     */
    public void receiveHelloWorldActiveMQ() {

        //定义链接工厂
        ConnectionFactory connectionFactory = null;

        //定义链接对象
        Connection connection = null;

        //定义会话
        Session session = null;

        //定义目的地
        Destination destination = null;

        //定义消息的接收者
        MessageConsumer messageConsumer = null;

        //定义消息
        Message message = null;

        try {
            /**
             * userName:访问 ActiveMQ 服务的用户名。用户密码。默认的为 admin。用户名可以通过jetty-ream.properties 文件进行修改
             * password:访问 ActiveMQ 服务的用户名。用户密码。默认的为 admin。用户名可以通过jetty-ream.properties 文件进行修改
             * brokerURL:访问 ActiveMQ 服务的路径地址。 路径结构为:协议名://主机地址:端口号
             */
            connectionFactory = new ActiveMQConnectionFactory(&amp;quot;admin&amp;quot;, &amp;quot;admin&amp;quot;, &amp;quot;tcp://124.70.181.124:61616&amp;quot;);

            //创建连接对象
            connection = connectionFactory.createConnection();
            //启动连接
            connection.start();

            /**
             * transacted:是否使用事务 可选值为：   true|false
             * true:使用事务 当设置次变量值。  Session.SESSION_TRANSACTED
             * false:不适用事务,设置次变量 则 acknowledgeMode 参数必须设置
             * acknowledgeMode:
             * Session.AUTO_ACKNOWLEDGE:自动消息确认机制
             * Session.CLIENT_ACKNOWLEDGE:客户端确认机制
             * Session.DUPS_OK_ACKNOWLEDGE:有副本的客户端确认消息机制
             */
            session = connection.createSession(false, session.AUTO_ACKNOWLEDGE);
            //创建目的地，目的地名称即队列的名称。消息的消费者需要通过此名称访问对应的队列
            destination = session.createTopic(&amp;quot;test-topic&amp;quot;);
            //创建消息的消费者
            messageConsumer = session.createConsumer(destination);

            messageConsumer.setMessageListener(new MessageListener() {
                public void onMessage(Message message) {
                    /**
                     * ActiveMQ 回调的方法。通过该方法将消息传递到 consumer
                     */
                    String msg= null;
                    try {
                        msg = ((TextMessage)message).getText();
                    } catch (JMSException e) {
                        e.printStackTrace();
                    }
                    System.out.println(&amp;quot;从ActiveMQ中取得的文本信息Topic3:&amp;quot;+msg);
                }
            });

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public void run() {
        this.receiveHelloWorldActiveMQ();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;6244-测试&#34;&gt;6.2.4.4 测试&lt;/h5&gt;
&lt;p&gt;consunmer:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TestConsumer {
    public static void main(String[] args) {
        HelloWorldConsumerTopic helloWorldConsumerTopic = new HelloWorldConsumerTopic();
        Thread t1 = new Thread(helloWorldConsumerTopic);
        t1.start();

        HelloWorldConsumerTopic2 helloWorldConsumerTopic2 = new HelloWorldConsumerTopic2();
        Thread t2 = new Thread(helloWorldConsumerTopic2);
        t2.start();

        HelloWorldConsumerTopic3 helloWorldConsumerTopic3 = new HelloWorldConsumerTopic3();
        Thread t3 = new Thread(helloWorldConsumerTopic3);
        t3.start();
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;producer:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TestProducer {
    public static void main(String[] args) {
        HelloWorldProducerTopic helloWorldProducerTopic = new HelloWorldProducerTopic();
        helloWorldProducerTopic.sendHelloWorldActiveMQ(&amp;quot;Hello-Topic&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200706103105.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;7-spring-整合-activemq&#34;&gt;7、Spring 整合 ActiveMQ&lt;/h2&gt;
&lt;h3 id=&#34;71-创建-spring-activemq-producer&#34;&gt;7.1  创建 spring-activemq-producer&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;修改 POM 文件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;父项目POM文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
	xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
	&amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
	&amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;parent&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
	&amp;lt;packaging&amp;gt;pom&amp;lt;/packaging&amp;gt;

	&amp;lt;!-- 对依赖的jar包的版本统一进行定义 --&amp;gt;
	&amp;lt;properties&amp;gt;
		&amp;lt;activemq.version&amp;gt;5.9.0&amp;lt;/activemq.version&amp;gt;
		&amp;lt;xbean.version&amp;gt;4.5&amp;lt;/xbean.version&amp;gt;
		&amp;lt;jms.version&amp;gt;4.1.6.RELEASE&amp;lt;/jms.version&amp;gt;
		&amp;lt;activemq-pool.version&amp;gt;5.9.0&amp;lt;/activemq-pool.version&amp;gt;
		&amp;lt;solrj.version&amp;gt;4.10.3&amp;lt;/solrj.version&amp;gt;
		&amp;lt;jedis.version&amp;gt;2.9.0&amp;lt;/jedis.version&amp;gt;
		&amp;lt;junit.version&amp;gt;4.12&amp;lt;/junit.version&amp;gt;
		&amp;lt;spring.version&amp;gt;4.1.3.RELEASE&amp;lt;/spring.version&amp;gt;
		&amp;lt;mybatis.version&amp;gt;3.2.8&amp;lt;/mybatis.version&amp;gt;
		&amp;lt;mybatis.spring.version&amp;gt;1.2.2&amp;lt;/mybatis.spring.version&amp;gt;
		&amp;lt;mysql.version&amp;gt;5.1.32&amp;lt;/mysql.version&amp;gt;
		&amp;lt;slf4j.version&amp;gt;1.6.4&amp;lt;/slf4j.version&amp;gt;
		&amp;lt;druid.version&amp;gt;1.0.9&amp;lt;/druid.version&amp;gt;
		&amp;lt;jstl.version&amp;gt;1.2&amp;lt;/jstl.version&amp;gt;
		&amp;lt;servlet-api.version&amp;gt;2.5&amp;lt;/servlet-api.version&amp;gt;
		&amp;lt;tomcat.version&amp;gt;2.2&amp;lt;/tomcat.version&amp;gt;
		&amp;lt;jsp-api.version&amp;gt;2.0&amp;lt;/jsp-api.version&amp;gt;
		&amp;lt;zkClient-version&amp;gt;0.10&amp;lt;/zkClient-version&amp;gt;
		&amp;lt;dubbo-version&amp;gt;2.5.4&amp;lt;/dubbo-version&amp;gt;
		&amp;lt;jackson.version&amp;gt;2.4.2&amp;lt;/jackson.version&amp;gt;
		&amp;lt;commons-net.version&amp;gt;3.3&amp;lt;/commons-net.version&amp;gt;
		&amp;lt;commons-fileupload.version&amp;gt;1.3.1&amp;lt;/commons-fileupload.version&amp;gt;
	&amp;lt;/properties&amp;gt;


	&amp;lt;!-- jar包的依赖注入 ，由于该工程是一个父工程，所以jar包在该pom文件中只是声明 --&amp;gt;
	&amp;lt;dependencyManagement&amp;gt;
		&amp;lt;dependencies&amp;gt;
		&amp;lt;!-- ActiveMQ客户端完整jar包依赖 --&amp;gt;
		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;org.apache.activemq&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;activemq-all&amp;lt;/artifactId&amp;gt;
			&amp;lt;version&amp;gt;${activemq.version}&amp;lt;/version&amp;gt;
		&amp;lt;/dependency&amp;gt;
		&amp;lt;!-- ActiveMQ和Spring整合配置文件标签处理jar包依赖 --&amp;gt;
		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;org.apache.xbean&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;xbean-spring&amp;lt;/artifactId&amp;gt;
			&amp;lt;version&amp;gt;${xbean.version}&amp;lt;/version&amp;gt;
		&amp;lt;/dependency&amp;gt;
		&amp;lt;!-- Spring-JMS插件相关jar包依赖 --&amp;gt;
		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;spring-jms&amp;lt;/artifactId&amp;gt;
			&amp;lt;version&amp;gt;${jms.version}&amp;lt;/version&amp;gt;
		&amp;lt;/dependency&amp;gt;
		&amp;lt;!-- Spring-JMS插件相关jar包依赖 --&amp;gt;
		&amp;lt;dependency&amp;gt;
		    &amp;lt;groupId&amp;gt;org.apache.activemq&amp;lt;/groupId&amp;gt;
		    &amp;lt;artifactId&amp;gt;activemq-pool&amp;lt;/artifactId&amp;gt;
		    &amp;lt;version&amp;gt;${activemq-pool.version}&amp;lt;/version&amp;gt;
		&amp;lt;/dependency&amp;gt;
		&amp;lt;dependency&amp;gt;
		    &amp;lt;groupId&amp;gt;org.apache.activemq&amp;lt;/groupId&amp;gt;
		    &amp;lt;artifactId&amp;gt;activemq-jms-pool&amp;lt;/artifactId&amp;gt;
		    &amp;lt;version&amp;gt;${activemq-pool.version}&amp;lt;/version&amp;gt;
		&amp;lt;/dependency&amp;gt;
		
		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;org.apache.solr&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;solr-solrj&amp;lt;/artifactId&amp;gt;
			&amp;lt;version&amp;gt;${solrj.version}&amp;lt;/version&amp;gt;
		&amp;lt;/dependency&amp;gt;
		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;redis.clients&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;jedis&amp;lt;/artifactId&amp;gt;
			&amp;lt;version&amp;gt;${jedis.version}&amp;lt;/version&amp;gt;
		&amp;lt;/dependency&amp;gt;
			&amp;lt;!-- 单元测试 --&amp;gt;
			&amp;lt;dependency&amp;gt;
				&amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
				&amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
				&amp;lt;version&amp;gt;${junit.version}&amp;lt;/version&amp;gt;
			&amp;lt;/dependency&amp;gt;
			&amp;lt;!-- 日志处理 --&amp;gt;
			&amp;lt;dependency&amp;gt;
				&amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
				&amp;lt;artifactId&amp;gt;slf4j-log4j12&amp;lt;/artifactId&amp;gt;
				&amp;lt;version&amp;gt;${slf4j.version}&amp;lt;/version&amp;gt;
			&amp;lt;/dependency&amp;gt;
			&amp;lt;!-- Mybatis --&amp;gt;
			&amp;lt;dependency&amp;gt;
				&amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt;
				&amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt;
				&amp;lt;version&amp;gt;${mybatis.version}&amp;lt;/version&amp;gt;
			&amp;lt;/dependency&amp;gt;
			&amp;lt;dependency&amp;gt;
				&amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt;
				&amp;lt;artifactId&amp;gt;mybatis-spring&amp;lt;/artifactId&amp;gt;
				&amp;lt;version&amp;gt;${mybatis.spring.version}&amp;lt;/version&amp;gt;
			&amp;lt;/dependency&amp;gt;
			&amp;lt;!-- MySql --&amp;gt;
			&amp;lt;dependency&amp;gt;
				&amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
				&amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
				&amp;lt;version&amp;gt;${mysql.version}&amp;lt;/version&amp;gt;
			&amp;lt;/dependency&amp;gt;
			&amp;lt;!-- 连接池 --&amp;gt;
			&amp;lt;dependency&amp;gt;
				&amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
				&amp;lt;artifactId&amp;gt;druid&amp;lt;/artifactId&amp;gt;
				&amp;lt;version&amp;gt;${druid.version}&amp;lt;/version&amp;gt;
			&amp;lt;/dependency&amp;gt;
			&amp;lt;!-- Spring --&amp;gt;
			&amp;lt;dependency&amp;gt;
				&amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
				&amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;
				&amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
			&amp;lt;/dependency&amp;gt;
			&amp;lt;dependency&amp;gt;
				&amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
				&amp;lt;artifactId&amp;gt;spring-beans&amp;lt;/artifactId&amp;gt;
				&amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
			&amp;lt;/dependency&amp;gt;
			&amp;lt;dependency&amp;gt;
				&amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
				&amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt;
				&amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
			&amp;lt;/dependency&amp;gt;
			&amp;lt;dependency&amp;gt;
				&amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
				&amp;lt;artifactId&amp;gt;spring-jdbc&amp;lt;/artifactId&amp;gt;
				&amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
			&amp;lt;/dependency&amp;gt;
			&amp;lt;dependency&amp;gt;
				&amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
				&amp;lt;artifactId&amp;gt;spring-aspects&amp;lt;/artifactId&amp;gt;
				&amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
			&amp;lt;/dependency&amp;gt;
			&amp;lt;!-- JSP相关 --&amp;gt;
			&amp;lt;dependency&amp;gt;
				&amp;lt;groupId&amp;gt;jstl&amp;lt;/groupId&amp;gt;
				&amp;lt;artifactId&amp;gt;jstl&amp;lt;/artifactId&amp;gt;
				&amp;lt;version&amp;gt;${jstl.version}&amp;lt;/version&amp;gt;
			&amp;lt;/dependency&amp;gt;
			&amp;lt;dependency&amp;gt;
				&amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt;
				&amp;lt;artifactId&amp;gt;servlet-api&amp;lt;/artifactId&amp;gt;
				&amp;lt;version&amp;gt;${servlet-api.version}&amp;lt;/version&amp;gt;
				&amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
			&amp;lt;/dependency&amp;gt;
			&amp;lt;dependency&amp;gt;
				&amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt;
				&amp;lt;artifactId&amp;gt;jsp-api&amp;lt;/artifactId&amp;gt;
				&amp;lt;version&amp;gt;${jsp-api.version}&amp;lt;/version&amp;gt;
				&amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
			&amp;lt;/dependency&amp;gt;
			&amp;lt;!-- 文件上传组件 --&amp;gt;
			&amp;lt;dependency&amp;gt;
				&amp;lt;groupId&amp;gt;commons-fileupload&amp;lt;/groupId&amp;gt;
				&amp;lt;artifactId&amp;gt;commons-fileupload&amp;lt;/artifactId&amp;gt;
				&amp;lt;version&amp;gt;${commons-fileupload.version}&amp;lt;/version&amp;gt;
			&amp;lt;/dependency&amp;gt;
			
			&amp;lt;dependency&amp;gt;
				&amp;lt;groupId&amp;gt;commons-net&amp;lt;/groupId&amp;gt;
				&amp;lt;artifactId&amp;gt;commons-net&amp;lt;/artifactId&amp;gt;
				&amp;lt;version&amp;gt;${commons-net.version}&amp;lt;/version&amp;gt;
			&amp;lt;/dependency&amp;gt;
			
			&amp;lt;!-- Jackson Json处理工具包 --&amp;gt;
			&amp;lt;dependency&amp;gt;
				&amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt;
				&amp;lt;artifactId&amp;gt;jackson-databind&amp;lt;/artifactId&amp;gt;
				&amp;lt;version&amp;gt;${jackson.version}&amp;lt;/version&amp;gt;
			&amp;lt;/dependency&amp;gt;
		&amp;lt;/dependencies&amp;gt;
	&amp;lt;/dependencyManagement&amp;gt;

	&amp;lt;build&amp;gt;
		&amp;lt;resources&amp;gt;
			&amp;lt;resource&amp;gt;
				&amp;lt;directory&amp;gt;src/main/java&amp;lt;/directory&amp;gt;
				&amp;lt;includes&amp;gt;
					&amp;lt;include&amp;gt;**/*.xml&amp;lt;/include&amp;gt;
				&amp;lt;/includes&amp;gt;
			&amp;lt;/resource&amp;gt;
			&amp;lt;resource&amp;gt;
				&amp;lt;directory&amp;gt;src/main/resources&amp;lt;/directory&amp;gt;
				&amp;lt;includes&amp;gt;
					&amp;lt;include&amp;gt;**/*.xml&amp;lt;/include&amp;gt;
					&amp;lt;include&amp;gt;**/*.properties&amp;lt;/include&amp;gt;
				&amp;lt;/includes&amp;gt;
			&amp;lt;/resource&amp;gt;
		&amp;lt;/resources&amp;gt;
		&amp;lt;!-- tomcat插件，由于子项目不一定每个都是web项目，所以该插件只是声明，并未开启 --&amp;gt;
		&amp;lt;pluginManagement&amp;gt;
			&amp;lt;plugins&amp;gt;
				&amp;lt;!-- 配置Tomcat插件 --&amp;gt;
				&amp;lt;plugin&amp;gt;
					&amp;lt;groupId&amp;gt;org.apache.tomcat.maven&amp;lt;/groupId&amp;gt;
					&amp;lt;artifactId&amp;gt;tomcat7-maven-plugin&amp;lt;/artifactId&amp;gt;
					&amp;lt;version&amp;gt;${tomcat.version}&amp;lt;/version&amp;gt;
				&amp;lt;/plugin&amp;gt;
			&amp;lt;/plugins&amp;gt;
		&amp;lt;/pluginManagement&amp;gt;
	&amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;spring-active-producer项目POM文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
	xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
	&amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
	&amp;lt;parent&amp;gt;
		&amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
		&amp;lt;artifactId&amp;gt;parent&amp;lt;/artifactId&amp;gt;
		&amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
	&amp;lt;/parent&amp;gt;
	&amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;spring-activemq-producer&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
	&amp;lt;packaging&amp;gt;war&amp;lt;/packaging&amp;gt;

	&amp;lt;dependencies&amp;gt;
		&amp;lt;!-- ActiveMQ客户端完整jar包依赖 --&amp;gt;
		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;org.apache.activemq&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;activemq-all&amp;lt;/artifactId&amp;gt;
		&amp;lt;/dependency&amp;gt;
		&amp;lt;!-- ActiveMQ和Spring整合配置文件标签处理jar包依赖 --&amp;gt;
		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;org.apache.xbean&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;xbean-spring&amp;lt;/artifactId&amp;gt;
		&amp;lt;/dependency&amp;gt;
		&amp;lt;!-- Spring-JMS插件相关jar包依赖 --&amp;gt;
		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;spring-jms&amp;lt;/artifactId&amp;gt;
		&amp;lt;/dependency&amp;gt;
			&amp;lt;dependency&amp;gt;
		    &amp;lt;groupId&amp;gt;org.apache.activemq&amp;lt;/groupId&amp;gt;
		    &amp;lt;artifactId&amp;gt;activemq-pool&amp;lt;/artifactId&amp;gt;
		&amp;lt;/dependency&amp;gt;
		&amp;lt;dependency&amp;gt;
		    &amp;lt;groupId&amp;gt;org.apache.activemq&amp;lt;/groupId&amp;gt;
		    &amp;lt;artifactId&amp;gt;activemq-jms-pool&amp;lt;/artifactId&amp;gt;
		&amp;lt;/dependency&amp;gt;
		&amp;lt;!-- 单元测试 --&amp;gt;
		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
		&amp;lt;/dependency&amp;gt;
		&amp;lt;!-- 日志处理 --&amp;gt;
		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;slf4j-log4j12&amp;lt;/artifactId&amp;gt;
		&amp;lt;/dependency&amp;gt;
		&amp;lt;!-- spring --&amp;gt;
		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;
		&amp;lt;/dependency&amp;gt;
		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;spring-beans&amp;lt;/artifactId&amp;gt;
		&amp;lt;/dependency&amp;gt;
		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt;
		&amp;lt;/dependency&amp;gt;

		&amp;lt;!-- JSP相关 --&amp;gt;
		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;jstl&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;jstl&amp;lt;/artifactId&amp;gt;
		&amp;lt;/dependency&amp;gt;
		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;servlet-api&amp;lt;/artifactId&amp;gt;
			&amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
		&amp;lt;/dependency&amp;gt;
		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;jsp-api&amp;lt;/artifactId&amp;gt;
			&amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
		&amp;lt;/dependency&amp;gt;
	&amp;lt;/dependencies&amp;gt;

	&amp;lt;build&amp;gt;
		&amp;lt;plugins&amp;gt;
			&amp;lt;!-- 配置Tomcat插件 --&amp;gt;
			&amp;lt;plugin&amp;gt;
				&amp;lt;groupId&amp;gt;org.apache.tomcat.maven&amp;lt;/groupId&amp;gt;
				&amp;lt;artifactId&amp;gt;tomcat7-maven-plugin&amp;lt;/artifactId&amp;gt;
				&amp;lt;configuration&amp;gt;
					&amp;lt;path&amp;gt;/&amp;lt;/path&amp;gt;
					&amp;lt;port&amp;gt;8080&amp;lt;/port&amp;gt;
				&amp;lt;/configuration&amp;gt;
			&amp;lt;/plugin&amp;gt;
		&amp;lt;/plugins&amp;gt;
	&amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;整合 ActiveMQ&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
	xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xmlns:jms=&amp;quot;http://www.springframework.org/schema/jms&amp;quot;
	xmlns:context=&amp;quot;http://www.springframework.org/schema/context&amp;quot;
	xmlns:amq=&amp;quot;http://activemq.apache.org/schema/core&amp;quot;
	xsi:schemaLocation=&amp;quot;
		http://www.springframework.org/schema/beans 
		http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/jms
		http://www.springframework.org/schema/jms/spring-jms.xsd
		http://activemq.apache.org/schema/core
		http://activemq.apache.org/schema/core/activemq-core.xsd
		http://www.springframework.org/schema/context
		http://www.springframework.org/schema/context/spring-context.xsd&amp;quot;&amp;gt;


	&amp;lt;!-- 需要创建一个连接工厂,连接ActiveMQ. ActiveMQConnectionFactory. 需要依赖ActiveMQ提供的amq标签 --&amp;gt;
	&amp;lt;!-- amq:connectionFactory 是bean标签的子标签, 会在spring容器中创建一个bean对象. 可以为对象命名. 
		类似: &amp;lt;bean id=&amp;quot;&amp;quot; class=&amp;quot;ActiveMQConnectionFactory&amp;quot;&amp;gt;&amp;lt;/bean&amp;gt; --&amp;gt;
	&amp;lt;amq:connectionFactory brokerURL=&amp;quot;tcp://192.168.70.151:61616&amp;quot;
		userName=&amp;quot;admin&amp;quot; password=&amp;quot;admin&amp;quot; id=&amp;quot;amqConnectionFactory&amp;quot; /&amp;gt;
		
	&amp;lt;!-- 配置池化的ConnectionFactory。 为连接ActiveMQ的connectionFactory提供连接池 --&amp;gt;
	&amp;lt;bean id=&amp;quot;pooledConnectionFactory&amp;quot; class=&amp;quot;org.apache.activemq.pool.PooledConnectionFactoryBean&amp;quot;&amp;gt;
		&amp;lt;property name=&amp;quot;connectionFactory&amp;quot; ref=&amp;quot;amqConnectionFactory&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
		&amp;lt;property name=&amp;quot;maxConnections&amp;quot; value=&amp;quot;10&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
	&amp;lt;/bean&amp;gt;
	&amp;lt;!-- spring管理JMS相关代码的时候,必须依赖jms标签库. spring-jms提供的标签库. --&amp;gt;
	&amp;lt;!-- 定义Spring-JMS中的连接工厂对象 CachingConnectionFactory - spring框架提供的连接工厂对象. 
		不能真正的访问MOM容器. 类似一个工厂的代理对象. 需要提供一个真实工厂,实现MOM容器的连接访问. --&amp;gt;
	&amp;lt;!-- 配置有缓存的ConnectionFactory，session的缓存大小可定制。 --&amp;gt;
	&amp;lt;bean id=&amp;quot;connectionFactory&amp;quot;
		class=&amp;quot;org.springframework.jms.connection.CachingConnectionFactory&amp;quot;&amp;gt;
		&amp;lt;property name=&amp;quot;targetConnectionFactory&amp;quot; ref=&amp;quot;amqConnectionFactory&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
		&amp;lt;property name=&amp;quot;sessionCacheSize&amp;quot; value=&amp;quot;3&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
	&amp;lt;/bean&amp;gt;

	&amp;lt;!-- JmsTemplate配置 --&amp;gt;
	&amp;lt;bean id=&amp;quot;template&amp;quot; class=&amp;quot;org.springframework.jms.core.JmsTemplate&amp;quot;&amp;gt;
		&amp;lt;!-- 给定连接工厂, 必须是spring创建的连接工厂. --&amp;gt;
		&amp;lt;property name=&amp;quot;connectionFactory&amp;quot; ref=&amp;quot;connectionFactory&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
		&amp;lt;!-- 可选 - 默认目的地命名 --&amp;gt;
		&amp;lt;property name=&amp;quot;defaultDestinationName&amp;quot; value=&amp;quot;test-spring&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
	&amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;72-创建-spring-activemq-consumer&#34;&gt;7.2 创建 spring-activemq-consumer&lt;/h3&gt;
&lt;p&gt;是一个 jar 工程&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;修改 POM 文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
  &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
  &amp;lt;parent&amp;gt;
    &amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;parent&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
  &amp;lt;/parent&amp;gt;
  &amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-activemq-consumer&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
  
  	&amp;lt;dependencies&amp;gt;
		&amp;lt;!-- activemq客户端 --&amp;gt;
		&amp;lt;dependency&amp;gt;
		    &amp;lt;groupId&amp;gt;org.apache.activemq&amp;lt;/groupId&amp;gt;
		    &amp;lt;artifactId&amp;gt;activemq-all&amp;lt;/artifactId&amp;gt;
		&amp;lt;/dependency&amp;gt;
		&amp;lt;!-- spring框架对JMS标准的支持 --&amp;gt;
		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;spring-jms&amp;lt;/artifactId&amp;gt;
		&amp;lt;/dependency&amp;gt;
		&amp;lt;!-- ActiveMQ和spring整合的插件 --&amp;gt;
		&amp;lt;dependency&amp;gt;
		    &amp;lt;groupId&amp;gt;org.apache.xbean&amp;lt;/groupId&amp;gt;
		    &amp;lt;artifactId&amp;gt;xbean-spring&amp;lt;/artifactId&amp;gt;
		&amp;lt;/dependency&amp;gt;
		
		
		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;
		&amp;lt;/dependency&amp;gt;
		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;spring-beans&amp;lt;/artifactId&amp;gt;
		&amp;lt;/dependency&amp;gt;
	&amp;lt;/dependencies&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;整合 ActiveMQ&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
	xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; 
	xmlns:jms=&amp;quot;http://www.springframework.org/schema/jms&amp;quot; 
	xmlns:amq=&amp;quot;http://activemq.apache.org/schema/core&amp;quot;
	xsi:schemaLocation=&amp;quot;
		http://www.springframework.org/schema/beans 
		http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/jms
		http://www.springframework.org/schema/jms/spring-jms.xsd
		http://activemq.apache.org/schema/core
		http://activemq.apache.org/schema/core/activemq-core.xsd&amp;quot;&amp;gt;
	&amp;lt;!-- 需要创建一个连接工厂,连接ActiveMQ. ActiveMQConnectionFactory. 需要依赖ActiveMQ提供的amq标签 --&amp;gt;
	&amp;lt;!-- amq:connectionFactory 是bean标签的子标签, 会在spring容器中创建一个bean对象.
		可以为对象命名. 类似: &amp;lt;bean id=&amp;quot;&amp;quot; class=&amp;quot;ActiveMQConnectionFactory&amp;quot;&amp;gt;&amp;lt;/bean&amp;gt;
	 --&amp;gt;
	&amp;lt;amq:connectionFactory brokerURL=&amp;quot;tcp://192.168.70.151:61616&amp;quot;
		userName=&amp;quot;admin&amp;quot; password=&amp;quot;admin&amp;quot; id=&amp;quot;amqConnectionFactory&amp;quot;/&amp;gt;

	&amp;lt;!-- spring管理JMS相关代码的时候,必须依赖jms标签库. spring-jms提供的标签库. --&amp;gt;
	&amp;lt;!-- 定义Spring-JMS中的连接工厂对象
		CachingConnectionFactory - spring框架提供的连接工厂对象. 不能真正的访问MOM容器.
			类似一个工厂的代理对象. 需要提供一个真实工厂,实现MOM容器的连接访问.
	 --&amp;gt;
	&amp;lt;bean id=&amp;quot;connectionFactory&amp;quot; 
		class=&amp;quot;org.springframework.jms.connection.CachingConnectionFactory&amp;quot;&amp;gt;
		&amp;lt;property name=&amp;quot;targetConnectionFactory&amp;quot; ref=&amp;quot;amqConnectionFactory&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
		&amp;lt;property name=&amp;quot;sessionCacheSize&amp;quot; value=&amp;quot;3&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
	&amp;lt;/bean&amp;gt;
	
	&amp;lt;!-- 注册监听器 --&amp;gt;
	&amp;lt;!-- 开始注册监听. 
		需要的参数有:
			acknowledge - 消息确认机制
			container-type - 容器类型 default|simple
			simple:SimpleMessageListenerContainer最简单的消息监听器容器，只能处理固定数量的JMS会话，且不支持事务。
			default:DefaultMessageListenerContainer是一个用于异步消息监听器容器 ，且支持事务         
			destination-type - 目的地类型. 使用队列作为目的地.
			connection-factory - 连接工厂, spring-jms使用的连接工厂,必须是spring自主创建的
			不能使用三方工具创建的工程. 如: ActiveMQConnectionFactory.
	 --&amp;gt;
	&amp;lt;jms:listener-container acknowledge=&amp;quot;auto&amp;quot; container-type=&amp;quot;default&amp;quot;
		destination-type=&amp;quot;queue&amp;quot; connection-factory=&amp;quot;connectionFactory&amp;quot; &amp;gt;
		&amp;lt;!-- 在监听器容器中注册某监听器对象.
			destination - 设置目的地命名
			ref - 指定监听器对象
		 --&amp;gt;
		&amp;lt;jms:listener destination=&amp;quot;test-spring&amp;quot; ref=&amp;quot;myListener&amp;quot;/&amp;gt;
	&amp;lt;/jms:listener-container&amp;gt;
	
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;73-整合测试&#34;&gt;7.3 整合测试&lt;/h3&gt;
&lt;p&gt;需求：&lt;br&gt;
1）在 producer 中创建 Users 对象&lt;br&gt;
2）将 Users 对象传递到 ActiveMQ 中&lt;br&gt;
3）在 Consumer 中获取 Users 对象并在控制台打印&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Producer 发送消息&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果使用了连接池需要添加两个坐标&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;PooledConnectionFactoryBean&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;org.apache.activemq&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;activemq-pool&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;5.9.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;org.apache.activemq&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;activemq-jms-pool&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;5.9.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;发送消息&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
public class UserServiceImpl implements UserService {

	@Autowired
	private JmsTemplate jmsTemplate;
	
	@Override
	public void addUser(final Users user) {
		//发送消息
		this.jmsTemplate.send(new MessageCreator() {
			
			@Override
			public Message createMessage(Session session) throws JMSException {
				Message message = session.createObjectMessage(user);
				return message;
			}
		});
	}

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Consumer 接收消息&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;接收消息&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 消息服务监听器
 * @author Administrator
 *
 */
@Component(value=&amp;quot;myListener&amp;quot;)
public class MyMessageListener implements MessageListener{

	@Autowired
	private UserService userService;
	
	@Override
	public void onMessage(Message message) {
		//处理消息
		ObjectMessage objMessage = (ObjectMessage)message;
		Users user=null;
		try {
			user = (Users)objMessage.getObject();
		} catch (JMSException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		this.userService.showUser(user);
	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
">ActiveMQ</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jonchan1013.github.io/post/swagger/"" data-c="
          &lt;h2 id=&#34;1-swagger-简介&#34;&gt;1、Swagger 简介&lt;/h2&gt;
&lt;h3 id=&#34;11-前言&#34;&gt;1.1 前言&lt;/h3&gt;
&lt;p&gt;​		接口文档对于前后端开发人员都十分重要。尤其近几年流行前后端分离后接口文档又变成重中之重。接口文档固然重要，但是由于项目周期等原因后端人员经常出现无法及时更新，导致前端人员抱怨接口文档和实际情况不一致。&lt;br&gt;
​        很多人员会抱怨别人写的接口文档不规范，不及时更新。当时当自己写的时候确实最烦去写接口文档。这种痛苦只有亲身经历才会牢记于心。&lt;br&gt;
​        如果接口文档可以实时动态生成就不会出现上面问题。&lt;br&gt;
​        Swagger 可以完美的解决上面的问题。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;12-open-api-是什么&#34;&gt;1.2 Open API 是什么&lt;/h3&gt;
&lt;p&gt;​		Open API 规范(OpenAPI Specification)以前叫做Swagger 规范，是&lt;br&gt;
REST API 的API 描述格式。&lt;br&gt;
​		Open API 文件允许描述整个API，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每个访问地址的类型。POST 或GET。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个操作的参数。包括输入输出参数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;认证方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;连接信息，声明，使用团队和其他信息。&lt;br&gt;
Open API 规范可以使用YAML 或JSON 格式进行编写。这样更利于我们和机器进行阅读。&lt;/p&gt;
&lt;p&gt;OpenAPI 规范（OAS）为 RESTful API 定义了一个与语言无关的标准接口，允许人和计算机发现和理解服务的功能，而无需访问源代码，文档或通过网络流量检查。正确定义后，消费者可以使用最少量的实现逻辑来理解远程服务并与之交互。&lt;br&gt;
然后，文档生成工具可以使用OpenAPI 定义来显示API，使用各种编程语言生成服务器和客户端的代码生成工具，测试工具以及许多其他用例。&lt;/p&gt;
&lt;p&gt;源码和说明参照：&lt;/p&gt;
&lt;p&gt;https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.&lt;br&gt;
0.0.md#oasDocument&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;13-swagger-简介&#34;&gt;1.3 Swagger 简介&lt;/h3&gt;
&lt;p&gt;​		Swagger 是一套围绕Open API 规范构建的开源工具，可以帮助设计，构建，记录和使用REST API。&lt;br&gt;
​		Swagger 工具包括的组件：&lt;br&gt;
​		Swagger Editor ：基于浏览器编辑器，可以在里面编写Open API规范。类似Markdown 具有实时预览描述文件的功能。&lt;br&gt;
​		Swagger UI：将Open API 规范呈现为交互式API 文档。用可视化UI 展示描述文件。&lt;/p&gt;
&lt;p&gt;​		Swagger Codegen：将 OpenAPI 规范生成为服务器存根和客户端库。通过Swagger Codegen 可以将描述文件生成 html 格式和cwiki 形式的接口文档，同时也可以生成多种言语的客户端和服务端代码。&lt;br&gt;
​		Swagger Inspector：和 Swagger UI 有点类似，但是可以返回更多信息，也会保存请求的实际参数数据。&lt;br&gt;
​		Swagger Hub：集成了上面所有项目的各个功能，你可以以项目和版本为单位，将你的描述文件上传到Swagger Hub 中。在 SwaggerHub 中可以完成上面项目的所有工作，需要注册账号，分免费版和收费版。&lt;br&gt;
​		使用Swagger，就是把相关的信息存储在它定义的描述文件里面（yml 或 json 格式），再通过维护这个描述文件可以去更新接口文档，以及生成各端代码。&lt;/p&gt;
&lt;h2 id=&#34;2-springfox&#34;&gt;2、Springfox&lt;/h2&gt;
&lt;p&gt;​		使用 Swagger 时如果碰见版本更新或迭代时，只需要更改Swagger 的描述文件即可。但是在频繁的更新项目版本时很多开发人员认为即使修改描述文件（yml 或json）也是一定的工作负担，久而久之就直接修改代码，而不去修改描述文件了，这样基于描述文件生成接口文档也失去了意义。&lt;br&gt;
​		Marty Pitt 编写了一个基于 Spring 的组件 swagger-springmvc。Spring-fox 就是根据这个组件发展而来的全新项目。&lt;br&gt;
​		Spring-fox 是根据代码生成接口文档，所以正常的进行更新项目版本，修改代码即可，而不需要跟随修改描述文件。&lt;br&gt;
​		Spring-fox 利用自身AOP 特性，把Swagger 集成进来，底层还是Swagger。但是使用起来确方便很多。&lt;br&gt;
​		所以在实际开发中，都是直接使用spring-fox。&lt;br&gt;
​		附：官网地址&lt;/p&gt;
&lt;p&gt;​		http://springfox.github.io/springfox/&lt;/p&gt;
&lt;p&gt;​		附：官方源码&lt;/p&gt;
&lt;p&gt;​		https://github.com/springfox/springfox&lt;/p&gt;
&lt;h2 id=&#34;3-swagger-极致用法&#34;&gt;3、Swagger 极致用法&lt;/h2&gt;
&lt;h3 id=&#34;31-编写springboot-项目&#34;&gt;3.1  编写SpringBoot 项目&lt;/h3&gt;
&lt;p&gt;​	编写SpringBoot 项目，项目中controller 中包含一个Handler，测试项目，保证程序可以正确运行。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@RequestMapping(&amp;quot;/people&amp;quot;)
public class DemoController {

	@RequestMapping(&amp;quot;/getPeople&amp;quot;)
	public People getPeople(Long id, String name){
		People peo = new People();
		peo.setId(id);
		peo.setName(name);
		peo.setAddress(&amp;quot;海淀&amp;quot;);
		return peo;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;32-导入spring-fox-依赖&#34;&gt;3.2 导入Spring-fox 依赖&lt;/h3&gt;
&lt;p&gt;​		在项目的pom.xml 中导入Spring-fox 依赖。目前最新版本为2.9.2，所以导入的依赖也是这个版本。其中 springfox-swagger2 是核心内容的封装。springfox-swagger-ui 是对swagger-ui 的封装。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;springfox-swagger2&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;2.9.2&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;springfox-swagger-ui&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;2.9.2&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;33-添加注解&#34;&gt;3.3 添加注解&lt;/h3&gt;
&lt;p&gt;​		在SpringBoot 的&lt;strong&gt;启动类&lt;/strong&gt;中添加@EnableSwagger2 注解。&lt;br&gt;
​		添加此注解后表示对当前项目中全部控制器进行扫描。应用Swagger2&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SpringBootApplication
@EnableSwagger2
public class MyApp {
	public static void main(String [] args){
		SpringApplication.run(MyApp.class,args);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;34-访问swagger-ui&#34;&gt;3.4 访问swagger-ui&lt;/h3&gt;
&lt;p&gt;​		启动项目后在浏览器中输入http://ip:port/swagger-ui.html 即可以访问到swagger-ui 页面，在页面中可以可视化的进行操作项目中所有接口。&lt;/p&gt;
&lt;h2 id=&#34;4-swagger-ui-使用&#34;&gt;4、Swagger-UI 使用&lt;/h2&gt;
&lt;p&gt;​		访问 swagger-ui.html 后可以在页面中看到所有需要生成接口文档的控制器名称。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200701174528.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;每个控制器中间包含多所有控制器方法的各种访问方式。如果使用的是@RequestMapping 进行映射，将显示下面的所有请求方式。如果使用@PostMapping 将只有Post 方式可以能访问，下面也就只显示Post 的一个。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200701174547.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;点击某个请求方式中try it out&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200701174601.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;会出现界面要求输入的值。输入完成后点击Execute 按钮，下面会出现Request URL 已经不同状态码相应回来的结果。&lt;/p&gt;
&lt;h2 id=&#34;5-swagger-配置&#34;&gt;5、Swagger 配置&lt;/h2&gt;
&lt;p&gt;可以在项目中创建SwaggerConfig，进行配置文档内容。&lt;/p&gt;
&lt;h3 id=&#34;51-配置基本信息&#34;&gt;5.1 配置基本信息&lt;/h3&gt;
&lt;p&gt;Docket：摘要对象，通过对象配置描述文件的信息。&lt;br&gt;
apiInfo:设置描述文件中info。参数类型ApiInfo&lt;br&gt;
select():返回 ApiSelectorBuilder 对象，通过对象调用 build()可以创建Docket 对象&lt;br&gt;
ApiInfoBuilder：ApiInfo 构建器。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class SwaggerConfig {
	@Bean
	public Docket getDocket(){
        return new Docket(DocumentationType.SWAGGER_2)
			.apiInfo(swaggerDemoApiInfo())
			.select()
			.build();
}
private ApiInfo swaggerDemoApiInfo(){
	return new ApiInfoBuilder()
		.contact(new Contact(&amp;quot;Swagger&amp;quot;, &amp;quot;http://www.百度.com&amp;quot;,&amp;quot;xxx@163.com&amp;quot;))
		//文档标题
		.title(&amp;quot;这里是 Swagger 的标题&amp;quot;)
		//文档描述
		.description(&amp;quot;这里是 Swagger 的描述&amp;quot;)
		//文档版本
		.version(&amp;quot;1.0.0&amp;quot;)
		.build();
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;52-设置扫描的包&#34;&gt;5.2 设置扫描的包&lt;/h3&gt;
&lt;p&gt;可以通过apis()方法设置哪个包中内容被扫描&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Bean
public Docket getDocket() {
	return new Docket(DocumentationType.SWAGGER_2)
		.apiInfo(getApiInfo())
		.select()
        .apis(RequestHandlerSelectors.basePackage(&amp;quot;com.cy.controller&amp;quot;))
		.build();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;53-自定义注解设置不需要生成接口文档的方法&#34;&gt;5.3 自定义注解设置不需要生成接口文档的方法&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;自定义注解&lt;/p&gt;
&lt;p&gt;注解名称随意。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface NotIncludeSwagger {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;添加规则&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通 过 public ApiSelectorBuilder apis(Predicate&lt;RequestHandler&gt; selector)可以设置生成规则。&lt;br&gt;
public static &lt;T&gt; Predicate&lt;T&gt; not(Predicate&lt;T&gt; predicate) :表示不允许的条件。&lt;br&gt;
withMethodAnnotation：表示此注解是方法级别注解。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;添加NotIncludeSwagger 注解&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在不需要生成接口文档的方法上面添加@NotIncludeSwagger 注解后，该方法将不会被Swagger 进行生成在接口文档中。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@NotIncludeSwagger
@RequestMapping(&amp;quot;/getPeople2&amp;quot;)
public People getPeople2(Integer id, String name, String address){
	People peo = new People();
	peo.setId(id);
	peo.setName(name);
	peo.setAddress(address);
	return peo;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;54-设置范围&#34;&gt;5.4 设置范围&lt;/h3&gt;
&lt;p&gt;通过 public ApiSelectorBuilder paths(Predicate&lt;String&gt; selector)可以设置满足什么样规则的url 被生成接口文档。可以使用正则表达式进行匹配。&lt;br&gt;
下面例子中表示只有以/demo/开头的 url 才能被swagger 生成接口文档。&lt;br&gt;
如何希望全部扫描可以使用paths(PathSelectors.any())&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Bean
public Docket getDocket(){
	return new Docket(DocumentationType.SWAGGER_2)
		.apiInfo(swaggerDemoApiInfo())
		.select()
		.paths(allowPaths())
		.build();
}
private Predicate&amp;lt;String&amp;gt; allowPaths(){
	return or(
		regex(&amp;quot;/demo/.*&amp;quot;)
	);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;6-swagger2-常用注解&#34;&gt;6、Swagger2 常用注解&lt;/h2&gt;
&lt;h3 id=&#34;61-api&#34;&gt;6.1 Api&lt;/h3&gt;
&lt;p&gt;@Api 是类上注解。控制整个类生成接口信息的内容。&lt;br&gt;
tags：类的名称。可以有多个值，多个值表示多个副本。&lt;br&gt;
description:描述，已过时。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@RequestMapping(&amp;quot;/people&amp;quot;)
@Api(tags = {&amp;quot;mydemo&amp;quot;},description = &amp;quot;描述&amp;quot;)
public class DemoController {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在swagger-ui.html 中显示效果。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200702102613.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;62-apioperation&#34;&gt;6.2 ApiOperation&lt;/h3&gt;
&lt;p&gt;@ApiOperation 写在方法上，对方法进行总体描述&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;value：接口描述&lt;/li&gt;
&lt;li&gt;notes：提示信息&lt;br&gt;
代码示例：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@ApiOperation(value=&amp;quot;接口描述&amp;quot;,notes = &amp;quot;接口提示信息&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在swagger-ui 中显示效果&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200702102714.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;63-apiparam&#34;&gt;6.3 ApiParam&lt;/h3&gt;
&lt;p&gt;@ApiParam 写在方法参数前面。用于对参数进行描述或说明是否为必添项等说明。&lt;br&gt;
name：参数名称&lt;br&gt;
value：参数描述&lt;br&gt;
required：是否是必须&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public People getPeople(Integer id, @ApiParam(value=&amp;quot;姓名&amp;quot;,required = true) Stringname, String address)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;swagger-ui 显示效果如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200702102804.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;64-apimodel&#34;&gt;6.4 ApiModel&lt;/h3&gt;
&lt;p&gt;@ApiModel 是类上注解，主要应用Model，也就是说这个注解一&lt;br&gt;
般都是写在实体类上。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;value：名称&lt;/li&gt;
&lt;li&gt;description：描述&lt;br&gt;
代码示例：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@ApiModel(value = &amp;quot;人类&amp;quot;,description = &amp;quot;描述&amp;quot;)
public class People {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;swagger-ui.html 效果展示&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200702102900.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;65-apimodelproperty&#34;&gt;6.5 ApiModelProperty&lt;/h3&gt;
&lt;p&gt;@ApiModelProperty 可以用在方法或属性上。用于当对象作为参数时定义这个字段的内容。&lt;br&gt;
value：描述&lt;br&gt;
name：重写属性名&lt;br&gt;
required：是否是必须的&lt;br&gt;
example：示例内容&lt;br&gt;
hidden：是否隐藏。&lt;br&gt;
代码示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@ApiModelProperty(value = &amp;quot;姓名&amp;quot;,name = &amp;quot;name&amp;quot;,required = true,example = &amp;quot;张三&amp;quot;)
private String name;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;swagger-ui.html 效果展示&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200702102946.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;66-apiignore&#34;&gt;6.6  ApiIgnore&lt;/h3&gt;
&lt;p&gt;@ApiIgnore 用于方法或类或参数上，表示这个方法或类被忽略。和之前讲解的自定义注解@NotIncludeSwagger 效果类似。只是这个注解是Swagger 内置的注解，而@NotIncludeSwagger 是我们自定义的注解。&lt;/p&gt;
&lt;h3 id=&#34;67-apiimplicitparam&#34;&gt;6.7 ApiImplicitParam&lt;/h3&gt;
&lt;p&gt;@ApiImplicitParam 用在方法上，表示单独的请求参数，总体功能和@ApiParam 类似。&lt;br&gt;
name：属性名&lt;br&gt;
value：描述&lt;br&gt;
required：是否是必须的&lt;br&gt;
paramType：属性类型&lt;br&gt;
dataType：数据类型&lt;br&gt;
代码示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@PostMapping(&amp;quot;/getPeople&amp;quot;)
@ApiImplicitParam(name = &amp;quot;address&amp;quot;,value = &amp;quot;地址&amp;quot;,required = true,paramType =&amp;quot;query&amp;quot;,dataType = &amp;quot;string&amp;quot;)
public People getPeople(Integer id, @ApiParam(value=&amp;quot;姓名&amp;quot;,required = true) Stringname, String address){
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;swagger-ui.html 效果展示&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200702103120.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如果希望在方法上配置多个参数时，使用@ApiImplicitParams 进行配置。示例如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@ApiImplicitParams(value={@ApiImplicitParam(name=&amp;quot;id&amp;quot;,value = &amp;quot;编号&amp;quot;,required =true),@ApiImplicitParam(name=&amp;quot;name&amp;quot;,value = &amp;quot;姓名&amp;quot;,required = true)})
&lt;/code&gt;&lt;/pre&gt;
">Swagger</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jonchan1013.github.io/post/fastdfs/"" data-c="
          &lt;h2 id=&#34;1-简介&#34;&gt;1、简介&lt;/h2&gt;
&lt;p&gt;FastDFS 是一个开源的轻量级分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。特别适合以文件为载体的在线服务，如相册网站、视频网站等等。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;技术论坛： http://bbs.chinaunix.net/forum-240-1.html&lt;br&gt;
资源地址： https://sourceforge.net/projects/fastdfs/&lt;br&gt;
源码资源： https://github.com/happyfish100&lt;/p&gt;
&lt;p&gt;FastDFS 为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用 FastDFS 很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。&lt;br&gt;
FastDFS 服务端有两个角色：跟踪器（tracker）和存储节点（storage）。跟踪器主要做调度工作，在访问上起负载均衡的作用。&lt;br&gt;
存储节点存储文件，完成文件管理的所有功能：就是这样的存储、同步和提供存取接口，FastDFS 同时对文件的 metadata 进行管理。所谓文件的 meta data 就是文件的相关属性，以键值对（key value）方式表示，如：width=1024，其中的 key 为 width，value 为 1024。文件metadata 是文件属性列表，可以包含多个键值对。&lt;br&gt;
跟踪器和存储节点都可以由一台或多台服务器构成。跟踪器和存储节点中的服务器均可以随时增加或下线而不会影响线上服务。其中跟踪器中的所有服务器都是对等的，可以根据服务器的压力情况随时增加或减少。&lt;br&gt;
为了支持大容量，存储节点（服务器）采用了分卷（或分组）的组织方式。存储系统由一个或多个卷组成，卷与卷之间的文件是相互独立的，所有卷的文件容量累加就是整个存储系统中的文件容量。一个卷可以由一台或多台存储服务器组成，一个卷下的存储服务器中的文件都是相同的，卷中的多台存储服务器起到了冗余备份和负载均衡的作用。&lt;br&gt;
在卷中增加服务器时，同步已有的文件由系统自动完成，同步完成后，系统自动将新增服务器切换到线上提供服务。&lt;br&gt;
当存储空间不足或即将耗尽时，可以动态添加卷。只需要增加一台或多台服务器，并将它们配置为一个新的卷，这样就扩大了存储系统的容量。&lt;br&gt;
FastDFS 中的文件标识分为两个部分：卷名和文件名，二者缺一不可。&lt;/p&gt;
&lt;h3 id=&#34;11-架构图&#34;&gt;1.1 架构图&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200630172517.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;12-上传流程&#34;&gt;1.2 上传流程&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200630172540.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​	client 询问 tracker 上传到的 storage，不需要附加参数；&lt;br&gt;
​	tracker 返回一台可用的 storage；&lt;br&gt;
​	client 直接和 storage 通讯完成文件上传&lt;/p&gt;
&lt;h3 id=&#34;13-下载流程&#34;&gt;1.3 下载流程&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200630172732.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​	client 询问 tracker 下载文件的 storage，参数为文件标识（组名和文件名）；&lt;br&gt;
​	tracker 返回一台可用的 storage；&lt;br&gt;
​	client 直接和 storage 通讯完成文件下载。&lt;/p&gt;
&lt;h3 id=&#34;14-术语简介&#34;&gt;1.4 术语简介&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Tracker Server&lt;/strong&gt;：跟踪服务器，主要做调度工作，在访问上起负载均衡的作用。记录 storageserver 的状态，是连接 Client 和 Storage server 的枢纽。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Storage Server&lt;/strong&gt;：存储服务器，文件和 meta data 都保存到存储服务器上&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;group&lt;/strong&gt;：组，也称为卷。同组内服务器上的文件是完全相同的&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;文件标识&lt;/strong&gt;：包括两部分：组名和文件名（包含路径）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;meta data&lt;/strong&gt;：文件相关属性，键值对（Key Value Pair）方式，如：width=1024,heigth=768&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;15-同步机制&#34;&gt;1.5 同步机制&lt;/h3&gt;
&lt;p&gt;​	同一组内的 storage server 之间是对等的，文件上传、删除等操作可以在任意一台 storage server 上进行；&lt;br&gt;
​		文件同步只在同组内的 storage server 之间进行，采用 push 方式，即源服务器同步给目标服务器；&lt;br&gt;
​		源头数据才需要同步，备份数据不需要再次同步，否则就构成环路了；&lt;br&gt;
​		上述第二条规则有个例外，就是新增加一台storage server 时，由已有的一台storage server将已有的所有数据（包括源头数据和备份数据）同步给该新增服务器&lt;/p&gt;
&lt;h3 id=&#34;16-fastdfs-运行时目录结构&#34;&gt;1.6 FastDFS 运行时目录结构&lt;/h3&gt;
&lt;h4 id=&#34;161-tracker-server-目录&#34;&gt;1.6.1 Tracker Server 目录&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200630173335.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;162-storage-server-目录&#34;&gt;1.6.2 Storage Server 目录&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200630173358.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;17-fastdfs-和其他文件存储的简单对比&#34;&gt;1.7 FastDFS 和其他文件存储的简单对比&lt;/h3&gt;
&lt;h4 id=&#34;171-fastdfs-和集中存储方式对比&#34;&gt;1.7.1 FastDFS 和集中存储方式对比&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;指标&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;FastDFS&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;NFS&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;集中存储设备如 NetApp 、NAS&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;线性扩容性&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;高&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;差&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;差&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;文件高并发访问性能&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;高&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;差&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;一般&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;文件访问方式&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;专有 API&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;POSIX&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;支持 POSIX&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;硬件成本&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;较低&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;中等&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;高&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;相同内容文件只保存一份&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;支持&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;不支持&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;不支持&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;172-fastdfs-和-mogilefs-对比&#34;&gt;1.7.2 FastDFS 和 mogileFS 对比&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;指标&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;FastDFS&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;mogileFS&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;系统简洁性&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;简洁&lt;br/&gt;只有两个角色：tracker 和storage&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;一般&lt;br/&gt;有三个角色：tracker、storage和存储文件信息的 mysql db&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;系统性能&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;很高（没有使用数据库，文件同步直接点对点，不经过tracker 中转）&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;高（使用 mysql 来存储文件索 引 等 信 息 ， 文 件 同 步 通 过tracker 调度和中转）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;系统稳定性&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;高（C 语言开发，可以支持高并发和高负载）&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;一般（Perl 语言开发，高并发和高负载支持一般）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;RAID 方式&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;分组（组内冗余），灵活性较大&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;动态冗余，灵活性一般&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;通信协议&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;专有协议&lt;br/&gt;下载文件支持 HTTP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;HTTP&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;技术文档&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;较详细&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;较少&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;文 件 附 加 属 性（meta data）&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;支持&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;不支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;相同内容文件只保存一份&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;支持&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;不支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;下载文件时支持文件偏移量（断点续传）&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;支持&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;不支持&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;2-安装&#34;&gt;2、安装&lt;/h2&gt;
&lt;p&gt;准备两个 Linux 服务器。两个服务器分别作为 tracker 服务器（跟踪服务器）和 storage&lt;br&gt;
服务器（存储服务器）。&lt;br&gt;
Tracker 服务器 ： 192.168.2.109&lt;br&gt;
Storage 服务器 ： 192.168.2.110&lt;br&gt;
本次学习中，所有的安装包都存放在/root/upload 目录中。解压后的安装包根据具体命令查看。（/usr/local/fastdfs）&lt;/p&gt;
&lt;h3 id=&#34;21-核心安装&#34;&gt;2.1 核心安装&lt;/h3&gt;
&lt;p&gt;Tracker Server 和 Storage Server 完全一致的安装。&lt;br&gt;
安装 FastDFS 5.08 版本&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安装 FastDFS 依赖&lt;/p&gt;
&lt;p&gt;FastDFS 是 C 语言开发的应用。安装必须使用 make、cmake 和 gcc 编译器。&lt;br&gt;
yum install -y make cmake gcc gcc-c++&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解压 FastDFS 核心库&lt;/p&gt;
&lt;p&gt;libfastcommon 是从 FastDFS 和 FastDHT 中提取出来的公共 C 函数库&lt;br&gt;
cd /root/upload&lt;br&gt;
unzip libfastcommon-master.zip -d /usr/local/fastdfs&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进入解压后的目录&lt;/p&gt;
&lt;p&gt;cd /usr/local/fastdfs/libfastcommon-master&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编译安装&lt;/p&gt;
&lt;p&gt;libfastcommon 没有提供 make 命令安装文件。使用的是 shell 脚本执行编译和安装。shell脚本为 make.sh&lt;br&gt;
编译&lt;br&gt;
./make.sh&lt;br&gt;
安装&lt;br&gt;
./make.sh install&lt;br&gt;
有固定的默认安装位置。在/usr/lib64 和/usr/include/fastcommon 两个目录中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建软连接&lt;/p&gt;
&lt;p&gt;因为 FastDFS 主程序设置的 lib 目录是/usr/local/lib，所以需要创建软链接&lt;br&gt;
ln -s /usr/lib64/libfastcommon.so /usr/local/lib/libfastcommon.so&lt;br&gt;
ln -s /usr/lib64/libfastcommon.so /usr/lib/libfastcommon.so&lt;br&gt;
ln -s /usr/local/lib64/libfdfsclient.so /usr/local/lib/libfdfsclient.so&lt;br&gt;
ln -s /usr/local/lib64/libfdfsclient.so /usr/lib/libfdfsclient.so&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解压 FastDFS 主程序&lt;/p&gt;
&lt;p&gt;本案例使用 5.08 版本 FastDFS。&lt;br&gt;
cd /root/upload&lt;br&gt;
tar -zxf FastDFS_v5.08.tar.gz -C /usr/local/fastdfs&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进入 FastDFS 主程序源码目录&lt;/p&gt;
&lt;p&gt;cd /usr/local/fastdfs/FastDFS&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改安装路径&lt;/p&gt;
&lt;p&gt;此操作可选。在集群环境中使用默认安装路径安装。两种安装方式都尝试一下。&lt;br&gt;
vi /usr/local/fastdfs/FastDFS/make.sh&lt;br&gt;
TARGET_PREFIX=&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;D&lt;/mi&gt;&lt;mi&gt;E&lt;/mi&gt;&lt;mi&gt;S&lt;/mi&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mi&gt;D&lt;/mi&gt;&lt;mi&gt;I&lt;/mi&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;/&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mo&gt;&amp;gt;&lt;/mo&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mi&gt;G&lt;/mi&gt;&lt;mi&gt;E&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;/msub&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mi&gt;E&lt;/mi&gt;&lt;mi&gt;F&lt;/mi&gt;&lt;mi&gt;I&lt;/mi&gt;&lt;mi&gt;X&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;DESTDIR/usr -&amp;gt; TARGET_PREFIX=&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;D&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;D&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;I&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;G&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.32833099999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;F&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;I&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;DESTDIR/usr/local&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编译安装&lt;/p&gt;
&lt;p&gt;./make.sh&lt;br&gt;
./make.sh install&lt;br&gt;
安装后，FastDFS 主程序所在位置是：&lt;br&gt;
/usr/local/bin - 可执行文件所在位置。默认安装在/usr/bin 中。&lt;br&gt;
/etc/fdfs - 配置文件所在位置。就是默认位置。&lt;br&gt;
/usr/local/lib64 - 主程序代码所在位置。默认在/usr/bin 中。&lt;br&gt;
/usr/local/include/fastdfs - 包含的一些插件组所在位置。默认在/usr/include/fastdfs 中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FastDFS 安装后资源简介&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;服务脚本&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;/etc/init.d/目录中，脚本文件是 - fdfs-storaged 和 fdfs-trackerd&lt;br&gt;
ls /etc/init.d/ | grep fdfs&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;配置文件模板&lt;/p&gt;
&lt;p&gt;/etc/fdfs/ 目 录 中 ， 配 置 文 件 是 - client.conf.sample 、 storage.conf.sample 和tracker.conf.sample&lt;br&gt;
ls /etc/fdfs/&lt;br&gt;
tracker.conf.sample - 跟踪器服务配置文件模板&lt;br&gt;
storage.conf.sample - 存储服务器配置文件模板&lt;br&gt;
client.conf.sample - FastDFS 提供的命令行客户端配置文件模板。可以通过命令行测试FastDFS 有效性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内置命令&lt;/p&gt;
&lt;p&gt;/usr/local/bin/目录中。命令有若干。可通过命令在控制台访问 FastDFS。&lt;br&gt;
ls /usr/local/bin/ | grep fdfs&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200701105145.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;以上为通用安装，FastDFS 的跟踪服务和存储服务是通过配置实现的。后续内容为跟踪服务和存储服务的具体配置。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;22-tracker-基础配置&#34;&gt;2.2 tracker 基础配置&lt;/h3&gt;
&lt;p&gt;​	只在 tracker server 节点中配置。192.168.2.109&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建跟踪服务配置文件&lt;/p&gt;
&lt;p&gt;FastDFS 提供了配置文件模板，可以根据模板创建需要使用的配置文件。cd /etc/fdfs&lt;br&gt;
cp tracker.conf.sample tracker.conf&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改配置文件&lt;/p&gt;
&lt;p&gt;tracker.conf 配置文件用于描述跟踪服务的行为，需要进行下述修改：&lt;br&gt;
vi /etc/fdfs/tracker.conf&lt;br&gt;
port=22122 # 默认服务端口&lt;br&gt;
base_path=/home/yuqing/fastdfs -&amp;gt; base_path=/fastdfs/tracker（自定义目录）&lt;br&gt;
base_path 是 FastDFSTracker 启动后使用的根目录。也就是 data 和 logs 所在位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建自定义目录&lt;br&gt;
为配置文件中定义的 base_path 变量创建对应的目录。&lt;br&gt;
mkdir -p /fastdfs/tracker&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改启动服务脚本&lt;br&gt;
vi /etc/init.d/fdfs_trackerd&lt;br&gt;
将 PRG=/usr/bin/fdfs_trackerd 修改为 PRG=/usr/local/bin/fdfs_trackerd&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动服务&lt;br&gt;
/etc/init.d/fdfs_trackerd start&lt;br&gt;
启动成功后，配置文件中 base_path 指向的目录中出现 FastDFS 服务相关数据目录（data目录、logs 目录）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看服务状态&lt;br&gt;
/etc/init.d/fdfs_trackerd status&lt;br&gt;
ps aux | grep fdfs&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;停止服务&lt;br&gt;
/etc/init.d/fdfs_trackerd stop&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重启服务&lt;br&gt;
/etc/init.d/fdfs_trackerd restart&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置开启自启&lt;br&gt;
vi /etc/rc.d/rc.local&lt;br&gt;
新增内容 - /etc/init.d/fdfs_trackerd start&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;23-storage-基础配置&#34;&gt;2.3 storage 基础配置&lt;/h3&gt;
&lt;p&gt;只在 storage server 中配置。192.168.2.100&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建存储服务配置文件&lt;br&gt;
FastDFS 提供了配置文件模板，可以根据模板创建需要使用的配置文件。&lt;br&gt;
cd /etc/fdfs&lt;br&gt;
cp storage.conf.sample storage.conf&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改配置文件&lt;br&gt;
storage.conf 配置文件用于描述存储服务的行为，需要进行下述修改：&lt;br&gt;
vi /etc/fdfs/storage.conf&lt;br&gt;
&lt;strong&gt;base_path=/home/yuqing/fastdfs -&amp;gt; base_path=/fastdfs/storage/base （自定义目录）&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;store_path0=/home/yuqing/fastdfs -&amp;gt; store_path0=/fastdfs/storage/store（自定义目录）&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;tracker_server=192.168.2.109:22122 -&amp;gt; tracker_server=tracker 服务 IP:22122&lt;/strong&gt;&lt;br&gt;
base_path - 基础路径。用于保存 storage server 基础数据内容和日志内容的目录。&lt;br&gt;
store_path0 - 存储路径。是用于保存 FastDFS 中存储文件的目录，就是要创建 256*256个子目录的位置。&lt;br&gt;
base_path 和 store_path0 可以使用同一个目录。&lt;br&gt;
tracker_server - 跟踪服务器位置。就是跟踪服务器的 ip 和端口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建自定义目录&lt;br&gt;
mkdir -p /fastdfs/storage/base&lt;br&gt;
mkdir -p /fastdfs/storage/store&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改服务脚本&lt;br&gt;
vi /etc/init.d/fdfs_storaged&lt;br&gt;
将 PRG=/usr/bin/fdfs_storaged 修改为 PRG=/usr/local/bin/fdfs_storaged&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动服务（&lt;em&gt;要求 tracker 服务必须已启动&lt;/em&gt;）&lt;br&gt;
/etc/init.d/fdfs_storaged start&lt;br&gt;
启动成功后，配置文件中 base_path 指向的目录中出现 FastDFS 服务相关数据目录（data目录、logs 目录），配置文件中的 store_path0 指向的目录中同样出现 FastDFS 存储相关数据录（data 目录）。其中$store_path0/data/目录中默认创建若干子孙目录（两级目录层级总计 256&lt;em&gt;256 个目录），是用于存储具体文件数据的。&lt;br&gt;
Storage 服务器启动比较慢，因为第一次启动的时候，需要创建 256&lt;/em&gt;256 个目录。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看服务状态&lt;br&gt;
/etc/init.d/fdfs_storaged status&lt;br&gt;
ps aux | grep fdfs&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;停止服务&lt;br&gt;
/etc/init.d/fdfs_storaged stop&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重启服务&lt;br&gt;
/etc/init.d/fdfs_storaged restart&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置开机自启&lt;br&gt;
vi /etc/rc.d/rc.local&lt;br&gt;
新增内容 - /etc/init.d/fdfs_storaged start&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;因启动前提为 tracker 服务必须已启动，不推荐开启自启。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;24-客户端基础配置&#34;&gt;2.4 客户端基础配置&lt;/h3&gt;
&lt;p&gt;不是必须的。就是用于使用命令行测试 FastDFS 才需要配置的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建客户端配置文件&lt;br&gt;
在 tracker 服务结点所在服务器中配置客户端。同样通过配置文件模板创建对应配置文件。&lt;br&gt;
cd /etc/fdfs&lt;br&gt;
cp client.conf.sample client.conf&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改配置文件&lt;br&gt;
client.conf 配置文件中主要描述客户端的行为，需要进行下述修改：&lt;br&gt;
vi /etc/fdfs/client.conf&lt;br&gt;
&lt;strong&gt;base_path=/home/yuqing/fastdfs -&amp;gt; base_path=/fastdfs/client （自定义目录）&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;tracker_server=192.168.2.109:22122 -&amp;gt; tracker_server=tracker 服务 IP:22122&lt;/strong&gt;&lt;br&gt;
base_path - 就是客户端命令行执行过程时临时数据存储位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建自定义目录&lt;br&gt;
mkdir -p /fastdfs/client&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;25-控制台测试-fastdfs&#34;&gt;2.5 控制台测试 FastDFS&lt;/h3&gt;
&lt;p&gt;​		命令所在： /usr/local/bin 目录。 （如果在安装 FastDFS 过程中，没有修改 make.sh 文件中的 TARGET_PREFIX 属性值，命令所在为/usr/bin 目录）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;上传文件&lt;br&gt;
/usr/local/bin/fdfs_upload_file /etc/fdfs/client.conf /要上传的文件&lt;br&gt;
上传结束后，返回 group1/M00/00/00/xxxxxxxxxx.xxx ，检查 storage 服务结点中的&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;/msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;/&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;/&lt;/mi&gt;&lt;mn&gt;00&lt;/mn&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;/&lt;/mi&gt;&lt;mn&gt;00&lt;/mn&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;/&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;目&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;录&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;中&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;是&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;否&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;有&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;上&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;传&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;文&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;件&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;（&lt;/mi&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;一&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;般&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;情&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;况&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;上&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;传&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;文&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;件&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;按&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;顺&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;序&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;保&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;存&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;在&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;store_path0/data/00/00/目录中是否有上传的文件（**一般情况上传的文件按顺序保存在&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.036108em;vertical-align:-0.286108em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15139200000000003em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;p&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.286108em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;目&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;录&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;中&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;是&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;否&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;有&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;上&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;传&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;的&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;文&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;件&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;（&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.46528em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;一&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;般&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;情&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;况&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;上&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;传&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;的&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;文&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;件&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;按&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;顺&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;序&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;保&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;存&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;在&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;store_path0/data/00/00/目录中，不能完全保证**）。&lt;br&gt;
本次 测 试 的 上 传 文 件 结 果 ：group1/M00/00/00/wKgCbltTYaeACDWgAAVCLEPUQWI.tar.gz&lt;br&gt;
卷名 ： group1&lt;br&gt;
文件名 ： M00/00/00/wKgCbltTYaeACDWgAAVCLEPUQWI.tar.gz&lt;br&gt;
其中 M00 是一个虚拟目录，相当于 windows 中的快捷方式，引用的是$store_path0/data目录。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除文件&lt;br&gt;
/usr/local/bin/fdfs_delete_file /etc/fdfs/client.conf group1/M00/00/00/xxxxxxx.xxx&lt;br&gt;
删除结束后，检查$store_path0/data/00/00/目录中是否还有文件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;26-安装-nginx-组件&#34;&gt;2.6 安装 Nginx 组件&lt;/h3&gt;
&lt;p&gt;​		如果 FastDFS 中保存的是图片信息。希望在 WEB 应用中可以直接访问 FastDFS 中的图片进行显示。如果操作？&lt;br&gt;
​		安装 Nginx 是为了 WEB 应用中可以使用 HTTP 协议直接访问 Storage 服务中存储的文件。在 storage 结点所在服务器安装 Nginx 组件。&lt;br&gt;
​		需要安装两部分内容。&lt;br&gt;
Nginx 应用，在安装 nginx 应用的时候，同时要在 nginx 中增加一个 FastDFS 的组件。Module。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;解压 fastdfs-nginx-module_v1.16.tar.gz&lt;/p&gt;
&lt;p&gt;tar -zxf fastdfs-nginx-module_v1.16.tar.gz -C /usr/local/fastdfs&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 fastdfs-nginx-module_v1.16.tar.gz 源文件中的配置&lt;/p&gt;
&lt;p&gt;&lt;em&gt;此操作必须修改，否则 Nginx 编译会报错。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;cd /usr/local/fastdfs/fastdfs-nginx-module/src&lt;br&gt;
vi /usr/local/fastdfs/fastdfs-nginx-module/src/config&lt;br&gt;
参数是用于配置安装 nginx 中的 FastDFS 组件的时候，在什么位置查找 FastDFS 核心代码。&lt;/p&gt;
&lt;p&gt;源数据：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;ngx_addon_name=ngx_http_fastdfs_module
HTTP_MODULES=&amp;quot;$HTTP_MODULES ngx_http_fastdfs_module&amp;quot;
NGX_ADDON_SRCS=&amp;quot;$NGX_ADDON_SRCS
$ngx_addon_dir/ngx_http_fastdfs_module.c&amp;quot;
CORE_INCS=&amp;quot;$CORE_INCS /usr/local/include/fastdfs /usr/local/include/fastcommon/&amp;quot;
CORE_LIBS=&amp;quot;$CORE_LIBS -L/usr/local/lib -lfastcommon -lfdfsclient&amp;quot;
CFLAGS=&amp;quot;$CFLAGS -D_FILE_OFFSET_BITS=64
-DFDFS_OUTPUT_CHUNK_SIZE=&#39;256*1024&#39;
-DFDFS_MOD_CONF_FILENAME=&#39;\&amp;quot;/etc/fdfs/mod_fastdfs.conf\&amp;quot;&#39;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修 改 后 内 容 ： （ 如 果 安 装 FastDFS 时 ， 没 有 修 改 make.sh 文 件 ， 则 改 为 ：CORE_INCS=&amp;quot;$CORE_INCS /usr/include/fastdfs /usr/include/fastcommon/&amp;quot;）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;ngx_addon_name=ngx_http_fastdfs_module
HTTP_MODULES=&amp;quot;$HTTP_MODULES ngx_http_fastdfs_module&amp;quot;
NGX_ADDON_SRCS=&amp;quot;$NGX_ADDON_SRCS
$ngx_addon_dir/ngx_http_fastdfs_module.c&amp;quot;
CORE_INCS=&amp;quot;$CORE_INCS /usr/local/include/fastdfs /usr/include/fastcommon/&amp;quot;
CORE_LIBS=&amp;quot;$CORE_LIBS -L/usr/local/lib -lfastcommon -lfdfsclient&amp;quot;
CFLAGS=&amp;quot;$CFLAGS -D_FILE_OFFSET_BITS=64
-DFDFS_OUTPUT_CHUNK_SIZE=&#39;256*1024&#39;
-DFDFS_MOD_CONF_FILENAME=&#39;\&amp;quot;/etc/fdfs/mod_fastdfs.conf\&amp;quot;&#39;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;安装 Nginx&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安装 Nginx 需要的依赖&lt;br&gt;
yum install -y gcc gcc-c++ make automake autoconf libtool pcre pcre-devel   zlib zlib-devel openssl openssl-devel&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 SFTP 上传文件到 Linux&lt;br&gt;
进入到本地的应用所在目录。&lt;br&gt;
cd /xxxx 目录&lt;br&gt;
sftp 192.168.2.110&lt;br&gt;
输入用户名和密码。使用哪一个用户登录，上传的文件就在该用户对应的主目录下。如：root 用户，上传的文件在/root 目录中。&lt;/p&gt;
&lt;p&gt;上传的命令：&lt;br&gt;
put 文件名&lt;br&gt;
下载的命令：&lt;br&gt;
get 文件名&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解压 Nginx&lt;br&gt;
tar -zxf nginx-1.8.0.tar.gz -C /usr/local/fastdfs/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进入 Nginx 源码目录&lt;br&gt;
cd /usr/local/fastdfs/nginx-1.8.0/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置 Nginx 安装信息&lt;br&gt;
./configure &lt;br&gt;
--prefix=/usr/local/nginx &lt;br&gt;
--pid-path=/var/run/nginx/nginx.pid &lt;br&gt;
--lock-path=/var/lock/nginx.lock &lt;br&gt;
--error-log-path=/var/log/nginx/error.log &lt;br&gt;
--http-log-path=/var/log/nginx/access.log &lt;br&gt;
--with-http_gzip_static_module &lt;br&gt;
--http-client-body-temp-path=/var/temp/nginx/client &lt;br&gt;
--http-proxy-temp-path=/var/temp/nginx/proxy &lt;br&gt;
--http-fastcgi-temp-path=/var/temp/nginx/fastcgi &lt;br&gt;
--http-uwsgi-temp-path=/var/temp/nginx/uwsgi &lt;br&gt;
--http-scgi-temp-path=/var/temp/nginx/scgi &lt;br&gt;
&lt;em&gt;&lt;strong&gt;--add-module=/usr/local/fastdfs/fastdfs-nginx-module/src&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;
&lt;em&gt;&lt;strong&gt;--add-module 必须定义，此配置信息是用于指定安装 Nginx 时需要加载的模块，如果未指定，Nginx 安装过程不会加载 fastdfs-nginx-module 模块，后续功能无法实现。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建目录&lt;br&gt;
Nginx 运行时需要创建若干临时文件，如果默认安装不需创建此目录。&lt;br&gt;
mkdir -p /var/temp/nginx&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编译安装&lt;br&gt;
make&lt;br&gt;
make install&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置 fastdfs-nginx-module 模块配置文件&lt;br&gt;
复制配置文件/usr/local/fastdfs/fastdfs-nginx-module/src/mod_fastdfs.conf 到/etc/fdfs 目录中&lt;/p&gt;
&lt;p&gt;cp /usr/local/fastdfs/fastdfs-nginx-module/src/mod_fastdfs.conf /etc/fdfs/&lt;br&gt;
cd /etc/fdfs/&lt;br&gt;
修改配置文件 mod_fastdfs.conf&lt;br&gt;
vi mod_fastdfs.conf&lt;br&gt;
源配置：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;connect_timeout=2 #连接超时时间，单位秒
tracker_server=tracker:22122 #tracker 服务结点
url_have_group_name = false #URL 中是否包含 group 名称
store_path0=/home/yuqing/fastdfs # storage 服务结点的存储位置，与配置 storage 结点一致
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参考修改值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;connect_timeout=10
tracker_server=192.168.2.109:22122
url_have_group_name = true
store_path0=/fastdfs/storage/store
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;9&#34;&gt;
&lt;li&gt;
&lt;p&gt;提供 FastDFS 需要的 HTTP 配置文件&lt;br&gt;
复制 FastDFS 安装包中的两个配置文件（http.conf 和 mime.types）到/etc/fdfs 目录中&lt;br&gt;
cp /usr/local/fastdfs/FastDFS/conf/http.conf /etc/fdfs/&lt;br&gt;
cp /usr/local/fastdfs/FastDFS/conf/mime.types /etc/fdfs/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建 nginx 启动需要的软连接&lt;br&gt;
创建软连接&lt;br&gt;
ln -s /usr/local/lib64/libfdfsclient.so /usr/lib64/libfdfsclient.so&lt;br&gt;
nginx 启动后，会在默认的/usr/lib64 目录中查找需要的 so 文件。如果在安装 FastDFS时，修改了 make.sh 文件中的 TARGET_PREFIX 参数，则必须创建此软连接&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建网络访问存储服务的软连接&lt;br&gt;
ln -s /fastdfs/storage/store/data/ /fastdfs/storage/store/data/M00&lt;br&gt;
在上传文件到 FastDFS 后，FastDFS 会返回 group1/M00/00/00/xxxxxxxxxx.xxx。其中group1 是卷名，在 mod_fastdfs.conf 配置文件中已配置了 url_have_group_name，以保证 URL解析正确。而其中的 M00 是 FastDFS 保存数据时使用的虚拟目录，需要将这个虚拟目录定位到真实数据目录上。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 nginx 配置文件&lt;br&gt;
cd /usr/local/nginx/conf&lt;br&gt;
vi nginx.conf&lt;br&gt;
参考修改配置：（部分配置信息，不要完整复制）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;user root; # Nginx 需要访问 linux 文件系统，必须有文件系统的权限。User root 代表nginx 访问文件系统的权限是 root 用户权限。如果不开启权限，可能有 404 访问错误。
server{
listen 8888; # storage 配置中，有 http.server_port=8888 的配置信息，必须一致。配置文件是/etc/fdfs/storaged.conf
server_name localhost;
location ~/group([0-9])/M00{
ngx_fastdfs_module;
}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;测试 WEB 访问存储服务中的文件&lt;br&gt;
使用浏览器查看 FastDFS 中保存的文件：&lt;br&gt;
http://ip:8888/group1/M00/00/00/x xxxxxx.xxx&lt;br&gt;
测试上传的文件： group1/M00/00/00/wKgCbltTmv-ASTG2AAAmTx4ns0s172.jpg&lt;br&gt;
测试 WEB 访问地址：&lt;br&gt;
http://192.168.2.110:8888/group1/M00/00/00/wKgCbltTmv-ASTG2AAAmTx4ns0s172.jpg&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-java-客户端-api-简单应用&#34;&gt;3、 Java 客户端 API 简单应用&lt;/h2&gt;
&lt;h3 id=&#34;31-依赖&#34;&gt;3.1 依赖&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;cn.bestwu&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;fastdfs-client-java&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;1.27&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;org.apache.commons&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;commons-lang3&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;3.4&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;commons-io&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;commons-io&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;2.4&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;32-创建客户端&#34;&gt;3.2 创建客户端&lt;/h3&gt;
&lt;h4 id=&#34;321-根据-conf-文件创建客户端&#34;&gt;3.2.1 根据 conf 文件创建客户端&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;conf 配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 配置连接超时
connect_timeout=10
# 网络工作的超时， 一次连接的超时时长。
network_timeout=30
# 连接中的使用字符集
charset=UTF-8
# tracker的http协议端口，和FastDFS中的tracker服务的配置文件tracker.conf中的http.server_port一致
http.tracker_http_port=8080

# tracker服务器的所在地址。 就是IP：port
tracker_server=192.168.89.152:22122
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TestInitClient {

    public static void main(String[] args) {
        // 创建FastDFS  Java 客户端。
        try {
            // 加载客户端配置文件，就是刚定义的conf配置文件。
            ClientGlobal.init(&amp;quot;src/main/resources/test/fdfs.conf&amp;quot;);

            // 创建Tracker服务器的客户端连接对象。 无参构造其中默认会调用一个有参构造
            // new TrackerClient(TrackerGlobal.g_tracker_group), 绑定tracker服务器的IP地址和端口。
            // 绑定配置文件中的tracker_server属性信息。
            TrackerClient trackerClient = new TrackerClient();
            // 通过Tracker客户端对象，获取Tracker服务端对象。
            TrackerServer trackerServer = trackerClient.getConnection();
            // 通过Tracker客户端和服务端对象，获取Storage服务端对象。
            StorageServer storageServer = trackerClient.getStoreStorage(trackerServer);
            // 通过Tracker服务端对象和Storage服务端对象，来创建Storage客户端访问对象，实现文件的上传和下载。
            // 最终使用的，用于文件处理的对象。
            StorageClient storageClient = new StorageClient(trackerServer, storageServer);

            System.out.println(&amp;quot;trackerClient : &amp;quot; + trackerClient);
            System.out.println(&amp;quot;trackerServer : &amp;quot; + trackerServer);
            System.out.println(&amp;quot;storageServer : &amp;quot; + storageServer);
            System.out.println(&amp;quot;storageClient : &amp;quot; + storageClient);
        }catch(IOException e1){ // 配置文件找不到之类的 IO异常。
            e1.printStackTrace();
        }catch(MyException e2){ // FastDFS 的java客户端API定义的自定义异常。
            // 如：tracker服务器连接错误， Storage服务器连接错误
            e2.printStackTrace();
        }
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;322-根据-properties-文件创建客户端&#34;&gt;3.2.2 根据 properties 文件创建客户端&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;properties 配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;# 连接超时
fastdfs.connect_timeout_in_seconds=10
# 网络超时
fastdfs.network_timeout_in_seconds=30
# 连接的字符集
fastdfs.charset=UTF-8
# tracker服务器的配置文件中的http端口配置
fastdfs.http_tracker_http_port=8080

# tracker服务器的IP：端口
fastdfs.tracker_servers=192.168.89.152:22122
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TestInitClientByProperties {
    public static void main(String[] args) {
        // 加载properties配置文件
        Properties properties = new Properties();
        try {
            properties.load(TestInitClientByProperties.class.getClassLoader().getResourceAsStream(&amp;quot;test/fdfs.properties&amp;quot;));
        }catch (IOException e){
            e.printStackTrace();
            System.out.println(&amp;quot;Properties配置文件加载错误&amp;quot;);
            return;
        }

        try{
            // 通过ClientGlobal对象加载配置内容
            ClientGlobal.initByProperties(properties);

            TrackerClient trackerClient = new TrackerClient(ClientGlobal.g_tracker_group);
            TrackerServer trackerServer = trackerClient.getConnection();
            StorageServer storageServer = trackerClient.getStoreStorage(trackerServer);
            StorageClient storageClient = new StorageClient(trackerServer, storageServer);

            System.out.println(&amp;quot;trackerClient : &amp;quot; + trackerClient);
            System.out.println(&amp;quot;trackerServer : &amp;quot; + trackerServer);
            System.out.println(&amp;quot;storageServer : &amp;quot; + storageServer);
            System.out.println(&amp;quot;storageClient : &amp;quot; + storageClient);
        }catch(IOException e1){
            e1.printStackTrace();
        }catch(MyException e2){
            e2.printStackTrace();
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;33-定义fastdfs-工具类&#34;&gt;3.3  定义FastDFS 工具类&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.cy.fdfs.test;

import org.csource.fastdfs.*;

public class FastDFSClientUtils {
    // 定义FastDFS配置文件地址路径
    private static final String configFile = &amp;quot;src/main/resources/test/fdfs.conf&amp;quot;;
    // 要使用的FastDFS客户端对象。
    private static StorageClient storageClient;
    private static TrackerClient trackerClient;
    private static TrackerServer trackerServer;
    private static StorageServer storageServer;

    static{
        // 初始化代码块， 初始化需要使用的客户端对象。
        try {
            ClientGlobal.init(configFile);
            trackerClient = new TrackerClient();
            trackerServer = trackerClient.getConnection();
            storageServer = trackerClient.getStoreStorage(trackerServer);
            storageClient = new StorageClient(trackerServer, storageServer);
        }catch(Exception e){
            e.printStackTrace();
            // 初始化错误。
            throw new ExceptionInInitializerError(e);
        }
    }

    // 获取Storage客户端对象的方法。 工具方法。
    public static StorageClient getStorageClient(){
        return storageClient;
    }

    public static void main(String[] args) {
        StorageClient storageClient = FastDFSClientUtils.getStorageClient();
        System.out.println(&amp;quot;storageClient : &amp;quot; + storageClient);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;34-文件上传&#34;&gt;3.4 文件上传&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;代码&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.cy.fdfs.test;

import org.csource.common.MyException;
import org.csource.common.NameValuePair;
import org.csource.fastdfs.StorageClient;

import java.io.IOException;

// 文件上传到FastDFS
public class TestUpload {

    public static void main(String[] args) {
        // 获取Storage客户端对象
        StorageClient storageClient = FastDFSClientUtils.getStorageClient();

        // 准备上传文件需要的信息
        String local_file = &amp;quot;testFile/1.jpg&amp;quot;;
        String ext_file_name = &amp;quot;jpg&amp;quot;;
        NameValuePair[] meta_list = new NameValuePair[]{
                new NameValuePair(&amp;quot;fileName&amp;quot;, &amp;quot;1.jpg&amp;quot;),
                new NameValuePair(&amp;quot;uploadUser&amp;quot;, &amp;quot;cy&amp;quot;)
        };

        // 上传文件到FastDFS
        /*
         * String[] upload_file(String local_file, String ext_file_name, NameValuePair[] meta_list);
         * local_file - 要上传的本地文件的地址
         * ext_file_name - 要上传的文件的后缀名。FastDFS使用uuid管理上传的文件命名，需要提供文件的后缀名。
         * meta_list - 要上传的文件的元数据。如：文件的原始名称，文件的大小，文件的创建者等。
         *   可有可无的，如果不需要FastDFS记录，则传递null即可。
         *
         * 返回值：返回上传后的文件在FastDFS中的卷名和文件名。 如：group1 , 00/00/xxxxx.jpg
         */
        String[] fileIds = null;
        try{
            fileIds = storageClient.upload_file(local_file, ext_file_name, meta_list);
        }catch(IOException e){
            e.printStackTrace();
        }catch(MyException e){
            e.printStackTrace();
        }

        // 解析上传的结果
        System.out.println(&amp;quot;返回字符串数组长度 - &amp;quot; + fileIds.length);
        System.out.println(&amp;quot;0下标位置 - &amp;quot; + fileIds[0]);
        System.out.println(&amp;quot;1下标位置 - &amp;quot; + fileIds[1]);

    }

}

&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200701151511.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;35-文件下载&#34;&gt;3.5 文件下载&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;代码&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.cy.fdfs.test;

import org.apache.commons.io.IOUtils;
import org.csource.common.MyException;
import org.csource.common.NameValuePair;
import org.csource.fastdfs.StorageClient;

import java.io.FileOutputStream;
import java.io.IOException;

// 下载文件
public class TestDownload {
    public static void main(String[] args) {
        // 获取Storage客户端对象
        StorageClient storageClient = FastDFSClientUtils.getStorageClient();

        // 准备下载文件的信息资源
        String groupName = &amp;quot;group1&amp;quot;;
        String remoteFileName = &amp;quot;M00/00/00/wKhZmV2m1tiAFtwTAADW-MWxcrw364.jpg&amp;quot;;

        // 下载文件
        /*
         * byte[] download_file(String group_name, String remote_file_name);
         * group_name - 要下载的文件的卷名
         * remote_file_name - 要下载的文件的远程名称，就是FastDFS服务器中的文件名称。
         * 返回值：就是要下载的文件的字节数组。
         */
        byte[] datas = null;
        try{
            datas = storageClient.download_file(groupName,remoteFileName);
        }catch (IOException e){
            e.printStackTrace();
        }catch (MyException e){
            e.printStackTrace();
        }

        // 查询要下载的文件的元数据，获取文件的原始名称，作为下载文件的文件名。
        /*
         * NameValuePair[] get_metadata(String group_name, String remote_file_name)
         * group_name - 要获取元数据的文件的卷名
         * remote_file_name - 要获取元数据的文件的远程文件名
         * 返回值：文件的元数据数组。
         */
        NameValuePair[] metaList = null;
        try{
            metaList = storageClient.get_metadata(groupName, remoteFileName);
        }catch(IOException e){
            e.printStackTrace();
        }catch (MyException e){
            e.printStackTrace();
        }

        String fileName = &amp;quot;&amp;quot;;
        for(NameValuePair nvp : metaList){
            if(nvp.getName().equals(&amp;quot;fileName&amp;quot;)){
                fileName = nvp.getValue();
            }
        }

        // 处理下载后的数据信息
        try{
            IOUtils.write(datas, new FileOutputStream(&amp;quot;downloadFile/&amp;quot;+fileName));
        }catch(IOException e){
            e.printStackTrace();
        }

        System.out.println(&amp;quot;文件下载成功，下载文件名称是：&amp;quot; + fileName);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200701151636.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;36-删除文件&#34;&gt;3.6 删除文件&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.cy.fdfs.test;

import org.csource.common.MyException;
import org.csource.fastdfs.StorageClient;

import java.io.IOException;

// 删除文件
public class TestDelete {
    public static void main(String[] args) {
        // 获取Storage客户端对象
        StorageClient storageClient = FastDFSClientUtils.getStorageClient();

        // 准备要删除的文件的信息
        String groupName = &amp;quot;group1&amp;quot;;
        String remoteFileName = &amp;quot;M00/00/00/wKhZmV2m1tiAFtwTAADW-MWxcrw364.jpg&amp;quot;;

        // 删除文件
        /*
         * int delete_file(String group_name, String remote_file_name)
         * group_name - 要删除的文件的卷名
         * remote_file_name - 要删除的文件的文件名，FastDFS中的文件名。
         * 返回值： 是否删除文件成功。 0 代表删除成功， 其他代表删除失败。
         */
        int flag = 0;
        try{
            flag = storageClient.delete_file(groupName, remoteFileName);
        }catch(IOException e){
            e.printStackTrace();
        }catch (MyException e){
            e.printStackTrace();
        }

        // 处理删除结果
        System.out.println(flag == 0 ? &amp;quot;删除文件成功&amp;quot; : &amp;quot;删除文件失败&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;结果&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200701151758.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;4-web-应用中使用-fastdfs&#34;&gt;4、WEB 应用中使用 FastDFS&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200701154535.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;41-依赖&#34;&gt;4.1 依赖&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot;
         xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
         xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;fdfs&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;packaging&amp;gt;war&amp;lt;/packaging&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;cn.bestwu&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;fastdfs-client-java&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.27&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;4.12&amp;lt;/version&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!-- MyBatis --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;3.4.6&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!-- mybatis整合spring插件 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mybatis-spring&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.3.1&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!-- mysql数据库驱动 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;5.1.39&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;5.0.6.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;5.0.6.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-jdbc&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;5.0.6.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-tx&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;5.0.6.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-aspects&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;5.0.6.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;jstl&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.2&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;servlet-api&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.5&amp;lt;/version&amp;gt;
            &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;javax.servlet.jsp&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;jsp-api&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.2&amp;lt;/version&amp;gt;
            &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.github.pagehelper&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;pagehelper&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;4.1.6&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;jackson-databind&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.9.5&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.commons&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;commons-lang3&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;3.4&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;commons-io&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;commons-io&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.4&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;commons-fileupload&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;commons-fileupload&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.3.1&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
    &amp;lt;build&amp;gt;
        &amp;lt;pluginManagement&amp;gt;
            &amp;lt;plugins&amp;gt;
                &amp;lt;plugin&amp;gt;
                    &amp;lt;groupId&amp;gt;org.apache.tomcat.maven&amp;lt;/groupId&amp;gt;
                    &amp;lt;artifactId&amp;gt;tomcat7-maven-plugin&amp;lt;/artifactId&amp;gt;
                    &amp;lt;version&amp;gt;2.2&amp;lt;/version&amp;gt;
                &amp;lt;/plugin&amp;gt;
            &amp;lt;/plugins&amp;gt;
        &amp;lt;/pluginManagement&amp;gt;

        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.apache.tomcat.maven&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;tomcat7-maven-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;configuration&amp;gt;
                    &amp;lt;port&amp;gt;80&amp;lt;/port&amp;gt;
                    &amp;lt;path&amp;gt;/&amp;lt;/path&amp;gt;
                &amp;lt;/configuration&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;

&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;42-数据库建模&#34;&gt;4.2 数据库建模&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;drop table if exists t_files;

create table t_files(
    id bigint not null auto_increment,
    file_name varchar(255), -- 文件的原始名称
    group_name varchar(32), -- 文件在FastDFS中的卷名
    remote_file_name varchar(255), -- 文件在FastDFS中的文件名， UUID
    file_path varchar(255), -- 文件在FastDFS中的路径， 就是卷名+远程文件名
    primary key(id)
);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;43-fastdfs-配置&#34;&gt;4.3 FastDFS 配置&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;connect_timeout = 10
network_timeout = 30
charset = UTF-8
http.tracker_http_port = 8080
tracker_server = 192.168.89.152:22122
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;44-spring-配置&#34;&gt;4.4 Spring 配置&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
       xmlns:mvc=&amp;quot;http://www.springframework.org/schema/mvc&amp;quot;
       xmlns:tx=&amp;quot;http://www.springframework.org/schema/tx&amp;quot;
       xmlns:aop=&amp;quot;http://www.springframework.org/schema/aop&amp;quot;
       xmlns:context=&amp;quot;http://www.springframework.org/schema/context&amp;quot;
       xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/mvc
        http://www.springframework.org/schema/mvc/spring-mvc.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd&amp;quot;&amp;gt;

    &amp;lt;mvc:annotation-driven/&amp;gt;

    &amp;lt;context:component-scan base-package=&amp;quot;com.cy&amp;quot;&amp;gt;&amp;lt;/context:component-scan&amp;gt;

    &amp;lt;!-- 文件上传的转换器 --&amp;gt;
    &amp;lt;bean id=&amp;quot;multipartResolver&amp;quot; class=&amp;quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&amp;quot;&amp;gt;
        &amp;lt;!-- 限制文件上传大小 --&amp;gt;
        &amp;lt;property name=&amp;quot;maxUploadSize&amp;quot; value=&amp;quot;2048000&amp;quot; /&amp;gt;
        &amp;lt;!-- 内存缓存大小 --&amp;gt;
        &amp;lt;property name=&amp;quot;maxInMemorySize&amp;quot; value=&amp;quot;2048&amp;quot; /&amp;gt;
        &amp;lt;!-- 处理文本文件的字符集 --&amp;gt;
        &amp;lt;property name=&amp;quot;defaultEncoding&amp;quot; value=&amp;quot;UTF-8&amp;quot; /&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!-- 连接池数据源 --&amp;gt;
    &amp;lt;bean id=&amp;quot;dataSource&amp;quot; class=&amp;quot;org.springframework.jdbc.datasource.DriverManagerDataSource&amp;quot;&amp;gt;
        &amp;lt;property name=&amp;quot;driverClassName&amp;quot; value=&amp;quot;com.mysql.jdbc.Driver&amp;quot;/&amp;gt;
        &amp;lt;property name=&amp;quot;url&amp;quot; value=&amp;quot;jdbc:mysql://localhost:3306/fdfsfile&amp;quot; /&amp;gt;
        &amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;root&amp;quot; /&amp;gt;
        &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;root&amp;quot; /&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!-- 会话工厂 --&amp;gt;
    &amp;lt;bean id=&amp;quot;sqlSessionFactory&amp;quot; class=&amp;quot;org.mybatis.spring.SqlSessionFactoryBean&amp;quot;&amp;gt;
        &amp;lt;property name=&amp;quot;dataSource&amp;quot; ref=&amp;quot;dataSource&amp;quot;/&amp;gt;
        &amp;lt;property name=&amp;quot;mapperLocations&amp;quot;&amp;gt;
            &amp;lt;array&amp;gt;
                &amp;lt;value&amp;gt;classpath:com/cy/mapper/*.xml&amp;lt;/value&amp;gt;
            &amp;lt;/array&amp;gt;
        &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!-- Mapper工厂 --&amp;gt;
    &amp;lt;bean class=&amp;quot;org.mybatis.spring.mapper.MapperScannerConfigurer&amp;quot;&amp;gt;
        &amp;lt;property name=&amp;quot;sqlSessionFactoryBeanName&amp;quot; value=&amp;quot;sqlSessionFactory&amp;quot; /&amp;gt;
        &amp;lt;property name=&amp;quot;basePackage&amp;quot; value=&amp;quot;com.cy.mapper&amp;quot; /&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!-- 事务管理器 --&amp;gt;
    &amp;lt;bean id=&amp;quot;transactionManager&amp;quot; class=&amp;quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&amp;quot;&amp;gt;
        &amp;lt;property name=&amp;quot;dataSource&amp;quot; ref=&amp;quot;dataSource&amp;quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!-- 事务通知 --&amp;gt;
    &amp;lt;tx:advice id=&amp;quot;txAdvice&amp;quot; transaction-manager=&amp;quot;transactionManager&amp;quot;&amp;gt;
        &amp;lt;tx:attributes&amp;gt;
            &amp;lt;tx:method name=&amp;quot;*&amp;quot; propagation=&amp;quot;REQUIRED&amp;quot; isolation=&amp;quot;DEFAULT&amp;quot;
            rollback-for=&amp;quot;java.lang.Exception&amp;quot;/&amp;gt;
        &amp;lt;/tx:attributes&amp;gt;
    &amp;lt;/tx:advice&amp;gt;

    &amp;lt;!-- 事务切面 --&amp;gt;
    &amp;lt;aop:config&amp;gt;
        &amp;lt;aop:advisor advice-ref=&amp;quot;txAdvice&amp;quot; pointcut=&amp;quot;execution( * com.cy.service.*.*(..))&amp;quot;/&amp;gt;
    &amp;lt;/aop:config&amp;gt;

&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;web.xml 配置&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;web-app xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
         xmlns=&amp;quot;http://java.sun.com/xml/ns/javaee&amp;quot;
         xsi:schemaLocation=&amp;quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&amp;quot;
         id=&amp;quot;WebApp_ID&amp;quot; version=&amp;quot;2.5&amp;quot;&amp;gt;

    &amp;lt;welcome-file-list&amp;gt;
        &amp;lt;welcome-file&amp;gt;/index&amp;lt;/welcome-file&amp;gt;
    &amp;lt;/welcome-file-list&amp;gt;
    
    &amp;lt;filter&amp;gt;
        &amp;lt;filter-name&amp;gt;charsetFilter&amp;lt;/filter-name&amp;gt;
        &amp;lt;filter-class&amp;gt;org.springframework.web.filter.CharacterEncodingFilter&amp;lt;/filter-class&amp;gt;
        &amp;lt;init-param&amp;gt;
            &amp;lt;param-name&amp;gt;encoding&amp;lt;/param-name&amp;gt;
            &amp;lt;param-value&amp;gt;UTF-8&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;
    &amp;lt;/filter&amp;gt;
    &amp;lt;filter-mapping&amp;gt;
        &amp;lt;filter-name&amp;gt;charsetFilter&amp;lt;/filter-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/filter-mapping&amp;gt;

    &amp;lt;servlet&amp;gt;
        &amp;lt;servlet-name&amp;gt;mvc&amp;lt;/servlet-name&amp;gt;
        &amp;lt;servlet-class&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt;
        &amp;lt;init-param&amp;gt;
            &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
            &amp;lt;param-value&amp;gt;classpath:applicationContext.xml&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;
        &amp;lt;load-on-startup&amp;gt;0&amp;lt;/load-on-startup&amp;gt;
    &amp;lt;/servlet&amp;gt;
    &amp;lt;servlet-mapping&amp;gt;
        &amp;lt;servlet-name&amp;gt;mvc&amp;lt;/servlet-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/servlet-mapping&amp;gt;
    
&amp;lt;/web-app&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;FastDFS 工具类定义&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.cy.fdfs.test;

import org.csource.fastdfs.*;

public class FastDFSClientUtils {
    // 定义FastDFS配置文件地址路径
    private static final String configFile = &amp;quot;src/main/resources/test/fdfs.conf&amp;quot;;
    // 要使用的FastDFS客户端对象。
    private static StorageClient storageClient;
    private static TrackerClient trackerClient;
    private static TrackerServer trackerServer;
    private static StorageServer storageServer;

    static{
        // 初始化代码块， 初始化需要使用的客户端对象。
        try {
            ClientGlobal.init(configFile);
            trackerClient = new TrackerClient();
            trackerServer = trackerClient.getConnection();
            storageServer = trackerClient.getStoreStorage(trackerServer);
            storageClient = new StorageClient(trackerServer, storageServer);
        }catch(Exception e){
            e.printStackTrace();
            // 初始化错误。
            throw new ExceptionInInitializerError(e);
        }
    }

    // 获取Storage客户端对象的方法。 工具方法。
    public static StorageClient getStorageClient(){
        return storageClient;
    }

    public static void main(String[] args) {
        StorageClient storageClient = FastDFSClientUtils.getStorageClient();
        System.out.println(&amp;quot;storageClient : &amp;quot; + storageClient);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;47-实体类型&#34;&gt;4.7  实体类型&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.cy.entity;

import java.io.Serializable;
import java.util.Objects;

// 文件相关信息的实体类
public class FileInfo implements Serializable {
    private Long id;
    private String fileName;
    private String groupName;
    private String remoteFileName;
    private String filePath;

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        FileInfo fileInfo = (FileInfo) o;
        return Objects.equals(id, fileInfo.id) &amp;amp;&amp;amp;
                Objects.equals(fileName, fileInfo.fileName) &amp;amp;&amp;amp;
                Objects.equals(groupName, fileInfo.groupName) &amp;amp;&amp;amp;
                Objects.equals(remoteFileName, fileInfo.remoteFileName) &amp;amp;&amp;amp;
                Objects.equals(filePath, fileInfo.filePath);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id, fileName, groupName, remoteFileName, filePath);
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getFileName() {
        return fileName;
    }

    public void setFileName(String fileName) {
        this.fileName = fileName;
    }

    public String getGroupName() {
        return groupName;
    }

    public void setGroupName(String groupName) {
        this.groupName = groupName;
    }

    public String getRemoteFileName() {
        return remoteFileName;
    }

    public void setRemoteFileName(String remoteFileName) {
        this.remoteFileName = remoteFileName;
    }

    public String getFilePath() {
        return filePath;
    }

    public void setFilePath(String filePath) {
        this.filePath = filePath;
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;48-mapper-接口定义&#34;&gt;4.8 Mapper 接口定义&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.cy.mapper;

import com.cy.entity.FileInfo;

import java.util.List;

// 文件数据的数据访问接口
public interface FileInfoMapper {
    /**
     * 新增文件相关数据到数据库
     * @param fileInfo 要新增的数据
     */
    void insertFileInfo(FileInfo fileInfo);

    /**
     * 查询所有的文件相关数据
     * @return
     */
    List&amp;lt;FileInfo&amp;gt; selectFileInfos();

    /**
     * 主键查询详情
     * @param id
     * @return
     */
    FileInfo selectById(Long id);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;49-mapper-配置文件&#34;&gt;4.9 Mapper 配置文件&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;!DOCTYPE mapper PUBLIC &amp;quot;-//mybatis.org//DTD Mapper 3.0//EN&amp;quot; &amp;quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&amp;quot;&amp;gt;
&amp;lt;mapper namespace=&amp;quot;com.cy.mapper.FileInfoMapper&amp;quot;&amp;gt;
    &amp;lt;insert id=&amp;quot;insertFileInfo&amp;quot;&amp;gt;
        insert into t_files(id, file_name, group_name, remote_file_name, file_path)
        values(default, #{fileName}, #{groupName}, #{remoteFileName}, #{filePath})
    &amp;lt;/insert&amp;gt;
    &amp;lt;select id=&amp;quot;selectFileInfos&amp;quot; resultType=&amp;quot;com.cy.entity.FileInfo&amp;quot;&amp;gt;
        select id, file_name as fileName, group_name as groupName, remote_file_name as remoteFileName,
            file_path as filePath
        from t_files
    &amp;lt;/select&amp;gt;
    &amp;lt;select id=&amp;quot;selectById&amp;quot; resultType=&amp;quot;com.cy.entity.FileInfo&amp;quot;&amp;gt;
        select id, file_name as fileName, group_name as groupName, remote_file_name as remoteFileName,
            file_path as filePath
        from t_files
        where id = #{id}
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;410-服务接口&#34;&gt;4.10 服务接口&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.cy.service;

import com.cy.entity.FileInfo;
import org.springframework.web.multipart.MultipartFile;

import java.io.InputStream;
import java.util.List;

// 文件处理服务接口
public interface FileService {
    /**
     * 上传文件到FastDFS中，把文件的一些相关数据保存到数据库中。
     * @param file - 要上传的文件
     * @return true - 成功 ； false - 失败
     */
    boolean uploadFile(MultipartFile file);

    /**
     * 查询所有的可下载的文件的数据
     * @return 数据库中的数据集合
     */
    List&amp;lt;FileInfo&amp;gt; getFileInfos();

    /**
     * 获取要下载的文件
     * @param fileInfoId 文件在数据库中的主键
     * @return 要下载的文件的输入流
     */
    InputStream getFile(Long fileInfoId);

    FileInfo getFileInfoById(Long fileInfoId);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;411-服务实现&#34;&gt;4.11 服务实现&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.cy.service.impl;

import com.cy.entity.FileInfo;
import com.cy.fdfs.FastDFSCommonsUtils;
import com.cy.mapper.FileInfoMapper;
import com.cy.service.FileService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.InputStream;
import java.util.Arrays;
import java.util.List;

// 文件处理服务实现
@Service
public class FileServiceImpl implements FileService {
    @Autowired
    private FileInfoMapper fileInfoMapper;
    @Override
    public boolean uploadFile(MultipartFile file) {
        try {
            String[] result = FastDFSCommonsUtils.upload(file.getInputStream(), file.getOriginalFilename());
            if(result == null){
                // 上传失败
                return false;
            }
            // System.out.println(Arrays.toString(result));
            // 将文件相关信息保存到数据库
            FileInfo fileInfo = new FileInfo();
            fileInfo.setFileName(file.getOriginalFilename());
            fileInfo.setGroupName(result[0]);
            fileInfo.setRemoteFileName(result[1]);
            fileInfo.setFilePath(result[0]+&amp;quot;/&amp;quot;+result[1]);
            this.fileInfoMapper.insertFileInfo(fileInfo);
            return true;
        }catch (Exception e){ // 上传失败
            e.printStackTrace();
            return false;
        }
    }

    @Override
    public List&amp;lt;FileInfo&amp;gt; getFileInfos() {
        return this.fileInfoMapper.selectFileInfos();
    }

    @Override
    public InputStream getFile(Long fileInfoId) {
        // 访问数据库，获取要下载的文件的详情信息
        FileInfo fileInfo = this.fileInfoMapper.selectById(fileInfoId);

        // 访问FastDFS，获取要下载的文件的具体内容
        InputStream inputStream = FastDFSCommonsUtils.download(fileInfo.getGroupName(), fileInfo.getRemoteFileName());

        // 返回
        return inputStream;
    }

    @Override
    public FileInfo getFileInfoById(Long fileInfoId) {
        return this.fileInfoMapper.selectById(fileInfoId);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;412-控制器&#34;&gt;4.12 控制器&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.cy.controller;

import com.cy.entity.FileInfo;
import com.cy.service.FileService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.multipart.MultipartFile;

import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.List;

// 文件控制器，实现上传、下载功能
@Controller
public class FileController {
    @Autowired
    private FileService fileService;
    /**
     * 文件上传
     * @param uploadFile 要上传的文件
     * @return
     */
    @RequestMapping(&amp;quot;/uploadFile&amp;quot;)
    public String uploadFile(MultipartFile uploadFile){
//        System.out.println(&amp;quot;上传文件的原始名称 - &amp;quot; + uploadFile.getOriginalFilename());
//        System.out.println(&amp;quot;上传文件的大小 - &amp;quot; + uploadFile.getSize());
        // 上传文件到FastDFS中
        boolean flag = this.fileService.uploadFile(uploadFile);
        System.out.println(flag ? &amp;quot;上传成功&amp;quot; : &amp;quot;上传失败&amp;quot;);

        return &amp;quot;redirect:/index&amp;quot;;
    }

    /**
     * 进入到首页面的方法。
     * 在进入首页面之前，需要先访问数据库，查询可以下载的文件的相关信息。
     * @return
     */
    @RequestMapping(value = {&amp;quot;/&amp;quot;, &amp;quot;/index&amp;quot;})
    public String toIndex(Model model){
        List&amp;lt;FileInfo&amp;gt; list = this.fileService.getFileInfos();
        model.addAttribute(&amp;quot;list&amp;quot;, list);
        return &amp;quot;forward:/index.jsp&amp;quot;;
    }

    /**
     * 下载文件
     * @param fileInfoId 要下载的文件在数据库中的相关数据主键
     */
    @RequestMapping(value=&amp;quot;/downloadFile/{fileInfoId}&amp;quot;)
    public void downloadFile(@PathVariable(&amp;quot;fileInfoId&amp;quot;) Long fileInfoId, HttpServletResponse response){
        // 获取要传递给客户端的文件数据
        InputStream inputStream = null;
        try {
            inputStream = this.fileService.getFile(fileInfoId);
            FileInfo fileInfo = this.fileService.getFileInfoById(fileInfoId);
            // 设置响应头， 响应为下载，下载的文件名是什么
            response.setContentType(&amp;quot;application/octet-stream&amp;quot;);
            response.setHeader(&amp;quot;content-disposition&amp;quot;, &amp;quot;attachement;filename=&amp;quot;+fileInfo.getFileName());

            // 通过输出流输出文件内容到客户端
            OutputStream outputStream = response.getOutputStream();

            byte[] temp = new byte[512];
            int len = 0;
            while((len = inputStream.read(temp)) != -1){
                outputStream.write(temp, 0, len);
            }

            // 刷新缓存
            outputStream.flush();
        }catch(Exception e){
            e.printStackTrace();
        }finally {
            if(inputStream != null){ // 回收资源
                try {
                    inputStream.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;413-页面indexjsp&#34;&gt;4.13 页面index.jsp&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;%@ page contentType=&amp;quot;text/html;charset=UTF-8&amp;quot; language=&amp;quot;java&amp;quot; %&amp;gt;
&amp;lt;%@taglib prefix=&amp;quot;c&amp;quot; uri=&amp;quot;http://java.sun.com/jsp/jstl/core&amp;quot; %&amp;gt;

&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;FastDFS WEB应用&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;center&amp;gt;
        &amp;lt;form method=&amp;quot;post&amp;quot; enctype=&amp;quot;multipart/form-data&amp;quot; action=&amp;quot;/uploadFile&amp;quot;&amp;gt;
            选择要上传的文件:&amp;lt;input type=&amp;quot;file&amp;quot; name=&amp;quot;uploadFile&amp;quot;&amp;gt;
            &amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;
            &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;上传&amp;quot;&amp;gt;
        &amp;lt;/form&amp;gt;
        &amp;lt;table border=&amp;quot;1&amp;quot; style=&amp;quot;width: 800px&amp;quot;&amp;gt;
            &amp;lt;thead&amp;gt;
            &amp;lt;tr&amp;gt;
                &amp;lt;th&amp;gt;文件原始名称&amp;lt;/th&amp;gt;
                &amp;lt;th&amp;gt;文件卷标名称&amp;lt;/th&amp;gt;
                &amp;lt;th&amp;gt;文件远程名称&amp;lt;/th&amp;gt;
                &amp;lt;th&amp;gt;操作&amp;lt;/th&amp;gt;
            &amp;lt;/tr&amp;gt;
            &amp;lt;/thead&amp;gt;
            &amp;lt;tbody&amp;gt;
            &amp;lt;c:forEach items=&amp;quot;${list}&amp;quot; var=&amp;quot;fileInfo&amp;quot;&amp;gt;
                &amp;lt;tr&amp;gt;
                    &amp;lt;th&amp;gt;${fileInfo.fileName}&amp;lt;/th&amp;gt;
                    &amp;lt;th&amp;gt;${fileInfo.groupName}&amp;lt;/th&amp;gt;
                    &amp;lt;th&amp;gt;${fileInfo.remoteFileName}&amp;lt;/th&amp;gt;
                    &amp;lt;th&amp;gt;&amp;lt;a href=&amp;quot;/downloadFile/${fileInfo.id}&amp;quot;&amp;gt;下载&amp;lt;/a&amp;gt;&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;
                        &amp;lt;a href=&amp;quot;http://192.168.89.153:8888/${fileInfo.filePath}&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;预览&amp;lt;/a&amp;gt;&amp;lt;/th&amp;gt;
                &amp;lt;/tr&amp;gt;
            &amp;lt;/c:forEach&amp;gt;
            &amp;lt;/tbody&amp;gt;
        &amp;lt;/table&amp;gt;
    &amp;lt;/center&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
">FastDFS</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jonchan1013.github.io/post/dubbo/"" data-c="
          &lt;h2 id=&#34;1-dubbo简介&#34;&gt;1、Dubbo简介&lt;/h2&gt;
&lt;h3 id=&#34;11-dubbo是什么&#34;&gt;1.1 Dubbo是什么&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200624160121.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
Dubbo 官网地址：http://dubbo.apache.org/zh-cn/&lt;br&gt;
Dubbo 最早是 Alibaba 开源的分布式服务框架，它最大的特点是按照分层的方式来架构，使用这种方式可以使各个层之间解耦合（或者最大限度地松耦合）。从服务模型的角度来看，Dubbo 采用的是一种非常简单的模型，要么是提供方提供服务，要么是消费方消费服务，所以基于这一点可以抽象出服务提供方（Provider）和服务消费方（Consumer）两个角色。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;12-发展历史&#34;&gt;1.2 发展历史&lt;/h3&gt;
&lt;p&gt;​	Dubbo 是最开始是阿里巴巴内部使用的 RPC 框架。&lt;/p&gt;
&lt;p&gt;​	2011 年对外提供。&lt;br&gt;
​	2012 年停止更新。&lt;br&gt;
​	2017 年开始继续更新。&lt;br&gt;
​	2019 年捐献给 Apache，由 Apache 维护 2.7 以上版本。&lt;/p&gt;
&lt;h3 id=&#34;13-dubbo能做什么&#34;&gt;1.3 Dubbo能做什么&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Dubbo 可实现透明化的远程方法调用，就像调用本地方法一样调用远程方法，只需简单配置即可，没有任何 API 侵入。&lt;/li&gt;
&lt;li&gt;软负载均衡及容错机制，可在内网替代 F5 等硬件负载均衡器，降低成本，减少单点。&lt;/li&gt;
&lt;li&gt;软负载均衡及容错机制，可在内网替代 F5 等硬件负载均衡器，降低成本，减少单点。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;14-dubbo产生的背景&#34;&gt;1.4 Dubbo产生的背景&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200624171428.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;单一应用架构（单体架构）&lt;/p&gt;
&lt;p&gt;当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM) 是关键。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;垂直应用架构&lt;/p&gt;
&lt;p&gt;当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。&lt;br&gt;
此时，用于加速前端页面开发的 Web 框架(MVC) 是关键。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分布式服务架构（RPC 架构）&lt;br&gt;
当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。&lt;br&gt;
此时，用于提高业务复用及整合的分布式服务框架(RPC) 是关键。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;流动计算架构（SOA 架构）&lt;/p&gt;
&lt;p&gt;当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。&lt;br&gt;
此时，用于提高机器利用率的资源调度和治理中心(SOA) 是关键。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-dubbo架构讲解&#34;&gt;2、Dubbo架构讲解&lt;/h2&gt;
&lt;h3 id=&#34;21-架构图&#34;&gt;2.1 架构图&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200624171618.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;22-架构说明&#34;&gt;2.2 架构说明&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;虚线&lt;br&gt;
虚线表示异步，实线表示同步。异步不阻塞线程性能高，同步阻塞线程必须等待响应结果才能继续执行，相对性能低。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Provider&lt;br&gt;
暴露服务的服务提供方。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Container&lt;br&gt;
服务运行容器。Dubbo 完全基于 Spring 实现的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Registry&lt;br&gt;
服务注册与发现的注册中心。注册中心，放置所有 Provider 对外提供的信息。包含Provider 的 IP，访问端口，访问遵守的协议，对外提供的接口，接口中有哪些方法等相关信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Consumer&lt;br&gt;
调用远程服务的服务消费方。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Monitor&lt;br&gt;
统计服务的调用次调和调用时间的监控中心。监控中心，监控 Provider 的压力情况等。每隔 2 分钟 Consumer 和 Provider 会把调用次数发送给 Monitor，由 Monitor 进行统计。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;23-执行流程&#34;&gt;2.3 执行流程&lt;/h3&gt;
&lt;ol start=&#34;0&#34;&gt;
&lt;li&gt;start：启动 Spring 容器时会把 Provider 启动。&lt;/li&gt;
&lt;li&gt;register：把 Provider 相关信息注册到 Registry 里&lt;/li&gt;
&lt;li&gt;subscribe：Consumer 从 Registry 中订阅 Provider 的信息&lt;/li&gt;
&lt;li&gt;notify：当Provider发生改变时，Registry通知给 Consumer&lt;/li&gt;
&lt;li&gt;invoke：Consumer 根据 Registry 通知的信息进行调用 Provider 中方法。&lt;/li&gt;
&lt;li&gt;count:Consumer 和 Provider 把调用次数信息异步发送给 Monitor 进行统计。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-dobbo支持的协议&#34;&gt;3、Dobbo支持的协议&lt;/h2&gt;
&lt;h3 id=&#34;31-dubbo协议官方推荐协议&#34;&gt;3.1 Dubbo协议（官方推荐协议）&lt;/h3&gt;
&lt;p&gt;优点：&lt;br&gt;
采用 NIO 复用单一长连接，并使用线程池并发处理请求，减少握手和加大并发效率，性能较好（推荐使用）&lt;/p&gt;
&lt;p&gt;缺点：&lt;br&gt;
大文件上传时,可能出现问题(不使用 Dubbo 文件上传)&lt;/p&gt;
&lt;h3 id=&#34;32-rmiremote-method-invocation协议&#34;&gt;3.2  RMI(Remote Method Invocation)协议&lt;/h3&gt;
&lt;p&gt;优点:&lt;br&gt;
JDK 自带的能力。&lt;br&gt;
缺点:&lt;br&gt;
偶尔连接失败.&lt;/p&gt;
&lt;h3 id=&#34;33-hessian-协议&#34;&gt;3.3  Hessian 协议&lt;/h3&gt;
&lt;p&gt;优点:&lt;br&gt;
可与原生 Hessian 互操作，基于 HTTP 协议&lt;br&gt;
缺点:&lt;br&gt;
需 hessian.jar 支持，http 短连接的开销大&lt;/p&gt;
&lt;h2 id=&#34;4-dubbo-支持的注册中心&#34;&gt;4、Dubbo 支持的注册中心&lt;/h2&gt;
&lt;h3 id=&#34;41-zookeeper官方推荐&#34;&gt;4.1 Zookeeper(官方推荐)&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;优点:&lt;br&gt;
支持分布式.很多周边产品.&lt;/li&gt;
&lt;li&gt;缺点:&lt;br&gt;
受限于 Zookeeper 软件的稳定性。Zookeeper 是一款专门为分布式架构提供辅助型处理的软件，稳定较优。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;42-multicast&#34;&gt;4.2  Multicast&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;优点:&lt;br&gt;
去中心化,不需要单独安装软件.&lt;/li&gt;
&lt;li&gt;缺点:&lt;br&gt;
Provider 和 Consumer 和 Registry 不能跨机房(路由)&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;43-redis&#34;&gt;4.3 Redis&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;优点:&lt;br&gt;
支持集群,性能高&lt;/li&gt;
&lt;li&gt;缺点:&lt;br&gt;
要求服务器时间同步.否则可能出现集群失败问题.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;44-simple&#34;&gt;4.4 Simple&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;优点:&lt;br&gt;
标准 RPC 服务.没有兼容问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点:&lt;br&gt;
不支持集群.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;5-dubbo-应用&#34;&gt;5、Dubbo 应用&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200628095739.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;Dubbo 在不同的版本中对于添加的依赖也是不同的。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200628195505.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;51-创建父工程&#34;&gt;5.1 创建父工程&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建项目&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改POM 文件添加依赖&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot;
         xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
         xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;parent&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;packaging&amp;gt;pom&amp;lt;/packaging&amp;gt;

    &amp;lt;properties&amp;gt;
        &amp;lt;spring.version&amp;gt;5.2.5.RELEASE&amp;lt;/spring.version&amp;gt;
        &amp;lt;dubbo.version&amp;gt;2.7.6&amp;lt;/dubbo.version&amp;gt;
        &amp;lt;curator.version&amp;gt;4.2.0&amp;lt;/curator.version&amp;gt;
        &amp;lt;registry-zookeeper.version&amp;gt;2.7.6&amp;lt;/registry-zookeeper.version&amp;gt;
        &amp;lt;servlet.version&amp;gt;3.1.0&amp;lt;/servlet.version&amp;gt;
        &amp;lt;jsp.version&amp;gt;2.0&amp;lt;/jsp.version&amp;gt;
        &amp;lt;jstl.version&amp;gt;1.2&amp;lt;/jstl.version&amp;gt;
    &amp;lt;/properties&amp;gt;
    &amp;lt;dependencyManagement&amp;gt;
        &amp;lt;dependencies&amp;gt;
            &amp;lt;!--Spring Context Dependence--&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
            &amp;lt;/dependency&amp;gt;
            &amp;lt;!--Spring MVC Dependence--&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
            &amp;lt;/dependency&amp;gt;
            &amp;lt;!--Apache Dubbo Dependence--&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;dubbo&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${dubbo.version}&amp;lt;/version&amp;gt;
            &amp;lt;/dependency&amp;gt;
            &amp;lt;!--Registry Zookeeper Dependence--&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;dubbo-registry-zookeeper&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${registry-zookeeper.version}&amp;lt;/version&amp;gt;
            &amp;lt;/dependency&amp;gt;
            &amp;lt;!--Apache Curator Dependence--&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.apache.curator&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;curator-framework&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${curator.version}&amp;lt;/version&amp;gt;
            &amp;lt;/dependency&amp;gt;
            &amp;lt;!--Servlet Dependence--&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;javax.servlet-api&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${servlet.version}&amp;lt;/version&amp;gt;
                &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
            &amp;lt;/dependency&amp;gt;
            &amp;lt;!--JSP Dependence--&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;jsp-api&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${jsp.version}&amp;lt;/version&amp;gt;
                &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
            &amp;lt;/dependency&amp;gt;
            &amp;lt;!--JSTL Dependence--&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;javax.servlet.jsp.jstl&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;jstl&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${jstl.version}&amp;lt;/version&amp;gt;
            &amp;lt;/dependency&amp;gt;
        &amp;lt;/dependencies&amp;gt;
    &amp;lt;/dependencyManagement&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;pluginManagement&amp;gt;
            &amp;lt;plugins&amp;gt;
                &amp;lt;!--Tomcat Plugin--&amp;gt;
                &amp;lt;plugin&amp;gt;
                    &amp;lt;groupId&amp;gt;org.apache.tomcat.maven&amp;lt;/groupId&amp;gt;
                    &amp;lt;artifactId&amp;gt;tomcat7-maven-plugin&amp;lt;/artifactId&amp;gt;
                    &amp;lt;version&amp;gt;2.2&amp;lt;/version&amp;gt;
                &amp;lt;/plugin&amp;gt;
            &amp;lt;/plugins&amp;gt;
        &amp;lt;/pluginManagement&amp;gt;
    &amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;52-创建服务接口&#34;&gt;5.2  创建服务接口&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建项目&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200628102304.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;添加接口&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface DemoDubboService {
    String showMsg(String str);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;53-创建provider&#34;&gt;5.3  创建Provider&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建项目&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200628135344.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改POM 文件添加依赖&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot;
         xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
         xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;artifactId&amp;gt;parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
        &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;/parent&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;artifactId&amp;gt;provider&amp;lt;/artifactId&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;api&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--Spring Context Dependence--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--Apache Dubbo Dependence--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;dubbo&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--Registry Zookeeper Dependence--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;dubbo-registry-zookeeper&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--Apache Curator Dependence--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.curator&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;curator-framework&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;添加接口实现&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class DemoDubboServiceimpl implements DemoDubboService{
    public String showMsg(String str) {
        return &amp;quot;Hello Dubbo &amp;quot;+ str;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;54-添加dubbo-的配置文件&#34;&gt;5.4 添加Dubbo 的配置文件&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Dubbo 配置文件的存放位置&lt;/p&gt;
&lt;p&gt;配置文件必须放到 resources/META-INF/spring/*.xml&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置文件内容&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用配置bean 标签配置接口实现类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
       xmlns:dubbo=&amp;quot;http://dubbo.apache.org/schema/dubbo&amp;quot;
       xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans-4.3.xsd        http://dubbo.apache.org/schema/dubbo        http://dubbo.apache.org/schema/dubbo/dubbo.xsd&amp;quot;&amp;gt;

    &amp;lt;!--定义服务的名称(自定义)--&amp;gt;
    &amp;lt;dubbo:application name=&amp;quot;myProvider&amp;quot; /&amp;gt;

    &amp;lt;!--配置注册中心--&amp;gt;
    &amp;lt;dubbo:registry address=&amp;quot;124.70.181.124:2181,124.70.181.124:2182,124.70.181.124:2183&amp;quot; protocol=&amp;quot;zookeeper&amp;quot; timeout=&amp;quot;10000&amp;quot;/&amp;gt;

    &amp;lt;!--服务协议以及监听端口--&amp;gt;
    &amp;lt;dubbo:protocol  name=&amp;quot;dubbo&amp;quot; port=&amp;quot;20880&amp;quot; /&amp;gt;

    &amp;lt;!--注册接口--&amp;gt;
	&amp;lt;dubbo:service interface=&amp;quot;com.bjsxt.dubbo.service.DemoDubboService&amp;quot; ref=&amp;quot;service&amp;quot;/&amp;gt;

    &amp;lt;!--创建接口实现类--&amp;gt;
	&amp;lt;bean id=&amp;quot;service&amp;quot; class=&amp;quot;com.bjsxt.dubbo.service.impl.DemoDubboServiceImpl&amp;quot;/&amp;gt;
&amp;lt;/beans&amp;gt;
  
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用注解方式开发服务接口&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;需改配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
       xmlns:dubbo=&amp;quot;http://dubbo.apache.org/schema/dubbo&amp;quot;
       xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans-4.3.xsd        http://dubbo.apache.org/schema/dubbo        http://dubbo.apache.org/schema/dubbo/dubbo.xsd&amp;quot;&amp;gt;

    &amp;lt;!--定义服务的名称(自定义)--&amp;gt;
    &amp;lt;dubbo:application name=&amp;quot;myProvider&amp;quot; /&amp;gt;

    &amp;lt;!--配置注册中心--&amp;gt;
    &amp;lt;dubbo:registry address=&amp;quot;124.70.181.124:2181,124.70.181.124:2182,124.70.181.124:2183&amp;quot; protocol=&amp;quot;zookeeper&amp;quot; timeout=&amp;quot;10000&amp;quot;/&amp;gt;

    &amp;lt;!--服务协议以及监听端口--&amp;gt;
    &amp;lt;dubbo:protocol  name=&amp;quot;dubbo&amp;quot; port=&amp;quot;20880&amp;quot; /&amp;gt;

    &amp;lt;!--扫描接口的位置的指定@Service：注意该注解并不是Spring的@Service--&amp;gt;
    &amp;lt;dubbo:annotation  package=&amp;quot;com.cy.dubbo.service&amp;quot;/&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改接口实现类&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200628135900.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service //注意使用的是 Dubbo 的@Service 注解。
//org.apache.dubbo.config.annotation.Service
public class DemoDubboServiceimpl implements DemoDubboService{
    public String showMsg(String str) {
        return &amp;quot;Hello Dubbo &amp;quot;+ str;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动Provider&lt;/p&gt;
&lt;p&gt;创建Dubbo 启动类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Dubbo的启动类
 */
public class Start {
    public static void main(String[] args) {
        Main.main(args);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;55-使用zookeeper-客户端工具查看注册信息&#34;&gt;5.5  使用Zookeeper 客户端工具查看注册信息&lt;/h3&gt;
&lt;p&gt;​	ls /dubbo/服务接口名称/providers&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200628144412.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;注：url信息在Zookeeper中以一个节点的名字而不是信息存储&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;解码前&lt;/p&gt;
&lt;p&gt;dubbo%3A%2F%2F192.168.92.1%3A20880%2Fcom.cy.dubbo.service.DemoDubboService%3Fanyhost%3Dtrue%26application%3DmyProvider%26deprecated%3Dfalse%26dubbo%3D2.0.2%26dynamic%3Dtrue%26generic%3Dfalse%26interface%3Dcom.cy.dubbo.service.DemoDubboService%26methods%3DshowMsg%26pid%3D36272%26release%3D2.7.6%26side%3Dprovider%26timestamp%3D1593326084675&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解码后&lt;/p&gt;
&lt;p&gt;dubbo://192.168.92.1:20880/com.cy.dubbo.service.DemoDubboService?anyhost=true&amp;amp;application=myProvider&amp;amp;deprecated=false&amp;amp;dubbo=2.0.2&amp;amp;dynamic=true&amp;amp;generic=false&amp;amp;interface=com.cy.dubbo.service.DemoDubboService&amp;amp;methods=showMsg&amp;amp;pid=36272&amp;amp;release=2.7.6&amp;amp;side=provider&amp;amp;timestamp=1593326084675&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;56-创建consumer&#34;&gt;5.6 创建Consumer&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建项目&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200628145857.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改POM 文件添加依赖&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot;
         xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
         xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;artifactId&amp;gt;parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
        &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;/parent&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;artifactId&amp;gt;consumer&amp;lt;/artifactId&amp;gt;
    &amp;lt;packaging&amp;gt;war&amp;lt;/packaging&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;api&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--Spring MVC Dependence--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--Apache Dubbo Dependence--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;dubbo&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--Registry Zookeeper Dependence--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;dubbo-registry-zookeeper&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--Apache Curator Dependence--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.curator&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;curator-framework&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!--Servlet Dependence--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;javax.servlet-api&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--JSP Dependence--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;jsp-api&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--JSTL Dependence--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;javax.servlet.jsp.jstl&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;jstl&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;!--Tomcat Plugin--&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.apache.tomcat.maven&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;tomcat7-maven-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;2.2&amp;lt;/version&amp;gt;
                &amp;lt;configuration&amp;gt;
                    &amp;lt;port&amp;gt;8888&amp;lt;/port&amp;gt;
                    &amp;lt;path&amp;gt;/&amp;lt;/path&amp;gt;
                &amp;lt;/configuration&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编写配置文件&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Spring 配置文件&lt;/p&gt;
&lt;p&gt;applicationContext-service.xml&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:context=&amp;quot;http://www.springframework.org/schema/context&amp;quot; xmlns:p=&amp;quot;http://www.springframework.org/schema/p&amp;quot;
       xmlns:aop=&amp;quot;http://www.springframework.org/schema/aop&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
       xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
   http://www.springframework.org/schema/context
   http://www.springframework.org/schema/context/spring-context.xsd
   http://www.springframework.org/schema/aop
   http://www.springframework.org/schema/aop/spring-aop.xsd
   http://www.springframework.org/schema/util
   http://www.springframework.org/schema/util/spring-util.xsd&amp;quot;&amp;gt;
    &amp;lt;context:component-scan base-package=&amp;quot;com.cy.service&amp;quot;/&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SpringMVC 配置文件&lt;/p&gt;
&lt;p&gt;springmvc.xml&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:context=&amp;quot;http://www.springframework.org/schema/context&amp;quot; xmlns:p=&amp;quot;http://www.springframework.org/schema/p&amp;quot;
       xmlns:aop=&amp;quot;http://www.springframework.org/schema/aop&amp;quot;
       xmlns:mvc=&amp;quot;http://www.springframework.org/schema/mvc&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
       xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
   http://www.springframework.org/schema/context
   http://www.springframework.org/schema/context/spring-context.xsd
   http://www.springframework.org/schema/aop
   http://www.springframework.org/schema/aop/spring-aop.xsd
   http://www.springframework.org/schema/util
   http://www.springframework.org/schema/util/spring-util.xsd
    http://www.springframework.org/schema/mvc
    http://www.springframework.org/schema/mvc/spring-mvc.xsd&amp;quot;&amp;gt;
    &amp;lt;context:component-scan base-package=&amp;quot;com.cy.web.controller&amp;quot;/&amp;gt;
    &amp;lt;mvc:annotation-driven/&amp;gt;
    &amp;lt;bean class=&amp;quot;org.springframework.web.servlet.view.InternalResourceViewResolver&amp;quot;&amp;gt;
        &amp;lt;property name=&amp;quot;prefix&amp;quot; value=&amp;quot;/WEB-INF/jsp/&amp;quot;/&amp;gt;
        &amp;lt;property name=&amp;quot;suffix&amp;quot; value=&amp;quot;.jsp&amp;quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Dubbo 配置文件&lt;/p&gt;
&lt;p&gt;applicationContext-dubbo.xml&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
       xmlns:dubbo=&amp;quot;http://dubbo.apache.org/schema/dubbo&amp;quot;
       xmlns:context=&amp;quot;http://www.springframework.org/schema/context&amp;quot; xmlns:dubbot=&amp;quot;http://dubbo.apache.org/schema/dubbo&amp;quot;
       xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd
      http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&amp;quot;&amp;gt;
    &amp;lt;!--配置服务名称--&amp;gt;
    &amp;lt;dubbo:application name=&amp;quot;myConsumer&amp;quot;/&amp;gt;
    &amp;lt;!--配置注册中心地址以及访问协议--&amp;gt;
    &amp;lt;dubbo:registry address=&amp;quot;124.70.181.124:2181,124.70.181.124:2182,124.70.181.124:2183&amp;quot; protocol=&amp;quot;zookeeper&amp;quot; timeout=&amp;quot;10000&amp;quot;/&amp;gt;
    &amp;lt;!--dubbo扫描自己@Reference注解--&amp;gt;
    &amp;lt;dubbo:annotation package=&amp;quot;com.cy.service.impl&amp;quot;/&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Web.xml 配置文件&lt;/p&gt;
&lt;p&gt;web.xml&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;web-app xmlns=&amp;quot;http://java.sun.com/xml/ns/javaee&amp;quot;
         xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
         xsi:schemaLocation=&amp;quot;http://java.sun.com/xml/ns/javaee
        http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&amp;quot;
         version=&amp;quot;3.0&amp;quot;&amp;gt;
    &amp;lt;context-param&amp;gt;
        &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
        &amp;lt;param-value&amp;gt;classpath:spring/applicationContext-*.xml&amp;lt;/param-value&amp;gt;
    &amp;lt;/context-param&amp;gt;
    &amp;lt;listener&amp;gt;
        &amp;lt;listener-class&amp;gt;org.springframework.web.context.ContextLoaderListener&amp;lt;/listener-class&amp;gt;
    &amp;lt;/listener&amp;gt;
    &amp;lt;servlet&amp;gt;
        &amp;lt;servlet-name&amp;gt;springmvc&amp;lt;/servlet-name&amp;gt;
        &amp;lt;servlet-class&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt;
        &amp;lt;init-param&amp;gt;
            &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
            &amp;lt;param-value&amp;gt;classpath:spring/springmvc.xml&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;
        &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;
    &amp;lt;/servlet&amp;gt;
    &amp;lt;servlet-mapping&amp;gt;
        &amp;lt;servlet-name&amp;gt;springmvc&amp;lt;/servlet-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/servlet-mapping&amp;gt;
    &amp;lt;!--SpringMVC中的编码过滤器--&amp;gt;
    &amp;lt;filter&amp;gt;
        &amp;lt;filter-name&amp;gt;encodeFilter&amp;lt;/filter-name&amp;gt;
        &amp;lt;filter-class&amp;gt;org.springframework.web.filter.CharacterEncodingFilter&amp;lt;/filter-class&amp;gt;
        &amp;lt;init-param&amp;gt;
            &amp;lt;param-name&amp;gt;encoding&amp;lt;/param-name&amp;gt;
            &amp;lt;param-value&amp;gt;utf-8&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;
    &amp;lt;/filter&amp;gt;
    &amp;lt;filter-mapping&amp;gt;
        &amp;lt;filter-name&amp;gt;encodeFilter&amp;lt;/filter-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/filter-mapping&amp;gt;
&amp;lt;/web-app&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;57-实现远程调用&#34;&gt;5.7 实现远程调用&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建业务层&lt;/p&gt;
&lt;p&gt;DemoService接口:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface DemoService {
    public String showInf(String str);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;DemoServiceImpl:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Consumer的业务层
 */
@Service
public class DemoServiceImpl implements DemoService {
    //该注解针对DemoDubboService接口生成代理对象，通过代理对象远程调用provider中方法
    @Reference
    private DemoDubboService demoDubboService;

    public String showInf(String str) {
        return this.demoDubboService.showMsg(str);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建Controller层&lt;/p&gt;
&lt;p&gt;DemoController:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
public class DemoController {
    @Autowired
    private DemoService demoService;

    @RequestMapping(&amp;quot;/getMsg&amp;quot;)
    public String getMsg(String str){
        return this.demoService.showInf(str);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;测试结果&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200628195240.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;6-spring-boot-整合dubbo&#34;&gt;6、 Spring Boot 整合Dubbo&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200629112338.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;61-创建服务接口&#34;&gt;6.1 创建服务接口&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建项目&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200629013311.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;添加接口&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface DemoDubboService {
    public String showMsg(String str);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;62-创建provider&#34;&gt;6.2 创建Provider&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建项目&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200629013420.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;修改POM 文件添加依赖&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
	xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
	&amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
	&amp;lt;parent&amp;gt;
		&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
		&amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
		&amp;lt;version&amp;gt;2.3.1.RELEASE&amp;lt;/version&amp;gt;
		&amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
	&amp;lt;/parent&amp;gt;
	&amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;springbootdubbo_provider&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
	&amp;lt;name&amp;gt;springbootdubbo_provider&amp;lt;/name&amp;gt;
	&amp;lt;description&amp;gt;Demo project for Spring Boot&amp;lt;/description&amp;gt;

	&amp;lt;properties&amp;gt;
		&amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
	&amp;lt;/properties&amp;gt;

	&amp;lt;dependencies&amp;gt;
		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;springboot_api&amp;lt;/artifactId&amp;gt;
			&amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
		&amp;lt;/dependency&amp;gt;
		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;spring-boot-starter&amp;lt;/artifactId&amp;gt;
		&amp;lt;/dependency&amp;gt;
		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;dubbo-spring-boot-starter&amp;lt;/artifactId&amp;gt;
			&amp;lt;version&amp;gt;2.7.6&amp;lt;/version&amp;gt;
		&amp;lt;/dependency&amp;gt;
		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;dubbo-registry-zookeeper&amp;lt;/artifactId&amp;gt;
			&amp;lt;version&amp;gt;2.7.6&amp;lt;/version&amp;gt;
		&amp;lt;/dependency&amp;gt;

		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
			&amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
			&amp;lt;exclusions&amp;gt;
				&amp;lt;exclusion&amp;gt;
					&amp;lt;groupId&amp;gt;org.junit.vintage&amp;lt;/groupId&amp;gt;
					&amp;lt;artifactId&amp;gt;junit-vintage-engine&amp;lt;/artifactId&amp;gt;
				&amp;lt;/exclusion&amp;gt;
			&amp;lt;/exclusions&amp;gt;
		&amp;lt;/dependency&amp;gt;
	&amp;lt;/dependencies&amp;gt;

	&amp;lt;build&amp;gt;
		&amp;lt;plugins&amp;gt;
			&amp;lt;plugin&amp;gt;
				&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
				&amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
			&amp;lt;/plugin&amp;gt;
		&amp;lt;/plugins&amp;gt;
	&amp;lt;/build&amp;gt;

&amp;lt;/project&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;添加接口实现&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service //在Provider中使用的dubbo的@Service注解。
public class DemoDubboServiceImpl implements DemoDubboService {
    @Override
    public String showMsg(String str) {
        return &amp;quot;Hello Dubbo &amp;quot; + str;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在配置文件中配置Dubbo&lt;/p&gt;
&lt;p&gt;application.yml：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# 指定服务的名称
dubbo:
  application:
    name: MYProvider
  registry:
    address: zookeeper://124.70.181.124:2181?backup=124.70.181.124:2182,124.70.181.124:2183
    timeout: 10000
# 配置服务所使用的的协议
  protocol:
    name: dubbo
    port: 20880
  scan:
    base-packages: com.cy.springbootdubbo_provider.service.impl

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动Provider&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;通过spring-boot-starter-web 启动Dubbo&lt;/p&gt;
&lt;p&gt;​		如果在项目中添加的是 spring-boot-starter-web 启动器，那么在启动 dubbo 后还会监听一个端口，因为在 web 启动器中内置了一个 Tomcat，Tomcat 的启动不会影响 dubbo 的运行，但是会多占用一个端口，未来在其他的 Provider 中还需要考虑端口分配的问题，避免端口抢占。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过spring-boot-starter 启动Dubbo&lt;/p&gt;
&lt;p&gt;​		可以使用 spring-boot-starter 起来启动 Dubbo，在该启动器中并未包含 Tomcat 所以并不会监听端口。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200629014059.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;解码后：dubbo://192.168.92.1:20880/com.cy.dubbo.service.DemoDubboService?anyhost=true&amp;amp;application=MYProvider&amp;amp;deprecated=false&amp;amp;dubbo=2.0.2&amp;amp;dynamic=true&amp;amp;generic=false&amp;amp;interface=com.cy.dubbo.service.DemoDubboService&amp;amp;methods=showMsg&amp;amp;pid=28764&amp;amp;release=2.7.6&amp;amp;side=provider&amp;amp;timestamp=1593365445283&lt;/p&gt;
&lt;h3 id=&#34;63-创建consumer&#34;&gt;6.3 创建consumer&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建项目&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200629111858.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改POM 文件添加依赖&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
	xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
	&amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
	&amp;lt;parent&amp;gt;
		&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
		&amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
		&amp;lt;version&amp;gt;2.3.1.RELEASE&amp;lt;/version&amp;gt;
		&amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
	&amp;lt;/parent&amp;gt;
	&amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;springbootdubbo_consumer&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
	&amp;lt;name&amp;gt;springbootdubbo_consumer&amp;lt;/name&amp;gt;
	&amp;lt;description&amp;gt;Demo project for Spring Boot&amp;lt;/description&amp;gt;

	&amp;lt;properties&amp;gt;
		&amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
	&amp;lt;/properties&amp;gt;

	&amp;lt;dependencies&amp;gt;
		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;springboot_api&amp;lt;/artifactId&amp;gt;
			&amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
		&amp;lt;/dependency&amp;gt;
		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
		&amp;lt;/dependency&amp;gt;

		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;dubbo-spring-boot-starter&amp;lt;/artifactId&amp;gt;
			&amp;lt;version&amp;gt;2.7.6&amp;lt;/version&amp;gt;
		&amp;lt;/dependency&amp;gt;
		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;dubbo-registry-zookeeper&amp;lt;/artifactId&amp;gt;
			&amp;lt;version&amp;gt;2.7.6&amp;lt;/version&amp;gt;
		&amp;lt;/dependency&amp;gt;

		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
			&amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
			&amp;lt;exclusions&amp;gt;
				&amp;lt;exclusion&amp;gt;
					&amp;lt;groupId&amp;gt;org.junit.vintage&amp;lt;/groupId&amp;gt;
					&amp;lt;artifactId&amp;gt;junit-vintage-engine&amp;lt;/artifactId&amp;gt;
				&amp;lt;/exclusion&amp;gt;
			&amp;lt;/exclusions&amp;gt;
		&amp;lt;/dependency&amp;gt;
	&amp;lt;/dependencies&amp;gt;

	&amp;lt;build&amp;gt;
		&amp;lt;plugins&amp;gt;
			&amp;lt;plugin&amp;gt;
				&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
				&amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
			&amp;lt;/plugin&amp;gt;
		&amp;lt;/plugins&amp;gt;
	&amp;lt;/build&amp;gt;

&amp;lt;/project&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编写配置文件&lt;/p&gt;
&lt;p&gt;application.yml&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# 指定服务的名称
dubbo:
  application:
    name: MYConsumer
  registry:
    address: zookeeper://124.70.181.124:2181?backup=124.70.181.124:2182,124.70.181.124:2183
    timeout: 10000
  # 配置服务所使用的的协议
  protocol:
    name: dubbo

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现远程调用&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建业务层&lt;/p&gt;
&lt;p&gt;DemoService接口：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface DemoService {
    public String getMsg(String str);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;DemoServiceImpl:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
public class DemoServiceImpl implements DemoService {
    @Reference
    private DemoDubboService demoDubboService;

    @Override
    public String getMsg(String str) {
        return this.demoDubboService.showMsg(str);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建Controller 层&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
public class DemoController {
    @Autowired
    private DemoService demoService;

    @RequestMapping(&amp;quot;/getMsg&amp;quot;)
    public String getMsg(String str){
        return this.demoService.getMsg(str);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200629113307.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;7-dubbo-监控与管理&#34;&gt;7、Dubbo 监控与管理&lt;/h2&gt;
&lt;h3 id=&#34;71-监控平台-dubbo-monitor&#34;&gt;7.1  监控平台: dubbo-monitor&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Dubbo Monitor 简介&lt;/p&gt;
&lt;p&gt;主要用来统计服务的调用次数和调用时间，服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心，监控中心则使用数据绘制图表来显示。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Dubbo Monitor 的使用&lt;/p&gt;
&lt;p&gt;修改 Monitor 的配置文件&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200629170013.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动Monitor&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;18&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200629170125.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Monitor 监控界面&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;19&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200629170143.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;72-管理控制台dubbo-admin&#34;&gt;7.2 管理控制台：dubbo-admin&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Dubbo-Admin 简介&lt;/p&gt;
&lt;p&gt;主要包含：路由规则、动态配置、服务降级、访问控制、权重调整、负载均衡等管理功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Dubbo Admin 的使用&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;20&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200629170229.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;21&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200629170237.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;启动Admin&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;22&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200629170253.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Admin 管理界面&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;23&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200629170311.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;8-dubbo-中服务的负载均衡&#34;&gt;8、Dubbo 中服务的负载均衡&lt;/h2&gt;
&lt;h3 id=&#34;81-什么是服务集群&#34;&gt;8.1 什么是服务集群&lt;/h3&gt;
&lt;p&gt;一个服务，部署多次，形成的整体称为服务集群。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;服务集群优点:&lt;/p&gt;
&lt;p&gt;避免出现单点故障：如果集群中有某个服务宕机，其他服务可继续运行。&lt;/p&gt;
&lt;p&gt;提高效率：在集群模式下有多个服务处理业务，相比非集群模式下可分担单个服务的压力，提高服务效率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;集群模式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;真实集群&lt;br&gt;
真实集群是指在集群中，每一个节点在一个独立的物理机中运行，当某个物理机出现设备故障并不会影响其他节点的运行。建议在生产环境中使用。&lt;/p&gt;
&lt;p&gt;优点：单个硬件出现故障并不会影响集群中其他节点的运行。&lt;/p&gt;
&lt;p&gt;缺点：加大硬件成本的开销。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;伪集群&lt;br&gt;
集群中所有的服务都部署到同一台设备上，通过不同端口区分不同个体。当设备出现问题会导致整个集群不可用。学习阶段可以使用，但不建议在生产环境中使用。&lt;/p&gt;
&lt;p&gt;优点：可节省硬件成本开销。&lt;/p&gt;
&lt;p&gt;缺点：硬件出现故障会影响正个集群的使用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;82-什么是负载均衡&#34;&gt;8.2  什么是负载均衡&lt;/h3&gt;
&lt;p&gt;​	负载均衡（Load Balance），是指将负载（工作任务，访问请求）进行平衡、分摊到多个操作单元（服务器，组件）上进行执行。&lt;/p&gt;
&lt;h3 id=&#34;83-负载均衡解决方案分类及特征&#34;&gt;8.3  负载均衡解决方案分类及特征&lt;/h3&gt;
&lt;h4 id=&#34;831-集中式负载均衡&#34;&gt;8.3.1 集中式负载均衡&lt;/h4&gt;
&lt;p&gt;即在客户端和服务端之间使用独立的负载均衡设施(可以是硬件，如 F5, 也可以是软件，如 nginx), 由该设施负责把访问请求通过某种策略转发至服务端。&lt;/p&gt;
&lt;h5 id=&#34;8311-常见的集中式负载均衡方式&#34;&gt;8.3.1.1 常见的集中式负载均衡方式&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;DNS 轮询&lt;br&gt;
大多域名注册商都支持 DNS 轮询，DNS 服务器将解析请求按照配置顺序，逐一分配到不同的 IP 上，这样就完成了简单的负载均衡。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;反向代理负载均衡&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;24&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200629170724.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;使用代理服务器，可以将请求转发给内部的服务器。Nginx 是比较常见的服务反向代理技术。在 Nginx 中是支持对代理的服务的负载均衡处理的。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;基于硬件的负载均衡&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;25&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200629170748.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;硬件负载均衡解决方案是直接在服务器和外部网络间安装负载均衡设备，这种设备我们通常称之为负载均衡器，由于专门的设备完成专门的任务，独立于操作系统，整体性能得到大量提高，加上多样化的负载均衡策略，智能化的流量管理，可达到最佳的负载均衡需求。&lt;/p&gt;
&lt;p&gt;常见的主流产品：&lt;br&gt;
F5 BIG-IP 负载均衡器（LTM）&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;26&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200629170827.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;思科 IOS 路由器&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;27&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200629170841.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;Radware 的 AppDirector 系列&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;28&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200629170850.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;832-进程内负载均衡&#34;&gt;8.3.2 进程内负载均衡&lt;/h4&gt;
&lt;p&gt;​		将负载均衡逻辑集成到服务组件中，服务组件从服务注册中心获知有哪些地址可用，然后根据指定的负载均衡策略选择出一个合适的服务来调用。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;29&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200629170931.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;84-dubbo-的内置负载均衡策略&#34;&gt;8.4  Dubbo 的内置负载均衡策略&lt;/h3&gt;
&lt;h4 id=&#34;841-random&#34;&gt;8.4.1 Random&lt;/h4&gt;
&lt;p&gt;随机访问集群中节点。访问概率和权重有关。是 Dubbo 的默认负载均衡策略。&lt;br&gt;
权重（weight）：占有比例。集群中每个项目部署的服务器的性能可能是不同，性能好的服务器权重应该高一些。&lt;/p&gt;
&lt;h4 id=&#34;842-roundrobin&#34;&gt;8.4.2 RoundRobin&lt;/h4&gt;
&lt;p&gt;轮询。访问频率和权重有关。&lt;/p&gt;
&lt;h4 id=&#34;843-leastactive&#34;&gt;8.4.3 LeastActive&lt;/h4&gt;
&lt;p&gt;最少活跃调用数，相同活跃数的随机。&lt;/p&gt;
&lt;p&gt;如果某个机器性能越差，那么接收的请求越少，越不活跃，此时就会给不活跃的性能差的机器分配更少的请求。&lt;/p&gt;
&lt;h4 id=&#34;844-consistenthash&#34;&gt;8.4.4 ConsistentHash&lt;/h4&gt;
&lt;p&gt;一致性 Hash 算法，相同参数的请求一定分发到同一个 Provider 如果需要某一类请求都到一个节点，那么可以使用一致性 Hash 策略。&lt;/p&gt;
&lt;h3 id=&#34;85-dubbo-负载均衡的使用&#34;&gt;8.5 Dubbo 负载均衡的使用&lt;/h3&gt;
&lt;p&gt;​		Dubbo 的负载均衡可以在 Consumer 或者 Provider 中通过配置文件或者注解来配置。&lt;/p&gt;
&lt;h4 id=&#34;851在consumer-中配置负载均衡&#34;&gt;8.5.1在Consumer 中配置负载均衡&lt;/h4&gt;
&lt;p&gt;将 Provider 启动三次，在启动时注意修改 dubbo.protocol.port 的值。&lt;/p&gt;
&lt;h5 id=&#34;8511-启动provider-集群&#34;&gt;8.5.1.1 启动Provider 集群&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;通过创建多个启动类启动&lt;br&gt;
可以为 Provider 创建多个启动类来启动，通过不同的启动类来启动集群中不同的节点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过一个启动类启动多次&lt;br&gt;
打开配置启动项&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;30&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200629171351.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;31&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200629171413.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;选择需要多次运行的启动类，将 Allow parallel run 选中，开启允许并行运行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;8512-通过注解配置负载均衡&#34;&gt;8.5.1.2 通过注解配置负载均衡&lt;/h5&gt;
&lt;p&gt;​		在 Dubbo 中，如果没有指定负载均衡策略，那么 Dubbo 默认的使用随机策略调用Provider。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;指定负载均衡策略&lt;br&gt;
修改@Refrence 注解添加 loadbalance 属性指定负载均衡策略。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Reference(loadbalance =&amp;quot;负载均衡策略&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;随机策略配置权重&lt;br&gt;
随机获取一个[0, totalWeight)之间的数， offset = offset - weight,如果 offset 小于 0，则选中，很明显 weight 大的更容易让 offset 的值小于 0。&lt;br&gt;
举个例子 有 4 权重分别为（1，2， 3， 4）,totalWeight = 10, 假如 offset = 6, 6 - 1 = 5,5 大于 0，继续 5 - 2 = 3 大于 0，3 - 3 = 0， 0 - 4 小于 0 ，所以选择权重为 4 的 invoker, 这里可以发现只要 offset &amp;gt;= 6 则选择权重为 4 的 invoker, 正好是 40%。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过Provider 的@Service 注解配置权重&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service(weight = 权重数)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置轮询策略&lt;br&gt;
所谓轮询是指将请求轮流分配给每台服务器。举个例子，我们有三台服务器 A、B、C。我们将第一个请求分配给服务器 A，第二个请求分配给服务器 B，第三个请求分配给服务器 C，第四个请求再次分配给服务器 A。这个过程就叫做轮询。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Reference(loadbalance = &amp;quot;roundrobin&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;轮询策略加权&lt;br&gt;
如果我们将等量的请求分配给性能较差的服务器，这显然是不合理的。因此，这个时候我们需要对轮询过程进行加权，以调控每台服务器的负载。经过加权后，每台服务器能够得到的请求数比例，接近或等于他们的权重比。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service(weight = 权重数)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;8513-通过配置文件配置配置负载均衡&#34;&gt;8.5.1.3 通过配置文件配置配置负载均衡&lt;/h5&gt;
&lt;p&gt;​	在 SpringBoot 的配置文件中可以配置全局的负载均衡。Consumer 中所有调用 Provider集群的业务层都会使用该负载均衡策略。&lt;/p&gt;
&lt;p&gt;​	与注解配置方式区别：&lt;/p&gt;
&lt;p&gt;​	注解配置方式：局部，只针对当前业务层生效。&lt;/p&gt;
&lt;p&gt;​	配置文件方式：全局，对所有业务层生效。&lt;/p&gt;
&lt;p&gt;application.yml:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;dubbo:
	consumer:
		loadbalance: random
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;852-在provider-中配置负载均衡&#34;&gt;8.5.2 在Provider 中配置负载均衡&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;在Dubbo 的@Service 注解中配置负载均衡以及权重&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service(loadbalance = &amp;quot;roundrobin&amp;quot;,weight = 3)
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;通过配置文件配置负载均衡&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;dubbo:
	provider:
		loadbalance: aoundrobin
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;9-项目打包&#34;&gt;9、项目打包&lt;/h2&gt;
&lt;h3 id=&#34;91-基于springboot-整合dubbo-的打包方式&#34;&gt;9.1 基于SpringBoot 整合Dubbo 的打包方式&lt;/h3&gt;
&lt;p&gt;​	通过 SpringBoot 打包插件打包项目&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;plugin&amp;gt;
	&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
&amp;lt;/plugin&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;92-基于assembly-插件打包&#34;&gt;9.2 基于Assembly 插件打包&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Assembly 插件&lt;br&gt;
Assembly 是 Mave 的打包插件，他的作用是可以帮助我们对 &lt;strong&gt;jar&lt;/strong&gt; 项目做打包处理。在 Spring整合 dubbo 的项目中，需要使用 Assembly 打包插件来对项目做打包处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用步骤&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需要在项目根下创建一个目录，名称为 assembly&lt;/li&gt;
&lt;li&gt;将示例中 bin,conf 目录拷贝到 assembly 的根目录中&lt;/li&gt;
&lt;li&gt;删除 conf 目录中 dubbo.properties 配置文件中的内容&lt;/li&gt;
&lt;li&gt;修改项目的 POM 文件添加 assembly 的打包插件&lt;/li&gt;
&lt;li&gt;在 assembly 目录下添加 assembly.xml 配置文件&lt;/li&gt;
&lt;li&gt;运行打包插件，对项目进行打包处理。可以使用 maven 的 install 命令，也可以使用插件的命令&lt;/li&gt;
&lt;li&gt;修改 start.sh 或 start.bat 中配置信息，将启动类修改为当前 dubbo 版本的启动类&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;nohup java $JAVA_OPTS $JAVA_MEM_OPTS $JAVA_DEBUG_OPTS $JAVA_JMX_OPTS-classpath $CONF_DIR:$LIB_JARS org.apache.dubbo.container.Main &amp;gt;$STDOUT_FILE 2&amp;gt;&amp;amp;1 &amp;amp;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;10-dubbo-实战案例&#34;&gt;10、Dubbo 实战案例&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;32&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200630145113.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;101-案例介绍&#34;&gt;10.1 案例介绍&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;需求&lt;br&gt;
完成对用户表的 CRUD 操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;架构方式&lt;br&gt;
使用分布式架构方式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;技术选型&lt;br&gt;
Maven、Spring Boot、Thymeleaf、Zookeeper、Dubbo、MySql&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;项目结构设计&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;33&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200629172708.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;102-创建表&#34;&gt;10.2 创建表&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;CREATE TABLE `users` (
`userid` int(11) NOT NULL AUTO_INCREMENT,
`username` varchar(30) DEFAULT NULL,
`userage` int(11) DEFAULT NULL,
PRIMARY KEY (`userid`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;103-创建项目&#34;&gt;10.3 创建项目&lt;/h3&gt;
&lt;h4 id=&#34;1031-创建dubbo_parent-父项目&#34;&gt;10.3.1 创建dubbo_parent 父项目&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建项目&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;34&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200629215828.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改POM 文件&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot;
         xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
         xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;dubbo_parent&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;modules&amp;gt;
        &amp;lt;module&amp;gt;user_api&amp;lt;/module&amp;gt;
        &amp;lt;!--同时添加consumer为子模块，因为springboot默认会继承springboot启动器--&amp;gt;
        &amp;lt;module&amp;gt;user_consumer&amp;lt;/module&amp;gt;
        &amp;lt;module&amp;gt;user_provider&amp;lt;/module&amp;gt;
    &amp;lt;/modules&amp;gt;
    &amp;lt;!--pom 项目里没有java代码，也不执行任何代码，只是为了聚合工程或传递依赖用的。--&amp;gt;
    &amp;lt;packaging&amp;gt;pom&amp;lt;/packaging&amp;gt;

    &amp;lt;!--parent对所有非springboot依赖做集中管理--&amp;gt;
    &amp;lt;properties&amp;gt;
        &amp;lt;dubbo.spring.starter.version&amp;gt;2.7.6&amp;lt;/dubbo.spring.starter.version&amp;gt;
        &amp;lt;dubbo.registry.zookeeper.version&amp;gt;2.7.6&amp;lt;/dubbo.registry.zookeeper.version&amp;gt;
        &amp;lt;mybatis.spring.starter.version&amp;gt;2.1.2&amp;lt;/mybatis.spring.starter.version&amp;gt;
        &amp;lt;mysql.connector.version&amp;gt;5.1.38&amp;lt;/mysql.connector.version&amp;gt;
        &amp;lt;mybatis-generator.version&amp;gt;1.3.5&amp;lt;/mybatis-generator.version&amp;gt;
    &amp;lt;/properties&amp;gt;
    &amp;lt;dependencyManagement&amp;gt;
        &amp;lt;dependencies&amp;gt;
            &amp;lt;!--Dubbo Starter Dependency Version:2.7.6--&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;dubbo-spring-boot-starter&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${dubbo.spring.starter.version}&amp;lt;/version&amp;gt;
            &amp;lt;/dependency&amp;gt;
            &amp;lt;!--Zookeeper Registry Dependency Version:2.7.6--&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;dubbo-registry-zookeeper&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${dubbo.registry.zookeeper.version}&amp;lt;/version&amp;gt;
            &amp;lt;/dependency&amp;gt;
            &amp;lt;!--Mybatis Starter Dependency Version:2.1.2--&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${mybatis.spring.starter.version}&amp;lt;/version&amp;gt;
            &amp;lt;/dependency&amp;gt;
            &amp;lt;!--MySQL Driver Dependency Version:5.1.38--&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${mysql.connector.version}&amp;lt;/version&amp;gt;
            &amp;lt;/dependency&amp;gt;
        &amp;lt;/dependencies&amp;gt;
    &amp;lt;/dependencyManagement&amp;gt;
    &amp;lt;build&amp;gt;
        &amp;lt;pluginManagement&amp;gt;
            &amp;lt;plugins&amp;gt;
                &amp;lt;!--MyBatis Generator Plugin--&amp;gt;
                &amp;lt;plugin&amp;gt;
                    &amp;lt;groupId&amp;gt;org.mybatis.generator&amp;lt;/groupId&amp;gt;
                    &amp;lt;artifactId&amp;gt;mybatis-generator-maven-plugin&amp;lt;/artifactId&amp;gt;
                    &amp;lt;version&amp;gt;${mybatis-generator.version}&amp;lt;/version&amp;gt;
                &amp;lt;/plugin&amp;gt;
            &amp;lt;/plugins&amp;gt;
        &amp;lt;/pluginManagement&amp;gt;
    &amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;1032-创建user_api&#34;&gt;10.3.2 创建user_api&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建项目&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;35&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200629220530.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改POM文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot;
         xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
         xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;artifactId&amp;gt;dubbo_parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
        &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;/parent&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;artifactId&amp;gt;user_api&amp;lt;/artifactId&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;!--Zookeeper Registry Dependency--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;dubbo-registry-zookeeper&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--Dubbo Starter Dependency--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;dubbo-spring-boot-starter&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;1033-创建user_consumer&#34;&gt;10.3.3 创建user_consumer&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建项目&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;36&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200629221041.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改POM 文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
         xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.3.1.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
    &amp;lt;/parent&amp;gt;
    &amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;user_consumer&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;name&amp;gt;user_consumer&amp;lt;/name&amp;gt;
    &amp;lt;description&amp;gt;Demo project for Spring Boot&amp;lt;/description&amp;gt;

    &amp;lt;dependencyManagement&amp;gt;
        &amp;lt;!--Dependency dubbo_parent--&amp;gt;
        &amp;lt;dependencies&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;dubbo_parent&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
                &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
                &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt;
            &amp;lt;/dependency&amp;gt;
        &amp;lt;/dependencies&amp;gt;
    &amp;lt;/dependencyManagement&amp;gt;
    &amp;lt;properties&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
    &amp;lt;/properties&amp;gt;
    &amp;lt;dependencies&amp;gt;
        &amp;lt;!--user_api Dependency --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;user_api&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--Spring Boot Starter Web Dependency --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--Spring Boot Starter Thymeleaf Dependency --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-thymeleaf&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--Spring Boot Starter Test Dependency --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
            &amp;lt;exclusions&amp;gt;
                &amp;lt;exclusion&amp;gt;
                    &amp;lt;groupId&amp;gt;org.junit.vintage&amp;lt;/groupId&amp;gt;
                    &amp;lt;artifactId&amp;gt;junit-vintage-engine&amp;lt;/artifactId&amp;gt;
                &amp;lt;/exclusion&amp;gt;
            &amp;lt;/exclusions&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;

&amp;lt;/project&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改配置文件&lt;/p&gt;
&lt;p&gt;application.yml:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# 指定服务的名称
dubbo:
  application:
    name: MYConsumer
  registry:
    address: zookeeper://124.70.181.124:2181?backup=124.70.181.124:2182,124.70.181.124:2183
    timeout: 10000
  # 配置服务所使用的的协议
  protocol:
    name: dubbo
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;1034-创建user_provider-项目及模块&#34;&gt;10.3.4 创建user_provider 项目及模块&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建项目及模块&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;37&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200630010949.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改项目模块的POM 文件&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;修改Mapper 项目的POM 文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot;
         xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
         xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;artifactId&amp;gt;user_provider&amp;lt;/artifactId&amp;gt;
        &amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
        &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;/parent&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;artifactId&amp;gt;mapper&amp;lt;/artifactId&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;!--POJO Dependency--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;pojo&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--MyBatis Starter Dependency--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--MySQL Driver Dependency--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;!--MyBatis Generator Plugin--&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.mybatis.generator&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;mybatis-generator-maven-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;dependencies&amp;gt;
                    &amp;lt;dependency&amp;gt;
                        &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
                        &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
                        &amp;lt;version&amp;gt;5.1.38&amp;lt;/version&amp;gt;
                    &amp;lt;/dependency&amp;gt;
                &amp;lt;/dependencies&amp;gt;
                &amp;lt;!--指定配置文件的路径--&amp;gt;
                &amp;lt;configuration&amp;gt;

                    &amp;lt;configurationFile&amp;gt;${project.basedir}/src/main/resources/generatorConfig.xml&amp;lt;/configurationFile&amp;gt;
                    &amp;lt;verbose&amp;gt;true&amp;lt;/verbose&amp;gt;
                    &amp;lt;overwrite&amp;gt;true&amp;lt;/overwrite&amp;gt;
                &amp;lt;/configuration&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
        &amp;lt;resources&amp;gt;
            &amp;lt;!--Configure Resource Copy Path--&amp;gt;
            &amp;lt;resource&amp;gt;
                &amp;lt;directory&amp;gt;src/main/java&amp;lt;/directory&amp;gt;
                &amp;lt;includes&amp;gt;
                    &amp;lt;include&amp;gt;**/*.xml&amp;lt;/include&amp;gt;
                &amp;lt;/includes&amp;gt;
            &amp;lt;/resource&amp;gt;
        &amp;lt;/resources&amp;gt;
    &amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;修改Provider 项目的POM 文件&lt;/p&gt;
&lt;p&gt;继承 Spring Boot 父工程&lt;/p&gt;
&lt;p&gt;继承 dubbo_parent 工程&lt;/p&gt;
&lt;p&gt;添加其他依赖&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot;
         xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
         xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.3.1.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
    &amp;lt;/parent&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;provider&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPASHOT&amp;lt;/version&amp;gt;

    &amp;lt;dependencyManagement&amp;gt;
        &amp;lt;dependencies&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;user_provider&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
                &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
                &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt;
            &amp;lt;/dependency&amp;gt;
        &amp;lt;/dependencies&amp;gt;
    &amp;lt;/dependencyManagement&amp;gt;
    &amp;lt;properties&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
    &amp;lt;/properties&amp;gt;
    &amp;lt;dependencies&amp;gt;
        &amp;lt;!--Mapper Dependency--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mapper&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--user_api Dependency--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;user_api&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--Spring Boot Starter Dependency--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--Spring Boot Test Starter Dependency--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
            &amp;lt;exclusions&amp;gt;
                &amp;lt;exclusion&amp;gt;
                    &amp;lt;groupId&amp;gt;org.junit.vintage&amp;lt;/groupId&amp;gt;
                    &amp;lt;artifactId&amp;gt;junit-vintage-engine&amp;lt;/artifactId&amp;gt;
                &amp;lt;/exclusion&amp;gt;
            &amp;lt;/exclusions&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置Provider&lt;/p&gt;
&lt;p&gt;因为是maven项目修改成springboot项目的，所以要手动添加application.yml和启动类&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;添加application.yml 配置文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;#配置数据源
spring:
  datasource:
    driver-class-name: com.mysql.jdbc.Driver
    url: jdbc:mysql://localhost:3306/test03?serverTimezone=UTC
    username: root
    password: root
#Mybatis 配置
mybatis:
  type-aliases-package: com.bjsxt.pojo
#Dubbo 配置
dubbo:
  application:
    name: MYProvider
  registry: address:zookeeper://124.70.181.124:2181?backup=124.70.181.124:2182,124.70.181.124:2183
    timeout: 10000
#配置服务协议及端口
  protocol:
    name: dubbo
    port: 20880
#配置 Dubbo 扫描包
  scan:
    base-packages: com.cy.provider.service.impl
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;需改启动类&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SpringBootApplication
@MapperScan(&amp;quot;com.cy.mapper&amp;quot;) //指定扫描Mapper的包
public class ProviderApplication {
    public static void main(String[] args) {
        SpringApplication.run(ApplicationProvider.class,args);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;1035-通过mybatis-generator-插件生成mapper-与pojo&#34;&gt;10.3.5 通过Mybatis Generator 插件生成Mapper 与POJO&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;添加generatorConfig.xml 配置文件&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;38&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200630012843.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;!DOCTYPE generatorConfiguration
  PUBLIC &amp;quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&amp;quot;
  &amp;quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&amp;quot;&amp;gt;

&amp;lt;generatorConfiguration&amp;gt;
	&amp;lt;context id=&amp;quot;testTables&amp;quot; targetRuntime=&amp;quot;MyBatis3&amp;quot;&amp;gt;
		&amp;lt;!-- 生成实体类实现序列化--&amp;gt;
		&amp;lt;plugin type=&amp;quot;org.mybatis.generator.plugins.SerializablePlugin&amp;quot;  /&amp;gt;
		&amp;lt;!-- 实体类中包含toString() --&amp;gt;
		&amp;lt;plugin type=&amp;quot;org.mybatis.generator.plugins.ToStringPlugin&amp;quot; &amp;gt;&amp;lt;/plugin&amp;gt;
		&amp;lt;commentGenerator&amp;gt;
			&amp;lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&amp;gt;
			&amp;lt;property name=&amp;quot;suppressAllComments&amp;quot; value=&amp;quot;true&amp;quot; /&amp;gt;
		&amp;lt;/commentGenerator&amp;gt;
		&amp;lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&amp;gt;
		&amp;lt;jdbcConnection driverClass=&amp;quot;com.mysql.jdbc.Driver&amp;quot;
			connectionURL=&amp;quot;jdbc:mysql://localhost:3306/test03&amp;quot; userId=&amp;quot;root&amp;quot;
			password=&amp;quot;root&amp;quot;&amp;gt;
		&amp;lt;/jdbcConnection&amp;gt;
		&amp;lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和 
			NUMERIC 类型解析为java.math.BigDecimal --&amp;gt;
		&amp;lt;javaTypeResolver&amp;gt;
			&amp;lt;property name=&amp;quot;forceBigDecimals&amp;quot; value=&amp;quot;false&amp;quot; /&amp;gt;
		&amp;lt;/javaTypeResolver&amp;gt;

		&amp;lt;!-- targetProject:生成PO类的位置 --&amp;gt;
		&amp;lt;javaModelGenerator targetPackage=&amp;quot;com.cy.pojo&amp;quot;
			targetProject=&amp;quot;.\src\main\java&amp;quot;&amp;gt;
			&amp;lt;!-- enableSubPackages:是否让schema作为包的后缀 --&amp;gt;
			&amp;lt;property name=&amp;quot;enableSubPackages&amp;quot; value=&amp;quot;false&amp;quot; /&amp;gt;
			&amp;lt;!-- 从数据库返回的值被清理前后的空格 --&amp;gt;
			&amp;lt;property name=&amp;quot;trimStrings&amp;quot; value=&amp;quot;true&amp;quot; /&amp;gt;
		&amp;lt;/javaModelGenerator&amp;gt;
        &amp;lt;!-- targetProject:mapper映射文件生成的位置 --&amp;gt;
		&amp;lt;sqlMapGenerator targetPackage=&amp;quot;com.cy.mapper&amp;quot;
			targetProject=&amp;quot;.\src\main\java&amp;quot;&amp;gt;
			&amp;lt;!-- enableSubPackages:是否让schema作为包的后缀 --&amp;gt;
			&amp;lt;property name=&amp;quot;enableSubPackages&amp;quot; value=&amp;quot;false&amp;quot; /&amp;gt;
		&amp;lt;/sqlMapGenerator&amp;gt;
		&amp;lt;!-- targetPackage：mapper接口生成的位置 --&amp;gt;
		&amp;lt;javaClientGenerator type=&amp;quot;XMLMAPPER&amp;quot;
			targetPackage=&amp;quot;com.cy.mapper&amp;quot;
			targetProject=&amp;quot;.\src\main\java&amp;quot;&amp;gt;
			&amp;lt;!-- enableSubPackages:是否让schema作为包的后缀 --&amp;gt;
			&amp;lt;property name=&amp;quot;enableSubPackages&amp;quot; value=&amp;quot;false&amp;quot; /&amp;gt;
		&amp;lt;/javaClientGenerator&amp;gt;
		&amp;lt;!-- 指定数据库表 --&amp;gt;
		&amp;lt;table schema=&amp;quot;&amp;quot; tableName=&amp;quot;users&amp;quot;&amp;gt;&amp;lt;/table&amp;gt;

	&amp;lt;/context&amp;gt;
&amp;lt;/generatorConfiguration&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行Mybatis Generator 插件&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;39&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200630012929.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;将实体类拷贝到pojo 项目中&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;40&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200630012953.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;104-修改user_api-的pom-文件添加pojo-依赖&#34;&gt;10.4 修改user_api 的POM 文件添加pojo 依赖&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在user_api中添加pojo 依赖&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;        &amp;lt;!--pojo Dependency--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;pojo&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;排除冲突依赖&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;41&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200630013121.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;42&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200630013248.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;        &amp;lt;!--Zookeeper Registry Dependency--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;dubbo-registry-zookeeper&amp;lt;/artifactId&amp;gt;
            &amp;lt;exclusions&amp;gt;
                &amp;lt;exclusion&amp;gt;
                    &amp;lt;artifactId&amp;gt;slf4j-log4j12&amp;lt;/artifactId&amp;gt;
                    &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
                &amp;lt;/exclusion&amp;gt;
            &amp;lt;/exclusions&amp;gt;
        &amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;105-实现业务&#34;&gt;10.5 实现业务&lt;/h3&gt;
&lt;h4 id=&#34;1051-添加用户业务&#34;&gt;10.5.1 添加用户业务&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建添加用户业务接口&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在user_api 项目中创建添加用户接口&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface AddUserService {
	void addUser(Users users);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;在provider 中实现添加用户业务接口&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 添加用户业务
 */
@Service
public class AddUserServiceImpl implements AddUserService {
    @Autowired
    private UsersMapper usersMapper;
    @Override
    public void addUser(Users users) {
        this.usersMapper.insert(users);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在Consumer 中调用添加用户业务接口&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建首页&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;首页&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;a href=&amp;quot;/addUser&amp;quot;&amp;gt;添加用户&amp;lt;/a&amp;gt;&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;&amp;lt;a href=&amp;quot;/user/getUser&amp;quot;&amp;gt;查询用户&amp;lt;/a&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;创建页面跳转Controller&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 页面跳转controller
 */
@Controller
public class PageController {
    /**
     * 页面跳转方法
     */
    @RequestMapping(&amp;quot;/{page}&amp;quot;)
    public String showPage(@PathVariable String page){
        return page;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;创建添加用户页面&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;添加用户&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;form action=&amp;quot;/user/addUser&amp;quot; method=&amp;quot;post&amp;quot;&amp;gt;
    用户姓名：&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;username&amp;quot;&amp;gt;&amp;lt;br/&amp;gt;
    用户性别：&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;username&amp;quot;&amp;gt;&amp;lt;br/&amp;gt;
    &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;ok&amp;quot;&amp;gt;
&amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;创建Consumer 业务层&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;UserService接口：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface UserService {
    void addUser(Users users);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;UserServiceImpl:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 用户操作业务层
 */
@Service
public class UserServiceImpl implements UserService {
    @Reference
    private AddUserService addUserService;

    @Override
    public void addUser(Users users) {
        this.addUserService.addUser(users);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;创建添加用户Controller&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 处理用户操作控制器
 */
@Controller
@RequestMapping(&amp;quot;/user&amp;quot;)
public class UserController {

    @Autowired
    private UserService userService;

    /**
     * 处理添加用户请求
     */
    @PostMapping(&amp;quot;/addUser&amp;quot;)
    public String addUser(Users users){
        this.userService.addUser(users);
        return &amp;quot;redirect:/ok&amp;quot;;
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;创建成功页面&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;成功页面&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    操作成功，请&amp;lt;a href=&amp;quot;/index&amp;quot;&amp;gt;返回&amp;lt;/a&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;1052-查询用户业务&#34;&gt;10.5.2 查询用户业务&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建查询用户业务接口&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在user_api 项目中添加查询用户业务接口&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface FindUserService {
    List&amp;lt;Users&amp;gt; findUserAll();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;在provider 中实现查询用户业务接口&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 查询所有用户业务层
 */
@Service
public class FindUserServiceImpl implements FindUserService {
    @Autowired
    private UsersMapper usersMapper;

    /**
     * 查询全部用户
     * @return
     */
    @Override
    public List&amp;lt;Users&amp;gt; findUserAll() {
        UsersExample example = new UsersExample();
        return this.usersMapper.selectByExample(example);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在Consumer 中调用查询用户业务&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;修改Consumer 业务层添加查询用户业务&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;UserService接口:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface UserService {
    void addUser(Users users);
    List&amp;lt;Users&amp;gt; getUsersAll();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;UserServiceImpl：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
public class UserServiceImpl implements UserService {
    @Reference
    private AddUserService addUserService;

    @Reference
    private FindUserService findUserService;

    @Override
    public void addUser(Users users) {
        this.addUserService.addUser(users);
    }

    /**
     * 查询所有用户
     * @return
     */
    @Override
    public List&amp;lt;Users&amp;gt; getUsersAll() {
        return this.findUserService.findUserAll();
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;修改Consumer 添加处理查询用户请求&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 处理用户操作控制器
 */
@Controller
@RequestMapping(&amp;quot;/user&amp;quot;)
public class UsersController {
    @Autowired
    private UserService userService;
    /**
     * 处理添加用户请求
     */
    @RequestMapping(&amp;quot;/addUser&amp;quot;)
    public String addUser(Users users){
        this.userService.addUser(users);
        return &amp;quot;redirect:/ok&amp;quot;;
    }

    /**
     * 处理查询用户请求
     */
    @RequestMapping(&amp;quot;/getUser&amp;quot;)
    public String getUser(Model model){
        List&amp;lt;Users&amp;gt; list = this.userService.getUsersAll();
        model.addAttribute(&amp;quot;list&amp;quot;,list);
        return &amp;quot;showUser&amp;quot;;
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;创建showUser 页面&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot; xmlns:th=&amp;quot;http://www.thymeleaf.org&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;显示用户&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;table border=&amp;quot;1&amp;quot; align=&amp;quot;center&amp;quot;&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;th&amp;gt;用户ID&amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;用户姓名&amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;用户年龄&amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;操作&amp;lt;/th&amp;gt;
        &amp;lt;/tr&amp;gt;
        &amp;lt;tr th:each=&amp;quot;user:${list}&amp;quot;&amp;gt;
            &amp;lt;td th:text=&amp;quot;${user.userid}&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
            &amp;lt;td th:text=&amp;quot;${user.username}&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
            &amp;lt;td th:text=&amp;quot;${user.userage}&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;
                &amp;lt;a th:href=&amp;quot;@{/user/preUpdateUser(userid=${user.userid})}&amp;quot;&amp;gt;修改用户&amp;lt;/a&amp;gt;
                &amp;lt;a th:href=&amp;quot;@{/user/deleteUser(userid=${user.userid})}&amp;quot;&amp;gt;删除用户&amp;lt;/a&amp;gt;
            &amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
    &amp;lt;/table&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;1053-更新用户业务&#34;&gt;10.5.3 更新用户业务&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建更新用户业务接口&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在user_api 项目中添加更新用户业务接口&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface UpdateUserService {Users preUpdateUsers(Integer userid);
	void updateUsers(Users users);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;在provider 中实现更新用户业务接口&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 更新用户业务
 */
@Service
public class UpdateUserServiceImpl implements UpdateUserService {

    @Autowired
    private UsersMapper usersMapper;


    /**
     * 预更新用户查询
     * @param userid
     * @return
     */
    @Override
    public Users preUpdateUsers(Integer userid) {
        return this.usersMapper.selectByPrimaryKey(userid);
    }

    /**
     * 更新用户
     * @param users
     */
    @Override
    public void updateUsers(Users users) {
        this.usersMapper.updateByPrimaryKey(users);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在Consumer 中调用更新用户业务&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;修改Consumer 业务层添加预更新查询用户业务&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;UserService接口:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface UserService {
    void addUser(Users users);
    List&amp;lt;Users&amp;gt; getUsersAll();
    Users preUpdateUsers(Integer userid);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;UserServiceImpl:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 用户操作业务层
 */
@Service
public class UserServiceImpl implements UserService {
    @Reference
    private AddUserService addUserService;

    @Reference
    private FindUserService findUserService;

    @Reference
    private UpdateUserService updateUserService;

    @Override
    public void addUser(Users users) {
        this.addUserService.addUser(users);
    }

    /**
     * 查询所有用户
     * @return
     */
    @Override
    public List&amp;lt;Users&amp;gt; getUsersAll() {
        return this.findUserService.findUserAll();
    }

    /**
     * 根据用户ID查询用户
     * @param userid
     * @return
     */
    @Override
    public Users preUpdateUsers(Integer userid) {
        return this.updateUserService.preUpdateUsers(userid);
    }

}

&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;修改Consumer 添加处理查询用户请求&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 处理用户操作控制器
 */
@Controller
@RequestMapping(&amp;quot;/user&amp;quot;)
public class UsersController {
    @Autowired
    private UserService userService;
    /**
     * 处理添加用户请求
     */
    @RequestMapping(&amp;quot;/addUser&amp;quot;)
    public String addUser(Users users){
        this.userService.addUser(users);
        return &amp;quot;redirect:/ok&amp;quot;;
    }

    /**
     * 处理查询用户请求
     */
    @RequestMapping(&amp;quot;/getUser&amp;quot;)
    public String getUser(Model model){
        List&amp;lt;Users&amp;gt; list = this.userService.getUsersAll();
        model.addAttribute(&amp;quot;list&amp;quot;,list);
        return &amp;quot;showUser&amp;quot;;
    }

    /**
     * 处理预更新查询请求
     */
    @RequestMapping(&amp;quot;/preUpdateUser&amp;quot;)
    public String preUpdateUser(Integer userid,Model model){
        Users users = this.userService.preUpdateUsers(userid);
        model.addAttribute(&amp;quot;users&amp;quot;,users);
        return &amp;quot;updateUsers&amp;quot;;
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;创建更新用户页面&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot; xmlns:th=&amp;quot;http://www.thymeleaf.org&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;更新用户&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;form action=&amp;quot;/user/updateUser&amp;quot; method=&amp;quot;post&amp;quot;&amp;gt;
        &amp;lt;input type=&amp;quot;hidden&amp;quot; name=&amp;quot;userid&amp;quot; th:value=&amp;quot;${users.userid}&amp;quot;/&amp;gt;&amp;lt;br/&amp;gt;
       用户姓名： &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;username&amp;quot; th:value=&amp;quot;${users.username}&amp;quot;/&amp;gt;&amp;lt;br/&amp;gt;
        用户年龄：&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;userage&amp;quot; th:value=&amp;quot;${users.userage}&amp;quot;/&amp;gt;&amp;lt;br/&amp;gt;
        &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;Update&amp;quot;/&amp;gt;
    &amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;修改Consumer 业务层添加更新用户业务&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;UserService接口：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface UserService {
    void addUser(Users users);
    List&amp;lt;Users&amp;gt; getUsersAll();
    Users preUpdateUsers(Integer userid);
    void updateUsers(Users users);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;UserServiceImpl：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 用户操作业务层
 */
@Service
public class UserServiceImpl implements UserService {
    @Reference
    private AddUserService addUserService;

    @Reference
    private FindUserService findUserService;

    @Reference
    private UpdateUserService updateUserService;

    @Override
    public void addUser(Users users) {
        this.addUserService.addUser(users);
    }

    /**
     * 查询所有用户
     * @return
     */
    @Override
    public List&amp;lt;Users&amp;gt; getUsersAll() {
        return this.findUserService.findUserAll();
    }

    /**
     * 根据用户ID查询用户
     * @param userid
     * @return
     */
    @Override
    public Users preUpdateUsers(Integer userid) {
        return this.updateUserService.preUpdateUsers(userid);
    }

    /**
     * 更新用户
     * @param users
     */
    @Override
    public void updateUsers(Users users) {
        this.updateUserService.updateUsers(users);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;修改Consumer 添加处理更新用户请求&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 处理用户操作控制器
 */
@Controller
@RequestMapping(&amp;quot;/user&amp;quot;)
public class UsersController {
    @Autowired
    private UserService userService;
    /**
     * 处理添加用户请求
     */
    @RequestMapping(&amp;quot;/addUser&amp;quot;)
    public String addUser(Users users){
        this.userService.addUser(users);
        return &amp;quot;redirect:/ok&amp;quot;;
    }

    /**
     * 处理查询用户请求
     */
    @RequestMapping(&amp;quot;/getUser&amp;quot;)
    public String getUser(Model model){
        List&amp;lt;Users&amp;gt; list = this.userService.getUsersAll();
        model.addAttribute(&amp;quot;list&amp;quot;,list);
        return &amp;quot;showUser&amp;quot;;
    }

    /**
     * 处理预更新查询请求
     */
    @RequestMapping(&amp;quot;/preUpdateUser&amp;quot;)
    public String preUpdateUser(Integer userid,Model model){
        Users users = this.userService.preUpdateUsers(userid);
        model.addAttribute(&amp;quot;users&amp;quot;,users);
        return &amp;quot;updateUsers&amp;quot;;
    }

    /**
     * 处理更新用户请求
     */
    @RequestMapping(&amp;quot;/updateUser&amp;quot;)
    public String updateUser(Users users){
        this.userService.updateUsers(users);
        return &amp;quot;redirect:/ok&amp;quot;;
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;1054-删除用户业务&#34;&gt;10.5.4 删除用户业务&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建删除用户业务接口&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在user_api 项目中添加删除用户业务接口&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface DeleteUserService {
	void deleteUsersById(Integer userid);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;在provider 中实现删除用户业务接口&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 删除用户业务
 */
@Service
public class DeleteUserServiceImpl implements DeleteUserService {
    @Autowired
    private UsersMapper usersMapper;

    /**
     * 根据用户ID删除用户
     * @param userid
     */
    @Override
    public void deleteUsersById(Integer userid) {
        this.usersMapper.deleteByPrimaryKey(userid);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在Consumer 中调用删除用户业务&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;修改Consumer 业务层添加删除用户业务&lt;/p&gt;
&lt;p&gt;UserService接口：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface UserService {
    void addUser(Users users);
    List&amp;lt;Users&amp;gt; getUsersAll();
    Users preUpdateUsers(Integer userid);
    void updateUsers(Users users);
    void deleteUsersById(Integer userid);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	UserServiceImpl：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 用户操作业务层
 */
@Service
public class UserServiceImpl implements UserService {
    @Reference
    private AddUserService addUserService;

    @Reference
    private FindUserService findUserService;

    @Reference
    private UpdateUserService updateUserService;

    @Reference
    private DeleteUserService deleteUserService;

    @Override
    public void addUser(Users users) {
        this.addUserService.addUser(users);
    }

    /**
     * 查询所有用户
     * @return
     */
    @Override
    public List&amp;lt;Users&amp;gt; getUsersAll() {
        return this.findUserService.findUserAll();
    }

    /**
     * 根据用户ID查询用户
     * @param userid
     * @return
     */
    @Override
    public Users preUpdateUsers(Integer userid) {
        return this.updateUserService.preUpdateUsers(userid);
    }

    /**
     * 更新用户
     * @param users
     */
    @Override
    public void updateUsers(Users users) {
        this.updateUserService.updateUsers(users);
    }

    /**
     * 根据用户ID删除用户
     * @param userid
     */
    @Override
    public void deleteUsersById(Integer userid) {
        this.deleteUserService.deleteUsersById(userid);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;修改Consumer 添加处理删除用户请求&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 处理用户操作控制器
 */
@Controller
@RequestMapping(&amp;quot;/user&amp;quot;)
public class UsersController {
    @Autowired
    private UserService userService;
    /**
     * 处理添加用户请求
     */
    @RequestMapping(&amp;quot;/addUser&amp;quot;)
    public String addUser(Users users){
        this.userService.addUser(users);
        return &amp;quot;redirect:/ok&amp;quot;;
    }

    /**
     * 处理查询用户请求
     */
    @RequestMapping(&amp;quot;/getUser&amp;quot;)
    public String getUser(Model model){
        List&amp;lt;Users&amp;gt; list = this.userService.getUsersAll();
        model.addAttribute(&amp;quot;list&amp;quot;,list);
        return &amp;quot;showUser&amp;quot;;
    }

    /**
     * 处理预更新查询请求
     */
    @RequestMapping(&amp;quot;/preUpdateUser&amp;quot;)
    public String preUpdateUser(Integer userid,Model model){
        Users users = this.userService.preUpdateUsers(userid);
        model.addAttribute(&amp;quot;users&amp;quot;,users);
        return &amp;quot;updateUsers&amp;quot;;
    }

    /**
     * 处理更新用户请求
     */
    @RequestMapping(&amp;quot;/updateUser&amp;quot;)
    public String updateUser(Users users){
        this.userService.updateUsers(users);
        return &amp;quot;redirect:/ok&amp;quot;;
    }

    /**
     * 处理删除用户请求
     */
    @RequestMapping(&amp;quot;/deleteUser&amp;quot;)
    public String deleteUser(Integer userid){
        this.userService.deleteUsersById(userid);
        return &amp;quot;redirect:/ok&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;1055-项目部署&#34;&gt;10.5.5 项目部署&lt;/h4&gt;
&lt;h5 id=&#34;10551部署环境&#34;&gt;10.5.5.1部署环境&lt;/h5&gt;
&lt;p&gt;​	安装三台 Linux 操作系统，并正确安装 JDK。例如：&lt;br&gt;
​	192.168.233.130：部署 Zookeeper&lt;br&gt;
​	192.168.233.131：部署 Provider&lt;br&gt;
​	192.168.233.132：部署 Consumer&lt;/p&gt;
&lt;h5 id=&#34;10552-部署provider&#34;&gt;10.5.5.2 部署Provider&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在配置文件中修改数据库连接地址&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;#配置数据源
spring:
datasource:
driver-class-name: com.mysql.jdbc.Driver
url: jdbc:mysql://192.168.1.3:3306/test03?serverTimezone=UTC
username: root
password: root
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在Linux 系统中创建Provider 目录&lt;/p&gt;
&lt;p&gt;[root@localhost local]# mkdir provider&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;项目打包&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;43&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200630142002.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;上传启Provider 项目与启动脚本&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;44&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200630142028.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为启动脚本分配执行权限&lt;/p&gt;
&lt;p&gt;root@localhost provider]# chmod 777 server.sh&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动Provider&lt;/p&gt;
&lt;p&gt;[root@localhost logs]# ./server.sh start&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;10553-部署consumer&#34;&gt;10.5.5.3 部署Consumer&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在Linux 系统中创建Consumer 目录&lt;/p&gt;
&lt;p&gt;[root@localhost local]# mkdir consumer&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;项目打包&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;45&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200630142002.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;上传启Provider 项目与启动脚本&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;46&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200630142328.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为启动脚本分配执行权限&lt;/p&gt;
&lt;p&gt;root@localhost provider]# chmod 777 server.sh&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动Consumer&lt;/p&gt;
&lt;p&gt;[root@localhost logs]# ./server.sh start&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;10554-测试&#34;&gt;10.5.5.4 测试&lt;/h5&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;47&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200630142421.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">Dubbo</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jonchan1013.github.io/post/zookeeper/"" data-c="
          &lt;h2 id=&#34;1-zookeeper简介&#34;&gt;1、Zookeeper简介&lt;/h2&gt;
&lt;p&gt;Zookeeper 官网：http://zookeeper.apache.org/&lt;br&gt;
Zookeeper 是 Apache 的一个分布式服务框架，是 Apache Hadoop 的一个子项目。官方文档上这么解释 Zookeeper，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。&lt;br&gt;
简单来说 zookeeper=文件系统+监听通知机制。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;2-zookeeper存储结构&#34;&gt;2、Zookeeper存储结构&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200623131938.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;21-znode&#34;&gt;2.1 Znode&lt;/h3&gt;
&lt;p&gt;在 Zookeeper 中，znode 是一个跟 Unix 文件系统路径相似的节点，可以向节点存储数据或者获取数据。&lt;/p&gt;
&lt;p&gt;Zookeeper 底层是一套数据结构。这个存储结构是一个树形结构，其上的每一个节点，我们称之为“znode”&lt;/p&gt;
&lt;p&gt;Zookeeper 中的数据是按照“树”结构进行存储的。而且 znode 节点还分为 4 中不同的类型。&lt;/p&gt;
&lt;p&gt;每一个 znode 默认能够存储 1MB 的数据（对于记录状态性质的数据来说，够了）&lt;/p&gt;
&lt;p&gt;可以使用 zkCli 命令，登录到 Zookeeper 上，并通过 ls、create、delete、get、set等命令操作这些 znode 节点。&lt;/p&gt;
&lt;h3 id=&#34;22-znode节点类型&#34;&gt;2.2 Znode节点类型&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;PERSISTENT-持久化目录节点&lt;/p&gt;
&lt;p&gt;客户端与 zookeeper 断开连接后，该节点依旧存在。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PERSISTENT_SEQUENTIAL-持久化顺序编号目录节点&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;客户端与 zookeeper 断开连接后，该节点依旧存在，只是 Zookeeper 给该节点名称进行顺序编号。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;EPHEMERAL-临时目录节点&lt;/p&gt;
&lt;p&gt;客户端与 zookeeper 断开连接后，该节点被删除。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点&lt;/p&gt;
&lt;p&gt;客户端与 zookeeper 断开连接后，该节点被删除，只是 Zookeeper 给该节点名称进行顺序编号。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-监听通知机制&#34;&gt;3、监听通知机制&lt;/h2&gt;
&lt;p&gt;​		Zookeeper 是使用观察者设计模式来设计的。当客户端注册监听它关心的目录节点时，当目录节点发生变化（数据改变、被删除、子目录节点增加删除）时，Zookeeper 会通知客户端。&lt;/p&gt;
&lt;h2 id=&#34;4-安装-zookeeper&#34;&gt;4、安装 zookeeper&lt;/h2&gt;
&lt;p&gt;​		官方资源包可在 zookeeper.apache.com 站点中下载。本次安装版本为：3.6.0。&lt;/p&gt;
&lt;h3 id=&#34;41-安装单机版&#34;&gt;4.1 安装单机版&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安装 Linux&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装 JDK&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;上传 Zookeeper&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解压 Zookeeper 压缩包&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Zookeeper 目录结构&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200623132527.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;bin：放置运行脚本和工具脚本，&lt;/li&gt;
&lt;li&gt;conf：zookeeper 默认读取配置的目录，里面会有默认的配置文件&lt;/li&gt;
&lt;li&gt;docs：zookeeper 相关的文档&lt;/li&gt;
&lt;li&gt;lib：zookeeper 核心的 jar&lt;/li&gt;
&lt;li&gt;logs：zookeeper 日志&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置 Zookeeper&lt;/p&gt;
&lt;p&gt;Zookeeper 在启动时默认的去 conf 目录下查找一个名称为 zoo.cfg 的配置文件。在 zookeeper 应用目录中有子目录 conf。其中有配置文件模板：zoo_sample.cfg&lt;br&gt;
cp zoo_sample.cfg zoo.cfg。zookeeper 应用中的配置文件为 conf/zoo.cfg。&lt;/p&gt;
&lt;p&gt;修改配置文件 zoo.cfg - 设置数据缓存路径(这里把缓存放到Zookeeper根目录下新建的data文件夹)&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200623132606.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200623132629.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200623132718.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动 Zookeeper&lt;/p&gt;
&lt;p&gt;默认加载配置文件：./zkServer.sh start：默认的会去 conf 目录下加载 zoo.cfg 配置文件。&lt;br&gt;
指定加载配置文件：./zkServer.sh start 配置文件的路径。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200623132950.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200623133029.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;停止 Zookeeper&lt;/p&gt;
&lt;p&gt;./zkServer.sh stop&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看 Zookeeper 状态&lt;br&gt;
./zkServer.sh status&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200623134226.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用客户端连接单机版 Zookeeper&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;连接方式一&lt;/p&gt;
&lt;p&gt;bin/zkCli.sh&lt;br&gt;
默认连接地址为本机地址，默认连接端口为 2181&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200623134503.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;连接方式二&lt;/p&gt;
&lt;p&gt;bin/zkCli.sh -server ip:port&lt;br&gt;
连接指定 IP 地址与端口&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;42-安装集群版&#34;&gt;4.2 安装集群版&lt;/h3&gt;
&lt;h4 id=&#34;421-zookeeper-集群说明&#34;&gt;4.2.1 Zookeeper 集群说明&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;Zookeeper 集群中的角色&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Zookeeper 集群中的角色主要有以下三类&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200623142410.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200623142420.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;422-集群安装&#34;&gt;4.2.2 集群安装&lt;/h4&gt;
&lt;p&gt;​	使用 3 个 Zookeeper 应用搭建一个伪集群。应用部署位置是：192.168.233.130。客户端监听端口分别为：2181、2182、2183。投票选举端口分别为 2881/3881、2882/3882、2883/3883。&lt;/p&gt;
&lt;p&gt;​	tar -zxf zookeeper-3.6.0.tar.gz&lt;br&gt;
​	将解压后的 Zookeeper 应用目录重命名，便于管理&lt;br&gt;
​	mv zookeeper-3.6.0 zookeeper01&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;提供数据缓存目录&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 zookeeper01 应用目录中，创建 data 目录，用于缓存应用运行数据&lt;br&gt;
cd zookeeper01&lt;br&gt;
mkdir data&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;复制应用&lt;br&gt;
复制两份 Zookeeper 应用。用于模拟集群中的 3 个节点。&lt;br&gt;
cp -r zookeeper01 zookeeper02&lt;br&gt;
cp -r zookeeper01 zookeeper03&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提供配置文件&lt;br&gt;
在 zookeeper 应用目录中有子目录 conf。其中有配置文件模板：zoo_sample.cfg&lt;br&gt;
cp zoo_sample.cfg zoo.cfg&lt;br&gt;
zookeeper 应用中的配置文件为 conf/zoo.cfg。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改配置文件 zoo.cfg - 设置数据缓存路径&lt;br&gt;
dataDir 参数值为应用运行缓存数据保存目录。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提供应用唯一标识&lt;br&gt;
在 Zookeeper 集群中，每个节点需要一个唯一标识。这个唯一标识要求是自然数。且唯一标识保存位置是：数据缓存目录(dataDir=/usr/local/zookeeper/data)的 myid 文件中。其中“数据缓存目录”为配置文件 zoo.cfg 中的配置参数在 data 目录中创建文件 myid ： touch myid&lt;/p&gt;
&lt;p&gt;为应用提供唯一标识。本环境中使用 1、2、3 作为每个节点的唯一标识。&lt;br&gt;
vi myid&lt;br&gt;
简化方式为： echo [唯一标识] &amp;gt;&amp;gt; myid。 echo 命令为回声命令，系统会将命令发送的数据返回。 &#39;&amp;gt;&amp;gt;&#39;为定位，代表系统回声数据指定发送到什么位置。 此命令代表系统回声数据发送到 myid 文件中。 如果没有文件则创建文件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200623142717.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;
&lt;p&gt;修改配置文件 zoo.cfg - 设置监听客户端、投票、选举端口&lt;/p&gt;
&lt;p&gt;vim zoo.cfg&lt;/p&gt;
&lt;p&gt;clientPort=2181 #服务端口根据应用做对应修改,zk01-2181,zk02-2182,zk03-2183&lt;br&gt;
server.1=192.168.0.179:2881:3881&lt;br&gt;
server.2=192.168.0.179:2882:3882&lt;br&gt;
server.3=192.168.0.179:2883:3883&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：192.168.0.179代表zookeeper所在的服务器的IP，2881是zookeeper内部连接的端口号，3881是投票机制的端口&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200623165813.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200623165851.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200623165926.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200623144201.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/1592902142716_59800662-2B29-4867-AACF-1D8BA6D57A80.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;423-编写启动-关闭集群脚本&#34;&gt;4.2.3 编写启动、关闭集群脚本&lt;/h4&gt;
&lt;p&gt;在 Linux 中可以使用 chmod 命令为文件授权。&lt;br&gt;
chmod 777 文件名&lt;br&gt;
777 表示为文件分配可读，可写，可执行权限。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;启动 Zookeeper 集群脚本&lt;/p&gt;
&lt;p&gt;zookeeper01/bin/zkServer.sh start&lt;br&gt;
zookeeper02/bin/zkServer.sh start&lt;br&gt;
zookeeper03/bin/zkServer.sh start&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关闭 Zookeeper 集群脚本&lt;/p&gt;
&lt;p&gt;zookeeper01/bin/zkServer.sh stop&lt;/p&gt;
&lt;p&gt;zookeeper02/bin/zkServer.sh stop&lt;br&gt;
zookeeper03/bin/zkServer.sh stop&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;18&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200623165653.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;424-连接集群&#34;&gt;4.2.4 连接集群&lt;/h4&gt;
&lt;p&gt;可以使用任何节点中的客户端工具连接集群中的任何节点。&lt;br&gt;
./zkCli.sh -server 192.168.0.179:2183&lt;/p&gt;
&lt;h2 id=&#34;5-zookeeper-常用命令&#34;&gt;5、Zookeeper 常用命令&lt;/h2&gt;
&lt;h3 id=&#34;51-ls-命令&#34;&gt;5.1  ls 命令&lt;/h3&gt;
&lt;p&gt;​	ls /path&lt;/p&gt;
&lt;p&gt;​	使用 ls 命令查看 zookeeper 中的内容。在 ZooKeeper 控制台客户端中，没有默认列表功能，必须指定要列表资源的位置。 如： ls / 或者 ls /path&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;19&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200624091621.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;52-create-命令&#34;&gt;5.2 create 命令&lt;/h3&gt;
&lt;p&gt;​		create [-e] [-s] /path [data]&lt;br&gt;
​		使用 create 命令创建一个新的 Znode。create [-e] [-s] path data - 创建节点，默认不加是永久节点，如： create /test 123 创建一个/test 的永久节点，节点携带数据信息 123。 create -e /test 123 创建一个临时节点/test，携带数据为 123，临时节点只在当前会话生命周期中有效，会话结束节点自动删除。&lt;/p&gt;
&lt;p&gt;​		create -s /test 123 创建一个顺序节点/test，携带数据 123，创建的顺序节点由 ZooKeeper 自动为节点增加后缀信息，如-/test00000001 等。-e 和-s 参数可以联合使用。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;20&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200624095012.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;53-get命令&#34;&gt;5.3 get命令&lt;/h3&gt;
&lt;p&gt;get [-s] /path&lt;/p&gt;
&lt;p&gt;get 命令获取 Znode 中的数据。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;21&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200624095654.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;22&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200624095710.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​		get -s /path&lt;/p&gt;
&lt;p&gt;​		-s 查看 Znode 详细信息&lt;/p&gt;
&lt;p&gt;​		&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200624095840.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;123456:存放的数据&lt;br&gt;
cZxid:创建时 zxid(znode 每次改变时递增的事务 id)&lt;br&gt;
ctime:创建时间戳&lt;br&gt;
mZxid:最近一次更近的 zxid&lt;br&gt;
mtime:最近一次更新的时间戳&lt;br&gt;
pZxid:子节点的 zxid&lt;br&gt;
cversion:子节点更新次数&lt;br&gt;
dataversion:节点数据更新次数&lt;br&gt;
aclVersion:节点 ACL(授权信息)的更新次数&lt;br&gt;
ephemeralOwner: 如 果 该 节 点 为 ephemeral 节 点 ( 临 时 ， 生 命 周 期 与 session 一 样 ),&lt;br&gt;
ephemeralOwner 值表示与该节点绑定的 session id. 如果该节点不是&lt;br&gt;
ephemeral 节点, ephemeralOwner 值为 0.&lt;/p&gt;
&lt;p&gt;dataLength:节点数据字节数&lt;br&gt;
numChildren:子节点数量&lt;/p&gt;
&lt;h3 id=&#34;54-set命令&#34;&gt;5.4 set命令&lt;/h3&gt;
&lt;p&gt;set /path [data]&lt;br&gt;
添加或修改 Znode 中的值&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;23&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200624101639.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;55-delete-命令&#34;&gt;5.5 delete 命令&lt;/h3&gt;
&lt;p&gt;delete /path&lt;br&gt;
删除 Znode。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;24&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200624101730.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;6-使用-java-api-操作-zookeeper&#34;&gt;6、使用 Java API 操作 Zookeeper&lt;/h2&gt;
&lt;h3 id=&#34;61-创建znode&#34;&gt;6.1 创建Znode&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;创建项目&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;25&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200624102928.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;修改 POM 文件添加依赖&lt;/p&gt;
&lt;p&gt;该依赖为基于 Java 语言连接 Zookeeper 的客户端工具&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;org.apache.zookeeper&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;zookeeper&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.6.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3创建 Znode 并添加数据&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 操作 Zookeeper 的 Znode
 */
public class ZnodeDemo implements Watcher {
    public static void main(String[] args) throws IOException, KeeperException, InterruptedException {
        //创建一个Zookeeper对象 Zookeeper(&amp;quot;ip：端口，超时时间，回调处理器&amp;quot;)
        ZooKeeper zooKeeper = new ZooKeeper(&amp;quot;124.70.181.124:2181,124.70.181.124:2182,124.70.181.124:2183&amp;quot;,150000,new ZnodeDemo());

        //创建一个znode
        String path = zooKeeper.create(&amp;quot;/zk01/zk01-01&amp;quot;, &amp;quot;123&amp;quot;.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);
        System.out.println(path);
    }

    /**
     * 事件通知回调方法
     *
     * @param watchedEvent
     */
    public void process(WatchedEvent watchedEvent) {
        //获取连接事件
        if (watchedEvent.getState() == Event.KeeperState.SyncConnected){
            System.out.println(&amp;quot;连接成功！&amp;quot;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;26&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200624105903.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;27&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200624105957.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;62-获取-znode-中的数据&#34;&gt;6.2 获取 Znode 中的数据&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 操作 Zookeeper 的 Znode
 */
public class ZnodeDemo implements Watcher {
    public static void main(String[] args) throws IOException, KeeperException, InterruptedException {
        //创建一个Zookeeper对象 Zookeeper(&amp;quot;ip：端口，超时时间，回调处理器&amp;quot;)
        ZooKeeper zooKeeper = new ZooKeeper(&amp;quot;124.70.181.124:2181,124.70.181.124:2182,124.70.181.124:2183&amp;quot;, 150000, new ZnodeDemo());

        /*//创建一个znode
        String path = zooKeeper.create(&amp;quot;/zk01/zk01-01&amp;quot;, &amp;quot;123&amp;quot;.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);
        System.out.println(path);*/

        //获取指定节点中的数据
        byte[] data = zooKeeper.getData(&amp;quot;/zk04&amp;quot;, new ZnodeDemo(), new Stat());
        System.out.println(new String(data));

        //获取所有子节点中的数据
        List&amp;lt;String&amp;gt; children = zooKeeper.getChildren(&amp;quot;/zk04&amp;quot;, new ZnodeDemo(), new Stat());
        for (String child : children) {
            byte[] childdata = zooKeeper.getData(&amp;quot;/zk04/&amp;quot; + child, new ZnodeDemo(), null);
            System.out.println(new String(childdata));
        }
    }

    /**
     * 事件通知回调方法
     *
     * @param watchedEvent
     */
    public void process(WatchedEvent watchedEvent) {
        //获取连接事件
        if (watchedEvent.getState() == Event.KeeperState.SyncConnected) {
            System.out.println(&amp;quot;连接成功！&amp;quot;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;28&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200624111556.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;29&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200624111836.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;63-设置znode中的值&#34;&gt;6.3 设置Znode中的值&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;		//设置 Znode 中的值
        //-1表示匹配任何版本
        Stat stat = zooKeeper.setData(&amp;quot;/zk04/zk04-01&amp;quot;, &amp;quot;456&amp;quot;.getBytes(), -1);
        System.out.println(stat);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;30&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200624112812.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;31&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200624112829.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;64-删除znode&#34;&gt;6.4 删除Znode&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;zooKeeper.delete(&amp;quot;/zk04/zk04-01&amp;quot;,-1);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;32&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200624113023.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;7-zookeeper实战&#34;&gt;7、Zookeeper实战&lt;/h2&gt;
&lt;p&gt;​		实战案例介绍：使用 Zookeeper 与 RMI 技术实现一个 RPC 框架。&lt;br&gt;
​		RPC：RPC（Remote Procedure Call）远程过程调用。&lt;/p&gt;
&lt;h3 id=&#34;71-基于-rmi-实现远程方法调用&#34;&gt;7.1 基于 RMI 实现远程方法调用&lt;/h3&gt;
&lt;h4 id=&#34;711-rmi-简-介&#34;&gt;7.1.1 RMI 简 介&lt;/h4&gt;
&lt;p&gt;RMI(Remote Method Invocation) 远程方法调用。&lt;br&gt;
RMI 是从 JDK1.2 推出的功能，它可以实现在一个 Java 应用中可以像调用本地方法一样调用另一个服务器中 Java 应用（JVM）中的内容。&lt;br&gt;
RMI 是 Java 语言的远程调用，无法实现跨语言。&lt;/p&gt;
&lt;h4 id=&#34;712-执行流程&#34;&gt;7.1.2 执行流程&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;33&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200624142309.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​		Registry(注册表)是放置所有服务器对象的命名空间。 每次服务端创建一个对象时，它都会使用 bind()或 rebind()方法注册该对象。 这些是使用称为绑定名称的唯一名称注册的。&lt;br&gt;
​		要调用远程对象，客户端需要该对象的引用。即通过服务端绑定的名称从注册表中获取对象(lookup()方法)。&lt;/p&gt;
&lt;h4 id=&#34;713-rmi-的-api-介绍&#34;&gt;7.1.3 RMI 的 API 介绍&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Remote 接口&lt;br&gt;
java.rmi.Remote 定义了此接口为远程调用接口。如果接口被外部调用，需要继承此接口。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;34&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200624142408.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RemoteException 类&lt;br&gt;
java.rmi.RemoteException&lt;br&gt;
继承了 Remote 接口的接口，如果方法是允许被远程调用的，需要抛出此异常。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UnicastRemoteObject 类&lt;br&gt;
java.rmi.server.UnicastRemoteObject&lt;br&gt;
此类实现了 Remote 接口和 Serializable 接口。&lt;br&gt;
自定义接口实现类除了实现自定义接口还需要继承此类。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;LocateRegistry 类&lt;br&gt;
java.rmi.registry.LocateRegistry&lt;br&gt;
可以通过 LocateRegistry 在本机上创建 Registry ，通过特定的端口就可以访问这个&lt;br&gt;
Registry。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Naming 类&lt;br&gt;
java.rmi.Naming&lt;br&gt;
Naming 定义了发布内容可访问 RMI 名称。也是通过 Naming 获取到指定的远程方法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;714-创建server端&#34;&gt;7.1.4 创建server端&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建项目&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;35&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200624142724.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建接口&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 定义允许远程调用接口，这样客户端就能知道服务端里有什么方法，该接口必须要实现 Remote 接口
 * 允许被远程调用的方法必须要抛出 RemoteException
 */
public interface DemoService extends Remote {
    String demo(String str) throws RemoteException;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建接口实现类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 接口实现类必须要继承 UnicastRemoteObject。
 * 会自动添加构造方法，需要修改为 public
 */
public class DemoServiceImpl extends UnicastRemoteObject implements DemoService {
    public DemoServiceImpl() throws RemoteException {
    }

    public String demo(String str) throws RemoteException {
        return &amp;quot;Hello RMI&amp;quot; + str;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编写主方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class DemoServer {
    public static void main(String[] args) throws RemoteException, AlreadyBoundException, MalformedURLException {
        //将对象实例化
        DemoServiceImpl demoService = new DemoServiceImpl();
        //创建本地注册表
        LocateRegistry.createRegistry(8888);
        //将对象绑定到注册表中
        Naming.bind(&amp;quot;rmi://localhost:8888/demoService&amp;quot;,demoService);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;715-创建client端&#34;&gt;7.1.5 创建Client端&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建项目&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;36&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200624143249.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;复制服务端接口&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 定义允许远程调用接口，这样客户端就能知道服务端里有什么方法，该接口必须要实现 Remote 接口
 * 允许被远程调用的方法必须要抛出 RemoteException
 */
public interface DemoService extends Remote {
    String demo(String str) throws RemoteException;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建主方法&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class DemoClient {
    public static void main(String[] args) throws RemoteException, NotBoundException, MalformedURLException {
        DemoService demoService = (DemoService) Naming.lookup(&amp;quot;rmi://localhost:8888/demoService&amp;quot;);
        String s = demoService.demo(&amp;quot;调用成功&amp;quot;);
        System.out.println(s);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200624143433.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;72-使用-zookeeper-作为注册中心实现-rpc&#34;&gt;7.2 使用 Zookeeper 作为注册中心实现 RPC&lt;/h3&gt;
&lt;h4 id=&#34;721-创建服务端&#34;&gt;7.2.1 创建服务端&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建项目&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;37&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200624152139.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 POM 文件添加依赖&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt; &amp;lt;dependency&amp;gt;
     &amp;lt;groupId&amp;gt;org.apache.zookeeper&amp;lt;/groupId&amp;gt;
     &amp;lt;artifactId&amp;gt;zookeeper&amp;lt;/artifactId&amp;gt;
     &amp;lt;version&amp;gt;3.6.0&amp;lt;/version&amp;gt;
 &amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建接口&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface UserService extends Remote {
    String findUser(String str) throws RemoteException;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建接口实现类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UserServiceImpl extends UnicastRemoteObject implements UserService {
    public UserServiceImpl() throws RemoteException {
    }

    public String findUser(String str) throws RemoteException {
        return &amp;quot;Hello Zookeeper&amp;quot;+str;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编写主方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UserServer implements Watcher {
    public static void main(String[] args) throws IOException, AlreadyBoundException, KeeperException, InterruptedException {
        UserServiceImpl userService = new UserServiceImpl();
        LocateRegistry.createRegistry(8888);
        String url = &amp;quot;rmi://localhost:8888/userService&amp;quot;;
        Naming.bind(url,userService);

        //将url信息放到zookeeper的节点中
        ZooKeeper zooKeeper = new ZooKeeper(&amp;quot;124.70.181.124:2181,124.70.181.124:2182,124.70.181.124:2183&amp;quot;,150000,new UserServer());

        //创建Znode
        zooKeeper.create(&amp;quot;/zk01/service&amp;quot;,url.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
        System.out.println(&amp;quot;服务发布成功&amp;quot;);
    }

    public void process(WatchedEvent watchedEvent) {
        if(watchedEvent.getState()==Event.KeeperState.SyncConnected){
            System.out.println(&amp;quot;连接成功&amp;quot;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;38&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200624153911.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;39&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200624154720.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;722-创建客户端&#34;&gt;7.2.2 创建客户端&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建项目&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;40&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200624155446.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 POM 文件添加依赖&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;org.apache.zookeeper&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;zookeeper&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;3.6.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建接口&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//调用方不需要继承Remote，只有被调用方才需要实现
public interface UserService {
    String findUser(String str);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编写主方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ClientDemo implements Watcher {
    public static void main(String[] args) throws IOException, KeeperException, InterruptedException, NotBoundException {
        ZooKeeper zooKeeper = new ZooKeeper(&amp;quot;124.70.181.124:2181,124.70.181.124:2182,124.70.181.124:2183&amp;quot;,150000,new ClientDemo());
        byte[] bytes = zooKeeper.getData(&amp;quot;/zk01/service&amp;quot;, new ClientDemo(), new Stat());
        UserService userService =(UserService) Naming.lookup(new String(bytes));
        String result = userService.findUser(&amp;quot; 调用成功&amp;quot;);
        System.out.println(result);
    }

    public void process(WatchedEvent watchedEvent) {
        if(watchedEvent.getState()==Event.KeeperState.SyncConnected){
            System.out.println(&amp;quot;连接成功&amp;quot;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;实现效果：&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200624155630.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Zookeeper</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jonchan1013.github.io/post/springboot/"" data-c="
          &lt;h2 id=&#34;1-springboot介绍&#34;&gt;1、SpringBoot介绍&lt;/h2&gt;
&lt;h3 id=&#34;11-什么是springboot&#34;&gt;1.1 什么是SpringBoot&lt;/h3&gt;
&lt;p&gt;​		Spring Boot 是一个框架，一种全新的编程规范，他的产生简化了框架的使用，所谓简&lt;br&gt;
化是指简化了 Spring 众多框架中所需的大量且繁琐的配置文件，所以 Spring Boot 是一个服&lt;br&gt;
务于框架的框架，服务范围是简化配置文件。所以从本质上来说，Spring Boot 其实就是 Spring&lt;br&gt;
框架的另一种表现形式。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;12-spring-boot-特征&#34;&gt;1.2  Spring Boot 特征&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;使用 Spring Boot 可以创建独立的 Spring 应用程序&lt;/li&gt;
&lt;li&gt;在Spring Boot中直接嵌入了Tomcat、Jetty、Undertow 等Web 容器，所以在使用SpringBoot做 Web 开发时不需要部署 WAR 文件&lt;/li&gt;
&lt;li&gt;通过提供自己的启动器(Starter)依赖，简化项目构建配置&lt;/li&gt;
&lt;li&gt;尽量的自动配置 Spring 和第三方库&lt;/li&gt;
&lt;li&gt;提供了生产就绪特征，如：度量指标，运行状况检查和外部化配置&lt;/li&gt;
&lt;li&gt;绝对没有代码生成，也不需要 XML 配置文件&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;13-spring-boot-版本介绍&#34;&gt;1.3 Spring Boot 版本介绍&lt;/h3&gt;
&lt;p&gt;SNAPSHOT：快照版，即开发版。&lt;br&gt;
CURRENT：最新版，但是不一定是稳定版。&lt;br&gt;
GA：General Availability，正式发布的版本。&lt;/p&gt;
&lt;h2 id=&#34;2-创建基于-spring-boot-的项目&#34;&gt;2、创建基于 Spring Boot 的项目&lt;/h2&gt;
&lt;h3 id=&#34;21-通过官网创建项目&#34;&gt;2.1 通过官网创建项目&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200618115707.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200618115730.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200618115745.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;22-通过-idea-的脚手架工具创建&#34;&gt;2.2 通过 IDEA 的脚手架工具创建&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200618115904.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;23-通过-idea-的-maven-项目创建&#34;&gt;2.3 通过 IDEA 的 Maven 项目创建&lt;/h3&gt;
&lt;p&gt;maven创建好后修改pom文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot;
xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0
http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
&amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
&amp;lt;groupId&amp;gt;com.bjsxt&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;springbootdemo3&amp;lt;/artifactId&amp;gt;
&amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
&amp;lt;parent&amp;gt;
	&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;2.2.0.RELEASE&amp;lt;/version&amp;gt;
	&amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
&amp;lt;/parent&amp;gt;
&amp;lt;properties&amp;gt;
	&amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
&amp;lt;/properties&amp;gt;
    &amp;lt;dependencies&amp;gt;
		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
		&amp;lt;/dependency&amp;gt;
		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
			&amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
			&amp;lt;exclusions&amp;gt;
				&amp;lt;exclusion&amp;gt;
					&amp;lt;groupId&amp;gt;org.junit.vintage&amp;lt;/groupId&amp;gt;
					&amp;lt;artifactId&amp;gt;junit-vintage-engine&amp;lt;/artifactId&amp;gt;
				&amp;lt;/exclusion&amp;gt;
			&amp;lt;/exclusions&amp;gt;
		&amp;lt;/dependency&amp;gt;
	&amp;lt;/dependencies&amp;gt;
&amp;lt;build&amp;gt;
	&amp;lt;plugins&amp;gt;
		&amp;lt;plugin&amp;gt;
			&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
		&amp;lt;/plugin&amp;gt;
	&amp;lt;/plugins&amp;gt;
&amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-spring-boot-项目结构介绍&#34;&gt;3、Spring Boot 项目结构介绍&lt;/h2&gt;
&lt;h3 id=&#34;31-pom文件&#34;&gt;3.1 POM文件&lt;/h3&gt;
&lt;h4 id=&#34;311-继承&#34;&gt;3.1.1 继承&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;parent&amp;gt;
	&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;2.2.0.RELEASE&amp;lt;/version&amp;gt;
	&amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
&amp;lt;/parent&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Spring Boot 的父级依赖，只有继承它项目才是 Spring Boot 项目。&lt;br&gt;
spring-boot-starter-parent 是一个特殊的 starter，它用来提供相关的 Maven 默认依赖。使用它之后，常用的包依赖可以省去 version 标签。&lt;/p&gt;
&lt;h4 id=&#34;312-依赖&#34;&gt;3.1.2 依赖&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;启动器依赖&lt;/p&gt;
&lt;h4 id=&#34;313-插件&#34;&gt;3.1.3 插件&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;build&amp;gt;
	&amp;lt;plugins&amp;gt;
		&amp;lt;plugin&amp;gt;
			&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
		&amp;lt;/plugin&amp;gt;
	&amp;lt;/plugins&amp;gt;
&amp;lt;/build&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		spring-boot-maven-plugin 插件是将 springboot 的应用程序打包成 jar 包的插件。将所有应用启动运行所需要的 jar 包都包含进来，从逻辑上将具备了独立运行的条件。当运行&amp;quot;mvnpackage&amp;quot;进行打包后，使用&amp;quot;java -jar&amp;quot;命令就可以直接运行。&lt;/p&gt;
&lt;h3 id=&#34;32-启动类&#34;&gt;3.2 启动类&lt;/h3&gt;
&lt;p&gt;Spring Boot 的启动类的作用是启动 Spring Boot 项目，是基于 Main 方法来运行的。&lt;br&gt;
注意：启动类在启动时会做注解扫描(@Controller、@Service、@Repository......)，扫描位置为同包或者子包下的注解，所以启动类的位置应放于包的根下。&lt;/p&gt;
&lt;h4 id=&#34;321-启动类与启动器区别&#34;&gt;3.2.1 启动类与启动器区别&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;启动类表示项目的启动入口&lt;/li&gt;
&lt;li&gt;启动器表示 jar 包的坐标&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;322-创建启动类&#34;&gt;3.2.2 创建启动类&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
*Spring Boot 启动类
*/
@SpringBootApplication
public class SpringBootDemo3Application {
	public static void main(String[] args){
		SpringApplication.run(SpringBootDemo3Application.class,args);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;32-启动器&#34;&gt;3.2 启动器&lt;/h3&gt;
&lt;p&gt;Spring Boot 将所有的功能场景都抽取出来，做成一个个的 starter(启动器)，只需要在项目里面引入这些 starter 相关场景的所有依赖都会导入进来，要用什么功能就导入什么场景，在 jar 包管理上非常方便，最终实现一站式开发。&lt;br&gt;
Spring Boot 提供了多达 44 个启动器。&lt;/p&gt;
&lt;p&gt;spring-boot-starter&lt;br&gt;
这是 Spring Boot 的核心启动器，包含了自动配置、日志和 YAML。&lt;/p&gt;
&lt;p&gt;spring-boot-starter-actuator&lt;br&gt;
帮助监控和管理应用。&lt;/p&gt;
&lt;p&gt;spring-boot-starter-web&lt;br&gt;
支持全栈式 Web 开发，包括 Tomcat 和 spring-webmvc。&lt;/p&gt;
&lt;p&gt;spring-boot-starter-amqp&lt;br&gt;
通过 spring-rabbit 来支持 AMQP 协议（Advanced Message Queuing Protocol）。&lt;/p&gt;
&lt;p&gt;spring-boot-starter-aop&lt;br&gt;
支持面向方面的编程即 AOP，包括 spring-aop 和 AspectJ。&lt;/p&gt;
&lt;p&gt;spring-boot-starter-artemis&lt;br&gt;
通过 Apache Artemis 支持 JMS 的 API（Java Message Service API）。&lt;/p&gt;
&lt;p&gt;spring-boot-starter-batch&lt;br&gt;
支持 Spring Batch，包括 HSQLDB 数据库。&lt;/p&gt;
&lt;p&gt;spring-boot-starter-cache&lt;br&gt;
支持 Spring 的 Cache 抽象。&lt;/p&gt;
&lt;p&gt;spring-boot-starter-cloud-connectors&lt;br&gt;
支持 Spring Cloud Connectors，简化了在像 Cloud Foundry 或 Heroku 这样的云平台上连接服务。&lt;/p&gt;
&lt;p&gt;spring-boot-starter-data-elasticsearch&lt;br&gt;
支持 ElasticSearch 搜索和分析引擎，包括 spring-data-elasticsearch。&lt;br&gt;
spring-boot-starter-data-gemfire&lt;br&gt;
支持 GemFire 分布式数据存储，包括 spring-data-gemfire。&lt;/p&gt;
&lt;p&gt;spring-boot-starter-data-jpa&lt;/p&gt;
&lt;p&gt;支持 JPA（Java Persistence API），包括 spring-data-jpa、spring-orm、Hibernate。&lt;/p&gt;
&lt;p&gt;spring-boot-starter-data-mongodb&lt;br&gt;
支持 MongoDB 数据，包括 spring-data-mongodb。&lt;/p&gt;
&lt;p&gt;spring-boot-starter-data-rest&lt;br&gt;
通过 spring-data-rest-webmvc，支持通过 REST 暴露 Spring Data 数据仓库。&lt;/p&gt;
&lt;p&gt;spring-boot-starter-data-solr&lt;br&gt;
支持 Apache Solr 搜索平台，包括 spring-data-solr。&lt;/p&gt;
&lt;p&gt;spring-boot-starter-freemarker&lt;br&gt;
支持 FreeMarker 模板引擎。&lt;/p&gt;
&lt;p&gt;spring-boot-starter-groovy-templates&lt;br&gt;
支持 Groovy 模板引擎。&lt;/p&gt;
&lt;p&gt;spring-boot-starter-hateoas&lt;br&gt;
通过 spring-hateoas 支持基于 HATEOAS 的 RESTful Web 服务。&lt;/p&gt;
&lt;p&gt;spring-boot-starter-hornetq&lt;br&gt;
通过 HornetQ 支持 JMS。&lt;/p&gt;
&lt;p&gt;spring-boot-starter-integration&lt;br&gt;
支持通用的 spring-integration 模块。&lt;/p&gt;
&lt;p&gt;spring-boot-starter-jdbc&lt;br&gt;
支持 JDBC 数据库。&lt;/p&gt;
&lt;p&gt;spring-boot-starter-jersey&lt;br&gt;
支持 Jersey RESTful Web 服务框架。&lt;/p&gt;
&lt;p&gt;spring-boot-starter-jta-atomikos&lt;br&gt;
通过 Atomikos 支持 JTA 分布式事务处理。&lt;/p&gt;
&lt;p&gt;spring-boot-starter-jta-bitronix&lt;br&gt;
通过 Bitronix 支持 JTA 分布式事务处理。&lt;/p&gt;
&lt;p&gt;spring-boot-starter-mail&lt;br&gt;
支持 javax.mail 模块。&lt;/p&gt;
&lt;p&gt;spring-boot-starter-mobile&lt;br&gt;
支持 spring-mobile。&lt;/p&gt;
&lt;p&gt;spring-boot-starter-mustache&lt;br&gt;
支持 Mustache 模板引擎。&lt;/p&gt;
&lt;p&gt;spring-boot-starter-redis&lt;br&gt;
支持 Redis 键值存储数据库，包括 spring-redis。&lt;/p&gt;
&lt;p&gt;spring-boot-starter-security&lt;br&gt;
支持 spring-security。&lt;/p&gt;
&lt;p&gt;spring-boot-starter-social-facebook&lt;br&gt;
支持 spring-social-facebook&lt;/p&gt;
&lt;p&gt;spring-boot-starter-social-linkedin&lt;br&gt;
支持 pring-social-linkedin&lt;/p&gt;
&lt;p&gt;spring-boot-starter-social-twitter&lt;br&gt;
支持 pring-social-twitter&lt;/p&gt;
&lt;p&gt;spring-boot-starter-test&lt;br&gt;
支持常规的测试依赖，包括 JUnit、Hamcrest、Mockito 以及 spring-test 模块。&lt;/p&gt;
&lt;p&gt;spring-boot-starter-thymeleaf&lt;br&gt;
支持 Thymeleaf 模板引擎，包括与 Spring 的集成。&lt;/p&gt;
&lt;p&gt;spring-boot-starter-velocity&lt;br&gt;
支持 Velocity 模板引擎。&lt;/p&gt;
&lt;p&gt;spring-boot-starter-websocket&lt;br&gt;
支持 WebSocket 开发。&lt;/p&gt;
&lt;p&gt;spring-boot-starter-ws&lt;br&gt;
支持 Spring Web Services。&lt;/p&gt;
&lt;p&gt;spring-boot-starter-actuator&lt;br&gt;
增加了面向产品上线相关的功能，比如测量和监控。&lt;/p&gt;
&lt;p&gt;spring-boot-starter-remote-shell&lt;br&gt;
增加了远程 ssh shell 的支持。&lt;/p&gt;
&lt;p&gt;spring-boot-starter-jetty&lt;/p&gt;
&lt;p&gt;引入了 Jetty HTTP 引擎（用于替换 Tomcat）。&lt;/p&gt;
&lt;p&gt;spring-boot-starter-log4j&lt;br&gt;
支持 Log4J 日志框架。&lt;/p&gt;
&lt;p&gt;spring-boot-starter-logging&lt;br&gt;
引入了 Spring Boot 默认的日志框架 Logback。&lt;/p&gt;
&lt;p&gt;spring-boot-starter-tomcat&lt;br&gt;
引入了 Spring Boot 默认的 HTTP 引擎 Tomcat。&lt;/p&gt;
&lt;p&gt;spring-boot-starter-undertow&lt;br&gt;
引入了 Undertow HTTP 引擎（用于替换 Tomcat）。&lt;/p&gt;
&lt;h3 id=&#34;34-配置文件&#34;&gt;3.4 配置文件&lt;/h3&gt;
&lt;p&gt;​		Spring Boot 提供一个名称为 application 的全局配置文件，支持两种格式 properteis 格式与 YAML 格式。&lt;/p&gt;
&lt;h4 id=&#34;341-properties-格式&#34;&gt;3.4.1 Properties 格式&lt;/h4&gt;
&lt;p&gt;配置 Tomcat 监听端口&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;server.port=8888
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;342-yaml-格式&#34;&gt;3.4.2 YAML 格式&lt;/h4&gt;
&lt;p&gt;YAML 格式配置文件的扩展名可以是 yaml 或者 yml。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基本格式要求&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大小写敏感&lt;/li&gt;
&lt;li&gt;使用缩进代表层级关系&lt;/li&gt;
&lt;li&gt;相同的部分只出现一次&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;配置 Tomcat 监听端口&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;server:
	port: 8888
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;343-配置文件存放位置&#34;&gt;3.4.3 配置文件存放位置&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;当前项目根目录中&lt;/li&gt;
&lt;li&gt;当前项目根目录下的一个/config 子目录中&lt;/li&gt;
&lt;li&gt;项目的 resources 即 classpath 根路径中&lt;/li&gt;
&lt;li&gt;项目的 resources 即 classpath 根路径下的/config 目录中&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;344-配置文件加载顺序&#34;&gt;3.4.4 配置文件加载顺序&lt;/h4&gt;
&lt;h5 id=&#34;3441-不同格式的加载顺序&#34;&gt;3.4.4.1 不同格式的加载顺序&lt;/h5&gt;
&lt;p&gt;​		如 果 同 一 个 目 录 下 ， 有 application.yml 也 有 application.properties ， 默 认 先 读 取application.properties。&lt;br&gt;
​		如果同一个配置属性，在多个配置文件都配置了，默认使用第 1 个读取到的，后面读取的不覆盖前面读取到的。&lt;/p&gt;
&lt;h5 id=&#34;3442-不同位置的加载顺序&#34;&gt;3.4.4.2 不同位置的加载顺序&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;当前项目根目录下的一个/config 子目录中(最高)&lt;br&gt;
config/application.properties&lt;br&gt;
config/application.yml&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当前项目根目录中(其次)&lt;br&gt;
application.properties&lt;br&gt;
application.yml&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;项目的 resources 即 classpath 根路径下的/config 目录中(一般)&lt;br&gt;
resources/config/application.properties&lt;br&gt;
resources/config/application.yml&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;项目的 resources 即 classpath 根路径中(最后)&lt;br&gt;
resources/application.properties&lt;br&gt;
resources/application.yml&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;345-配置文件中的占位符&#34;&gt;3.4.5 配置文件中的占位符&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;占位符语法&lt;/p&gt;
&lt;p&gt;语法：${}&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;占位符的作用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;quot;${}&amp;quot;中可以获取框架提供的方法中的值如：random.int 等。&lt;/li&gt;
&lt;li&gt;占位符可以获取配置文件中的键的值赋给另一个键作为值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;生成随机数&lt;br&gt;
&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;/mrow&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;类&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;似&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;随&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;机&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;数&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;，&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;没&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;有&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;连&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;接&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;{random.value} - 类似 uuid 的随机数，没有&amp;quot;-&amp;quot;连接
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.77777em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.77777em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;类&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;似&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;的&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;随&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;机&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;数&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;没&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;有&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;连&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;接&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;{random.int} - 随机取整型范围内的一个值&lt;br&gt;
&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;/mrow&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;随&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;机&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;取&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;长&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;整&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;型&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;范&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;围&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;内&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;一&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;个&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;值&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;{random.long} - 随机取长整型范围内的一个值
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;随&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;机&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;取&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;长&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;整&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;型&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;范&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;围&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;内&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;的&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;一&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;个&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;值&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;{random.long(100,200)} - 随机生成长整型 100-200 范围内的一个值&lt;br&gt;
&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;/mrow&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;生&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;成&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;一&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;个&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;，&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;有&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;短&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;杠&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;连&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;接&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;{random.uuid} - 生成一个 uuid，有短杠连接
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.77777em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;生&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;成&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;一&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;个&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;有&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;短&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;杠&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;连&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;接&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;{random.int(10)} - 随机生成一个 10 以内的数&lt;br&gt;
${random.int(100,200)} - 随机生成一个 100-200 范围以内的数&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;346-bootstrap-配置文件&#34;&gt;3.4.6 bootstrap 配置文件&lt;/h4&gt;
&lt;h5 id=&#34;3461-bootstrap-配置文件介绍&#34;&gt;3.4.6.1 bootstrap 配置文件介绍&lt;/h5&gt;
&lt;p&gt;​		Spring Boot 中有两种上下文对象，一种是 bootstrap, 另外一种是 application, bootstrap是应用程序的父上下文，也就是说 bootstrap 加载优先于 applicaton。bootstrap 主要用于从额外的资源来加载配置信息，还可以在本地外部配置文件中解密属性。这两个上下文共用一个环境，它是任何 Spring 应用程序的外部属性的来源。bootstrap 里面的属性会优先加载，它们默认也不能被本地相同配置覆盖。&lt;/p&gt;
&lt;h5 id=&#34;3462-bootstrap-配置文件特征&#34;&gt;3.4.6.2 bootstrap 配置文件特征&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;boostrap 由父 ApplicationContext 加载，比 applicaton 优先加载。&lt;/li&gt;
&lt;li&gt;boostrap 里面的属性不能被覆盖。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;3463-bootstrap-与-application-的应用场景&#34;&gt;3.4.6.3 bootstrap 与 application 的应用场景&lt;/h5&gt;
&lt;p&gt;application 配置文件主要用于 Spring Boot 项目的自动化配置。&lt;br&gt;
bootstrap 配置文件有以下几个应用场景。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 Spring Cloud Config 配置中心时，这时需要在 bootstrap 配置文件中添加连接到配置中心的配置属性来加载外部配置中心的配置信息。&lt;/li&gt;
&lt;li&gt;一些固定的不能被覆盖的属性。&lt;/li&gt;
&lt;li&gt;一些加密/解密的场景。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;35-spring-boot-的核心注解&#34;&gt;3.5 Spring Boot 的核心注解&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;@SpringBootApplication&lt;br&gt;
是 SpringBoot 的启动类。&lt;br&gt;
此注解等同于@Configuration+@EnableAutoConfiguration+@ComponentScan 的组合。&lt;/li&gt;
&lt;li&gt;@SpringBootConfiguration&lt;br&gt;
@SpringBootConfiguration 注解是@Configuration 注解的派生注解，跟@Configuration注解的功能一致，标注这个类是一个配置类，只不过@SpringBootConfiguration 是 Springboot的注解，而@Configuration 是 Spring 的注解&lt;/li&gt;
&lt;li&gt;@Configuration&lt;br&gt;
通过对 bean 对象的操作替代 spring 中 xml 文件&lt;/li&gt;
&lt;li&gt;@EnableAutoConfiguration&lt;br&gt;
Spring Boot 自动配置（auto-configuration）：尝试根据你添加的 jar 依赖自动配置你的Spring 应用。是@AutoConfigurationPackage 和@Import(AutoConfigurationImportSelector.class)注解的组合。&lt;/li&gt;
&lt;li&gt;@AutoConfigurationPackage&lt;br&gt;
@AutoConfigurationPackage 注解，自动注入主类下所在包下所有的加了注解的类（@Controller，@Service 等），以及配置类（@Configuration）&lt;/li&gt;
&lt;li&gt;@Import({AutoConfigurationImportSelector.class})&lt;br&gt;
直接导入普通的类&lt;br&gt;
导入实现了 ImportSelector 接口的类&lt;br&gt;
导入实现了 ImportBeanDefinitionRegistrar 接口的类&lt;/li&gt;
&lt;li&gt;@ComponentScan&lt;br&gt;
组件扫描，可自动发现和装配一些 Bean。&lt;/li&gt;
&lt;li&gt;@ConfigurationPropertiesScan&lt;br&gt;
@ConfigurationPropertiesScan 扫描配置属性。@EnableConfigurationProperties 注解的作用是使用 @ConfigurationProperties 注解的类生效。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;4-编写helloworld&#34;&gt;4、编写HelloWorld&lt;/h2&gt;
&lt;h3 id=&#34;41-创建项目&#34;&gt;4.1 创建项目&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200618133340.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200618133358.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200618133412.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;通过maven方式创建SpringBoot项目&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200618133522.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200618133633.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200618133713.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;42-修改pom文件&#34;&gt;4.2 修改POM文件&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot;
         xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
         xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;SpringBootHelloWorld&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.2.0.RELEASE&amp;lt;/version&amp;gt;
    &amp;lt;/parent&amp;gt;


    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;43-修改-tomcat-端口&#34;&gt;4.3 修改 Tomcat 端口&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;server:
	port: 8888
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;44-创建启动类&#34;&gt;4.4 创建启动类&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* 启动类
*/
@SpringBootApplication
public class SpringBootHelloWorldApplication {
	public static void main(String[] args){
		SpringApplication.run(SpringBootHelloWorldApplication.class,args);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;45-创建-controller&#34;&gt;4.5 创建 Controller&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* 处理请求 Controller
*/
@RestController // @Controller+@ResponsBody 直接返回字符串
public class HelloWorldController {
	@RequestMapping(&amp;quot;/helloWorld&amp;quot;)
	public String showHelloWorld(){
		return &amp;quot;HelloWorld&amp;quot;;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;46-spring-boot-在-controller-中常用注解&#34;&gt;4.6 Spring Boot 在 Controller 中常用注解&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;@RestController&lt;/p&gt;
&lt;p&gt;@RestController 相当于@Controller+@ResponseBody 注解&lt;br&gt;
如果使用@RestController 注解 Controller 中的方法无法返回页面，相当于在方法上面自动 加 了 @ResponseBody 注 解 ， 所 以 没 办 法 跳 转 并 传 输 数 据 到 另 一 个 页 面 ， 所以InternalResourceViewResolver 也不起作用，返回的内容就是 Return 里的内容。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;@GetMapping&lt;br&gt;
@GetMapping 注解是@RequestMapping(method = RequestMethod.GET)的缩写。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;@PostMapping&lt;br&gt;
@PostMapping 注解是@RequestMapping(method = RequestMethod.POST)的缩写。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;@PutMapping&lt;br&gt;
@PutMapping 注解是@RequestMapping(method = RequestMethod.PUT)的缩写。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;@DeleteMapping&lt;br&gt;
@DeleteMapping 注解是@RequestMapping(method = RequestMethod.DELETE)的缩写。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;5-spring-boot-整合-web-层技术&#34;&gt;5. Spring Boot 整合 Web 层技术&lt;/h2&gt;
&lt;p&gt;整合 Servlet&lt;/p&gt;
&lt;h3 id=&#34;51-整合-servlet-方式一通过注解扫描完成-servlet-组件的注册&#34;&gt;5.1 整合 Servlet 方式一（通过注解扫描完成 Servlet 组件的注册）&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;创建 Servlet&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* 整合 Servlet 方式一
*/
@WebServlet(name = &amp;quot;FirstServlet&amp;quot;,urlPatterns = &amp;quot;/first&amp;quot;)
public class FirstServlet extends HttpServlet {
	public void doGet(HttpServletRequest request,HttpServletResponse response){
		System.out.println(&amp;quot;First Servlet........&amp;quot;);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;修改启动类&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SpringBootApplication
@ServletComponentScan//在 spring Boot 启动时会扫描@WebServlet注解，并将该类实例化
public class SpringbootwebApplication {
	public static void main(String[] args) {
		SpringApplication.run(SpringbootwebApplication.class,args);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;52-整合-servlet-方式二通过方法完成-servlet-组件的注册&#34;&gt;5.2  整合 Servlet 方式二（通过方法完成 Servlet 组件的注册）&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;创建servlet&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* 整合 Servlet 方式二
*/
public class SecondServlet extends HttpServlet {
	public void doGet(HttpServletRequest request,HttpServletResponse response){
		System.out.println(&amp;quot;Second Servlet........&amp;quot;);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;创建 Servlet 配置类&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* Servlet 配置类
*/
@Configuration
public class ServletConfig {
/**
* 完成 Servlet 组件的注册
*/
	@Bean
	public ServletRegistrationBean getServletRegistrationBean(){
		ServletRegistrationBean bean = new ServletRegistrationBean(new SecondServlet());
		bean.addUrlMappings(&amp;quot;/second&amp;quot;);
		return bean;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;53-整合-filter-方式一通过注解扫描完成-filter-组件注册&#34;&gt;5.3 整合 Filter 方式一(通过注解扫描完成 Filter 组件注册)&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;创建 Filter&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* 整合 Filter 方式一
*/
//@WebFilter(filterName = &amp;quot;FirstFilter&amp;quot;,urlPatterns ={&amp;quot;*.do&amp;quot;,&amp;quot;*.jsp&amp;quot;})
@WebFilter(filterName = &amp;quot;FirstFilter&amp;quot;,urlPatterns =&amp;quot;/first&amp;quot;)
public class FirstFilter implements Filter{
	@Override
	public void init(FilterConfig filterConfig) throws ServletException {
	}
	@Override
	public void doFilter(ServletRequest servletRequest,ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
		System.out.println(&amp;quot;进入 First Filter&amp;quot;);
        //chain.doFilter将请求转发给过滤器链下一个filter , 如果没有filter那就是你请求的资源
		filterChain.doFilter(servletRequest,servletResponse);
		System.out.println(&amp;quot;离开 First Filter&amp;quot;);
	}
	@Override
	public void destroy() {
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;修改启动类&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SpringBootApplication
@ServletComponentScan//在 spring Boot 启动时会扫描@WebServlet,@WebFilter 注解，并将该类实例化
public class SpringbootwebApplication {
	public static void main(String[] args) {
		SpringApplication.run(SpringbootwebApplication.class,args);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;54-整合-filter-方式二通过方法完成-filter-组件注册&#34;&gt;5.4 整合 Filter 方式二(通过方法完成 Filter 组件注册)&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;创建 Filter&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* 整合 Filter 方式二
*/
public class SecondFilter implements Filter {
	@Override
	public void init(FilterConfig filterConfig) throws ServletException {
	}
	@Override
	public void doFilter(ServletRequest servletRequest,ServletResponse servletResponse, FilterChain filterChain)throws IOException, ServletException {
		System.out.println(&amp;quot;进入 Second Filter&amp;quot;);
		filterChain.doFilter(servletRequest,servletResponse);
		System.out.println(&amp;quot;离开 Second Filter&amp;quot;);
	}
	@Override
	public void destroy() {
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;创建 Filter 配置类&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* Filter 配置类
*/
@Configuration
public class FilterConfig {
	@Bean
	public FilterRegistrationBean getFilterRegistrationBean(){
		FilterRegistrationBean bean = new FilterRegistrationBean(new SecondFilter());
		// bean.addUrlPatterns(new String[]{&amp;quot;*.do&amp;quot;,&amp;quot;*.jsp&amp;quot;});
		bean.addUrlPatterns(&amp;quot;/second&amp;quot;);
		return bean;	
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;55-整合-listener-方式一通过注解扫描完成-listener-组件注册&#34;&gt;5.5  整合 Listener 方式一(通过注解扫描完成 Listener 组件注册)&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;编写 Listener&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* 整合 Listener
*/
@WebListener
public class FirstListener implements ServletContextListener{
	public void contextDestroyed(ServletContextEvent event){
	}
	public void contextInitialized(ServletContextEvent event){
		System.out.println(&amp;quot;Listener ...Init......&amp;quot;);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;修改启动类&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SpringBootApplication
@ServletComponentScan//在 spring Boot 启动时会扫描@WebServlet,@WebFilter,@WebListener 注解，并将该类实例化
public class SpringbootwebApplication {
	public static void main(String[] args) {SpringApplication.run(SpringbootwebApplication.class, args);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;56-整合-listener-方式二通过方法完成-listener-组件注册&#34;&gt;5.6 整合 Listener 方式二(通过方法完成 Listener 组件注册)&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;编写 Listener&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* 整合 Listener 方式二
*/
public class SecondListener implementsServletContextListener {
	public void contextDestroyed(ServletContextEvent event){
	}
	public void contextInitialized(ServletContextEvent event){
		System.out.println(&amp;quot;Second....Listener ...Init......&amp;quot;);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;创建 Listener 配置类&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* Listener 配置类
*/
@Configuration
public class ListenerConfig {
	@Bean
	public ServletListenerRegistrationBean getServletListenerRegistrationBean(){
		ServletListenerRegistrationBean bean = new ServletListenerRegistrationBean(new SecondListener());
		return bean;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;6-spring-boot-访问静态资源&#34;&gt;6、Spring Boot 访问静态资源&lt;/h2&gt;
&lt;p&gt;​		在 SpringBoot 项目中没有我们之前常规 web 开发的 WebContent（WebApp），它只有&lt;br&gt;
src 目录。在 src/main/resources 下面有两个文件夹，static 和 templates。SpringBoot 默认在 static&lt;br&gt;
目录中存放静态页面，而 templates 中放动态页面。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;static 目录&lt;/p&gt;
&lt;p&gt;​		Spring Boot 通过 classpath/static 目录访问静态资源。注意存放静态资源的目录名称必须&lt;br&gt;
是 static。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;templates 目录&lt;/p&gt;
&lt;p&gt;​		在 Spring Boot 中不推荐使用 jsp 作为视图层技术，而是默认使用 Thymeleaf 来做动态页&lt;br&gt;
面。Templates 目录这是存放 Thymeleaf 的页面。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;静态资源存放其他位置&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Spring Boot 访问静态资源的位置&lt;/p&gt;
&lt;p&gt;classpath:/META‐INF/resources/&lt;br&gt;
classpath:/resources/&lt;br&gt;
classpath:/static/&lt;br&gt;
classpath:/public/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;自定义静态资源位置&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;#配置静态资源访问路径
spring.resources.static-locations=classpath:/suibian/,classpath:/static/
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;7-spring-boot-文件上传&#34;&gt;7、Spring Boot 文件上传&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;创建项目&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200619113918.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;POM 文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot;
xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0
https://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
&amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
&amp;lt;parent&amp;gt;
&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
&amp;lt;version&amp;gt;2.2.0.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
&amp;lt;/parent&amp;gt;
&amp;lt;groupId&amp;gt;com.bjsxt&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;springbootfileupload&amp;lt;/artifactId&amp;gt;
&amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;


&amp;lt;name&amp;gt;springbootfileupload&amp;lt;/name&amp;gt;
&amp;lt;description&amp;gt;Demo project for Spring Boot&amp;lt;/description&amp;gt;
&amp;lt;properties&amp;gt;
&amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
&amp;lt;/properties&amp;gt;
&amp;lt;dependencies&amp;gt;
&amp;lt;dependency&amp;gt;
&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
&amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
&amp;lt;exclusions&amp;gt;
&amp;lt;exclusion&amp;gt;
&amp;lt;groupId&amp;gt;org.junit.vintage&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;junit-vintage-engine&amp;lt;/artifactId&amp;gt;
&amp;lt;/exclusion&amp;gt;
&amp;lt;/exclusions&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&amp;lt;build&amp;gt;
&amp;lt;plugins&amp;gt;
&amp;lt;plugin&amp;gt;
&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
&amp;lt;/plugin&amp;gt;
&amp;lt;/plugins&amp;gt;
&amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;启动类&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SpringBootApplication
public class SpringbootfileuploadApplication {
    public static void main(String[] args) {
        SpringApplication.run(SpringbootfileuploadApplication.class, args);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;编写上传页面&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;html&amp;gt;
	&amp;lt;head&amp;gt;
	&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
	&amp;lt;form action=&amp;quot;/fileUploadController&amp;quot; method=&amp;quot;post&amp;quot; enctype=&amp;quot;multipart/form-data&amp;quot;&amp;gt;
		&amp;lt;input type=&amp;quot;file&amp;quot; name=&amp;quot;file&amp;quot;/&amp;gt;
		&amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;OKOK&amp;quot;/&amp;gt;
	&amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;编写 Controller&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* 文件上传
*/
@RestController
public class FileUploadController {
	@PostMapping(&amp;quot;/fileUploadController&amp;quot;)
	public String fileUpload(MultipartFile file)throws Exception{
		System.out.println(file.getOriginalFilename());
		file.transferTo(new File(&amp;quot;c:/&amp;quot;+file.getOriginalFilename()));
		return &amp;quot;OK&amp;quot;;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;修改上传文件大小&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;#配置单个上传文件的大小的限制
spring.servlet.multipart.max-file-size=2MB
#配置在一次请求中上传文件的总容量的限制
spring.servlet.multipart.max-request-size=20MB
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;8-spring-boot-整合视图层技术&#34;&gt;8、Spring Boot 整合视图层技术&lt;/h2&gt;
&lt;h3 id=&#34;81-spring-boot-整合-jsp-技术&#34;&gt;8.1 Spring Boot 整合 JSP 技术&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建项目&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200619142443.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 POM 文件，添加 JSP 引擎与 JSTL 标签库&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--添加 jsp 引擎，SpringBoot 内置的 Tomat 中没有此依赖--&amp;gt;
&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;org.apache.tomcat.embed&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;tomcat-embed-jasper&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;!--添加 JSTL 坐标依赖--&amp;gt;
&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;jstl&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;创建 webapp 目录&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200619142557.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;标记为 web 目录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建 JSP&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;%@ page contentType=&amp;quot;text/html;charset=UTF-8&amp;quot;
language=&amp;quot;java&amp;quot; %&amp;gt;
&amp;lt;html&amp;gt;
	&amp;lt;head&amp;gt;
		&amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
	&amp;lt;/head&amp;gt;
	&amp;lt;body&amp;gt;
		&amp;lt;h2&amp;gt;Hello JSP&amp;lt;/h2&amp;gt;
	&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改配置文件，配置视图解析器&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;spring.mvc.view.prefix=/WEB-INF/jsp/
spring.mvc.view.suffix=.jsp
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;
&lt;p&gt;创建 Controller&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* 页面跳转 Controller
*/
@Controller
public class PageController {
	@GetMapping(&amp;quot;/{page}&amp;quot;)
	public String showPage(@PathVariable String page){
		return page;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		如果在 IDEA 中项目结构为聚合工程。那么在运行 jsp 是需要指定路径。如果项目结构为独立项目则不需要。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200619142830.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;82-spring-boot-整合-freemarker&#34;&gt;8.2 Spring Boot 整合 Freemarker&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建项目&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200619143010.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 POM 文件，添加 Freemarker 启动器&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--Freemarker 启动器依赖--&amp;gt;
		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;spring-boot-starter-freemarker&amp;lt;/artifactId&amp;gt;
		&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建 User 实体&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class User {
    private String userName;
    private String userSex;
    private int userAge;

    public String getUserName() {
        return userName;
    }

    public void setUserName(String userName) {
        this.userName = userName;
    }

    public String getUserSex() {
        return userSex;
    }

    public void setUserSex(String userSex) {
        this.userSex = userSex;
    }

    public int getUserAge() {
        return userAge;
    }

    public void setUserAge(int userAge) {
        this.userAge = userAge;
    }

    public User(String userName, String userSex, int userAge) {
        this.userName = userName;
        this.userSex = userSex;
        this.userAge = userAge;
    }

    public User() {
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建 Controller&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Controller
public class UserController {
    @GetMapping(&amp;quot;/showUser&amp;quot;)
    public String showUser(Model model) {
        List&amp;lt;User&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        list.add(new User(&amp;quot;张三&amp;quot;, &amp;quot;M&amp;quot;, 18));
        list.add(new User(&amp;quot;李四&amp;quot;, &amp;quot;M&amp;quot;, 19));
        list.add(new User(&amp;quot;王五&amp;quot;, &amp;quot;M&amp;quot;, 20));
        model.addAttribute(&amp;quot;list&amp;quot;, list);
        return &amp;quot;userList&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建视图&lt;/p&gt;
&lt;p&gt;userList.ftl&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;table border=&amp;quot;1&amp;quot; align=&amp;quot;center&amp;quot; width=&amp;quot;50%&amp;quot;&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;th&amp;gt;Name&amp;lt;/th&amp;gt;
        &amp;lt;th&amp;gt;Sex&amp;lt;/th&amp;gt;
        &amp;lt;th&amp;gt;Age&amp;lt;/th&amp;gt;
    &amp;lt;/tr&amp;gt;
    &amp;lt;#--#list是freemarker中迭代list的标记，相当于JSTL中的foreach；
        list as user意思是从list中每迭代一个赋给user属性，然后就可以用user取里面的元素了--&amp;gt;
    &amp;lt;#list list as user&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;${user.userName}&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;${user.userSex}&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;${user.userAge}&amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
    &amp;lt;/#list&amp;gt;
&amp;lt;/table&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改配置文件添加后缀&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;spring.freemarker.suffix=.ftl
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;83-spring-boot-整合-thymeleaf&#34;&gt;8.3 Spring Boot 整合 Thymeleaf&lt;/h3&gt;
&lt;h4 id=&#34;831-thymeleaf-介绍&#34;&gt;8.3.1 Thymeleaf 介绍&lt;/h4&gt;
&lt;p&gt;​		Thymeleaf 的主要目标是将优雅的自然模板带到开发工作流程中，并将 HTML 在浏览器中正确显示，并且可以作为静态原型，让开发团队能更容易地协作。Thymeleaf 能够处理HTML，XML，JavaScript，CSS 甚至纯文本。&lt;br&gt;
​		长期以来,jsp 在视图领域有非常重要的地位,随着时间的变迁,出现了一位新的挑战者:Thymeleaf,Thymeleaf 是原生的,不依赖于标签库.它能够在接受原始 HTML 的地方进行编辑和渲染.因为它没有与Servelet 规范耦合,因此Thymeleaf 模板能进入jsp 所无法涉足的领域。&lt;/p&gt;
&lt;h4 id=&#34;832-thymeleaf-基本使用&#34;&gt;8.3.2 Thymeleaf 基本使用&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建项目&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200619174447.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 POM 文件，添加 Thymeleaf 启动器依赖&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--添加 Thymeleaf 启动器依赖--&amp;gt;
&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;spring-boot-starter-thymeleaf&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;创建 Controller&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* 页面跳转 Controller
*/
@Controller
public class PageController {
	/**
	* 页面跳转方法
	*/
	@GetMapping(&amp;quot;/show&amp;quot;)
	public String showPage(Model model){ model.addAttribute(&amp;quot;msg&amp;quot;,&amp;quot;Hello Thymeleaf&amp;quot;);
		return &amp;quot;index&amp;quot;;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;创建视图&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE HTML PUBLIC &amp;quot;-//W3C//DTD HTML 4.01
Transitional//EN&amp;quot;
&amp;quot;http://www.w3.org/TR/html4/loose.dtd&amp;quot;&amp;gt;
&amp;lt;html&amp;gt;
	&amp;lt;head&amp;gt;
		&amp;lt;title&amp;gt;首页&amp;lt;/title&amp;gt;
	&amp;lt;/head&amp;gt;
	&amp;lt;body&amp;gt;
		&amp;lt;span th:text=&amp;quot;标题&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;
		&amp;lt;hr/&amp;gt;
		&amp;lt;span th:text=&amp;quot;${msg}&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;
	&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;833-thymeleaf-语法讲解&#34;&gt;8.3.3 Thymeleaf 语法讲解&lt;/h4&gt;
&lt;p&gt;命名空间：xmlns:th=&amp;quot;http://www.thymeleaf.org&amp;quot;&lt;/p&gt;
&lt;h5 id=&#34;8331-字符串与变量输出操作&#34;&gt;8.3.3.1 字符串与变量输出操作&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;th:text&lt;br&gt;
在页面中输出值&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;span th:text=&amp;quot;${msg}&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;th:value&lt;br&gt;
可以将一个值放入到 input 标签的 value 中&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;input th:value=&amp;quot;${msg}&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;8332-字符串操作&#34;&gt;8.3.3.2 字符串操作&lt;/h5&gt;
&lt;p&gt;​		Thymeleaf 提供了一些内置对象，内置对象可直接在模板中使用。这些对象是以#引用的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用内置对象的语法&lt;/p&gt;
&lt;p&gt;1）引用内置对象需要使用#&lt;br&gt;
2）大部分内置对象的名称都以 s 结尾。如：strings、numbers、dates&lt;/p&gt;
&lt;p&gt;${#strings.isEmpty(key)}&lt;br&gt;
判断字符串是否为空，如果为空返回 true，否则返回 false&lt;/p&gt;
&lt;p&gt;${#strings.contains(msg,&#39;T&#39;)}&lt;br&gt;
判断字符串是否包含指定的子串，如果包含返回 true，否则返回 false&lt;/p&gt;
&lt;p&gt;${#strings.startsWith(msg,&#39;a&#39;)}&lt;br&gt;
判断当前字符串是否以子串开头，如果是返回 true，否则返回 false&lt;/p&gt;
&lt;p&gt;${#strings.endsWith(msg,&#39;a&#39;)}&lt;br&gt;
判断当前字符串是否以子串结尾，如果是返回 true，否则返回 false&lt;/p&gt;
&lt;p&gt;${#strings.length(msg)}&lt;br&gt;
返回字符串的长度&lt;/p&gt;
&lt;p&gt;${#strings.indexOf(msg,&#39;h&#39;)}&lt;br&gt;
查找子串的位置，并返回该子串的下标，如果没找到则返回-1&lt;/p&gt;
&lt;p&gt;&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;}&amp;#039;, got &amp;#039;#&amp;#039; at position 2: {#̲strings.substri…&#39;&gt;{#strings.substring(msg,2)}
&lt;/span&gt;{#strings.substring(msg,2,5)}&lt;br&gt;
截取子串，用户与 jdk String 类下 SubString 方法相同&lt;/p&gt;
&lt;p&gt;&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;}&amp;#039;, got &amp;#039;#&amp;#039; at position 2: {#̲strings.toUpper…&#39;&gt;{#strings.toUpperCase(msg)}
&lt;/span&gt;{#strings.toLowerCase(msg)}&lt;br&gt;
字符串转大小写。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;	&amp;lt;hr/&amp;gt;
    &amp;lt;span th:text=&amp;quot;${#strings.isEmpty(msg)}&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;
    &amp;lt;hr/&amp;gt;
    &amp;lt;span th:text=&amp;quot;${#strings.contains(msg,&#39;s&#39;)}&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;
    &amp;lt;hr/&amp;gt;
    &amp;lt;span th:text=&amp;quot;${#strings.length(msg)}&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;8333-日期格式化处理&#34;&gt;8.3.3.3 日期格式化处理&lt;/h5&gt;
&lt;p&gt;​	${#dates.format(key)}&lt;br&gt;
​	格式化日期，默认的以浏览器默认语言为格式化标准&lt;/p&gt;
&lt;p&gt;​	${#dates.format(key,&#39;yyyy/MM/dd&#39;)}&lt;br&gt;
​	按照自定义的格式做日期转换&lt;/p&gt;
&lt;p&gt;​	${#dates.year(key)}&lt;br&gt;
​	${#dates.month(key)}&lt;br&gt;
​	${#dates.day(key)}&lt;br&gt;
​	Year：取年&lt;br&gt;
​	Month：取月&lt;br&gt;
​	Day：取日&lt;/p&gt;
&lt;p&gt;​	```html&lt;/p&gt;
&lt;hr/&gt;
```html
&lt;span th:text=&#34;${#dates.format(date)}&#34;&gt;&lt;/span&gt;
&lt;hr/&gt;
&lt;span th:text=&#34;${#dates.format(date,&#39;yyyy/MM/dd&#39;)}&#34;&gt;&lt;/span&gt;
&lt;hr/&gt;
&lt;span th:text=&#34;${#dates.year(date)}&#34;&gt;&lt;/span&gt;
&lt;span th:text=&#34;${#dates.month(date)}&#34;&gt;&lt;/span&gt;
&lt;span th:text=&#34;${#dates.day(date)}&#34;&gt;&lt;/span&gt;
&lt;hr/&gt;
```
##### 8.3.3.4 条件判断
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;th:if&lt;/p&gt;
&lt;p&gt;条件判断&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div&amp;gt;
        &amp;lt;span th:if=&amp;quot;${sex} == &#39;男&#39;&amp;quot;&amp;gt;
            性别：男
        &amp;lt;/span&amp;gt;
        &amp;lt;span th:if=&amp;quot;${sex} == &#39;女&#39;&amp;quot;&amp;gt;
            性别：女
        &amp;lt;/span&amp;gt;
    &amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;th:switch / th:case&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;th:switch / th:case 与 Java 中的 switch 语句等效，有条件地显示匹配的内容。如果有多个匹配结果只选择第一个显示。&lt;br&gt;
th:case=&amp;quot;&lt;em&gt;&amp;quot;表示 Java 中 switch 的 default，即没有 case 的值为 true 时则显示 th:case=&amp;quot;&lt;/em&gt;&amp;quot;的内容。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div th:switch=&amp;quot;${id}&amp;quot;&amp;gt;
        &amp;lt;span th:case=&amp;quot;1&amp;quot;&amp;gt;ID为1&amp;lt;/span&amp;gt;
        &amp;lt;span th:case=&amp;quot;2&amp;quot;&amp;gt;ID为2&amp;lt;/span&amp;gt;
        &amp;lt;span th:case=&amp;quot;3&amp;quot;&amp;gt;ID为3&amp;lt;/span&amp;gt;
        &amp;lt;span th:case=&amp;quot;*&amp;quot;&amp;gt;ID为*&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;8335-迭代遍历&#34;&gt;8.3.3.5 迭代遍历&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;th:each&lt;/p&gt;
&lt;p&gt;迭代器，用于循环迭代集合&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;table border=&amp;quot;1&amp;quot; width=&amp;quot;50%&amp;quot;&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;th&amp;gt;ID&amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;Name&amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;Age&amp;lt;/th&amp;gt;
        &amp;lt;/tr&amp;gt;
        &amp;lt;tr th:each=&amp;quot;u : ${list}&amp;quot;&amp;gt;
            &amp;lt;td th:text=&amp;quot;${u.id}&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
            &amp;lt;td th:text=&amp;quot;${u.name}&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
            &amp;lt;td th:text=&amp;quot;${u.age}&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
    &amp;lt;/table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;th:each 状态变量&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;index:当前迭代器的索引 从 0 开始&lt;/li&gt;
&lt;li&gt;count:当前迭代对象的计数 从 1 开始&lt;/li&gt;
&lt;li&gt;size:被迭代对象的长度&lt;/li&gt;
&lt;li&gt;odd/even:布尔值，当前循环是否是偶数/奇数 从 0 开始&lt;/li&gt;
&lt;li&gt;first:布尔值，当前循环的是否是第一条，如果是返回 true 否则返回 false&lt;/li&gt;
&lt;li&gt;last:布尔值，当前循环的是否是最后一条，如果是则返回 true 否则返回 false&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;table border=&amp;quot;1&amp;quot; width=&amp;quot;50%&amp;quot;&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;th&amp;gt;ID&amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;Name&amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;Age&amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;Index&amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;Count&amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;Size&amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;Odd&amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;Even&amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;First&amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;Last&amp;lt;/th&amp;gt;
        &amp;lt;/tr&amp;gt;
    	&amp;lt;!--迭代的状态变量放在第二位 --&amp;gt;
        &amp;lt;tr th:each=&amp;quot;u,suibian : ${list}&amp;quot;&amp;gt;
            &amp;lt;td th:text=&amp;quot;${u.id}&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
            &amp;lt;td th:text=&amp;quot;${u.name}&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
            &amp;lt;td th:text=&amp;quot;${u.age}&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
            &amp;lt;td th:text=&amp;quot;${suibian.index}&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
            &amp;lt;td th:text=&amp;quot;${suibian.count}&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
            &amp;lt;td th:text=&amp;quot;${suibian.size}&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
            &amp;lt;td th:text=&amp;quot;${suibian.odd}&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
            &amp;lt;td th:text=&amp;quot;${suibian.even}&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
            &amp;lt;td th:text=&amp;quot;${suibian.first}&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
            &amp;lt;td th:text=&amp;quot;${suibian.last}&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
    &amp;lt;/table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;8336-theach-迭代-map&#34;&gt;8.3.3.6 th:each 迭代 Map&lt;/h5&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;    &amp;lt;table border=&amp;quot;1&amp;quot; width=&amp;quot;50%&amp;quot;&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;th&amp;gt;Value&amp;lt;/th&amp;gt;
        &amp;lt;/tr&amp;gt;
        &amp;lt;tr th:each=&amp;quot;m : ${map}&amp;quot;&amp;gt;
            &amp;lt;!--结果是键值对形式--&amp;gt;
            &amp;lt;td th:text=&amp;quot;${m}&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
    &amp;lt;/table&amp;gt;
    &amp;lt;hr/&amp;gt;
    &amp;lt;table border=&amp;quot;1&amp;quot; width=&amp;quot;50%&amp;quot;&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;th&amp;gt;ID&amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;Name&amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;Age&amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;Key&amp;lt;/th&amp;gt;
        &amp;lt;/tr&amp;gt;
        &amp;lt;tr th:each=&amp;quot;m : ${map}&amp;quot;&amp;gt;
            &amp;lt;td th:text=&amp;quot;${m.value.id}&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
            &amp;lt;td th:text=&amp;quot;${m.value.name}&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
            &amp;lt;td th:text=&amp;quot;${m.value.age}&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
            &amp;lt;td th:text=&amp;quot;${m.key}&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
    &amp;lt;/table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;8337-操作域对象&#34;&gt;8.3.3.7 操作域对象&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;HttpServletRequest&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;request.setAttribute(&amp;quot;req&amp;quot;, &amp;quot;HttpServletRequest&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;span th:text=&amp;quot;${#httpServletRequest.getAttribute(&#39;req&#39;)}&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;
&amp;lt;span th:text=&amp;quot;${#request.getAttribute(&#39;req&#39;)}&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;HttpSession&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;request.getSession().setAttribute(&amp;quot;ses&amp;quot;, &amp;quot;HttpSession&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;span th:text=&amp;quot;${session.ses}&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;br/&amp;gt;
&amp;lt;span th:text=&amp;quot;${#session.getAttribute(&#39;ses&#39;)}&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;br/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;ServletContext&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;request.getSession().getServletContext().setAttribute(&amp;quot;app&amp;quot;,
&amp;quot;Application&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;span th:text=&amp;quot;${application.app}&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;
&amp;lt;span th:text=&amp;quot;${#servletContext.getAttribute(&#39;app&#39;)}&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;8338-url表达式&#34;&gt;8.3.3.8 URL表达式&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;语法&lt;/p&gt;
&lt;p&gt;在 Thymeleaf 中 URL 表达式的语法格式为@{}&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;URL 类型&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;绝对路径&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;a th:href=&amp;quot;@{http://www.baidu.com}&amp;quot;&amp;gt;打开百度&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;相对路径&lt;/p&gt;
&lt;p&gt;相对于当前项目的根：&lt;/p&gt;
&lt;p&gt;controller：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//所有超链接都是基于get方式请求的
@GetMapping(&amp;quot;/show2&amp;quot;)
    public String show2(){
        return &amp;quot;index2&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;a th:href=&amp;quot;@{/show2}&amp;quot;&amp;gt;打开index2&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;相对于服务器路径的根&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;a th:href=&amp;quot;@{~/project2/resourcename}&amp;quot;&amp;gt;相对于服务器的根&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 URL 中传递参数&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在普通格式的 URL 中传递参数&lt;/p&gt;
&lt;p&gt;controller:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;     model.addAttribute(&amp;quot;id&amp;quot;,&amp;quot;100&amp;quot;);
     model.addAttribute(&amp;quot;name&amp;quot;,&amp;quot;cy&amp;quot;);

   @GetMapping(&amp;quot;/show2&amp;quot;)
   public String show2(String id,String name){
       System.out.println(id+&amp;quot;\t&amp;quot;+name);
       return &amp;quot;index2&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- url显示为：localhost:8080/show2?id=1&amp;amp;name=admin--&amp;gt; 
&amp;lt;a th:href=&amp;quot;@{/show2?id=1&amp;amp;name=admin}&amp;quot;&amp;gt;普通URL传递参数方式一(参数写死)&amp;lt;/a&amp;gt;

&amp;lt;!--url显示为：localhost:8080/show2?id=1&amp;amp;name=kevin--&amp;gt;
&amp;lt;a th:href=&amp;quot;@{/show2(id=2,name=kevin)}&amp;quot;&amp;gt;普通URL传递参数方式二（括号）&amp;lt;/a&amp;gt;

&amp;lt;!--url显示为：localhost:8080/show2?id=100&amp;amp;name=cy--&amp;gt;
&amp;lt;a th:href=&amp;quot;@{&#39;/show2?id=&#39;+${id}+&#39;&amp;amp;name=&#39;+${name}}&amp;quot;&amp;gt;普通URL传递参数方式三(拼接)&amp;lt;/a&amp;gt;

&amp;lt;!--url显示为：localhost:8080/show2?id=100&amp;amp;name=cy--&amp;gt;
&amp;lt;a th:href=&amp;quot;@{/show2(id=${id},name=${name})}&amp;quot;&amp;gt;普通URL传递参数方式四（括号）&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		2.在 restful 格式的 URL 中传递参数&lt;/p&gt;
&lt;p&gt;controller:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    @GetMapping(&amp;quot;/show3/{id}/{name}&amp;quot;)
	/*@PathVariable
	获取的是请求路径中参数的值
	@RequestParam
	获取的是请求参数，一般是url问号后面的参数值
	简单类来说@PathVariable是/get/1 @RequestParam是/get?id=1
	*/
    public String show3(@PathVariable String id,@PathVariable String name){
        System.out.println(id+&amp;quot;\t&amp;quot;+name);
        return &amp;quot;index2&amp;quot;;
    }

    @GetMapping(&amp;quot;/show4/{id}&amp;quot;)
    public String show4(@PathVariable String id,String name){
        System.out.println(id+&amp;quot;\t&amp;quot;+name);
        return &amp;quot;index2&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!--url显示为：localhost:8080/show3/200--&amp;gt;
&amp;lt;a th:href=&amp;quot;@{/show3/{id}(id=200)}&amp;quot;&amp;gt;restful格式传递参数方式一&amp;lt;/a&amp;gt;

&amp;lt;!--url显示为：localhost:8080/show3/200/admin--&amp;gt;
&amp;lt;a th:href=&amp;quot;@{/show3/{id}/{name}(id=200,name=admin)}&amp;quot;&amp;gt;restful格式传递参数方式二&amp;lt;/a&amp;gt;

&amp;lt;!--url显示为：localhost:8080/show4/200?name=admin--&amp;gt;
&amp;lt;a th:href=&amp;quot;@{/show4/{id}(id=200,name=admin)}&amp;quot;&amp;gt;restful格式传递参数方式三&amp;lt;/a&amp;gt;

&amp;lt;!--url显示为：localhost:8080/show4/200?name=cy--&amp;gt;
&amp;lt;a th:href=&amp;quot;@{/show4/{id}(id=${id},name=${name})}&amp;quot;&amp;gt;restful格式传递参数方式四&amp;lt;/a&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;总结：在（）形式里面都可以用EL表达式进行取值&lt;/p&gt;
&lt;h5 id=&#34;8339-在配置文件中配置thymeleaf&#34;&gt;8.3.3.9 在配置文件中配置Thymeleaf&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;spring.thymeleaf.prefix=classpath:/templates/suibian/
spring.thymeleaf.suffix=.html
spring.thymeleaf.mode=HTML #配置视图模板类型，如果视图模板使用的是 html5 需要配置
spring.thymeleaf.encoding=utf-8
spring.thymeleaf.servlet.content-type=text/html #响应类型
#配置页面缓存
spring.thymeleaf.cache=false
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;9-spring-boot-整合持久层技术&#34;&gt;9、 Spring Boot 整合持久层技术&lt;/h2&gt;
&lt;h3 id=&#34;91-整合jdbc&#34;&gt;9.1 整合JDBC&lt;/h3&gt;
&lt;h4 id=&#34;911-搭建项目环境&#34;&gt;9.1.1 搭建项目环境&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建表&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;CREATE TABLE `users` (
`userid` int(11) NOT NULL AUTO_INCREMENT,
`username` varchar(30) DEFAULT NULL,
`usersex` varchar(10) DEFAULT NULL,
PRIMARY KEY (`userid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建项目&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200620152431.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;修改pom文件，添加相关依赖&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
	xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
	&amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
	&amp;lt;parent&amp;gt;
		&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
		&amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
		&amp;lt;version&amp;gt;2.2.0.RELEASE&amp;lt;/version&amp;gt;
		&amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
	&amp;lt;/parent&amp;gt;
	&amp;lt;groupId&amp;gt;com.bjsxt&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;springbootjdbc&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
	&amp;lt;name&amp;gt;springbootjdbc&amp;lt;/name&amp;gt;
	&amp;lt;description&amp;gt;Demo project for Spring Boot&amp;lt;/description&amp;gt;

	&amp;lt;properties&amp;gt;
		&amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
	&amp;lt;/properties&amp;gt;

	&amp;lt;dependencies&amp;gt;
		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
		&amp;lt;/dependency&amp;gt;

        &amp;lt;!--Thymeleaf启动器坐标--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-thymeleaf&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--JDBC启动器坐标--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-jdbc&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--数据库驱动坐标--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;5.1.38&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--Druid数据源依赖--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;druid&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.1.12&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
			&amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
			&amp;lt;exclusions&amp;gt;
				&amp;lt;exclusion&amp;gt;
					&amp;lt;groupId&amp;gt;org.junit.vintage&amp;lt;/groupId&amp;gt;
					&amp;lt;artifactId&amp;gt;junit-vintage-engine&amp;lt;/artifactId&amp;gt;
				&amp;lt;/exclusion&amp;gt;
			&amp;lt;/exclusions&amp;gt;
		&amp;lt;/dependency&amp;gt;
	&amp;lt;/dependencies&amp;gt;

	&amp;lt;build&amp;gt;
		&amp;lt;plugins&amp;gt;
			&amp;lt;plugin&amp;gt;
				&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
				&amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
			&amp;lt;/plugin&amp;gt;
		&amp;lt;/plugins&amp;gt;
	&amp;lt;/build&amp;gt;

&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;912-配置数据源&#34;&gt;9.1.2 配置数据源&lt;/h4&gt;
&lt;h5 id=&#34;9121-通过自定义配置文件方式配置数据源信息&#34;&gt;9.1.2.1 通过自定义配置文件方式配置数据源信息&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;通过@PropertySource 注解读取配置文件
&lt;ol&gt;
&lt;li&gt;添加 Druid 数据源依赖&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;        &amp;lt;!--Druid数据源依赖--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;druid&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.1.12&amp;lt;/version&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		2. 创建 Properties 文件&lt;/p&gt;
&lt;p&gt;​		jdbc.properties&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;jdbc.driverClassName=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/test?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;useSSL=false
jdbc.username=root
jdbc.password=root
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;创建配置类&lt;/p&gt;
&lt;p&gt;JdbcConfiguration类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**


* 数据源的 JDBC 配置类
*/
@Configuration
@PropertySource(&amp;quot;classpath:/jdbc.properties&amp;quot;) //加载指定的Properties 配置文件
public class JdbcConfiguration {
	@Value(&amp;quot;${jdbc.driverClassName}&amp;quot;)
	private String driverClassName;
	@Value(&amp;quot;${jdbc.url}&amp;quot;)
	private String url;
	@Value(&amp;quot;${jdbc.username}&amp;quot;)
	private String username;
	@Value(&amp;quot;${jdbc.password}&amp;quot;)
	private String password;
	
    /**
	* 实例化 Druid
	*/
	@Bean
	public DataSource getDataSource(){
		DruidDataSource source = new DruidDataSource();
		source.setPassword(this.password);
		source.setUsername(this.username);
		source.setUrl(this.url);
		source.setDriverClassName(this.driverClassName);
		return source;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;通过@ConfigurationProperties 注解读取配置信息&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建配置信息实体类&lt;/p&gt;
&lt;p&gt;​	JdbcProperties类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * JDBC配置信息属性类
 */
@ConfigurationProperties(prefix = &amp;quot;jdbc&amp;quot;)//是SpringBoot的注解不能读取其他配置文件，只能读取SpringBoot的application配置文件
public class JdbcProperties {

    private String driverClassName;
    private String url;
    private String username;
    private String password;

    public String getDriverClassName() {
        return driverClassName;
    }

    public void setDriverClassName(String driverClassName) {
        this.driverClassName = driverClassName;
    }

    public String getUrl() {
        return url;
    }

    public void setUrl(String url) {
        this.url = url;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;修改配置类&lt;/p&gt;
&lt;p&gt;JdbcConfiguration类：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 数据源的JDBC配置类
 */
//@Configuration
//@PropertySource(&amp;quot;classpath:/jdbc.properties&amp;quot;)  //加载指定的Properties配置文件
@EnableConfigurationProperties(JdbcProperties.class)//指定加载哪个配置信息属性类
public class JdbcConfiguration {

    //@Autowired
   /* private JdbcProperties jdbcProperties;

    //通过构造方法来注入
    public JdbcConfiguration(JdbcProperties jdbcProperties){
        this.jdbcProperties = jdbcProperties;
    }*/

    /**
     * 实例化Druid
     */
    @Bean
    public DataSource getDataSource(JdbcProperties
jdbcProperties){
        DruidDataSource source = new DruidDataSource();
		source.setPassword(this.password);
		source.setUsername(this.username);
		source.setUrl(this.url);		source.setDriverClassName(this.driverClassName);
		return source;
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;@ConfigurationProperties 注解的优雅使用方式（重点）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JdbcConfiguration类：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 数据源的JDBC配置类
 */
//@Configuration
//@PropertySource(&amp;quot;classpath:/jdbc.properties&amp;quot;)  //加载指定的Properties配置文件
//@EnableConfigurationProperties(JdbcProperties.class)//指定加载哪个配置信息属性类
public class JdbcConfiguration {

    //@Autowired
   /* private JdbcProperties jdbcProperties;

    //通过构造方法来注入
    public JdbcConfiguration(JdbcProperties jdbcProperties){
        this.jdbcProperties = jdbcProperties;
    }*/

    /**
     * 实例化Druid
     */
    @Bean
    //这个注解会将从配置文件中解析出来的内容，通过调用getDataSource方法所创建的source对象的setUsername、setPassword、setUrl、setDriverClassName这些方法，将解析出来的值直接注入到Datasource中
    @ConfigurationProperties(prefix = &amp;quot;jdbc&amp;quot;)
    public DataSource getDataSource(){
        DruidDataSource source = new DruidDataSource();
        return source;
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;UserController类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@controller
public class UserController{
    
    @AutoWried
    private DataSource dataSource;
    
    @GetMapping(&amp;quot;/showInfo&amp;quot;)
    public String showInfo(){
        return &amp;quot;ok&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这时JdbcProperties类没有任何意义了，可以删了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;9122-通过-spring-boot-配置文件配置数据源&#34;&gt;9.1.2.2 通过 Spring Boot 配置文件配置数据源&lt;/h5&gt;
&lt;p&gt;​		在 Spring Boot1.x 版 本 中 的 spring-boot-starter-jdbc 启 动 器 中 默 认 使 用 的 是org.apache.tomcat.jdbc.pool.DataSource 作为数据源&lt;br&gt;
​		在 Spring Boot2.x 版 本 中 的 spring-boot-starter-jdbc 启 动 器 中 默 认 使 用 的 是com.zaxxer.hikariDataSource 作为数据源&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用 Spring Boot 默认的 HikariDataSource 数据源&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;spring.datasource.url=jdbc:mysql://localhost:3306/test?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;useSSL=false
spring.datasource.driver-class-name=com.mysql.jdbc.Driver
spring.datasource.username=root
spring.datasource.password=root
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用第三方的数据源, 如： Druid&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;spring.datasource.url=jdbc:mysql://localhost:3306/test?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;useSSL=false
spring.datasource.driver-class-name=com.mysql.jdbc.Driver
spring.datasource.username=root
spring.datasource.password=root
spring.datasource.type=com.alibaba.druid.pool.DruidDataSo
urce
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;总结：在SpringBoot中配置数据非常简单，只要在pom文件中加入你想使用的数据源的依赖，并且在配置文件中加入spring.datasource.type这个key，后面跟你所使用数据源value类的全名。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;913-详细设计&#34;&gt;9.1.3 详细设计&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;18&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200621040916.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;视图层：&lt;/p&gt;
&lt;p&gt;addUser.html:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot; xmlns:th=&amp;quot;http://www.w3.org/1999/xhtml&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;form th:action=&amp;quot;@{/user/addUser}&amp;quot; method=&amp;quot;post&amp;quot;&amp;gt;
    username：&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;username&amp;quot;&amp;gt;&amp;lt;br/&amp;gt;
    usersex：&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;usersex&amp;quot;&amp;gt;&amp;lt;br/&amp;gt;
    &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;增加&amp;quot;&amp;gt;
&amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ok.html:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h2&amp;gt;操作成功！&amp;lt;/h2&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;showUsers.html:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot; xmlns:th=&amp;quot;http://www.w3.org/1999/xhtml&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;table border=&amp;quot;1&amp;quot; align=&amp;quot;center&amp;quot;&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;th&amp;gt;ID&amp;lt;/th&amp;gt;
        &amp;lt;th&amp;gt;姓名&amp;lt;/th&amp;gt;
        &amp;lt;th&amp;gt;性别&amp;lt;/th&amp;gt;
        &amp;lt;th&amp;gt;操作&amp;lt;/th&amp;gt;
    &amp;lt;/tr&amp;gt;
    &amp;lt;tr th:each=&amp;quot;u : ${list}&amp;quot;&amp;gt;
        &amp;lt;td th:text=&amp;quot;${u.userid}&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
        &amp;lt;td th:text=&amp;quot;${u.username}&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
        &amp;lt;td th:text=&amp;quot;${u.usersex}&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;
            &amp;lt;a th:href=&amp;quot;@{/user/preUpdateUser/(id=${u.userid})}&amp;quot;&amp;gt;修改&amp;lt;/a&amp;gt;
            &amp;lt;a th:href=&amp;quot;@{/user/deleteUser(id=${u.userid})}&amp;quot;&amp;gt;删除&amp;lt;/a&amp;gt;
        &amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;updateUser.html:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot; xmlns:th=&amp;quot;http://www.w3.org/1999/xhtml&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;form th:action=&amp;quot;@{/user/updateUser}&amp;quot; method=&amp;quot;post&amp;quot;&amp;gt;
    &amp;lt;input type=&amp;quot;hidden&amp;quot; name=&amp;quot;userid&amp;quot; th:value=&amp;quot;${user.userid}&amp;quot;&amp;gt;
    &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;username&amp;quot; th:value=&amp;quot;${user.username}&amp;quot;&amp;gt;&amp;lt;br/&amp;gt;
    &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;usersex&amp;quot; th:value=&amp;quot;${user.usersex}&amp;quot;&amp;gt;&amp;lt;br/&amp;gt;
    &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;修改&amp;quot;&amp;gt;
&amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;controller层&lt;/p&gt;
&lt;p&gt;PageController：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * @date 2020-06-20 17:26
 * 页面跳转
 */
@Controller
public class PageController {
    /*
     * 页面跳转方法
     * */
    @RequestMapping(&amp;quot;/{page}&amp;quot;)
    public String showPage(@PathVariable String page) {
        return page;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;UsersController:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Controller
@RequestMapping(&amp;quot;/user&amp;quot;)
public class UsersController {
    @Autowired
    private UsersService usersService;

    /**
     * 添加用户
     *
     * @param users
     * @return
     */
    @PostMapping(&amp;quot;/addUser&amp;quot;)
    public String addUser(Users users) {
        try {
            usersService.addUser(users);
        } catch (Exception e) {
            e.printStackTrace();
            return &amp;quot;error&amp;quot;;
        }
        //重定向，防止表单重复提交
        return &amp;quot;redirect:/ok&amp;quot;;
    }

    /**
     * 查询所有用户
     */
    @GetMapping(&amp;quot;/findUsersAll&amp;quot;)
    public String findUsersAll(Model model) {
        try {
            List&amp;lt;Users&amp;gt; list = usersService.findUsersAll();
            model.addAttribute(&amp;quot;list&amp;quot;, list);
        } catch (Exception e) {
            e.printStackTrace();
            return &amp;quot;error&amp;quot;;
        }
        return &amp;quot;showUsers&amp;quot;;
    }

    /**
     * 预更新用户的查询
     */
    @GetMapping(&amp;quot;/preUpdateUser&amp;quot;)
    public String preUpdateUser(Integer id, Model model) {
        try {
            Users user = usersService.findUserById(id);
            model.addAttribute(&amp;quot;user&amp;quot;, user);
        } catch (Exception e) {
            e.printStackTrace();
            return &amp;quot;error&amp;quot;;
        }
        return &amp;quot;updateUser&amp;quot;;
    }

    /**
     * 更新用户
     */
    @PostMapping(&amp;quot;/updateUser&amp;quot;)
    public String updateUser(Users user){
        try {
            usersService.modifyUser(user);
        } catch (Exception e) {
            e.printStackTrace();
            return &amp;quot;error&amp;quot;;
        }
        return &amp;quot;redirect:/ok&amp;quot;;
    }

    /**
     * 删除用户
     * @param id
     * @return
     */
    @GetMapping(&amp;quot;/deleteUser&amp;quot;)
    public String deleteUser(Integer id){
        try {
            usersService.dropUser(id);
        } catch (Exception e) {
            e.printStackTrace();
            return &amp;quot;error&amp;quot;;
        }
        return &amp;quot;redirect:/ok&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;service层&lt;/p&gt;
&lt;p&gt;UsersService接口:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface UsersService {

    void addUser(Users users);

    List&amp;lt;Users&amp;gt; findUsersAll();

    Users findUserById(Integer id);

    void modifyUser(Users user);

    void dropUser(Integer id);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;UsersServiceImpl:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 用户管理业务层
 */
@Service
public class UsersServiceImpl implements UsersService {
    @Autowired
    private UsersDao usersDao;

    /**
     * 添加用户
     *
     * @param users
     */
    @Override
    @Transactional
    public void addUser(Users users) {
        usersDao.insertUsers(users);
    }

    /**
     * 查询所有用户
     *
     * @return
     */
    @Override
    public List&amp;lt;Users&amp;gt; findUsersAll() {
        List&amp;lt;Users&amp;gt; list = usersDao.selectUsersAll();
        return list;
    }

    /**
     * 预更新查询
     *
     * @param id
     * @return
     */
    @Override
    public Users findUserById(Integer id) {
        Users user = usersDao.selectUserById(id);
        return user;
    }

    /**
     * 更新用户
     * @param user
     */
    @Override
    @Transactional
    public void modifyUser(Users user) {
        usersDao.updateUser(user);
    }

    /**
     * 删除用户
     * @param id
     */
    @Override
    @Transactional
    public void dropUser(Integer id) {
        usersDao.delUserById(id);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;dao层&lt;/p&gt;
&lt;p&gt;UsersDao接口：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface UsersDao {
    
    void insertUsers(Users users);

    List&amp;lt;Users&amp;gt; selectUsersAll();

    Users selectUserById(Integer id);

    void updateUser(Users user);

    void delUserById(Integer id);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;UsersDaImpl：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 持久层
 */
@Repository
public class UsersDaImpl implements UsersDao {
    @Autowired
    private JdbcTemplate jdbcTemplate;

    /**
     * 添加用户
     *
     * @param users
     */
    @Override
    public void insertUsers(Users users) {
        String sql = &amp;quot;insert into users(username,usersex) values(?,?)&amp;quot;;
        jdbcTemplate.update(sql, users.getUsername(), users.getUsersex());
    }

    @Override
    public List&amp;lt;Users&amp;gt; selectUsersAll() {
        String sql = &amp;quot;select * from users&amp;quot;;
        return jdbcTemplate.query(sql, new RowMapper&amp;lt;Users&amp;gt;() {
            /**
             * 结果集映射
             * @param resultSet
             * @param i
             * @return
             * @throws SQLException
             */
            @Override
            public Users mapRow(ResultSet resultSet, int i) throws SQLException {
                Users users = new Users();
                //自己做ORM的处理
                users.setUserid(resultSet.getInt(&amp;quot;userid&amp;quot;));
                users.setUsername(resultSet.getString(&amp;quot;username&amp;quot;));
                users.setUsersex(resultSet.getString(&amp;quot;usersex&amp;quot;));
                return users;
            }
        });
    }

    /**
     * 预更新用户查询
     *
     * @param id
     * @return
     */
    @Override
    public Users selectUserById(Integer id) {
        Users user = new Users();
        String sql = &amp;quot;select * from users where userid=?&amp;quot;;
        Object[] objects = new Object[]{id};
        jdbcTemplate.query(sql, objects, new RowCallbackHandler() {
            @Override
            public void processRow(ResultSet resultSet) throws SQLException {
                user.setUserid(resultSet.getInt(&amp;quot;userid&amp;quot;));
                user.setUsername(resultSet.getString(&amp;quot;username&amp;quot;));
                user.setUsersex(resultSet.getString(&amp;quot;usersex&amp;quot;));
            }
        });
        return user;
    }

    /**
     * 更新用户
     *
     * @param user
     */
    @Override
    public void updateUser(Users user) {
        String sql = &amp;quot;update users set username=?,usersex=? where userid=?&amp;quot;;
        jdbcTemplate.update(sql, user.getUsername(), user.getUsersex(), user.getUserid());
    }

    /**
     * 删除用户
     *
     * @param id
     */
    @Override
    public void delUserById(Integer id) {
        String sql = &amp;quot;delete from users where userid = ? &amp;quot;;
        jdbcTemplate.update(sql,id);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实现效果：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;19&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200621040455.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;20&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200621040539.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​	&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200621040622.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;21&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200621040708.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;22&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200621040728.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;23&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200621040803.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;24&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200621040823.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;25&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200621040839.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;92-整合mybatis&#34;&gt;9.2 整合MyBatis&lt;/h3&gt;
&lt;h4 id=&#34;921-搭建项目环境&#34;&gt;9.2.1 搭建项目环境&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建项目&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;26&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200622005620.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改POM文件，添加相关依赖&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
	xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
	&amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
	&amp;lt;parent&amp;gt;
		&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
		&amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
		&amp;lt;version&amp;gt;2.3.1.RELEASE&amp;lt;/version&amp;gt;
		&amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
	&amp;lt;/parent&amp;gt;
	&amp;lt;groupId&amp;gt;com.cy&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;springbootmybatis&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
	&amp;lt;name&amp;gt;springbootmybatis&amp;lt;/name&amp;gt;
	&amp;lt;description&amp;gt;Demo project for Spring Boot&amp;lt;/description&amp;gt;

	&amp;lt;properties&amp;gt;
		&amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
	&amp;lt;/properties&amp;gt;

	&amp;lt;dependencies&amp;gt;
		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;spring-boot-starter-thymeleaf&amp;lt;/artifactId&amp;gt;
		&amp;lt;/dependency&amp;gt;
		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
		&amp;lt;/dependency&amp;gt;
		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;/artifactId&amp;gt;
			&amp;lt;version&amp;gt;2.1.3&amp;lt;/version&amp;gt;
		&amp;lt;/dependency&amp;gt;
		&amp;lt;!--数据库驱动坐标--&amp;gt;
		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
			&amp;lt;version&amp;gt;5.1.38&amp;lt;/version&amp;gt;
		&amp;lt;/dependency&amp;gt;
		&amp;lt;!--Druid 数据源依赖--&amp;gt;
		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;druid&amp;lt;/artifactId&amp;gt;
			&amp;lt;version&amp;gt;1.1.12&amp;lt;/version&amp;gt;
		&amp;lt;/dependency&amp;gt;

		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
			&amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
			&amp;lt;exclusions&amp;gt;
				&amp;lt;exclusion&amp;gt;
					&amp;lt;groupId&amp;gt;org.junit.vintage&amp;lt;/groupId&amp;gt;
					&amp;lt;artifactId&amp;gt;junit-vintage-engine&amp;lt;/artifactId&amp;gt;
				&amp;lt;/exclusion&amp;gt;
			&amp;lt;/exclusions&amp;gt;
		&amp;lt;/dependency&amp;gt;
	&amp;lt;/dependencies&amp;gt;

	&amp;lt;build&amp;gt;
		&amp;lt;plugins&amp;gt;
			&amp;lt;plugin&amp;gt;
				&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
				&amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
			&amp;lt;/plugin&amp;gt;
		&amp;lt;/plugins&amp;gt;
	&amp;lt;/build&amp;gt;

&amp;lt;/project&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;配置数据源&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;spring:
  datasource:
    driver-class-name: com.mysql.jdbc.Driver
    url: jdbc:mysql://localhost:3306/test02?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;useSSL=false
    data-username: root
    data-password: root
    type: com.alibaba.druid.pool.DruidDataSource

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;922-配置-maven-的-generator-插件&#34;&gt;9.2.2 配置 Maven 的 generator 插件&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;添加 generator 插件坐标&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;    &amp;lt;plugin&amp;gt;
        &amp;lt;groupId&amp;gt;org.mybatis.generator&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;mybatis-generator-maven-plugin&amp;lt;/artifactId
        &amp;lt;version&amp;gt;1.3.5&amp;lt;/version&amp;gt;
        &amp;lt;dependencies&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;5.1.38&amp;lt;/version&amp;gt;
            &amp;lt;/dependency&amp;gt;
        &amp;lt;/dependencies&amp;gt;
        &amp;lt;!--指定配置文件的路径--&amp;gt;
        &amp;lt;configuration&amp;gt;
            &amp;lt;configurationFile&amp;gt;${project.basedir}/src/main/res
            &amp;lt;/configurationFile&amp;gt;
            &amp;lt;verbose&amp;gt;true&amp;lt;/verbose&amp;gt;
            &amp;lt;overwrite&amp;gt;true&amp;lt;/overwrite&amp;gt;
        &amp;lt;/configuration&amp;gt;
    &amp;lt;/plugin&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;添加 generator 配置文件&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;27&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200622010708.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;添加 generator 配置文件的 DTD 文件&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;28&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200622010812.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;29&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200622011008.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;
&lt;p&gt;运行 generator 插件生成代码&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;30&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200622011545.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;31&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200622011732.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;923-配置资源拷贝插件&#34;&gt;9.2.3 配置资源拷贝插件&lt;/h4&gt;
&lt;p&gt;​		由于映射配置文件在自定义包中，项目运行时在resources中找不到映射配置文件，所以要配置资源拷贝插件&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;添加资源拷贝插件坐标&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt; &amp;lt;!--配置资源拷贝插件--&amp;gt;
 &amp;lt;resources&amp;gt;
     &amp;lt;resource&amp;gt;
         &amp;lt;directory&amp;gt;src/main/java&amp;lt;/directory&amp;gt;
         &amp;lt;includes&amp;gt;
             &amp;lt;include&amp;gt;**/*.xml&amp;lt;/include&amp;gt;
         &amp;lt;/includes&amp;gt;
     &amp;lt;/resource&amp;gt;
     &amp;lt;!--由于前面配置了路径，这样就不到到resources目录下处理文件，所以还要配置resources目录--&amp;gt;
     &amp;lt;resource&amp;gt;
         &amp;lt;directory&amp;gt;src/main/resources&amp;lt;/directory&amp;gt;
         &amp;lt;includes&amp;gt;
             &amp;lt;include&amp;gt;**/*.yml&amp;lt;/include&amp;gt;
             &amp;lt;include&amp;gt;**/*.properties&amp;lt;/include&amp;gt;
             &amp;lt;!--加载模板文件--&amp;gt;
             &amp;lt;include&amp;gt;**/*.html&amp;lt;/include&amp;gt;
             &amp;lt;!--加载静态文件--&amp;gt;
             &amp;lt;include&amp;gt;/static/&amp;lt;/include&amp;gt;
         &amp;lt;/includes&amp;gt;
     &amp;lt;/resource&amp;gt;
 &amp;lt;/resources&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改启动类添加@MapperScan 注解&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SpringBootApplication
@MapperScan(&amp;quot;com.cy.springbootmybatis.mapper&amp;quot;)//指定扫描接口与映射配置文件的包名
public class SpringbootmybatisApplication {

	public static void main(String[] args) {
		SpringApplication.run(SpringbootmybatisApplication.class, args);
	}

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;924-mybatis-的其他配置项&#34;&gt;9.2.4 MyBatis 的其他配置项&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;mybatis:
#扫描 classpath 中 mapper 目录下的映射配置文件，针对于映射配置文件放到了 resources 目录下
	mapper-locations: classpath:/mapper/*.xml
#定义包别名，使用 pojo 时可以直接使用 pojo 的类型名称不用加包名
	type-aliases-package: com.bjsxt.springbootmybatis.pojo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于本项目mapper目录不在resources目录下，且已经在启动类中添加了@MapperScan注解，故本项目不需要此配置&lt;/p&gt;
&lt;h4 id=&#34;925-详细设计&#34;&gt;9.2.5 详细设计&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;32&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200622091922.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;视图层&lt;/p&gt;
&lt;p&gt;addUser.html:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot; xmlns:th=&amp;quot;http://www.thymeleaf.org&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;form th:action=&amp;quot;@{/user/addUser}&amp;quot; method=&amp;quot;post&amp;quot;&amp;gt;
    username：&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;username&amp;quot;&amp;gt;&amp;lt;br/&amp;gt;
    usersex：&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;usersex&amp;quot;&amp;gt;&amp;lt;br/&amp;gt;
    &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;增加&amp;quot;&amp;gt;
&amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ok.html:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h2&amp;gt;成功！&amp;lt;/h2&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;showUsers.html:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot; xmlns:th=&amp;quot;http://www.thymeleaf.org&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;table border=&amp;quot;1&amp;quot; align=&amp;quot;center&amp;quot;&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;th&amp;gt;ID&amp;lt;/th&amp;gt;
        &amp;lt;th&amp;gt;姓名&amp;lt;/th&amp;gt;
        &amp;lt;th&amp;gt;性别&amp;lt;/th&amp;gt;
        &amp;lt;th&amp;gt;操作&amp;lt;/th&amp;gt;
    &amp;lt;/tr&amp;gt;
    &amp;lt;tr th:each=&amp;quot;u : ${list}&amp;quot;&amp;gt;
        &amp;lt;td th:text=&amp;quot;${u.userid}&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
        &amp;lt;td th:text=&amp;quot;${u.username}&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
        &amp;lt;td th:text=&amp;quot;${u.usersex}&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;
            &amp;lt;a th:href=&amp;quot;@{/user/preUpdateUser(id=${u.userid})}&amp;quot;&amp;gt;修改&amp;lt;/a&amp;gt;
            &amp;lt;a th:href=&amp;quot;@{/user/deleteUser(id=${u.userid})}&amp;quot;&amp;gt;删除&amp;lt;/a&amp;gt;
        &amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;updateUser.html:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot; xmlns:th=&amp;quot;http://www.thymeleaf.org&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;form th:action=&amp;quot;@{/user/updateUser}&amp;quot; method=&amp;quot;post&amp;quot;&amp;gt;
    &amp;lt;input type=&amp;quot;hidden&amp;quot; name=&amp;quot;userid&amp;quot; th:value=&amp;quot;${user.userid}&amp;quot;&amp;gt;
    &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;username&amp;quot; th:value=&amp;quot;${user.username}&amp;quot;&amp;gt;&amp;lt;br/&amp;gt;
    &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;usersex&amp;quot; th:value=&amp;quot;${user.usersex}&amp;quot;&amp;gt;&amp;lt;br/&amp;gt;
    &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;修改&amp;quot;&amp;gt;
&amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;控制层&lt;/p&gt;
&lt;p&gt;PageController:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 页面跳转controller
 */
@Controller
public class PageController {

    /**
     * 页面跳转方法
     */
    @RequestMapping(&amp;quot;/{page}&amp;quot;)
    public String showPage(@PathVariable String page) {
        return page;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;UsersController:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 用户管理controller
 */
@Controller
@RequestMapping(&amp;quot;/user&amp;quot;)
public class UsersController {

    @Autowired
    private UsersService usersService;
    /**
     * 添加用户
     */
    @PostMapping(&amp;quot;/addUser&amp;quot;)
    public String addUsers(Users users){
        try {
            usersService.addUsers(users);
        }catch (Exception e){
            e.printStackTrace();
            return &amp;quot;error&amp;quot;;
        }
        return &amp;quot;redirect:/ok&amp;quot;;
    }

    /**
     * 查询全部用户
     */
    @GetMapping(&amp;quot;/findUsersAll&amp;quot;)
    public String findUsersAll(Model model){
        try {
            List&amp;lt;Users&amp;gt; list = usersService.findUsersAll();
            model.addAttribute(&amp;quot;list&amp;quot;,list);
        }catch (Exception e){
            e.printStackTrace();
            return &amp;quot;error&amp;quot;;
        }
        return &amp;quot;showUsers&amp;quot;;
    }

    /**
     * 预更新用户的查询
     */
    @GetMapping(&amp;quot;/preUpdateUser&amp;quot;)
    public String preUpdateUser(Integer id,Model model){
        try {
            Users user = usersService.findUserById(id);
            model.addAttribute(&amp;quot;user&amp;quot;,user);
        }catch (Exception e){
            e.printStackTrace();
            return &amp;quot;error&amp;quot;;
        }
        return &amp;quot;updateUser&amp;quot;;
    }

    /**
     * 修改用户
     */
    @PostMapping(&amp;quot;/updateUser&amp;quot;)
    public String updateUser(Users user){
        try {
            usersService.updateUser(user);
        }catch (Exception e){
            e.printStackTrace();
            return &amp;quot;error&amp;quot;;
        }
        return &amp;quot;redirect:/ok&amp;quot;;
    }

    /**
     * 删除用户
     */
    @GetMapping(&amp;quot;/deleteUser&amp;quot;)
    public String deleteUser(Integer id){
        try {
            usersService.deleteUser(id);
        }catch (Exception e){
            e.printStackTrace();
            return &amp;quot;error&amp;quot;;
        }
        return &amp;quot;redirect:/ok&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;service层&lt;/p&gt;
&lt;p&gt;UsersService接口：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface UsersService {

    void addUsers(Users user);

    List&amp;lt;Users&amp;gt; findUsersAll();

    Users findUserById(Integer id);

    void updateUser(Users user);

    void deleteUser(Integer id);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;UsersServiceImpl类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 用户管理业务层
 */
@Service
public class UsersServiceImpl implements UsersService {
    @Autowired
    private UsersMapper usersMapper;

    /**
     * 增加用户
     * @param users
     */
    @Override
    public void addUsers(Users users) {
        usersMapper.insert(users);
    }

    /**
     * 查询所有用户
     * @return
     */
    @Override
    public List&amp;lt;Users&amp;gt; findUsersAll() {
        UsersExample usersExample = new UsersExample();
        return usersMapper.selectByExample(usersExample);
    }

    /**
     * 预更新用户的查询
     * @param id
     * @return
     */
    @Override
    public Users findUserById(Integer id) {
        Users user = usersMapper.selectByPrimaryKey(id);
        return user;
    }

    /**
     * 修改用户
     */
    @Override
    public void updateUser(Users user) {
        usersMapper.updateByPrimaryKey(user);
    }

    /**
     * 删除用户
     * @param id
     */
    @Override
    public void deleteUser(Integer id) {
        usersMapper.deleteByPrimaryKey(id);
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mapper(generator插件自动生成)&lt;/p&gt;
&lt;p&gt;UsersMapper.xml:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;!DOCTYPE mapper PUBLIC &amp;quot;-//mybatis.org//DTD Mapper 3.0//EN&amp;quot; &amp;quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&amp;quot;&amp;gt;
&amp;lt;mapper namespace=&amp;quot;com.cy.springbootmybatis.mapper.UsersMapper&amp;quot;&amp;gt;
  &amp;lt;resultMap id=&amp;quot;BaseResultMap&amp;quot; type=&amp;quot;com.cy.springbootmybatis.pojo.Users&amp;quot;&amp;gt;
    &amp;lt;id column=&amp;quot;userid&amp;quot; jdbcType=&amp;quot;INTEGER&amp;quot; property=&amp;quot;userid&amp;quot; /&amp;gt;
    &amp;lt;result column=&amp;quot;username&amp;quot; jdbcType=&amp;quot;VARCHAR&amp;quot; property=&amp;quot;username&amp;quot; /&amp;gt;
    &amp;lt;result column=&amp;quot;usersex&amp;quot; jdbcType=&amp;quot;VARCHAR&amp;quot; property=&amp;quot;usersex&amp;quot; /&amp;gt;
  &amp;lt;/resultMap&amp;gt;
  &amp;lt;sql id=&amp;quot;Example_Where_Clause&amp;quot;&amp;gt;
    &amp;lt;where&amp;gt;
      &amp;lt;foreach collection=&amp;quot;oredCriteria&amp;quot; item=&amp;quot;criteria&amp;quot; separator=&amp;quot;or&amp;quot;&amp;gt;
        &amp;lt;if test=&amp;quot;criteria.valid&amp;quot;&amp;gt;
          &amp;lt;trim prefix=&amp;quot;(&amp;quot; prefixOverrides=&amp;quot;and&amp;quot; suffix=&amp;quot;)&amp;quot;&amp;gt;
            &amp;lt;foreach collection=&amp;quot;criteria.criteria&amp;quot; item=&amp;quot;criterion&amp;quot;&amp;gt;
              &amp;lt;choose&amp;gt;
                &amp;lt;when test=&amp;quot;criterion.noValue&amp;quot;&amp;gt;
                  and ${criterion.condition}
                &amp;lt;/when&amp;gt;
                &amp;lt;when test=&amp;quot;criterion.singleValue&amp;quot;&amp;gt;
                  and ${criterion.condition} #{criterion.value}
                &amp;lt;/when&amp;gt;
                &amp;lt;when test=&amp;quot;criterion.betweenValue&amp;quot;&amp;gt;
                  and ${criterion.condition} #{criterion.value} and #{criterion.secondValue}
                &amp;lt;/when&amp;gt;
                &amp;lt;when test=&amp;quot;criterion.listValue&amp;quot;&amp;gt;
                  and ${criterion.condition}
                  &amp;lt;foreach close=&amp;quot;)&amp;quot; collection=&amp;quot;criterion.value&amp;quot; item=&amp;quot;listItem&amp;quot; open=&amp;quot;(&amp;quot; separator=&amp;quot;,&amp;quot;&amp;gt;
                    #{listItem}
                  &amp;lt;/foreach&amp;gt;
                &amp;lt;/when&amp;gt;
              &amp;lt;/choose&amp;gt;
            &amp;lt;/foreach&amp;gt;
          &amp;lt;/trim&amp;gt;
        &amp;lt;/if&amp;gt;
      &amp;lt;/foreach&amp;gt;
    &amp;lt;/where&amp;gt;
  &amp;lt;/sql&amp;gt;
  &amp;lt;sql id=&amp;quot;Update_By_Example_Where_Clause&amp;quot;&amp;gt;
    &amp;lt;where&amp;gt;
      &amp;lt;foreach collection=&amp;quot;example.oredCriteria&amp;quot; item=&amp;quot;criteria&amp;quot; separator=&amp;quot;or&amp;quot;&amp;gt;
        &amp;lt;if test=&amp;quot;criteria.valid&amp;quot;&amp;gt;
          &amp;lt;trim prefix=&amp;quot;(&amp;quot; prefixOverrides=&amp;quot;and&amp;quot; suffix=&amp;quot;)&amp;quot;&amp;gt;
            &amp;lt;foreach collection=&amp;quot;criteria.criteria&amp;quot; item=&amp;quot;criterion&amp;quot;&amp;gt;
              &amp;lt;choose&amp;gt;
                &amp;lt;when test=&amp;quot;criterion.noValue&amp;quot;&amp;gt;
                  and ${criterion.condition}
                &amp;lt;/when&amp;gt;
                &amp;lt;when test=&amp;quot;criterion.singleValue&amp;quot;&amp;gt;
                  and ${criterion.condition} #{criterion.value}
                &amp;lt;/when&amp;gt;
                &amp;lt;when test=&amp;quot;criterion.betweenValue&amp;quot;&amp;gt;
                  and ${criterion.condition} #{criterion.value} and #{criterion.secondValue}
                &amp;lt;/when&amp;gt;
                &amp;lt;when test=&amp;quot;criterion.listValue&amp;quot;&amp;gt;
                  and ${criterion.condition}
                  &amp;lt;foreach close=&amp;quot;)&amp;quot; collection=&amp;quot;criterion.value&amp;quot; item=&amp;quot;listItem&amp;quot; open=&amp;quot;(&amp;quot; separator=&amp;quot;,&amp;quot;&amp;gt;
                    #{listItem}
                  &amp;lt;/foreach&amp;gt;
                &amp;lt;/when&amp;gt;
              &amp;lt;/choose&amp;gt;
            &amp;lt;/foreach&amp;gt;
          &amp;lt;/trim&amp;gt;
        &amp;lt;/if&amp;gt;
      &amp;lt;/foreach&amp;gt;
    &amp;lt;/where&amp;gt;
  &amp;lt;/sql&amp;gt;
  &amp;lt;sql id=&amp;quot;Base_Column_List&amp;quot;&amp;gt;
    userid, username, usersex
  &amp;lt;/sql&amp;gt;
  &amp;lt;select id=&amp;quot;selectByExample&amp;quot; parameterType=&amp;quot;com.cy.springbootmybatis.pojo.UsersExample&amp;quot; resultMap=&amp;quot;BaseResultMap&amp;quot;&amp;gt;
    select
    &amp;lt;if test=&amp;quot;distinct&amp;quot;&amp;gt;
      distinct
    &amp;lt;/if&amp;gt;
    &amp;lt;include refid=&amp;quot;Base_Column_List&amp;quot; /&amp;gt;
    from users
    &amp;lt;if test=&amp;quot;_parameter != null&amp;quot;&amp;gt;
      &amp;lt;include refid=&amp;quot;Example_Where_Clause&amp;quot; /&amp;gt;
    &amp;lt;/if&amp;gt;
    &amp;lt;if test=&amp;quot;orderByClause != null&amp;quot;&amp;gt;
      order by ${orderByClause}
    &amp;lt;/if&amp;gt;
  &amp;lt;/select&amp;gt;
  &amp;lt;select id=&amp;quot;selectByPrimaryKey&amp;quot; parameterType=&amp;quot;java.lang.Integer&amp;quot; resultMap=&amp;quot;BaseResultMap&amp;quot;&amp;gt;
    select 
    &amp;lt;include refid=&amp;quot;Base_Column_List&amp;quot; /&amp;gt;
    from users
    where userid = #{userid,jdbcType=INTEGER}
  &amp;lt;/select&amp;gt;
  &amp;lt;delete id=&amp;quot;deleteByPrimaryKey&amp;quot; parameterType=&amp;quot;java.lang.Integer&amp;quot;&amp;gt;
    delete from users
    where userid = #{userid,jdbcType=INTEGER}
  &amp;lt;/delete&amp;gt;
  &amp;lt;delete id=&amp;quot;deleteByExample&amp;quot; parameterType=&amp;quot;com.cy.springbootmybatis.pojo.UsersExample&amp;quot;&amp;gt;
    delete from users
    &amp;lt;if test=&amp;quot;_parameter != null&amp;quot;&amp;gt;
      &amp;lt;include refid=&amp;quot;Example_Where_Clause&amp;quot; /&amp;gt;
    &amp;lt;/if&amp;gt;
  &amp;lt;/delete&amp;gt;
  &amp;lt;insert id=&amp;quot;insert&amp;quot; parameterType=&amp;quot;com.cy.springbootmybatis.pojo.Users&amp;quot;&amp;gt;
    insert into users (userid, username, usersex
      )
    values (#{userid,jdbcType=INTEGER}, #{username,jdbcType=VARCHAR}, #{usersex,jdbcType=VARCHAR}
      )
  &amp;lt;/insert&amp;gt;
  &amp;lt;insert id=&amp;quot;insertSelective&amp;quot; parameterType=&amp;quot;com.cy.springbootmybatis.pojo.Users&amp;quot;&amp;gt;
    insert into users
    &amp;lt;trim prefix=&amp;quot;(&amp;quot; suffix=&amp;quot;)&amp;quot; suffixOverrides=&amp;quot;,&amp;quot;&amp;gt;
      &amp;lt;if test=&amp;quot;userid != null&amp;quot;&amp;gt;
        userid,
      &amp;lt;/if&amp;gt;
      &amp;lt;if test=&amp;quot;username != null&amp;quot;&amp;gt;
        username,
      &amp;lt;/if&amp;gt;
      &amp;lt;if test=&amp;quot;usersex != null&amp;quot;&amp;gt;
        usersex,
      &amp;lt;/if&amp;gt;
    &amp;lt;/trim&amp;gt;
    &amp;lt;trim prefix=&amp;quot;values (&amp;quot; suffix=&amp;quot;)&amp;quot; suffixOverrides=&amp;quot;,&amp;quot;&amp;gt;
      &amp;lt;if test=&amp;quot;userid != null&amp;quot;&amp;gt;
        #{userid,jdbcType=INTEGER},
      &amp;lt;/if&amp;gt;
      &amp;lt;if test=&amp;quot;username != null&amp;quot;&amp;gt;
        #{username,jdbcType=VARCHAR},
      &amp;lt;/if&amp;gt;
      &amp;lt;if test=&amp;quot;usersex != null&amp;quot;&amp;gt;
        #{usersex,jdbcType=VARCHAR},
      &amp;lt;/if&amp;gt;
    &amp;lt;/trim&amp;gt;
  &amp;lt;/insert&amp;gt;
  &amp;lt;select id=&amp;quot;countByExample&amp;quot; parameterType=&amp;quot;com.cy.springbootmybatis.pojo.UsersExample&amp;quot; resultType=&amp;quot;java.lang.Long&amp;quot;&amp;gt;
    select count(*) from users
    &amp;lt;if test=&amp;quot;_parameter != null&amp;quot;&amp;gt;
      &amp;lt;include refid=&amp;quot;Example_Where_Clause&amp;quot; /&amp;gt;
    &amp;lt;/if&amp;gt;
  &amp;lt;/select&amp;gt;
  &amp;lt;update id=&amp;quot;updateByExampleSelective&amp;quot; parameterType=&amp;quot;map&amp;quot;&amp;gt;
    update users
    &amp;lt;set&amp;gt;
      &amp;lt;if test=&amp;quot;record.userid != null&amp;quot;&amp;gt;
        userid = #{record.userid,jdbcType=INTEGER},
      &amp;lt;/if&amp;gt;
      &amp;lt;if test=&amp;quot;record.username != null&amp;quot;&amp;gt;
        username = #{record.username,jdbcType=VARCHAR},
      &amp;lt;/if&amp;gt;
      &amp;lt;if test=&amp;quot;record.usersex != null&amp;quot;&amp;gt;
        usersex = #{record.usersex,jdbcType=VARCHAR},
      &amp;lt;/if&amp;gt;
    &amp;lt;/set&amp;gt;
    &amp;lt;if test=&amp;quot;_parameter != null&amp;quot;&amp;gt;
      &amp;lt;include refid=&amp;quot;Update_By_Example_Where_Clause&amp;quot; /&amp;gt;
    &amp;lt;/if&amp;gt;
  &amp;lt;/update&amp;gt;
  &amp;lt;update id=&amp;quot;updateByExample&amp;quot; parameterType=&amp;quot;map&amp;quot;&amp;gt;
    update users
    set userid = #{record.userid,jdbcType=INTEGER},
      username = #{record.username,jdbcType=VARCHAR},
      usersex = #{record.usersex,jdbcType=VARCHAR}
    &amp;lt;if test=&amp;quot;_parameter != null&amp;quot;&amp;gt;
      &amp;lt;include refid=&amp;quot;Update_By_Example_Where_Clause&amp;quot; /&amp;gt;
    &amp;lt;/if&amp;gt;
  &amp;lt;/update&amp;gt;
  &amp;lt;update id=&amp;quot;updateByPrimaryKeySelective&amp;quot; parameterType=&amp;quot;com.cy.springbootmybatis.pojo.Users&amp;quot;&amp;gt;
    update users
    &amp;lt;set&amp;gt;
      &amp;lt;if test=&amp;quot;username != null&amp;quot;&amp;gt;
        username = #{username,jdbcType=VARCHAR},
      &amp;lt;/if&amp;gt;
      &amp;lt;if test=&amp;quot;usersex != null&amp;quot;&amp;gt;
        usersex = #{usersex,jdbcType=VARCHAR},
      &amp;lt;/if&amp;gt;
    &amp;lt;/set&amp;gt;
    where userid = #{userid,jdbcType=INTEGER}
  &amp;lt;/update&amp;gt;
  &amp;lt;update id=&amp;quot;updateByPrimaryKey&amp;quot; parameterType=&amp;quot;com.cy.springbootmybatis.pojo.Users&amp;quot;&amp;gt;
    update users
    set username = #{username,jdbcType=VARCHAR},
      usersex = #{usersex,jdbcType=VARCHAR}
    where userid = #{userid,jdbcType=INTEGER}
  &amp;lt;/update&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;UsersMapper接口:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface UsersMapper {
    long countByExample(UsersExample example);

    int deleteByExample(UsersExample example);

    int deleteByPrimaryKey(Integer userid);

    int insert(Users record);

    int insertSelective(Users record);

    List&amp;lt;Users&amp;gt; selectByExample(UsersExample example);

    Users selectByPrimaryKey(Integer userid);

    int updateByExampleSelective(@Param(&amp;quot;record&amp;quot;) Users record, @Param(&amp;quot;example&amp;quot;) UsersExample example);

    int updateByExample(@Param(&amp;quot;record&amp;quot;) Users record, @Param(&amp;quot;example&amp;quot;) UsersExample example);

    int updateByPrimaryKeySelective(Users record);

    int updateByPrimaryKey(Users record);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;10-springboot-中异常处理与单元测试&#34;&gt;10、 SpringBoot 中异常处理与单元测试&lt;/h2&gt;
&lt;h3 id=&#34;101-异常处理&#34;&gt;10.1 异常处理&lt;/h3&gt;
&lt;p&gt;SpringBoot 中对于异常处理提供了五种处理方式&lt;/p&gt;
&lt;h4 id=&#34;1011-自定义错误页面&#34;&gt;10.1.1 自定义错误页面&lt;/h4&gt;
&lt;p&gt;SpringBoot 默认的处理异常的机制：SpringBoot 默认的已经提供了一套处理异常的机制。一旦程序中出现了异常 SpringBoot 会向/error 的 url 发送请求。在 SpringBoot 中提供了一个名为 BasicErrorController 来处理/error 请求，然后跳转到默认显示异常的页面来展示异常信息。&lt;br&gt;
如 果 我 们 需 要 将 所 有 的 异 常 同 一 跳 转 到 自 定 义 的 错 误 页 面 ， 需 要 再src/main/resources/templates 目录下创建 error.html 页面。注意：页面名称必须叫 error&lt;/p&gt;
&lt;h4 id=&#34;1012-通过exceptionhandler-注解处理异常&#34;&gt;10.1.2 通过@ExceptionHandler 注解处理异常&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;修改 Controller&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Controller
public class UsersController {
    @RequestMapping(&amp;quot;showInfo&amp;quot;)
    public String showInfo() {
        String str = null;
        str.length();
        return &amp;quot;ok&amp;quot;;
    }

    @ExceptionHandler(value = {java.lang.NullPointerException.class})
    public ModelAndView nullpointExcepitonHandler(Exception e) {
        ModelAndView mv = new ModelAndView();
        mv.addObject(&amp;quot;err&amp;quot;, e.toString());
        mv.setViewName(&amp;quot;error1&amp;quot;);
        return mv;
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;创建页面&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE HTML PUBLIC &amp;quot;-//W3C//DTD HTML 4.01
Transitional//EN&amp;quot;
&amp;quot;http://www.w3.org/TR/html4/loose.dtd&amp;quot;&amp;gt;
&amp;lt;html xmlns:th=&amp;quot;http://www.thymeleaf.org&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;title&amp;gt;error1&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
出错了。。。
&amp;lt;span th:text=&amp;quot;${err}&amp;quot;/&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;1013-通过controlleradvice-与exceptionhandler-注解处理异常&#34;&gt;10.1.3 通过@ControllerAdvice 与@ExceptionHandler 注解处理异常&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建全局异常处理类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 全局异常处理类
 */
@ControllerAdvice
public class GlobalException {
    @ExceptionHandler(value = {java.lang.NullPointerException.class} )
    public ModelAndView nullpointExcepitonHandler(Exception e){
        ModelAndView mv = new ModelAndView();
        mv.addObject(&amp;quot;err&amp;quot;,e.toString());
        mv.setViewName(&amp;quot;error1&amp;quot;);
        return mv;

    }
    @ExceptionHandler(value = {java.lang.ArithmeticException.class} )
    public ModelAndView arithmeticExceptionHandler(Exception e){
        ModelAndView mv = new ModelAndView();
        mv.addObject(&amp;quot;err&amp;quot;, e.toString());
        mv.setViewName(&amp;quot;error2&amp;quot;);
        return mv;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;1014-通过-simplemappingexceptionresolver-对象处理异常&#34;&gt;10.1.4 通过 SimpleMappingExceptionResolver 对象处理异常&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建全局异常处理类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class GlobalException2 {

    /**
     * 此方法返回值必须是 SimpleMappingExceptionResolver 对象
     * @return
     */
    @Bean
    public SimpleMappingExceptionResolver getSimpleMappingExceptionResolver() {
        SimpleMappingExceptionResolver resolver = new SimpleMappingExceptionResolver();
        Properties properties = new Properties();
    /**
    * 参数一：异常类型，并且是全名
    * 参数二：视图名称
    */
        properties.put(&amp;quot;java.lang.NullPointerException&amp;quot;, &amp;quot;error3&amp;quot;);
        properties.put(&amp;quot;java.lang.ArithmeticException&amp;quot;, &amp;quot;error4&amp;quot;);

        resolver.setExceptionMappings(properties);
        return resolver;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;缺点：不能传递异常信息&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;1015-通过自定义-handlerexceptionresolver-对象处理异常推荐&#34;&gt;10.1.5 通过自定义 HandlerExceptionResolver 对象处理异常（推荐）&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建全局异常处理类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 自定义 HandlerExceptionResolver 对象处理异常
 * 必须要实现 HandlerExceptionResolver
 */
@Configuration
public class GlobalException3 implements HandlerExceptionResolver {
    @Override
    public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object handler, Exception e) {
        ModelAndView mv = new ModelAndView();
        //判断不同异常类型，做不同视图的跳转
        if (e instanceof NullPointerException) {
            mv.setViewName(&amp;quot;error5&amp;quot;);
        }
        if (e instanceof ArithmeticException) {
            mv.setViewName(&amp;quot;error6&amp;quot;);
        }
        mv.addObject(&amp;quot;error&amp;quot;, e.toString());
        return mv;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;102-spring-boot-整合-junit-单元测试&#34;&gt;10.2 Spring Boot 整合 Junit 单元测试&lt;/h3&gt;
&lt;p&gt;SpringBoot2.x 使用 Junit5 作为测试平台&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;修改 POM 文件添加 Test 启动器&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
	&amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
	&amp;lt;!--junit-vintage-engine 提供了 Junit3 与 Junit4 的运行平台--&amp;gt;
	&amp;lt;exclusions&amp;gt;
		&amp;lt;exclusion&amp;gt;
			&amp;lt;groupId&amp;gt;org.junit.vintage&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;junit-vintage-engine&amp;lt;/artifactId&amp;gt;
		&amp;lt;/exclusion&amp;gt;
	&amp;lt;/exclusions&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编写测试代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SpringBootTest
class SpringbootexcepionandjunitApplicationTests {
	@Autowired
	private UsersServiceImpl usersService;
	@Test
	void suibian() {
		this.usersService.addUser();
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;11-spring-boot-服务端数据校验&#34;&gt;11、 Spring Boot 服务端数据校验&lt;/h2&gt;
&lt;h3 id=&#34;111-spring-boot-对实体对象的校验&#34;&gt;11.1 Spring Boot 对实体对象的校验&lt;/h3&gt;
&lt;h4 id=&#34;1111-搭建项目环境&#34;&gt;11.1.1 搭建项目环境&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建项目&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;33&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200622113358.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建实体&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
public class Users {
    private  Integer userid;
    private String username;
    private String usersex;

    public Integer getUserid() {
        return userid;
    }

    public void setUserid(Integer userid) {
        this.userid = userid;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getUsersex() {
        return usersex;
    }

    public void setUsersex(String usersex) {
        this.usersex = usersex;
    }

    @Override
    public String toString() {
        return &amp;quot;Users{&amp;quot; +
                &amp;quot;userid=&amp;quot; + userid +
                &amp;quot;, username=&#39;&amp;quot; + username + &#39;\&#39;&#39; +
                &amp;quot;, usersex=&#39;&amp;quot; + usersex + &#39;\&#39;&#39; +
                &#39;}&#39;;
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建Controller&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Controller
@RequestMapping(&amp;quot;/user&amp;quot;)
public class UsersController {
	/**
	* 添加用户
	*/
	@RequestMapping(&amp;quot;/addUser&amp;quot;)
	public String addUser(Users users){
		System.out.println(users);
		return &amp;quot;ok&amp;quot;;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建页面&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE HTML PUBLIC &amp;quot;-//W3C//DTD HTML 4.01 Transitional//EN&amp;quot;
        &amp;quot;http://www.w3.org/TR/html4/loose.dtd&amp;quot;&amp;gt;
&amp;lt;html xmlns:th=&amp;quot;http://www.thymeleaf.org&amp;quot;&amp;gt;
&amp;lt;link rel=&amp;quot;shortcut icon&amp;quot; href=&amp;quot;../resources/favicon.ico&amp;quot; th:href=&amp;quot;@{/static/favicon.ico}&amp;quot;/&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;addUser&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

    &amp;lt;form th:action=&amp;quot;@{/user/addUser}&amp;quot; method=&amp;quot;post&amp;quot;&amp;gt;
        &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;username&amp;quot;&amp;gt;&amp;lt;br/&amp;gt;
        &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;usersex&amp;quot;&amp;gt;&amp;lt;br/&amp;gt;
        &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;OK&amp;quot;/&amp;gt;
    &amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;1112-对实体对象做数据校验&#34;&gt;11.1.2 对实体对象做数据校验&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Spring Boot 数据校验的技术特点&lt;/p&gt;
&lt;p&gt;Spring Boot 中使用了 Hibernate-validator 校验框架。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对实体对象数据校验步骤&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;修改实体类添加校验规则&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import org.hibernate.validator.constraints.Length;

import javax.validation.constraints.NotBlank;
import javax.validation.constraints.NotEmpty;
import javax.validation.constraints.NotNull;

/**
 * 以下注解是javax包下的
 * @NotNull: 对基本数据类型的对象类型做非空校验
 * @NotBlank：对字符串类型做非空校验
 * @NotEmpty：对集合类型做非空校验
 */
public class Users {
    @NotNull
    private  Integer userid;
    @NotBlank
    private String username;
    @NotBlank
    private String usersex;

    public Integer getUserid() {
        return userid;
    }

    public void setUserid(Integer userid) {
        this.userid = userid;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getUsersex() {
        return usersex;
    }

    public void setUsersex(String usersex) {
        this.usersex = usersex;
    }

    @Override
    public String toString() {
        return &amp;quot;Users{&amp;quot; +
                &amp;quot;userid=&amp;quot; + userid +
                &amp;quot;, username=&#39;&amp;quot; + username + &#39;\&#39;&#39; +
                &amp;quot;, usersex=&#39;&amp;quot; + usersex + &#39;\&#39;&#39; +
                &#39;}&#39;;
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;在 Controller 中开启校验&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Controller
@RequestMapping(&amp;quot;/user&amp;quot;)
public class UsersController {

    /**
     * 添加用户
     */
    @RequestMapping(&amp;quot;/addUser&amp;quot;)
    public String addUser(@Validated Users users, BindingResult result){
        if(result.hasErrors()){
            /*List&amp;lt;ObjectError&amp;gt; list = result.getAllErrors();
            for(ObjectError err:list){
                FieldError fieldError = (FieldError) err;
                String fieldName = fieldError.getField();
                String msg = fieldError.getDefaultMessage();
                System.out.println(fieldName+&amp;quot;\t&amp;quot;+msg);
            } 平时不需要 */
            return &amp;quot;addUser&amp;quot;;
        }
        System.out.println(users);
        return &amp;quot;ok&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;在页面中获取提示信息&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE HTML PUBLIC &amp;quot;-//W3C//DTD HTML 4.01 Transitional//EN&amp;quot;
        &amp;quot;http://www.w3.org/TR/html4/loose.dtd&amp;quot;&amp;gt;
&amp;lt;html xmlns:th=&amp;quot;http://www.thymeleaf.org&amp;quot;&amp;gt;
&amp;lt;link rel=&amp;quot;shortcut icon&amp;quot; href=&amp;quot;../resources/favicon.ico&amp;quot; th:href=&amp;quot;@{/static/favicon.ico}&amp;quot;/&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;addUser&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

    &amp;lt;form th:action=&amp;quot;@{/user/addUser}&amp;quot; method=&amp;quot;post&amp;quot;&amp;gt;
        &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;username&amp;quot;&amp;gt;&amp;lt;font color=&amp;quot;red&amp;quot;&amp;gt;&amp;lt;span th:errors=&amp;quot;${Users.username}&amp;quot;/&amp;gt;&amp;lt;/font&amp;gt;&amp;lt;br/&amp;gt;
        &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;usersex&amp;quot;&amp;gt;&amp;lt;font color=&amp;quot;red&amp;quot;&amp;gt;&amp;lt;span th:errors=&amp;quot;${Users.usersex}&amp;quot;/&amp;gt;&amp;lt;/font&amp;gt;&amp;lt;br/&amp;gt;
        &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;OK&amp;quot;/&amp;gt;
    &amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;自定义错误提示信息&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在注解中定义提示信息&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@NotNull(message = &amp;quot;用户 ID 不能为空&amp;quot;)
private Integer userid;
@NotBlank(message = &amp;quot;用户姓名不能为空&amp;quot;)
private String username;
@NotBlank(message = &amp;quot;用户性别不能为空&amp;quot;)
private String usersex;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在配置文件中定义提示信息&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	@NotNull(message =&amp;quot;{userid.notnull}&amp;quot; )
    private  Integer userid;
    @NotBlank(message = &amp;quot;{username.notnull}&amp;quot;)
    private String username;
    @NotBlank(message = &amp;quot;{usersex.notnull}&amp;quot;)
    private String usersex;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置文件名必须是 ValidationMessages.properties&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;userid.notnull=\u7528\u6237Id\u4e0d\u80fd\u4e3a\u7a7a-pro
username.notnull=\u7528\u6237\u59d3\u540d\u4e0d\u80fd\u4e3a\u7a7a-pro
usersex.notnull=\u7528\u6237\u6027\u522b\u4e0d\u80fd\u4e3a\u7a7a-pro
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解决页面跳转异常&lt;/p&gt;
&lt;p&gt;​		在跳转页面的方法中注入一个对象，要求参数对象的变量名必须是对象类型名称首字母小写格式。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Controller
public class PageController {

    /**
     * 跳转页面方法
     *解决异常的方式：可以在跳转页面的方法中注入一个Users对象
     * 由于SprignMVC会将该对象放入到Model中传递，key的名称会使用该对象
     * 的驼峰命名规则来作为key
     */
    @RequestMapping(&amp;quot;/{page}&amp;quot;)
    public String showPage(@PathVariable String page, Users suibian){
        return page;
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE HTML PUBLIC &amp;quot;-//W3C//DTD HTML 4.01 Transitional//EN&amp;quot;
        &amp;quot;http://www.w3.org/TR/html4/loose.dtd&amp;quot;&amp;gt;
&amp;lt;html xmlns:th=&amp;quot;http://www.thymeleaf.org&amp;quot;&amp;gt;
&amp;lt;link rel=&amp;quot;shortcut icon&amp;quot; href=&amp;quot;../resources/favicon.ico&amp;quot; th:href=&amp;quot;@{/static/favicon.ico}&amp;quot;/&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;addUser&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

    &amp;lt;form th:action=&amp;quot;@{/user/addUser}&amp;quot; method=&amp;quot;post&amp;quot;&amp;gt;
        &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;username&amp;quot;&amp;gt;&amp;lt;font color=&amp;quot;red&amp;quot;&amp;gt;&amp;lt;span th:errors=&amp;quot;${users.username}&amp;quot;/&amp;gt;&amp;lt;/font&amp;gt;&amp;lt;br/&amp;gt;
        &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;usersex&amp;quot;&amp;gt;&amp;lt;font color=&amp;quot;red&amp;quot;&amp;gt;&amp;lt;span th:errors=&amp;quot;${users.usersex}&amp;quot;/&amp;gt;&amp;lt;/font&amp;gt;&amp;lt;br/&amp;gt;
        &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;OK&amp;quot;/&amp;gt;
    &amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;
&lt;p&gt;修改参数 key 的名称&lt;/p&gt;
&lt;p&gt;PageController:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Controller
public class PageController {

    /**
     * 跳转页面方法
     *解决异常的方式：可以在跳转页面的方法中注入一个Users对象
     * 由于SprignMVC会将该对象放入到Model中传递，key的名称会使用该对象
     * 的驼峰命名规则来作为key
     * @ModelAttribute的作用是来指定当前做数据传递时SpringMVC放到Model中的key是什么
     */
    @RequestMapping(&amp;quot;/{page}&amp;quot;)
    public String showPage(@PathVariable String page, @ModelAttribute(&amp;quot;aa&amp;quot;) Users suibian){
        return page;
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	UsersController:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Controller
@RequestMapping(&amp;quot;/user&amp;quot;)
public class UsersController {

    /**
     * 添加用户
     */
    @RequestMapping(&amp;quot;/addUser&amp;quot;)
    public String addUser(@ModelAttribute(&amp;quot;aa&amp;quot;)@Validated Users users, BindingResult result){
        if(result.hasErrors()){
            List&amp;lt;ObjectError&amp;gt; list = result.getAllErrors();
            for(ObjectError err:list){
                FieldError fieldError = (FieldError) err;
                String fieldName = fieldError.getField();
                String msg = fieldError.getDefaultMessage();
                System.out.println(fieldName+&amp;quot;\t&amp;quot;+msg);
            }
            return &amp;quot;addUser&amp;quot;;
        }
        System.out.println(users);
        return &amp;quot;ok&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE HTML PUBLIC &amp;quot;-//W3C//DTD HTML 4.01 Transitional//EN&amp;quot;
        &amp;quot;http://www.w3.org/TR/html4/loose.dtd&amp;quot;&amp;gt;
&amp;lt;html xmlns:th=&amp;quot;http://www.thymeleaf.org&amp;quot;&amp;gt;
&amp;lt;link rel=&amp;quot;shortcut icon&amp;quot; href=&amp;quot;../resources/favicon.ico&amp;quot; th:href=&amp;quot;@{/static/favicon.ico}&amp;quot;/&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;addUser&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;!--th:errors取自BindingResult--&amp;gt;
    &amp;lt;form th:action=&amp;quot;@{/user/addUser}&amp;quot; method=&amp;quot;post&amp;quot;&amp;gt;
        &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;username&amp;quot;&amp;gt;&amp;lt;font color=&amp;quot;red&amp;quot;&amp;gt;&amp;lt;span th:errors=&amp;quot;${aa.username}&amp;quot;/&amp;gt;&amp;lt;/font&amp;gt;&amp;lt;br/&amp;gt;
        &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;usersex&amp;quot;&amp;gt;&amp;lt;font color=&amp;quot;red&amp;quot;&amp;gt;&amp;lt;span th:errors=&amp;quot;${aa.usersex}&amp;quot;/&amp;gt;&amp;lt;/font&amp;gt;&amp;lt;br/&amp;gt;
        &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;OK&amp;quot;/&amp;gt;
    &amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;
&lt;p&gt;其他校验规则&lt;/p&gt;
&lt;p&gt;@NotNull: 判断基本数据类型的对象类型是否为 null&lt;br&gt;
@NotBlank: 判断字符串是否为 null 或者是空串(去掉首尾空格)。&lt;br&gt;
@NotEmpty: 判断集合是否为空。&lt;br&gt;
@Length: 判断字符的长度(最大或者最小)&lt;br&gt;
@Min: 判断数值最小值&lt;br&gt;
@Max: 判断数值最大值&lt;br&gt;
@Email: 判断邮箱是否合法&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;112-spring-boot-对-controller-中其他参数的校验&#34;&gt;11.2  Spring Boot 对 Controller 中其他参数的校验&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;编写页面&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE HTML PUBLIC &amp;quot;-//W3C//DTD HTML 4.01 Transitional//EN&amp;quot;
        &amp;quot;http://www.w3.org/TR/html4/loose.dtd&amp;quot;&amp;gt;
&amp;lt;html xmlns:th=&amp;quot;http://www.thymeleaf.org&amp;quot;&amp;gt;
&amp;lt;link rel=&amp;quot;shortcut icon&amp;quot; href=&amp;quot;../resources/favicon.ico&amp;quot; th:href=&amp;quot;@{/static/favicon.ico}&amp;quot;/&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;findUser&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
这是一个查询页面
&amp;lt;form th:action=&amp;quot;@{/user/findUser}&amp;quot; method=&amp;quot;post&amp;quot;&amp;gt;
    &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;username&amp;quot;&amp;gt;&amp;lt;font color=&amp;quot;red&amp;quot;&amp;gt;&amp;lt;span th:text=&amp;quot;${error}&amp;quot;/&amp;gt;&amp;lt;/font&amp;gt;&amp;lt;br/&amp;gt;
    &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;OK&amp;quot;/&amp;gt;
&amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;对参数指定校验规则&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@PostMapping(&amp;quot;/findUser&amp;quot;)
public String findUser(@NotBlank(message = &amp;quot;用户名不能为空&amp;quot;) String username){
	System.out.println(username);
	return &amp;quot;ok&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;在 Controller 中开启校验&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Controller
@RequestMapping(&amp;quot;/user&amp;quot;)
@Validated
public class UsersController {

    @PostMapping(&amp;quot;/findUser&amp;quot;)
    public String findUser(@NotBlank(message = &amp;quot;用户名不能为空&amp;quot;) String username){
        System.out.println(username);
        return &amp;quot;ok&amp;quot;;
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;通过全局异常处理来跳转页面&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class GlobalException implements HandlerExceptionResolver {
    @Override
    public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object handler, Exception e) {
        ModelAndView mv = new ModelAndView();
        //判断不同异常类型，做不同视图的跳转
        if(e instanceof NullPointerException){
            mv.setViewName(&amp;quot;error5&amp;quot;);
        }
        if(e instanceof ArithmeticException){
            mv.setViewName(&amp;quot;error6&amp;quot;);
        }
        if(e instanceof ConstraintViolationException){
            mv.setViewName(&amp;quot;findUser&amp;quot;);
        }
        mv.addObject(&amp;quot;error&amp;quot;,e.getMessage().split(&amp;quot;:&amp;quot;)[1]);
        return mv;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;12-spring-boot-热部署&#34;&gt;12、Spring Boot 热部署&lt;/h2&gt;
&lt;p&gt;通过 DevTools 工具实现热部署：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;修改 POM 文件，添加 DevTools 依赖&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;spring-boot-devtools&amp;lt;/artifactId&amp;gt;
	&amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置 Idea&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;设置自动编译&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;34&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200622134350.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置 Idea 的 Registry&lt;/p&gt;
&lt;p&gt;通过快捷键打开该设置项：Ctrl+Shift+Alt+/&lt;br&gt;
勾选 complier.automake.allow.when.app.running&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;35&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200622134732.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;13-spring-boot-度量指标监控与健康检查&#34;&gt;13、Spring Boot 度量指标监控与健康检查&lt;/h2&gt;
&lt;h3 id=&#34;131-使用-actuator-检查与监控&#34;&gt;13.1 使用 Actuator 检查与监控&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;创建项目&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;36&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200622144536.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;需改 POM 文件，添加依赖&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--Actuator 坐标依赖--&amp;gt;
&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;修改配置文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;#配置访问端点的根路径
management.endpoints.web.base-path=/actuator

#配置开启其他端点的 URI
#开启所有的端点访问：*
#指定开启端点访问：如：beans,env
management.endpoints.web.exposure.include=*
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;各项监控指标接口 URL 介绍&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;37&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200622144724.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;38&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200622144737.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;39&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200622144748.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;40&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200622144756.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;132-使用可视化监控应用-spring-boot-admin&#34;&gt;13.2 使用可视化监控应用 Spring Boot Admin&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;使用步骤:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Spring Boot Admin 的使用是需要建立服务端与客户端。&lt;br&gt;
服务端：独立的项目，会将搜集到的数据在自己的图形界面中展示。&lt;br&gt;
客户端：需要监控的项目。&lt;br&gt;
对应关系：一个服务端可以监控多个客户端。&lt;/p&gt;
&lt;h4 id=&#34;1321-搭建服务端&#34;&gt;13.2.1 搭建服务端&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建项目&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;41&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200622145305.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 POM 文件&lt;/p&gt;
&lt;p&gt;注意：目前在 Spring Boot Admin Starter Server2.1.6 版本中不支持 Spring Boot2.2.x 版本,只支持到 2.1.X&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--
https://mvnrepository.com/artifact/de.codecentric/spring-
boot-admin-starter-server --&amp;gt;
&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;de.codecentric&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;spring-boot-admin-starter-server&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;2.1.6&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;server.port=9090
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改启动类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SpringBootApplication
@EnableAdminServer //开启 Spring Boot Admin 服务端
public class SpringbootactuatorserverApplication {
	public static void main(String[] args) {
	SpringApplication.run(SpringbootactuatorserverApplication.class, args);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;1322-搭建客户端&#34;&gt;13.2.2 搭建客户端&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;修改POM文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--
https://mvnrepository.com/artifact/de.codecentric/spring-
boot-admin-starter-client --&amp;gt;
&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;de.codecentric&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;spring-boot-admin-starter-client&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;2.1.6&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;修改配置文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;#配置访问端点的根路径
management.endpoints.web.base-path=/actuator

#配置开启其他端点的 URI
#开启所有的端点访问：*
#指定开启端点访问：如：beans,env
#这里暴露的会在服务端显示
management.endpoints.web.exposure.include=*

#指定服务端的访问地址
spring.boot.admin.client.url=http://localhost:9090
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;效果图&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;42&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200622150615.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;14-spring-boot-的日志管理&#34;&gt;14、Spring Boot 的日志管理&lt;/h2&gt;
&lt;p&gt;​		Spring Boot 默认使用 Logback 组件作为日志管理。Logback 是由 log4j 创始人设计的一个开源日志组件。&lt;br&gt;
​		在 Spring Boot 项目中我们不需要额外的添加 Logback 的依赖，因为在 spring-boot-starter或者 spring-boot-starter-web 中已经包含了 Logback 的依赖。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Logback 读取配置文件的步骤&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;（1）在 classpath 下查找文件 logback-test.xml&lt;br&gt;
（2）如果文件不存在，则查找 logback.xml&lt;br&gt;
（3）如果两个文件都不存在，LogBack 用 BasicConfiguration 自动对自己进行最小化配置，这样既实现了上面我们不需要添加任何配置就可以输出到控制台日志信息。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;添加 Logback 配置文件&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;43&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200622160355.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;Logback配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
 &amp;lt;configuration&amp;gt;
&amp;lt;!--定义日志文件的存储地址 勿在 LogBack 的配置中使用相对路径--&amp;gt;  
    &amp;lt;property name=&amp;quot;LOG_HOME&amp;quot; value=&amp;quot;${catalina.base}/logs/&amp;quot; /&amp;gt;  
    &amp;lt;!-- 控制台输出 --&amp;gt;   
    &amp;lt;appender name=&amp;quot;Stdout&amp;quot; class=&amp;quot;ch.qos.logback.core.ConsoleAppender&amp;quot;&amp;gt;
       &amp;lt;!-- 日志输出编码 --&amp;gt;  
        &amp;lt;layout class=&amp;quot;ch.qos.logback.classic.PatternLayout&amp;quot;&amp;gt;   
             &amp;lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&amp;gt; 
            &amp;lt;pattern&amp;gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n   
            &amp;lt;/pattern&amp;gt;   
        &amp;lt;/layout&amp;gt;   
    &amp;lt;/appender&amp;gt;   
    &amp;lt;!-- 按照每天生成日志文件 --&amp;gt;   
    &amp;lt;appender name=&amp;quot;RollingFile&amp;quot;  class=&amp;quot;ch.qos.logback.core.rolling.RollingFileAppender&amp;quot;&amp;gt;   
        &amp;lt;rollingPolicy class=&amp;quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&amp;quot;&amp;gt;
            &amp;lt;!--日志文件输出的文件名--&amp;gt;
            &amp;lt;FileNamePattern&amp;gt;${LOG_HOME}/server.%d{yyyy-MM-dd}.log&amp;lt;/FileNamePattern&amp;gt;   
            &amp;lt;MaxHistory&amp;gt;30&amp;lt;/MaxHistory&amp;gt;
        &amp;lt;/rollingPolicy&amp;gt;   
        &amp;lt;layout class=&amp;quot;ch.qos.logback.classic.PatternLayout&amp;quot;&amp;gt;  
            &amp;lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&amp;gt; 
            &amp;lt;pattern&amp;gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n   
            &amp;lt;/pattern&amp;gt;   
       &amp;lt;/layout&amp;gt; 
        &amp;lt;!--日志文件最大的大小--&amp;gt;
       &amp;lt;triggeringPolicy class=&amp;quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&amp;quot;&amp;gt;
         &amp;lt;MaxFileSize&amp;gt;10MB&amp;lt;/MaxFileSize&amp;gt;
       &amp;lt;/triggeringPolicy&amp;gt;
    &amp;lt;/appender&amp;gt;     

    &amp;lt;!-- 日志输出级别 --&amp;gt;
    &amp;lt;root level=&amp;quot;info&amp;quot;&amp;gt;   
        &amp;lt;appender-ref ref=&amp;quot;Stdout&amp;quot; /&amp;gt;   
        &amp;lt;appender-ref ref=&amp;quot;RollingFile&amp;quot; /&amp;gt;   
    &amp;lt;/root&amp;gt; 



&amp;lt;!--日志异步到数据库 --&amp;gt;  
&amp;lt;!--     &amp;lt;appender name=&amp;quot;DB&amp;quot; class=&amp;quot;ch.qos.logback.classic.db.DBAppender&amp;quot;&amp;gt;
        日志异步到数据库 
        &amp;lt;connectionSource class=&amp;quot;ch.qos.logback.core.db.DriverManagerConnectionSource&amp;quot;&amp;gt;
           连接池 
           &amp;lt;dataSource class=&amp;quot;com.mchange.v2.c3p0.ComboPooledDataSource&amp;quot;&amp;gt;
              &amp;lt;driverClass&amp;gt;com.mysql.jdbc.Driver&amp;lt;/driverClass&amp;gt;
              &amp;lt;url&amp;gt;jdbc:mysql://127.0.0.1:3306/databaseName&amp;lt;/url&amp;gt;
              &amp;lt;user&amp;gt;root&amp;lt;/user&amp;gt;
              &amp;lt;password&amp;gt;root&amp;lt;/password&amp;gt;
            &amp;lt;/dataSource&amp;gt;
        &amp;lt;/connectionSource&amp;gt;
  &amp;lt;/appender&amp;gt; --&amp;gt;

&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在代码中使用 Logback&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@RequestMapping(&amp;quot;/logback&amp;quot;)
public class HelloController {

    private final static Logger logger = LoggerFactory.getLogger(HelloController.class);

    @RequestMapping(&amp;quot;/showInfo&amp;quot;)
    public String showInfo(){
        logger.info(&amp;quot;记录日志&amp;quot;);
        return &amp;quot;Hello Logback &amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;44&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200622161037.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;
&lt;p&gt;在配置文件中屏蔽指定包的日志记录&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;#屏蔽指定包中的日志输出 logging.level.包名=off
logging.level.org=off
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;45&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200622161416.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;15-spring-boot-项目打包与多环境配置&#34;&gt;15、Spring Boot 项目打包与多环境配置&lt;/h2&gt;
&lt;h3 id=&#34;151-spring-boot-项目打包&#34;&gt;15.1 Spring Boot 项目打包&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Spring Boot 的打包插件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;build&amp;gt;
	&amp;lt;plugins&amp;gt;
		&amp;lt;plugin&amp;gt;
			&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;spring-boot-maven-lugin&amp;lt;/artifactId&amp;gt;
		&amp;lt;/plugin&amp;gt;
	&amp;lt;/plugins&amp;gt;
&amp;lt;/build&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;项目打包方式&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;46&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200622162322.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;运行命令&lt;/p&gt;
&lt;p&gt;注意：需要正确的配置环境变量。&lt;br&gt;
运行命令：java -jar 项目的名称&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;152-spring-boot-的多环境配置&#34;&gt;15.2 Spring Boot 的多环境配置&lt;/h3&gt;
&lt;p&gt;语法结构：application-{profile}.properties/yml&lt;br&gt;
profile：代表某个配置环境的标识&lt;/p&gt;
&lt;p&gt;示例：application-dev.properties/yml 开发环境&lt;br&gt;
application-test.properties/yml 测试环境&lt;br&gt;
application-prod.properties/yml 生产环境&lt;/p&gt;
&lt;h4 id=&#34;1521-windows-环境下启动方式&#34;&gt;15.2.1 Windows 环境下启动方式&lt;/h4&gt;
&lt;p&gt;​	java -jar xxx.jar --spring.profiles.active={profile}&lt;/p&gt;
&lt;h4 id=&#34;1522-在-linux-环境下启动方式&#34;&gt;15.2.2 在 Linux 环境下启动方式&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安装上传下载工具&lt;/p&gt;
&lt;p&gt;安装命令：yum install lrzsz -y&lt;br&gt;
上传命令：rz&lt;br&gt;
下载命令：sz 下载文件名&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动脚本的使用&lt;/p&gt;
&lt;p&gt;修改脚本文件中的参数值&lt;br&gt;
将启动脚本文件（sever.sh）上传到 Linux 中&lt;br&gt;
分配执行权限：chmod 777&lt;br&gt;
通过脚本启动命令：server.sh start&lt;br&gt;
通过脚本关闭命令：server.sh stop&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
">SpringBoot</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jonchan1013.github.io/post/spring/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200804155452.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;1-spring&#34;&gt;1、Spring&lt;/h2&gt;
&lt;h3 id=&#34;11-简介&#34;&gt;1.1 简介&lt;/h3&gt;
&lt;p&gt;Spring：春天—-&amp;gt;给软件行业带来了春天！&lt;br&gt;
2002，首次推出了Spring框架的雏形：interface21框架！&lt;br&gt;
Spring框架即以interface21框架为基础，经过重新设计，并不断丰富内涵，于2004年3月24日，发布了1.0正式版。&lt;br&gt;
Rod Johnson，Spring Framework创始人，著名作者。很难想象其学历，真的让好多人大吃一惊，他是悉尼大学的博士，然而他的专业不是计算机，而是音乐学。&lt;br&gt;
spring理念：使现有的技术更加容易使用，本身是一个大杂烩，整合了现有的技术框架。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;SSH：Struct2+Spring+Hibernate!&lt;br&gt;
SSM：SpringMVC+Spring+Mybatis!​&lt;br&gt;
官网：https://spring.io/projects/spring-framework#overview&lt;/p&gt;
&lt;p&gt;官方下载地址：https://repo.spring.io/release/org/springframework/spring/&lt;/p&gt;
&lt;p&gt;Github：https://github.com/spring-projects/spring-framework&lt;/p&gt;
&lt;p&gt;Maven仓库：导入webmvc包会自动导入相关依赖；jdbc用于和Mybatis整合。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;5.2.0.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-jdbc&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;5.2.0.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;12-优点&#34;&gt;1.2 优点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Spring是一个开源的免费的框架（容器）！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Spring是一个轻量级的、非入侵式的框架！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;控制反转（IOC）、面向切面编程（AOP）！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持事务的处理，对框架整合的支持！&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;&lt;strong&gt;总结一句话：Spring就是一个轻量级的控制反转（IOC）和面向切面编程的框架！&lt;/strong&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;13-组成&#34;&gt;1.3 组成&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200617110747.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式 .&lt;/p&gt;
&lt;p&gt;组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。每个模块的功能如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;核心容器&lt;/strong&gt;：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是BeanFactory，它是工厂模式的实现。BeanFactory 使用&lt;em&gt;控制反转&lt;/em&gt;（IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Spring 上下文&lt;/strong&gt;：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Spring AOP&lt;/strong&gt;：通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能 , 集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理任何支持 AOP的对象。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖组件，就可以将声明性事务管理集成到应用程序中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Spring DAO&lt;/strong&gt;：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Spring ORM&lt;/strong&gt;：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Spring Web 模块&lt;/strong&gt;：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Spring MVC 框架&lt;/strong&gt;：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;14-拓展&#34;&gt;1.4 拓展&lt;/h3&gt;
&lt;p&gt;在Spring的官网有这个介绍：现代化的java开发！说白了就是基于Spring的开发！&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200617111004.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;Spring Boot
&lt;ul&gt;
&lt;li&gt;一个快速开发的脚手架。&lt;/li&gt;
&lt;li&gt;基于Spring Boot可以快速的开发单个微服务。&lt;/li&gt;
&lt;li&gt;约定大于配置！&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Spring Cloud
&lt;ul&gt;
&lt;li&gt;SpringCloud是基于SpringBoot实现的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为现在大多数公司都在使用SpringBoot进行快速开发，学习SpringBoot的前提，需要完全掌握Spring以及SpringMVC！承上启下的作用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;弊端：发展了太久之后，违背了原来的理念！配置十分繁琐，人称：“配置地狱”。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-ioc理论推导&#34;&gt;2、IOC理论推导&lt;/h2&gt;
&lt;p&gt;1.UserDao接口&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.cy.dao;

public interface UserDao {
    public void getUser();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.UserDaoImpl实现类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.cy.dao;

public class UserDaoImpl implements UserDao{
    public void getUser() {
        System.out.println(&amp;quot;获取用户数据&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.UserService业务接口&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.cy.Service;

public interface UserService {
    public void getUser();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.UserServiceImpl业务实现类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.cy.Service;

import com.cy.dao.UserDao;
import com.cy.dao.UserDaoImpl;
import com.cy.dao.UserDaoMysqlImpl;

public class UserServiceImpl implements UserService {
    private UserDao userDao = new UserDaoImpl();


    public void getUser() {
        userDao.getUser();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试一下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void test(){
   UserService service = new UserServiceImpl();
   service.getUser();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么现在问题来了，如果用户想添加新的功能，那么我们只能从Service层Impl去修改代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UserServiceImpl implements UserService {
   private UserDao userDao = new UserDaoMySqlImpl();

   @Override
   public void getUser() {
       userDao.getUser();
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;假设如果我们还要新增一个功能的话，如&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.cy.dao;

public class UserDaoOracleImpl implements UserDao {
    public void getUser() {
        System.out.println(&amp;quot;Oracle获取数据&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;那么我们发现了一个很严重的问题，程序的耦合性太高了，牵一发而动全身。&lt;/li&gt;
&lt;li&gt;假设我们的这种需求非常大 , 这种方式就根本不适用了&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;那么我们如何解决呢？&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;22-推导结果&#34;&gt;2.2 推导结果&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;我们可以在需要用到它的地方，不去实现它，而是留出一个接口&lt;/li&gt;
&lt;li&gt;通过set方法区引用注入&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;修改过的UserServiceImpl.java&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UserServiceImpl implements UserService {
//    private UserDao userDao = new UserDaoImpl();

    private UserDao userDao;
    
	// 利用set实现
    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }

    public void getUser() {
        userDao.getUser();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;现在通过不一样的的方法去测试&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void test(){
   UserServiceImpl service = new UserServiceImpl();
   service.setUserDao( new UserDaoMySqlImpl() );
   service.getUser();
   //那我们现在又想用Oracle去实现呢
   service.setUserDao( new UserDaoOracleImpl() );
   service.getUser();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：这里已经发生了根本性的变化&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;以前所有的东西都是由程序去进行控制创建&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;而现在是由用户进行控制创建，把主动权交给了调用者，程序不要用管怎么创建对象。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;这种思想 , 从本质上解决了问题 , 我们程序员不再去管理对象的创建了 , 更多的去关注业务的实现 . 耦合性大大降低 . 这也就是IOC的原型 !&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200617140229.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200617140305.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;21-ioc本质&#34;&gt;2.1 IOC本质&lt;/h3&gt;
&lt;p&gt;**控制反转IOC（Inversion of Control），是一种设计思想，DI（依赖注入）是实现IOC的一种方法，**也有人认为DI是IoC的另一种说法。没有IoC的程序中，我们使用面向对象编程，对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200804143511.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;以上就是IOC带来的改变。&lt;/p&gt;
&lt;p&gt;同时，在Spring中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;IoC是Spring框架的核心内容&lt;/strong&gt;，使用多种方式完美的实现了IoC，可以使用XML配置，也可以使用注解，新版本的Spring也可以零配置实现IoC。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Spring容器在初始化的时候先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用时再去从IOC容器中读取需要的对象。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200804143612.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方式是依赖注入（Dependency Injection,DI）&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;3-hello-spring&#34;&gt;3、Hello Spring&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;导入Jar包&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
   &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt;
   &amp;lt;version&amp;gt;5.1.10.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;编写一个Hello实体类&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.cy.pojo;

public class Hello {
    private String str;

    public String getStr() {
        return str;
    }

    public void setStr(String str) {
        this.str = str;
    }

    @Override
    public String toString() {
        return &amp;quot;Hello{&amp;quot; +
                &amp;quot;str=&#39;&amp;quot; + str + &#39;\&#39;&#39; +
                &#39;}&#39;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;在resources/applicationContext.xml&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
       xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&amp;quot;&amp;gt;

&amp;lt;!--使用Spring来创建对象，在Spring中称为Bean--&amp;gt;
    &amp;lt;bean id=&amp;quot;hello&amp;quot; class=&amp;quot;com.cy.pojo.Hello&amp;quot;&amp;gt;
        &amp;lt;property name=&amp;quot;str&amp;quot; value=&amp;quot;Spring&amp;quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;

&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;测试&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import com.cy.pojo.Hello;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class MyTest {
    public static void main(String[] args) {
        // 获取Spring上下文对象！,现在所有对象都在Spring管理了
        ApplicationContext context = new ClassPathXmlApplicationContext(&amp;quot;applicationContext.xml&amp;quot;);

        Hello hello = (Hello) context.getBean(&amp;quot;hello&amp;quot;);
        System.out.println(hello.toString());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;31-思考问题&#34;&gt;3.1 思考问题？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Hello对象是谁创建的？&lt;/p&gt;
&lt;p&gt;hello对象是由Spring创建的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Hello对象的属性是怎么设置的？&lt;/p&gt;
&lt;p&gt;hello对象的属性是由Spring容器设置的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个过程就叫做控制反转：&lt;/p&gt;
&lt;p&gt;控制：谁来控制对象的创建，传统应用程序的对象是由程序本身控制创建的，使用Spring后，对象是由Spring来创建的。&lt;/p&gt;
&lt;p&gt;反转：程序本身不创建对象，而变成被动的接收对象。&lt;/p&gt;
&lt;p&gt;依赖注入：就是利用set方法来进行注入。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IoC是一种编程思想，由主动的编程编程被动的接收。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以通过new ClassPathXmlApplicationContext去浏览一下底层源码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OK，到了现在，我们彻底不用在程序中去改动了，要实现不同的操作，只需要在xml配置文件中进行修改，所谓的IoC，一句话搞定：对象由Spring来创建，管理，装配！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;IDEA快捷创建beans.xml文件，自动导入spring配置信息：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200617141027.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;4-ioc创建对象的方式&#34;&gt;4、IOC创建对象的方式&lt;/h2&gt;
&lt;h3 id=&#34;41-通过无参构造方法创建&#34;&gt;4.1 通过无参构造方法创建&lt;/h3&gt;
&lt;p&gt;使用无参构造创建对象，默认方式！&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;User.java&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.cy.pojo;

public class User {
    private String name;

    public User(){
        System.out.println(&amp;quot;进入了User的无参构造&amp;quot;);
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void show(){
        System.out.println(&amp;quot;name&amp;quot;+name);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;applicationContext.xml&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
       xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&amp;quot;&amp;gt;

    &amp;lt;bean id=&amp;quot;user&amp;quot; class=&amp;quot;com.cy.pojo.User&amp;quot;&amp;gt;
        &amp;lt;property name=&amp;quot;name&amp;quot; value=&amp;quot;朱酱酱&amp;quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;测试类&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import com.cy.pojo.User;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class MyTest {
    public static void main(String[] args) {
       ApplicationContext context = new ClassPathXmlApplicationContext(&amp;quot;applicationContext.xml&amp;quot;);

        User user = (User) context.getBean(&amp;quot;user&amp;quot;);
        user.show();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果可以发现，在调用show方法之前，&lt;strong&gt;User对象已经通过无参构造初始化了&lt;/strong&gt;！&lt;/p&gt;
&lt;h3 id=&#34;42-通过有参构造方法创建&#34;&gt;4.2 通过有参构造方法创建&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;UserT.java&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.cy.pojo;

public class UserT {

    private String name;

    // 有参构造
    public UserT(String name) {
        this.name = name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void show(){
        System.out.println(&amp;quot;name=&amp;quot;+ name );
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;有参构造的三种注入方式&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- 第一种根据index参数下标设置 --&amp;gt;
&amp;lt;bean id=&amp;quot;userT&amp;quot; class=&amp;quot;com.cy.pojo.UserT&amp;quot;&amp;gt;
   &amp;lt;!-- index指构造方法 , 下标从0开始 --&amp;gt;
   &amp;lt;constructor-arg index=&amp;quot;0&amp;quot; value=&amp;quot;朱酱酱2&amp;quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&amp;lt;!-- 第二种根据参数名字设置 --&amp;gt;
&amp;lt;bean id=&amp;quot;userT&amp;quot; class=&amp;quot;com.cy.pojo.UserT&amp;quot;&amp;gt;
   &amp;lt;!-- name指参数名 --&amp;gt;
   &amp;lt;constructor-arg name=&amp;quot;name&amp;quot; value=&amp;quot;朱酱酱2&amp;quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&amp;lt;!-- 第三种根据参数类型设置 --&amp;gt;
&amp;lt;bean id=&amp;quot;userT&amp;quot; class=&amp;quot;com.cy.pojo.UserT&amp;quot;&amp;gt;
   &amp;lt;constructor-arg type=&amp;quot;java.lang.String&amp;quot; value=&amp;quot;cy&amp;quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;测试&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import com.cy.pojo.User;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class MyTest {
    public static void main(String[] args) {
       ApplicationContext context = new ClassPathXmlApplicationContext(&amp;quot;applicationContext.xml&amp;quot;);

        UserT user = (UserT) context.getBean(&amp;quot;userT&amp;quot;);
        user.show();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;结论：在配置文件加载的时候。其中管理的对象都已经初始化了！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;5-spring配置&#34;&gt;5、Spring配置&lt;/h2&gt;
&lt;h3 id=&#34;51-别名&#34;&gt;5.1 别名&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--别名，如果添加了别名，我们也可以使用别名获取到--&amp;gt;
&amp;lt;alias name=&amp;quot;user&amp;quot; alias=&amp;quot;userNew&amp;quot;&amp;gt;&amp;lt;/alias&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;52-bean到底是什么&#34;&gt;5.2 Bean到底是什么？&lt;/h3&gt;
&lt;p&gt;bean就相当于定义一个组件，这个组件是用于具体实现某个功能的。这里的所定义的bean就相当于给了你一个简洁方便的方法来调用这个组件实现你要完成的功能。&lt;/p&gt;
&lt;p&gt;1、Java面向对象，对象有方法和属性，那么就需要对象实例来调用方法和属性（即实例化）；&lt;br&gt;
2、凡是有方法或属性的类都需要实例化，这样才能具象化去使用这些方法和属性；&lt;br&gt;
3、规律：凡是子类及带有方法或属性的类都要加上注册Bean到Spring IoC的注解；（@Component , @Repository , @ Controller , @Service , @Configration）&lt;br&gt;
4、把Bean理解为类的代理或代言人（实际上确实是通过反射、代理来实现的），这样它就能代表类拥有该拥有的东西了&lt;br&gt;
5、我们都在微博上@过某某，对方会优先看到这条信息，并给你反馈，那么在Spring中，你标识一个@符号，那么Spring就会来看看，并且从这里拿到一个Bean（注册）或者给出一个Bean（使用）&lt;/p&gt;
&lt;h3 id=&#34;53-怎么使用bean&#34;&gt;5.3 怎么使用bean&lt;/h3&gt;
&lt;p&gt;对于我们的spring最主要的应该就是由这些bean组成的bean工厂，每个bean实现一个功能&lt;br&gt;
例如：你写的第一个bean&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean id=&amp;quot;userAction&amp;quot; class=&amp;quot;com.neusoft.gmsbs.gms.user.action.UserAction&amp;quot;
scope=&amp;quot;prototype&amp;quot;&amp;gt;
&amp;lt;property name=&amp;quot;userBO&amp;quot; ref=&amp;quot;userBO&amp;quot; /&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;id相当于定义了你的这个bean的别名，如果你需要他的话只要关联这个别名就可以了，也就相当于下面的一样，在你的userAction中需要实现userBO这个功能，我关联它，那么在action中set注入就可以使用了！&lt;br&gt;
至于其他的属性看下面：&lt;br&gt;
Id : 标识该bean的名称，通过factory.getBean(“id”)来获得实例。&lt;br&gt;
Class : 该bean的类路径。&lt;br&gt;
Singleton : 默认为true，即单实例模式，每次getBean(“id”)时获取的都是同一个实例，如果设置为false，即原型模式，则每次获取的是新创建的实例。&lt;/p&gt;
&lt;h3 id=&#34;54-bean的配置&#34;&gt;5.4 Bean的配置&lt;/h3&gt;
&lt;p&gt;ID,name 或class&lt;br&gt;
一般情况下，转 配一个Bean时，通过指定一个ID属性作为Bean的名称&lt;br&gt;
1.&lt;strong&gt;id&lt;/strong&gt;属性在IOC容器中必须是唯一的&lt;br&gt;
2.如果Bean的名称中含有特殊字符，就需要使用&lt;strong&gt;name&lt;/strong&gt;属性&lt;br&gt;
3.&lt;strong&gt;class&lt;/strong&gt;用于设置一个类的完全路径名称，主要作用是ioc容器生成类的实例&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--
    id:bean的唯一标识符，相当于我们学的对象名；
    class：bean对象所对应的全限定名：包名+类名；
    name：也是别名，可以同时取多个别名，逗号分割
--&amp;gt;
&amp;lt;bean id=&amp;quot;userT&amp;quot; class=&amp;quot;com.cy.pojo.UserT&amp;quot; name=&amp;quot;user2,u2&amp;quot;&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;54-import&#34;&gt;5.4 import&lt;/h3&gt;
&lt;p&gt;这个import，一般用于团队开发使用，他可以将多个配置文件，导入合并为一个。&lt;/p&gt;
&lt;p&gt;假设，现在项目中有多个人开发，这三个人负责不同的类开发，不同的类需要注册在不同的bean中，我们可以利用import将所有人的beans.xml合并为一个总的！&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;张三&lt;/li&gt;
&lt;li&gt;李四&lt;/li&gt;
&lt;li&gt;王五&lt;/li&gt;
&lt;li&gt;applicationContext.xml&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;import resource=&amp;quot;beans.xml&amp;quot;/&amp;gt;
&amp;lt;import resource=&amp;quot;beans2.xml&amp;quot;/&amp;gt;
&amp;lt;import resource=&amp;quot;beans3.xml&amp;quot;/&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用的时候，直接使用总的配置就可以了。&lt;/p&gt;
&lt;h2 id=&#34;6-依赖注入&#34;&gt;6、依赖注入&lt;/h2&gt;
&lt;h3 id=&#34;61-构造器注入&#34;&gt;6.1 构造器注入&lt;/h3&gt;
&lt;p&gt;之前已经介绍过&lt;/p&gt;
&lt;h3 id=&#34;62-set方式注入重点&#34;&gt;6.2 Set方式注入【重点】&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;依赖注入：Set注入！
&lt;ul&gt;
&lt;li&gt;依赖：bean对象的创建依赖于容器！&lt;/li&gt;
&lt;li&gt;注入：bean对象中的所有属性，由容器来注入！&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;【环境搭建】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;复杂类型&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Address {
    private String address;

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;真实测试对象&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Student {

    private String name;

    private Address address;

    private String[] books;

    private List&amp;lt;String&amp;gt; hobbys;

    private Map&amp;lt;String,String&amp;gt; card;

    private Set&amp;lt;String&amp;gt; games;

    private Properties info;

    private String wife;


    @Override
    public String toString() {
        return &amp;quot;Student{&amp;quot; +
                &amp;quot;name=&#39;&amp;quot; + name + &#39;\&#39;&#39; +
                &amp;quot;, address=&amp;quot; + address.toString() +
                &amp;quot;, books=&amp;quot; + Arrays.toString(books) +
                &amp;quot;, hobbys=&amp;quot; + hobbys +
                &amp;quot;, card=&amp;quot; + card +
                &amp;quot;, games=&amp;quot; + games +
                &amp;quot;, info=&amp;quot; + info +
                &amp;quot;, wife=&#39;&amp;quot; + wife + &#39;\&#39;&#39; +
                &#39;}&#39;;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Address getAddress() {
        return address;
    }

    public void setAddress(Address address) {
        this.address = address;
    }

    public String[] getBooks() {
        return books;
    }

    public void setBooks(String[] books) {
        this.books = books;
    }

    public List&amp;lt;String&amp;gt; getHobbys() {
        return hobbys;
    }

    public void setHobbys(List&amp;lt;String&amp;gt; hobbys) {
        this.hobbys = hobbys;
    }

    public Map&amp;lt;String, String&amp;gt; getCard() {
        return card;
    }

    public void setCard(Map&amp;lt;String, String&amp;gt; card) {
        this.card = card;
    }

    public Set&amp;lt;String&amp;gt; getGames() {
        return games;
    }

    public void setGames(Set&amp;lt;String&amp;gt; games) {
        this.games = games;
    }

    public Properties getInfo() {
        return info;
    }

    public void setInfo(Properties info) {
        this.info = info;
    }

    public String getWife() {
        return wife;
    }

    public void setWife(String wife) {
        this.wife = wife;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;beans.xml&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
       xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&amp;quot;&amp;gt;
    &amp;lt;bean id=&amp;quot;student&amp;quot; class=&amp;quot;com.cy.pojo.Student&amp;quot;&amp;gt;
        &amp;lt;!--第一种，普通值注入--&amp;gt;
        &amp;lt;property name=&amp;quot;name&amp;quot; value=&amp;quot;憨批&amp;quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;测试类&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MyTest {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext(&amp;quot;beans.xml&amp;quot;);
        Student student = (Student) context.getBean(&amp;quot;student&amp;quot;);
        System.out.println(student.getName());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;mark&gt;&lt;strong&gt;完善注入：&lt;/strong&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
       xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&amp;quot;&amp;gt;

    &amp;lt;bean id=&amp;quot;address&amp;quot; class=&amp;quot;com.cy.pojo.Address&amp;quot;/&amp;gt;

    &amp;lt;bean id=&amp;quot;student&amp;quot; class=&amp;quot;com.cy.pojo.Student&amp;quot;&amp;gt;
        &amp;lt;!--第一种，普通值注入，value--&amp;gt;
        &amp;lt;property name=&amp;quot;name&amp;quot; value=&amp;quot;憨批&amp;quot;/&amp;gt;
        &amp;lt;!--第二种，Bean注入，ref--&amp;gt;
        &amp;lt;property name=&amp;quot;address&amp;quot; ref=&amp;quot;address&amp;quot;/&amp;gt;
        &amp;lt;!--数组注入--&amp;gt;
        &amp;lt;property name=&amp;quot;books&amp;quot;&amp;gt;
            &amp;lt;array&amp;gt;
                &amp;lt;value&amp;gt;红楼梦&amp;lt;/value&amp;gt;
                &amp;lt;value&amp;gt;西游记&amp;lt;/value&amp;gt;
                &amp;lt;value&amp;gt;水浒传&amp;lt;/value&amp;gt;
                &amp;lt;value&amp;gt;三国演义&amp;lt;/value&amp;gt;
            &amp;lt;/array&amp;gt;
        &amp;lt;/property&amp;gt;
        &amp;lt;!--List注入--&amp;gt;
        &amp;lt;property name=&amp;quot;hobbies&amp;quot;&amp;gt;
            &amp;lt;list&amp;gt;
                &amp;lt;value&amp;gt;听歌&amp;lt;/value&amp;gt;
                &amp;lt;value&amp;gt;敲代码&amp;lt;/value&amp;gt;
                &amp;lt;value&amp;gt;看电影&amp;lt;/value&amp;gt;
            &amp;lt;/list&amp;gt;
        &amp;lt;/property&amp;gt;
        &amp;lt;!--Map--&amp;gt;
        &amp;lt;property name=&amp;quot;card&amp;quot;&amp;gt;
            &amp;lt;map&amp;gt;
                &amp;lt;entry key=&amp;quot;身份证&amp;quot; value=&amp;quot;1555555555&amp;quot;/&amp;gt;
                &amp;lt;entry key=&amp;quot;银行卡&amp;quot; value=&amp;quot;5555555555&amp;quot;/&amp;gt;
            &amp;lt;/map&amp;gt;
        &amp;lt;/property&amp;gt;
        &amp;lt;!--Set--&amp;gt;
        &amp;lt;property name=&amp;quot;games&amp;quot;&amp;gt;
            &amp;lt;set&amp;gt;
                &amp;lt;value&amp;gt;lol&amp;lt;/value&amp;gt;
                &amp;lt;value&amp;gt;wow&amp;lt;/value&amp;gt;
            &amp;lt;/set&amp;gt;
        &amp;lt;/property&amp;gt;
        &amp;lt;!--null--&amp;gt;
        &amp;lt;property name=&amp;quot;wife&amp;quot;&amp;gt;
            &amp;lt;null/&amp;gt;
        &amp;lt;/property&amp;gt;
        &amp;lt;!--Properties--&amp;gt;
        &amp;lt;property name=&amp;quot;info&amp;quot;&amp;gt;
            &amp;lt;props&amp;gt;
                &amp;lt;prop key=&amp;quot;driver&amp;quot;&amp;gt;com.mysql.jdbc.Driver&amp;lt;/prop&amp;gt;
                &amp;lt;prop key=&amp;quot;url&amp;quot;&amp;gt;jdbc:mysql://localhost:3306/news&amp;lt;/prop&amp;gt;
                &amp;lt;prop key=&amp;quot;root&amp;quot;&amp;gt;root&amp;lt;/prop&amp;gt;
                &amp;lt;prop key=&amp;quot;password&amp;quot;&amp;gt;123456&amp;lt;/prop&amp;gt;
            &amp;lt;/props&amp;gt;
        &amp;lt;/property&amp;gt;

    &amp;lt;/bean&amp;gt;

&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;63-扩展方式注入&#34;&gt;6.3 扩展方式注入&lt;/h3&gt;
&lt;p&gt;我们可以使用&lt;strong&gt;c和p命令空间&lt;/strong&gt;进行注入：&lt;/p&gt;
&lt;p&gt;User.java（注意：这里没有有参构造器）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class User {
     private String name;
     private int age;
 
     public void setName(String name) {
         this.name = name;
    }
 
     public void setAge(int age) {
         this.age = age;
    }
 
     @Override
     public String toString() {
         return &amp;quot;User{&amp;quot; +
                 &amp;quot;name=&#39;&amp;quot; + name + &#39;\&#39;&#39; +
                 &amp;quot;, age=&amp;quot; + age +
                 &#39;}&#39;;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:p=&amp;quot;http://www.springframework.org/schema/p&amp;quot;
       xmlns:c=&amp;quot;http://www.springframework.org/schema/c&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
       xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&amp;quot;&amp;gt;

    &amp;lt;!--p命名空间注入，可以直接注入属性的值：property--&amp;gt;
    &amp;lt;bean id=&amp;quot;user&amp;quot; class=&amp;quot;com.cy.pojo.User&amp;quot; p:name=&amp;quot;憨批&amp;quot; p:age=&amp;quot;18&amp;quot;/&amp;gt;

    &amp;lt;!--c命名空间注入，通过构造器注入：construct-args--&amp;gt;
    &amp;lt;bean id=&amp;quot;user2&amp;quot; class=&amp;quot;com.cy.pojo.User&amp;quot; c:age=&amp;quot;18&amp;quot; c:name=&amp;quot;憨批&amp;quot;/&amp;gt;

&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void test2(){
    ApplicationContext context = new ClassPathXmlApplicationContext(&amp;quot;userBeans.xml&amp;quot;);
    User user = context.getBean(&amp;quot;user2&amp;quot;, User.class);
    System.out.println(user);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意点：p和c命名空间不能直接使用，需要导入xml约束！&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;xmlns:p=&amp;quot;http://www.springframework.org/schema/p&amp;quot;
xmlns:c=&amp;quot;http://www.springframework.org/schema/c&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;64-bean的作用域&#34;&gt;6.4 bean的作用域&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200617145745.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;代理模式（Spring默认机制）：get到的都是同一个对象！&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean id=&amp;quot;user2&amp;quot; class=&amp;quot;com.cy.pojo.User&amp;quot; c:age=&amp;quot;18&amp;quot; c:name=&amp;quot;憨批&amp;quot; scope=&amp;quot;singleton&amp;quot;/&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;原型模式：每次从容器中get的时候，都会产生一个新的对象！&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean id=&amp;quot;user2&amp;quot; class=&amp;quot;com.cy.pojo.User&amp;quot; c:age=&amp;quot;18&amp;quot; c:name=&amp;quot;憨批&amp;quot; scope=&amp;quot;prototype&amp;quot;/&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;其余的request、session、application、这些个只能在web开发中使用。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从上面的例子也印证了我上面的总结的内容：&lt;br&gt;
1、凡是子类及带属性、方法的类都注册Bean到Spring中，交给它管理；&lt;br&gt;
2、@Bean 用在方法上，告诉Spring容器，你可以从下面这个方法中拿到一个Bean&lt;/p&gt;
&lt;h2 id=&#34;7-bean的自动装配&#34;&gt;7、Bean的自动装配&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;自动装配是Spring满足bean依赖的一种方式！&lt;/li&gt;
&lt;li&gt;Spring会在上下文中自动寻找，并自动给bean装配属性！&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在Spring中有三种装配的方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在xml中显式配置；&lt;/li&gt;
&lt;li&gt;在java中显式配置；&lt;/li&gt;
&lt;li&gt;隐式的自动装配bean&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;推荐不使用自动装配xml配置 , 而使用注解 .&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;71-测试&#34;&gt;7.1 测试&lt;/h3&gt;
&lt;p&gt;环境搭建：一个人有两个宠物！&lt;/p&gt;
&lt;h3 id=&#34;72-byname自动装配&#34;&gt;7.2 ByName自动装配&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--
    byName:会自动在容器上下文中查找和自己对象set方法后面的值对应的beanid！
--&amp;gt;
&amp;lt;bean id=&amp;quot;people&amp;quot; class=&amp;quot;com.cy.pojo.People&amp;quot; autowire=&amp;quot;byName&amp;quot;&amp;gt;
    &amp;lt;property name=&amp;quot;name&amp;quot; value=&amp;quot;憨批&amp;quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;73-bytype自动装配&#34;&gt;7.3  ByType自动装配&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--
    byType:会自动在容器上下文中查找，和自己对象属性类型相同的bean！必须保证类型全局唯一。
--&amp;gt;
&amp;lt;bean id=&amp;quot;people&amp;quot; class=&amp;quot;com.cy.pojo.People&amp;quot; autowire=&amp;quot;byType&amp;quot;&amp;gt;
    &amp;lt;property name=&amp;quot;name&amp;quot; value=&amp;quot;憨批&amp;quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;小结：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;byName的时候，需要保证所有bean的id唯一，并且这个bean需要和自动注入的属性的set方法的值一致！&lt;/li&gt;
&lt;li&gt;byType的时候，需要保证所有bean的class唯一，并且这个bean需要和自动注入的属性的类型一致！&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;74-使用注解实现自动装配&#34;&gt;7.4 使用注解实现自动装配&lt;/h3&gt;
&lt;p&gt;jdk1.5开始支持注解，spring2.5开始全面支持注解。&lt;/p&gt;
&lt;p&gt;准备工作：利用注解的方式注入属性。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在spring配置文件中引入context文件头&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;xmlns:context=&amp;quot;http://www.springframework.org/schema/context&amp;quot;

http://www.springframework.org/schema/context
http://www.springframework.org/schema/context/spring-context.xsd
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;开启注解支持&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;context:annotation-config/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;741-autowired&#34;&gt;7.4.1 @AutoWired&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;@Autowired是按类型自动转配的，不支持id匹配。&lt;/li&gt;
&lt;li&gt;需要导入 spring-aop的包！&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;将User类中的set方法去掉，使用@Autowired注解&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class User {
   @Autowired
   private Cat cat;
   @Autowired
   private Dog dog;
   private String str;

   public Cat getCat() {
       return cat;
  }
   public Dog getDog() {
       return dog;
  }
   public String getStr() {
       return str;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;此时配置文件的内容&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
       xmlns:context=&amp;quot;http://www.springframework.org/schema/context&amp;quot;
       xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd&amp;quot;&amp;gt;


    &amp;lt;!--开启注解的支持--&amp;gt;
    &amp;lt;context:annotation-config/&amp;gt;

    &amp;lt;bean id=&amp;quot;dog&amp;quot; class=&amp;quot;com.cy.pojo.Dog&amp;quot;/&amp;gt;
    &amp;lt;bean id=&amp;quot;cat&amp;quot; class=&amp;quot;com.cy.pojo.Cat&amp;quot;/&amp;gt;
    &amp;lt;bean id=&amp;quot;people&amp;quot; class=&amp;quot;com.cy.pojo.People&amp;quot;/&amp;gt;


&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;测试，成功输出结果！&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;PS:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Autowired(required=false)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;false 说明对象可以是null&lt;/li&gt;
&lt;li&gt;true说明不能为null&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;742-qualifiers&#34;&gt;7.4.2 @Qualifiers&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;@Autowired是根据类型自动装配的,加上@Qualifiers就可以根据byName方法自动装配&lt;/li&gt;
&lt;li&gt;@Qualifier不能单独使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;测试步骤&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;配置文件修改内容，保证类型存在对象。且名字不为类的默认名字！&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean id=&amp;quot;dog1&amp;quot; class=&amp;quot;com.cy.pojo.Dog&amp;quot;/&amp;gt;
&amp;lt;bean id=&amp;quot;dog2&amp;quot; class=&amp;quot;com.cy.pojo.Dog&amp;quot;/&amp;gt;
&amp;lt;bean id=&amp;quot;cat1&amp;quot; class=&amp;quot;com.cy.pojo.Cat&amp;quot;/&amp;gt;
&amp;lt;bean id=&amp;quot;cat2&amp;quot; class=&amp;quot;com.cy.pojo.Cat&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;没有加Qualifier测试，直接报错&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在属性上添加Qualifier注解&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Autowired
@Qualifier(value = &amp;quot;cat2&amp;quot;)
private Cat cat;
@Autowired
@Qualifier(value = &amp;quot;dog2&amp;quot;)
private Dog dog;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;743-resource&#34;&gt;7.4.3 @Resource&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;@Resource如有指定的name属性，先按该属性进行byName方式查找装配；&lt;/li&gt;
&lt;li&gt;其次再进行默认的byName方式进行装配；&lt;/li&gt;
&lt;li&gt;如果以上都不成功，则按byType的方式自动装配。&lt;/li&gt;
&lt;li&gt;都不成功，则报异常&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;实体类&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class User {
   //如果允许对象为null，设置required = false,默认为true
   @Resource(name = &amp;quot;cat2&amp;quot;)
   private Cat cat;
   @Resource
   private Dog dog;
   private String str;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;applicaionContext.xml&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean id=&amp;quot;dog&amp;quot; class=&amp;quot;com.cy.pojo.Dog&amp;quot;/&amp;gt;
&amp;lt;bean id=&amp;quot;cat1&amp;quot; class=&amp;quot;com.cy.pojo.Cat&amp;quot;/&amp;gt;
&amp;lt;bean id=&amp;quot;cat2&amp;quot; class=&amp;quot;com.cy.pojo.Cat&amp;quot;/&amp;gt;

&amp;lt;bean id=&amp;quot;user&amp;quot; class=&amp;quot;com.cy.pojo.User&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试：结果OK&lt;/p&gt;
&lt;p&gt;配置文件2：beans.xml ， 删掉cat2&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean id=&amp;quot;dog&amp;quot; class=&amp;quot;com.cy.pojo.Dog&amp;quot;/&amp;gt;
&amp;lt;bean id=&amp;quot;cat1&amp;quot; class=&amp;quot;com.cy.pojo.Cat&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实体类上只保留注解&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Resource
private Cat cat;
@Resource
private Dog dog;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：OK&lt;/p&gt;
&lt;p&gt;结论：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先进行byName查找&lt;/li&gt;
&lt;li&gt;失败了在进行byType查找&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;@Resource和@Autowired的区别：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;都是用来自动装配的，都可以放在属性字段上；&lt;/li&gt;
&lt;li&gt;@Autowired通过byType的方式实现，而且必须要求这个对象存在！【常用】&lt;/li&gt;
&lt;li&gt;@Resource默认通过byName的方式实现，如果找不到名字，则通过byType实现！如果两个都找不到的情况下，就报错！&lt;/li&gt;
&lt;li&gt;执行顺序不同：@Autowired通过byType的方式实现，@Resource默认通过byName的方式实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;8-使用注解开发&#34;&gt;8、使用注解开发&lt;/h2&gt;
&lt;p&gt;在spring4之后，要使用注解开发，必须要保证aop的包导入了。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200617153338.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;使用注解需要导入context约束，增加注解的支持！&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--指定要扫描的包，这个包下的注解会生效--&amp;gt;
&amp;lt;context:component-scan base-package=&amp;quot;com.cy.pojo&amp;quot;/&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;81-bean的实现&#34;&gt;8.1 Bean的实现&lt;/h3&gt;
&lt;p&gt;我们之前都是使用 bean 的标签进行bean注入，但是实际开发中，我们一般都会使用注解！&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;配置扫描哪些包下的注解&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--扫描包--&amp;gt;
&amp;lt;context:component-scan base-package=&amp;quot;com.cy&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;在指定包下编写类，增加注解&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.cy.pojo;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Component;

// 等价于在applicationContext.xml写了一个bean
@Component

public class User {

	public String name = &amp;quot;cy&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;测试&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import com.cy.pojo.User;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Mytest {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext(&amp;quot;applicationContext.xml&amp;quot;);

        User user = (User) context.getBean(&amp;quot;user&amp;quot;);

        System.out.println(user.name);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;82-属性注入&#34;&gt;8.2 属性注入&lt;/h3&gt;
&lt;p&gt;使用注解注入属性&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以不使用Set方法，直接在属性上增加@Value(“值”)&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component(&amp;quot;user&amp;quot;)
// 相当于配置文件中 &amp;lt;bean id=&amp;quot;user&amp;quot; class=&amp;quot;当前注解的类&amp;quot;/&amp;gt;
public class User {
   @Value(&amp;quot;cy&amp;quot;)
   // 相当于配置文件中 &amp;lt;property name=&amp;quot;name&amp;quot; value=&amp;quot;cy&amp;quot;/&amp;gt;
   public String name;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;如果提供了set方法，在set方法上添加@value(“值”);&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component(&amp;quot;user&amp;quot;)
public class User {

   public String name;

    @Value(&amp;quot;cy&amp;quot;)
   public void setName(String name) {
       this.name = name;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;83-衍生的注解&#34;&gt;8.3 衍生的注解&lt;/h3&gt;
&lt;p&gt;@Component有几个衍生注解，我们在web开发中，会按照mvc三层架构分层！&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dao【@Repository】&lt;/li&gt;
&lt;li&gt;service【@Service】&lt;/li&gt;
&lt;li&gt;controller【@Controller】&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这四个注解功能都是一样的，都是代表将某个类注册到Spring中，装配Bean！&lt;/p&gt;
&lt;h3 id=&#34;84-自动装配&#34;&gt;8.4 自动装配&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;-@Autowired:自动装配通过类型，名字
	如果Autowired不能唯一自动装配上属性，则需要通过@Qualifier(value=&amp;quot;xxx&amp;quot;)
-@Nullable:字段标记了这个注解，说明这个字段可以为null
-@Resource:自动装配通过名字，类型
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;85-作用域&#34;&gt;8.5 作用域&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;@Scope(&amp;quot;singleton&amp;quot;)
public class User {
    //相当于&amp;lt;property name=&amp;quot;name&amp;quot; value=&amp;quot;cy&amp;quot;/&amp;gt;
    public String name;
    @Value(&amp;quot;cy&amp;quot;)
    public void setName(String name){
        this.name = name;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;86小结&#34;&gt;8.6小结&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;xml与注解：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;xml更加万能，适用于任何场合！维护简单方便。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注解，不是自己的类使用不了，维护相对复杂！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;xml与注解最佳实践：&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;xml用来管理bean；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注解只负责完成属性的注入；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我们在使用的过程中，只需要注意一个问题：必须让注解生效，就需要开启注解的支持。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt; &amp;lt;!--指定要扫描的包，这个包下的注解会生效--&amp;gt;
&amp;lt;context:component-scan base-package=&amp;quot;com.cy&amp;quot;/&amp;gt;
&amp;lt;context:annotation-config/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进行注解驱动注册，从而使注解生效&lt;/li&gt;
&lt;li&gt;用于激活那些已经在spring容器里注册过的bean上面的注解，也就是显示的向Spring注册&lt;/li&gt;
&lt;li&gt;如果不扫描包，就需要手动配置bean&lt;/li&gt;
&lt;li&gt;如果不加注解驱动，则注入的值为null&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;9-使用java的方式配置spring&#34;&gt;9. 使用java的方式配置Spring&lt;/h2&gt;
&lt;p&gt;我们现在要完全不适用Spring的xml配置了，全权交给java来做！&lt;/p&gt;
&lt;p&gt;javaConfig是Spring的一个子项目，在Spring4之后，它成为了一个核心功能。&lt;/p&gt;
&lt;p&gt;实体类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
public class User {
    private String name;

    public String getName() {
        return name;
    }

    @Value(&amp;quot;小笨蛋&amp;quot;)
    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return &amp;quot;User{&amp;quot; +
                &amp;quot;name=&#39;&amp;quot; + name + &#39;\&#39;&#39; +
                &#39;}&#39;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import com.cy.pojo.User;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;

//这个也会被Spring容器托管，注册到容器中，因为本来就是一个@Component
//@Configuration代表这是一个配置类，就和我们之前看的beans.xml
@Configuration
@ComponentScan(&amp;quot;com.cy.pojo&amp;quot;)
@Import(cyConfig2.class )
public class cyConfig {
    //注册一个bean，就相当于我们之前写的一个bean标签
    //这个方法的名字，就相当于bean标签中的id属性
    //这个方法的返回值，就相当于bean标签中的class属性
    @Bean
    public User getUser(){
        return new User();//就是返回要注入到bean的对象
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MyTest {
    public static void main(String[] args) {
        //如果完全使用了配置类方式去做，我们就只能通过AnnotationConfig上下文来获取容器，通过配置类的class对象加载！
        ApplicationContext context = new AnnotationConfigApplicationContext(cyConfig.class);
        User getUser = (User) context.getBean(&amp;quot;getUser&amp;quot;);
        System.out.println(getUser.getName());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;导入其他配置如何做呢？&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我们再编写一个配置类！&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration  //代表这是一个配置类
public class MyConfig2 {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;在之前的配置类中我们来选择导入这个配置类&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
//导入合并其他配置类，类似于配置文件中的 inculde 标签
@Import(MyConfig2.class)
public class MyConfig {

    // 注册一个bean（就相当于之前xml中写的一个bean）
    // 方法名：对应id
    // 返回值：相当于bean标签中的class属性
    @Bean
    public User getUser(){
        return new User();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;关于这种Java类的配置方式，我们在之后的SpringBoot 和 SpringCloud中还会大量看到，我们需要知道这些注解的作用即可！&lt;/p&gt;
&lt;h2 id=&#34;10-代理模式&#34;&gt;10、代理模式&lt;/h2&gt;
&lt;p&gt;为什么要学习代理模式？因为这就是SpringAOP的底层！【SpringAOP 和 SpringMVC 面试必问】&lt;/p&gt;
&lt;p&gt;代理模式的分类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态代理&lt;/li&gt;
&lt;li&gt;动态代理&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200617154558.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;101-静态代理&#34;&gt;10.1 静态代理&lt;/h3&gt;
&lt;p&gt;角色分析：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;抽象角色：一般会使用接口或者抽象类来解决&lt;/li&gt;
&lt;li&gt;真实角色：被代理的角色&lt;/li&gt;
&lt;li&gt;代理角色：代理真是角色，代理真实角色后，我们一般会做一些附属操作。&lt;/li&gt;
&lt;li&gt;客户：访问代理对象的人！&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;接口&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//租房
public interface Rent {
    public void rent();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;真实角色&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//房东
public class Host implements Rent {
    public void rent(){
        System.out.println(&amp;quot;房东要出租房子！&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;代理角色&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Proxy implements Rent {
    private Host host;

    public Proxy() {
    }
    public Proxy(Host host) {
        this.host = host;
    }

    public void rent(){
        seeHouse();
        host.rent();
        hetong();
        fee();
    }
    //看房
    public void seeHouse(){
        System.out.println(&amp;quot;中介带你看房&amp;quot;);
    }
    //签合同
    public void hetong(){
        System.out.println(&amp;quot;签合同&amp;quot;);
    }
    //收费
    public void fee(){
        System.out.println(&amp;quot;收取中介费用&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代理模式的好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以使真实角色的操作更加纯粹！不用去关注一些公共的业务&lt;/li&gt;
&lt;li&gt;公共也就交给代理角色！实现了业务的分工！&lt;/li&gt;
&lt;li&gt;公共业务发生扩展的时候，方便集中管理！&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个真实角色就会产生一个代理角色，代码量会翻倍，开发效率会变低&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;102-加深理解&#34;&gt;10.2 加深理解&lt;/h3&gt;
&lt;p&gt;聊聊AOP&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200617154837.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;103-动态代理&#34;&gt;10.3 动态代理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;动态代理和静态代理角色一样&lt;/li&gt;
&lt;li&gt;动态代理的代理类是动态生成的，不是我们直接写好的。&lt;/li&gt;
&lt;li&gt;动态代理分为两大类：基于接口的动态代理，基于类的动态代理
&lt;ul&gt;
&lt;li&gt;基于接口——JDK动态代理&lt;/li&gt;
&lt;li&gt;基于类：cglib&lt;/li&gt;
&lt;li&gt;java字节码实现：javasisit&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要了解两个类：Proxy：代理；InvocationHandler：调用处理程序&lt;/p&gt;
&lt;p&gt;动态代理的好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以使真实角色的操作更加纯粹！不用去关注一些公共的业务&lt;/li&gt;
&lt;li&gt;公共也就交给代理角色！实现了业务的分工！&lt;/li&gt;
&lt;li&gt;公共业务发生扩展的时候，方便集中管理！&lt;/li&gt;
&lt;li&gt;一个动态代理类代理类代理的是一个接口，一般就是对应的一类业务&lt;/li&gt;
&lt;li&gt;一个动态代理类可以代理多个类，只要是实现了同一个接口即可！&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;11-aop&#34;&gt;11、AOP&lt;/h2&gt;
&lt;h3 id=&#34;111-什么是aop&#34;&gt;11.1 什么是AOP&lt;/h3&gt;
&lt;p&gt;AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生泛型，利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的频率。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200804153530.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;112-aop在spring中的作用&#34;&gt;11.2 AOP在Spring中的作用&lt;/h3&gt;
&lt;p&gt;&lt;mark&gt;提供声明式事务；允许用户自定义切面&lt;/mark&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点，如日志、安全、缓存、事务等等……&lt;/li&gt;
&lt;li&gt;切面（ASPECT）：横切关注点被模块化的特殊对象，即是一个类。&lt;/li&gt;
&lt;li&gt;通知（Advice）：切面必须要完成的工作，即是类中的一个方法。&lt;/li&gt;
&lt;li&gt;目标（Target）：被通知对象。&lt;/li&gt;
&lt;li&gt;代理（Proxy）：向目标对象应用通知之后创建的对象。&lt;/li&gt;
&lt;li&gt;切入点（PointCut）：切面通知执行的“地点”的定义。&lt;/li&gt;
&lt;li&gt;连接点（jointPoint）：与切入点匹配的执行点。&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200804153605.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200617155041.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200617155102.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;(1)Before:在目标方法被调用之前做增强处理,@Before只需要指定切入点表达式即可&lt;/p&gt;
&lt;p&gt;(2)AfterReturning:在目标方法正常完成后做增强,@AfterReturning除了指定切入点表达式后，还可以指定一个返回值形参名returning,代表目标方法的返回值&lt;/p&gt;
&lt;p&gt;(3)AfterThrowing:主要用来处理程序中未处理的异常,@AfterThrowing除了指定切入点表达式后，还可以指定一个throwing的返回值形参名,可以通过该形参名来访问目标方法中所抛出的异常对象&lt;/p&gt;
&lt;p&gt;(4)After:在目标方法完成之后做增强，无论目标方法时候成功完成。@After可以指定一个切入点表达式&lt;/p&gt;
&lt;p&gt;(5)Around:环绕通知,在目标方法完成前后做增强处理,环绕通知是最重要的通知类型,像事务,日志等都是环绕通知,注意编程中核心是一个ProceedingJoinPoint&lt;/p&gt;
&lt;p&gt;即AOP在不改变原有代码的情况下，去增加新的功能。&lt;/p&gt;
&lt;h3 id=&#34;113-使用spring实现aop&#34;&gt;11.3 使用Spring实现AOP&lt;/h3&gt;
&lt;p&gt;【重点】使用AOP织入，需要导入一个依赖包。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.aspectj&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;aspectjweaver&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.9.5&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;1131-通过spring-api实现&#34;&gt;11.3.1 通过Spring API实现&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;首先编写我们的业务接口和实现类&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface UserService {

   public void add();

   public void delete();

   public void update();

   public void search();

}
public class UserServiceImpl implements UserService{

   @Override
   public void add() {
       System.out.println(&amp;quot;增加用户&amp;quot;);
  }

   @Override
   public void delete() {
       System.out.println(&amp;quot;删除用户&amp;quot;);
  }

   @Override
   public void update() {
       System.out.println(&amp;quot;更新用户&amp;quot;);
  }

   @Override
   public void search() {
       System.out.println(&amp;quot;查询用户&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;然后去写我们的增强类 , 我们编写两个 , 一个前置增强 一个后置增强&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Log implements MethodBeforeAdvice {

   //method : 要执行的目标对象的方法
   //objects : 被调用的方法的参数
   //Object : 目标对象
   @Override
   public void before(Method method, Object[] objects, Object o) throws Throwable {
       System.out.println( o.getClass().getName() + &amp;quot;的&amp;quot; + method.getName() + &amp;quot;方法被执行了&amp;quot;);
  }
}
public class AfterLog implements AfterReturningAdvice {
   //returnValue 返回值
   //method被调用的方法
   //args 被调用的方法的对象的参数
   //target 被调用的目标对象
   @Override
   public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable {
       System.out.println(&amp;quot;执行了&amp;quot; + target.getClass().getName()
       +&amp;quot;的&amp;quot;+method.getName()+&amp;quot;方法,&amp;quot;
       +&amp;quot;返回值：&amp;quot;+returnValue);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;最后去Spring中注册，并实现aop切入实现，注意导入约束&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
      xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
      xmlns:aop=&amp;quot;http://www.springframework.org/schema/aop&amp;quot;
      xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/aop
       http://www.springframework.org/schema/aop/spring-aop.xsd&amp;quot;&amp;gt;
    
    &amp;lt;!--注册bean--&amp;gt;
    &amp;lt;bean id=&amp;quot;userService&amp;quot; class=&amp;quot;com.cy.service.UserServiceImpl&amp;quot;/&amp;gt;
    &amp;lt;bean id=&amp;quot;log&amp;quot; class=&amp;quot;com.cy.log.log&amp;quot;/&amp;gt;
    &amp;lt;bean id=&amp;quot;afterLog&amp;quot; class=&amp;quot;com.cy.log.AfterLog&amp;quot;/&amp;gt;
    
    
    &amp;lt;!--配置aop--&amp;gt;
    &amp;lt;aop:config&amp;gt;
        &amp;lt;!-- 切入点   expression（要执行的位置） 表达式 --&amp;gt;
        &amp;lt;aop:pointcut id=&amp;quot;pointcut&amp;quot; expression=&amp;quot;execution(* com.cy.service.UserServiceImpl.*(..))&amp;quot;/&amp;gt;
        &amp;lt;!--使用环绕增加--&amp;gt;
        &amp;lt;aop:advisor advice-ref=&amp;quot;log&amp;quot; pointcut-ref=&amp;quot;pointcut&amp;quot;/&amp;gt;
        &amp;lt;aop:advisor advice-ref=&amp;quot;afterLog&amp;quot; pointcut-ref=&amp;quot;pointcut&amp;quot;/&amp;gt;
    &amp;lt;/aop:config&amp;gt;

&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Aop的重要性 : 很重要 . 一定要理解其中的思路 , 主要是思想的理解这一块 .&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring的AOP就是将公共的业务（日志，安全等）和领域业务结合起来&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;当执行领域业务会把公共业务加进来，实现公共业务的重复利用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;领域业务更加纯粹，AOP其本质还是动态代理&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;1132-自定义类来实现aop&#34;&gt;11.3.2  自定义类来实现AOP&lt;/h4&gt;
&lt;p&gt;目标业务类不变依旧是userServiceImpl&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一步 : 写我们自己的一个切入类&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.cy.config;

public class DiyPointCut {

    public void before(){
        System.out.println(&amp;quot;===执行前===&amp;quot;);
    }

    public void after(){
        System.out.println(&amp;quot;===执行后===&amp;quot;);
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;去spring中配置&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--第二种方式自定义实现--&amp;gt;
&amp;lt;!--注册bean--&amp;gt;
&amp;lt;bean id=&amp;quot;diy&amp;quot; class=&amp;quot;com.cy.config.DiyPointcut&amp;quot;/&amp;gt;

&amp;lt;!--aop的配置--&amp;gt;
&amp;lt;aop:config&amp;gt;
   &amp;lt;!--第二种方式：使用AOP的标签实现--&amp;gt;
   &amp;lt;aop:aspect ref=&amp;quot;diy&amp;quot;&amp;gt;
       &amp;lt;aop:pointcut id=&amp;quot;diyPonitcut&amp;quot; expression=&amp;quot;execution(* com.cy.service.UserServiceImpl.*(..))&amp;quot;/&amp;gt;
       &amp;lt;aop:before pointcut-ref=&amp;quot;diyPonitcut&amp;quot; method=&amp;quot;before&amp;quot;/&amp;gt;
       &amp;lt;aop:after pointcut-ref=&amp;quot;diyPonitcut&amp;quot; method=&amp;quot;after&amp;quot;/&amp;gt;
   &amp;lt;/aop:aspect&amp;gt;
&amp;lt;/aop:config&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;测试：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MyTest {
   @Test
   public void test(){
       ApplicationContext context = new ClassPathXmlApplicationContext(&amp;quot;beans.xml&amp;quot;);
       UserService userService = (UserService) context.getBean(&amp;quot;userService&amp;quot;);
       userService.add();
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;1133-注解实现&#34;&gt;11.3.3 注解实现&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;编写注解实现的增强类&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.cy.anno;

import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;


// 使用注解方式实现aop
@Aspect // 注解这个类是一个切面，本质就是一个插入的类
public class AnnoPointCut {

    @Before(&amp;quot;execution(* com.cy.service.UserServiceImpl.*(..))&amp;quot;)
    public void before(){
        System.out.println(&amp;quot;===执行前===&amp;quot;);
    }

    @After(&amp;quot;execution(* com.cy.service.UserServiceImpl.*(..))&amp;quot;)
    public void after(){
        System.out.println(&amp;quot;===执行后===&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;在Spring配置文件中，注册bean，并增加支持注解的配置&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--第三种方式:注解实现--&amp;gt;
&amp;lt;bean id=&amp;quot;annotationPointcut&amp;quot; class=&amp;quot;com.cy.anno.AnnoPointCut;&amp;quot;/&amp;gt;


&amp;lt;!--开启aop注解支持--&amp;gt;
&amp;lt;aop:aspectj-autoproxy/&amp;gt;

&amp;lt;!--
&amp;lt;aop:aspectj-autoproxy /&amp;gt;有一个proxy-target-class属性，默认为false，
表示使用jdk动态代理织入增强，
当配为&amp;lt;aop:aspectj-autoproxy  poxy-target-class=&amp;quot;true&amp;quot;/&amp;gt;时，表示使用CGLib动态代理技术织入增强。
不过即使proxy-target-class设置为false，如果目标类没有声明接口，则spring将自动使用CGLib动态代理。
--&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;12-整合mybatis&#34;&gt;12、整合Mybatis&lt;/h2&gt;
&lt;p&gt;官网mybatis-spring : http://mybatis.org/spring/zh/index.html&lt;/p&gt;
&lt;p&gt;环境准备：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;junit&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
   &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
   &amp;lt;version&amp;gt;4.12&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;mybatis&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
   &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt;
   &amp;lt;version&amp;gt;3.5.2&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mysql-connector-java&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
   &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
   &amp;lt;version&amp;gt;5.1.47&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;spring相关&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
   &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt;
   &amp;lt;version&amp;gt;5.1.10.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;
   &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;spring-jdbc&amp;lt;/artifactId&amp;gt;
   &amp;lt;version&amp;gt;5.1.10.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;aspectJ AOP 织入器&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&amp;gt;
&amp;lt;dependency&amp;gt;
   &amp;lt;groupId&amp;gt;org.aspectj&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;aspectjweaver&amp;lt;/artifactId&amp;gt;
   &amp;lt;version&amp;gt;1.9.4&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;配置Maven静态资源过滤问题！&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;build&amp;gt;
   &amp;lt;resources&amp;gt;
       &amp;lt;resource&amp;gt;
           &amp;lt;directory&amp;gt;src/main/java&amp;lt;/directory&amp;gt;
           &amp;lt;includes&amp;gt;
               &amp;lt;include&amp;gt;**/*.properties&amp;lt;/include&amp;gt;
               &amp;lt;include&amp;gt;**/*.xml&amp;lt;/include&amp;gt;
           &amp;lt;/includes&amp;gt;
           &amp;lt;filtering&amp;gt;true&amp;lt;/filtering&amp;gt;
       &amp;lt;/resource&amp;gt;
   &amp;lt;/resources&amp;gt;
&amp;lt;/build&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;121-回忆mybatis&#34;&gt;12.1 回忆MyBatis&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;编写实体类 pojo/User&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.cy.pojo;


public class User {
    private int id;
    private String name;
    private String pwd;

    @Override
    public String toString() {
        return &amp;quot;User{&amp;quot; +
                &amp;quot;id=&amp;quot; + id +
                &amp;quot;, name=&#39;&amp;quot; + name + &#39;\&#39;&#39; +
                &amp;quot;, pwd=&#39;&amp;quot; + pwd + &#39;\&#39;&#39; +
                &#39;}&#39;;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getPwd() {
        return pwd;
    }

    public void setPwd(String pwd) {
        this.pwd = pwd;
    }

    public User() {
    }

    public User(int id, String name, String pwd) {
        this.id = id;
        this.name = name;
        this.pwd = pwd;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;编写mybatis-config.xml&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE configuration
        PUBLIC &amp;quot;-//mybatis.org//DTD Config 3.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-3-config.dtd&amp;quot;&amp;gt;
&amp;lt;configuration&amp;gt;

    &amp;lt;typeAliases&amp;gt;
        &amp;lt;package name=&amp;quot;com.cy.pojo&amp;quot;/&amp;gt;
    &amp;lt;/typeAliases&amp;gt;


    &amp;lt;environments default=&amp;quot;development&amp;quot;&amp;gt;
        &amp;lt;environment id=&amp;quot;development&amp;quot;&amp;gt;
            &amp;lt;transactionManager type=&amp;quot;JDBC&amp;quot;/&amp;gt;
            &amp;lt;dataSource type=&amp;quot;POOLED&amp;quot;&amp;gt;
                &amp;lt;property name=&amp;quot;driver&amp;quot; value=&amp;quot;com.mysql.jdbc.Driver&amp;quot;/&amp;gt;
                &amp;lt;property name=&amp;quot;url&amp;quot; value=&amp;quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;amp;useUnicode=true&amp;amp;amp;characterEncoding=utf8&amp;amp;amp;serverTimezone=GMT%2B8&amp;quot;/&amp;gt;
                &amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;root&amp;quot;/&amp;gt;
                &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;123456&amp;quot;/&amp;gt;
            &amp;lt;/dataSource&amp;gt;
        &amp;lt;/environment&amp;gt;
    &amp;lt;/environments&amp;gt;

    
    &amp;lt;mappers&amp;gt;
        &amp;lt;package name=&amp;quot;com.cy.dao&amp;quot;/&amp;gt;
    &amp;lt;/mappers&amp;gt;
    
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;编写mapper (dao/UserMapper)&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.cy.dao;

import com.cy.pojo.User;
import java.util.List;

public interface UserMapper {
    public List&amp;lt;User&amp;gt; selectUser();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;编写mapper对应的xml (dao/UserMapper.xml)&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper
        PUBLIC &amp;quot;-//mybatis.org//DTD Mapper 3.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&amp;quot;&amp;gt;

&amp;lt;mapper namespace=&amp;quot;com.cy.dao.UserMapper&amp;quot;&amp;gt;
    &amp;lt;select id=&amp;quot;selectUser&amp;quot; resultType=&amp;quot;User&amp;quot;&amp;gt;
        select * from user
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;测试&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MyTest {
    public static void main(String[] args) throws IOException {
        String resource = &amp;quot;mybaits-config.xml&amp;quot;;

        InputStream inputStream = Resources.getResourceAsStream(resource);

        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);

        SqlSession sqlSession = sqlSessionFactory.openSession();

        UserMapper mapper = sqlSession.getMapper(UserMapper.class);

        List&amp;lt;User&amp;gt; userList = mapper.selectUser();

        for (User user : userList) {
            System.out.println(user);
        }

        sqlSession.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果显示如下：（当然这是我自己创建的数据库）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;User{id=1, name=&#39;cy&#39;, pwd=&#39;123456&#39;}
User{id=2, name=&#39;张三&#39;, pwd=&#39;abcdeft&#39;}
User{id=3, name=&#39;李四&#39;, pwd=&#39;435354353&#39;}
User{id=5, name=&#39;李五&#39;, pwd=&#39;123213123&#39;}
User{id=7, name=&#39;小明&#39;, pwd=&#39;123456&#39;}
User{id=8, name=&#39;root&#39;, pwd=&#39;123456&#39;}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;122-学习mybatis-spring&#34;&gt;12.2 学习MyBatis-Spring&lt;/h3&gt;
&lt;p&gt;官网mybatis-spring : http://mybatis.org/spring/zh/index.html&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;http://cy-bucket.oss-cn-beijing.aliyuncs.com/img/20200527/092328496.png&#34; alt=&#34;mark&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;MyBatis-Spring 需要以下版本：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;MyBatis-Spring&lt;/th&gt;
&lt;th&gt;MyBatis&lt;/th&gt;
&lt;th&gt;Spring 框架&lt;/th&gt;
&lt;th&gt;Spring Batch&lt;/th&gt;
&lt;th&gt;Java&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;2.0&lt;/td&gt;
&lt;td&gt;3.5+&lt;/td&gt;
&lt;td&gt;5.0+&lt;/td&gt;
&lt;td&gt;4.0+&lt;/td&gt;
&lt;td&gt;Java 8+&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1.3&lt;/td&gt;
&lt;td&gt;3.4+&lt;/td&gt;
&lt;td&gt;3.2.2+&lt;/td&gt;
&lt;td&gt;2.1+&lt;/td&gt;
&lt;td&gt;Java 6+&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;如果使用 Maven 作为构建工具，仅需要在 pom.xml 中加入以下代码即可：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
   &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;mybatis-spring&amp;lt;/artifactId&amp;gt;
   &amp;lt;version&amp;gt;2.0.2&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;要和Spring一起使用MyBatis，需要在Spring应用上下文中至少定义两样东西&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;sqlSessionFactory&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据映射器类&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;在 MyBatis-Spring 中，可使用 &lt;code&gt;SqlSessionFactoryBean&lt;/code&gt;来创建 &lt;code&gt;SqlSessionFactory&lt;/code&gt;。 要配置这个工厂 bean，只需要把下面代码放在 Spring 的 XML 配置文件中：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean id=&amp;quot;sqlSessionFactory&amp;quot; class=&amp;quot;org.mybatis.spring.SqlSessionFactoryBean&amp;quot;&amp;gt;
  &amp;lt;property name=&amp;quot;dataSource&amp;quot; ref=&amp;quot;dataSource&amp;quot; /&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：SqlSessionFactory需要一个 DataSource（数据源）。这可以是任意的 DataSource，只需要和配置其它 Spring 数据库连接一样配置它就可以了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;在基础的 MyBatis 用法中，是通过 SqlSessionFactoryBuilder 来创建 SqlSessionFactory 的，而在 MyBatis-Spring 中，则使用 SqlSessionFactoryBean 来创建。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 MyBatis 中，你可以使用 SqlSessionFactory 来创建 SqlSession。一旦你获得一个 session 之后，你可以使用它来执行映射了的语句，提交或回滚连接，最后，当不再需要它的时候，你可以关闭 session。&lt;/p&gt;
&lt;p&gt;一个常用的属性是 configLocation，它用来指定 MyBatis 的 XML 配置文件路径。它在需要修改 MyBatis 的基础配置非常有用。通常，基础配置指的是 &amp;lt; settings&amp;gt; 或 &amp;lt; typeAliases&amp;gt;元素。&lt;/p&gt;
&lt;p&gt;需要注意的是，这个配置文件并不需要是一个完整的 MyBatis 配置。确切地说，任何环境配置（&lt;code&gt;），数据源（&lt;/code&gt;）和 MyBatis 的事务管理器（``）都会被忽略。SqlSessionFactoryBean 会创建它自有的 MyBatis 环境配置（Environment），并按要求设置自定义环境的值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;同时，&lt;code&gt;SqlSessionTemplate&lt;/code&gt;是&lt;code&gt;MyBatis-Spring&lt;/code&gt;的核心，作为&lt;code&gt;SqlSession&lt;/code&gt;的一个实现，这就意味着可以使用它无缝替换你代码中已经使用的&lt;code&gt;sqlSession&lt;/code&gt;。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;模板可以参与到 Spring 的事务管理中，并且由于其是线程安全的，可以供多个映射器类使用，你应该总是用 SqlSessionTemplate 来替换 MyBatis 默认的 DefaultSqlSession 实现。在同一应用程序中的不同类之间混杂使用可能会引起数据一致性的问题。&lt;/p&gt;
&lt;p&gt;可以使用 SqlSessionFactory 作为构造方法的参数来创建 SqlSessionTemplate 对象.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean id=&amp;quot;sqlSession&amp;quot; class=&amp;quot;org.mybatis.spring.SqlSessionTemplate&amp;quot;&amp;gt;
 &amp;lt;constructor-arg index=&amp;quot;0&amp;quot; ref=&amp;quot;sqlSessionFactory&amp;quot; /&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;现在，这个 bean 就可以直接注入到你的 DAO bean 中了。你需要在你的 bean 中添加一个 SqlSession 属性，就像下面这样：(&lt;strong&gt;也就是需要写一个接口的实现类&lt;/strong&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UserDaoImpl implements UserDao {

 private SqlSession sqlSession;

 public void setSqlSession(SqlSession sqlSession) {
   this.sqlSession = sqlSession;
}

 public User getUser(String userId) {
   return sqlSession.getMapper...;
}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;按下面这样，注入 SqlSessionTemplate：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean id=&amp;quot;userDao&amp;quot; class=&amp;quot;org.mybatis.spring.sample.dao.UserDaoImpl&amp;quot;&amp;gt;
 &amp;lt;property name=&amp;quot;sqlSession&amp;quot; ref=&amp;quot;sqlSession&amp;quot; /&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;123-mybaits-spring-整合实现方式一&#34;&gt;12.3 MyBaits-Spring 整合实现方式一&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;这些配置大部分都是固定的！！&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;引入Spring配置文件beans.xml&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
      xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
      xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&amp;quot;&amp;gt;
    
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;配置数据源替换mybaits的数据源&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean id=&amp;quot;dataSource&amp;quot; class=&amp;quot;org.springframework.jdbc.datasource.DriverManagerDataSource&amp;quot;&amp;gt;
    &amp;lt;property name=&amp;quot;driverClassName&amp;quot; value=&amp;quot;com.mysql.jdbc.Driver&amp;quot;/&amp;gt;
    &amp;lt;property name=&amp;quot;url&amp;quot; value=&amp;quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;amp;useUnicode=true&amp;amp;amp;characterEncoding=utf8&amp;amp;amp;serverTimezone=GMT%2B8&amp;quot;/&amp;gt;
    &amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;root&amp;quot;/&amp;gt;
    &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;123456&amp;quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;配置SqlSessionFactory，关联MyBatis&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--配置sqlSessionFactory--&amp;gt;
&amp;lt;bean id=&amp;quot;sqlSessionFactory&amp;quot; class=&amp;quot;org.mybatis.spring.SqlSessionFactoryBean&amp;quot;&amp;gt;
    &amp;lt;property name=&amp;quot;dataSource&amp;quot; ref=&amp;quot;dataSource&amp;quot;/&amp;gt;
    &amp;lt;!--关联mybatis--&amp;gt;
    &amp;lt;property name=&amp;quot;configLocation&amp;quot; value=&amp;quot;classpath:mybaits-config.xml&amp;quot;/&amp;gt;
    &amp;lt;property name=&amp;quot;mapperLocations&amp;quot; value=&amp;quot;classpath:com/cy/dao/*.xml&amp;quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;注册sqlSessionTemplate，关联sqlSessionFactory；&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--注册sqlSessionTemplate并且关联sqlSessionFactory--&amp;gt;
&amp;lt;bean id=&amp;quot;sqlSession&amp;quot; class=&amp;quot;org.mybatis.spring.SqlSessionTemplate&amp;quot;&amp;gt;
    &amp;lt;!--利用构造器注入：因为sqlSessionTemplate 没有set方法--&amp;gt;
    &amp;lt;constructor-arg index=&amp;quot;0&amp;quot; ref=&amp;quot;sqlSessionFactory&amp;quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;18&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200804154448.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;增加Dao接口的实现类；私有化sqlSessionTemplate&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.cy.dao;

import com.cy.pojo.User;
import org.mybatis.spring.SqlSessionTemplate;

import java.util.List;

public class UserMapperImpl implements UserMapper{
    // sqlSession不用我们自己创建，Spring来自己管理
    private SqlSessionTemplate sqlSession;

    public void setSqlSession(SqlSessionTemplate sqlSession) {
        this.sqlSession = sqlSession;
    }


    public List&amp;lt;User&amp;gt; selectUser() {
        return sqlSession.getMapper(UserMapper.class).selectUser();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;把实现类注入到beans.xml中&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--注册bean实现--&amp;gt;
&amp;lt;bean id=&amp;quot;userDao&amp;quot; class=&amp;quot;com.cy.dao.UserMapperImpl&amp;quot;&amp;gt;
    &amp;lt;property name=&amp;quot;sqlSession&amp;quot; ref=&amp;quot;sqlSession&amp;quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;测试&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MyTestII {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext(&amp;quot;beans.xml&amp;quot;);

        UserMapper mapper = context.getBean(&amp;quot;userDao&amp;quot;, UserMapper.class);

        List&amp;lt;User&amp;gt; users = mapper.selectUser();

        for (User user : users) {
            System.out.println(user);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果成功输出！现在我们的Mybatis配置文件的状态！发现都可以被Spring整合！&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE configuration
        PUBLIC &amp;quot;-//mybatis.org//DTD Config 3.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-3-config.dtd&amp;quot;&amp;gt;
&amp;lt;configuration&amp;gt;

    &amp;lt;typeAliases&amp;gt;
        &amp;lt;package name=&amp;quot;com.cy.pojo&amp;quot;/&amp;gt;
    &amp;lt;/typeAliases&amp;gt;

&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;124-mybaits-spring-整合实现方式二&#34;&gt;12.4 MyBaits-Spring 整合实现方式二&lt;/h3&gt;
&lt;p&gt;mybatis-spring1.2.3版以上的才有这个 .&lt;/p&gt;
&lt;p&gt;官方文档截图 :&lt;/p&gt;
&lt;p&gt;dao继承Support类 , 直接利用 getSqlSession() 获得 , 然后直接注入SqlSessionFactory . 比起方式1 , 不需要管理SqlSessionTemplate , 而且对事务的支持更加友好 . 可跟踪源码查看&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;19&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200804154550.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;将我们上面写的UserDaoImpl修改一下&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UserDaoImpl extends SqlSessionDaoSupport implements UserMapper {
   public List&amp;lt;User&amp;gt; selectUser() {
       UserMapper mapper = getSqlSession().getMapper(UserMapper.class);
       return mapper.selectUser();
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;修改bean的配置&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean id=&amp;quot;userDao&amp;quot; class=&amp;quot;com.cy.dao.UserDaoImpl&amp;quot;&amp;gt;
   &amp;lt;property name=&amp;quot;sqlSessionFactory&amp;quot; ref=&amp;quot;sqlSessionFactory&amp;quot; /&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;测试&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void test2(){
   ApplicationContext context = new ClassPathXmlApplicationContext(&amp;quot;beans.xml&amp;quot;);
   UserMapper mapper = (UserMapper) context.getBean(&amp;quot;userDao&amp;quot;);
   List&amp;lt;User&amp;gt; user = mapper.selectUser();
   System.out.println(user);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;总结 : 整合到spring以后可以完全不要mybatis的配置文件，除了这些方式可以实现整合之外，我们还可以使用注解来实现，这个等我们后面学习SpringBoot的时候还会测试整合！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;13-声明式事务&#34;&gt;13、 声明式事务&lt;/h2&gt;
&lt;h3 id=&#34;131-回顾事务&#34;&gt;13.1 回顾事务&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;事务在项目开发过程非常重要，涉及到数据的一致性的问题，不容马虎！&lt;/li&gt;
&lt;li&gt;事务管理是企业级应用程序开发中必备技术，用来确保数据的完整性和一致性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;事务就是把一系列的动作当成一个独立的工作单元，这些动作要么全部完成，要么全部不起作用。&lt;/p&gt;
&lt;p&gt;事务的ACID原则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;原子性（atomicity）&lt;/p&gt;
&lt;p&gt;事务是原子性操作，由一系列动作组成，事务的原子性确保动作要么全部完成，要么完全不起作用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一致性（consistency）&lt;/p&gt;
&lt;p&gt;一旦所有事务动作完成，事务就要被提交。数据和资源处于一种满足业务规则的一致性状态中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;隔离性（isolation）&lt;/p&gt;
&lt;p&gt;可能多个事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;持久性（durability）&lt;/p&gt;
&lt;p&gt;事务一旦完成，无论系统发生什么错误，结果都不会受到影响。通常情况下，事务的结果被写到持久化存储器中&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;132-普通事务测试&#34;&gt;13.2 普通事务测试&lt;/h3&gt;
&lt;p&gt;将上一篇的代码拷贝到一个新的项目中&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在之前的案例中，我们给userDao接口新增两个方法，删除和增加用户；&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//添加一个用户
int addUser(User user);

//根据id删除用户
int deleteUser(int id);
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;mapper文件，我们故意把 deletes 写错，测试！&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;insert id=&amp;quot;addUser&amp;quot; parameterType=&amp;quot;com.cy.pojo.User&amp;quot;&amp;gt;
insert into user (id,name,pwd) values (#{id},#{name},#{pwd})
&amp;lt;/insert&amp;gt;

&amp;lt;delete id=&amp;quot;deleteUser&amp;quot; parameterType=&amp;quot;int&amp;quot;&amp;gt;
deletes from user where id = #{id}
&amp;lt;/delete&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;编写接口的实现类，在实现类中，我们去操作一波&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UserDaoImpl extends SqlSessionDaoSupport implements UserMapper {

   //增加一些操作
   public List&amp;lt;User&amp;gt; selectUser() {
       User user = new User(4,&amp;quot;小明&amp;quot;,&amp;quot;123456&amp;quot;);
       UserMapper mapper = getSqlSession().getMapper(UserMapper.class);
       mapper.addUser(user);
       mapper.deleteUser(4);
       return mapper.selectUser();
  }

   //新增
   public int addUser(User user) {
       UserMapper mapper = getSqlSession().getMapper(UserMapper.class);
       return mapper.addUser(user);
  }
   //删除
   public int deleteUser(int id) {
       UserMapper mapper = getSqlSession().getMapper(UserMapper.class);
       return mapper.deleteUser(id);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;测试：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void test2(){
   ApplicationContext context = new ClassPathXmlApplicationContext(&amp;quot;beans.xml&amp;quot;);
   UserMapper mapper = (UserMapper) context.getBean(&amp;quot;userDao&amp;quot;);
   List&amp;lt;User&amp;gt; user = mapper.selectUser();
   System.out.println(user);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这时候发现报错：sql异常，delete写错了&lt;/p&gt;
&lt;p&gt;结果：插入成功，并没有回滚&lt;/p&gt;
&lt;p&gt;没有进行事务的管理；我们想让他们都成功才成功，有一个失败，就都失败，我们就应该需要&lt;strong&gt;事务！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以前我们都需要自己手动管理事务，十分麻烦！&lt;/p&gt;
&lt;p&gt;但是Spring给我们提供了事务管理，我们只需要配置即可；&lt;/p&gt;
&lt;h3 id=&#34;133-spring中的事务管理&#34;&gt;13.3  Spring中的事务管理&lt;/h3&gt;
&lt;p&gt;Spring在不同的事务管理API之上定义了一个抽象层，使得开发人员不必了解底层的事务管理API就可以使用Spring的事务管理机制。Spring支持编程式事务管理和声明式的事务管理。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;编程式事务管理&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;20&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200804154906.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;将事务管理代码嵌到业务方法中来控制事务的提交和回滚&lt;/p&gt;
&lt;p&gt;缺点：必须在每个事务操作业务逻辑中包含额外的事务管理代码&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;声明式事务管理（只用这个,基本配置也是固定的）
&lt;ul&gt;
&lt;li&gt;一般情况下比编程式事务好用。&lt;/li&gt;
&lt;li&gt;将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。&lt;/li&gt;
&lt;li&gt;将事务管理作为横切关注点，&lt;strong&gt;通过aop方法模块化&lt;/strong&gt;。Spring中通过Spring AOP框架支持声明式事务管理。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;使用Spring管理事务，注意头文件的约束导入：&lt;strong&gt;tx&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;xmlns:tx=&amp;quot;http://www.springframework.org/schema/tx&amp;quot;

http://www.springframework.org/schema/tx
http://www.springframework.org/schema/tx/spring-tx.xsd&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;事务管理器&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;无论使用Spring的哪种事务管理策略（编程式或者声明式）事务管理器都是必须的。&lt;/li&gt;
&lt;li&gt;就是 Spring的核心事务管理抽象，管理封装了一组独立于技术的方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--配置事务管理器--&amp;gt;
&amp;lt;bean id=&amp;quot;transactionManager&amp;quot; class=&amp;quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&amp;quot;&amp;gt;
    &amp;lt;property name=&amp;quot;dataSource&amp;quot; ref=&amp;quot;dataSource&amp;quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;配置好事务管理器后我们需要去配置事务的通知&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--配置事务通知--&amp;gt;
&amp;lt;tx:advice id=&amp;quot;txAdvice&amp;quot; transaction-manager=&amp;quot;transactionManager&amp;quot;&amp;gt;
    &amp;lt;tx:attributes&amp;gt;
        &amp;lt;tx:method name=&amp;quot;add&amp;quot; propagation=&amp;quot;REQUIRED&amp;quot;/&amp;gt;
        &amp;lt;tx:method name=&amp;quot;delete&amp;quot; propagation=&amp;quot;REQUIRED&amp;quot;/&amp;gt;
        &amp;lt;tx:method name=&amp;quot;update&amp;quot; propagation=&amp;quot;REQUIRED&amp;quot;/&amp;gt;
        &amp;lt;tx:method name=&amp;quot;search*&amp;quot; propagation=&amp;quot;REQUIRED&amp;quot;/&amp;gt;
        &amp;lt;tx:method name=&amp;quot;get&amp;quot; read-only=&amp;quot;true&amp;quot;/&amp;gt;
        &amp;lt;tx:method name=&amp;quot;*&amp;quot; propagation=&amp;quot;REQUIRED&amp;quot;/&amp;gt;
    &amp;lt;/tx:attributes&amp;gt;
&amp;lt;/tx:advice&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;spring事务传播特性：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;事务传播行为就是多个事务方法相互调用时，事务如何在这些方法间传播。spring支持7种事务传播行为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;propagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。&lt;/li&gt;
&lt;li&gt;propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。&lt;/li&gt;
&lt;li&gt;propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。&lt;/li&gt;
&lt;li&gt;propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。&lt;/li&gt;
&lt;li&gt;propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。&lt;/li&gt;
&lt;li&gt;propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Spring 默认的事务传播行为是 PROPAGATION_REQUIRED，它适合于绝大多数的情况。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;假设 ServiveX#methodX() 都工作在事务环境下（即都被 Spring 事务增强了），
假设程序中存在如下的调用链：
Service1#method1()-&amp;gt;Service2#method2()-&amp;gt;Service3#method3()，
那么这 3 个服务类的 3 个方法通过 Spring 的事务传播机制都工作在同一个事务中。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;就好比，我们刚才的几个方法存在调用，所以会被放在一组事务当中！&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;配置AOP&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;导入aop的头文件&lt;/li&gt;
&lt;li&gt;aop 织入&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!--配置aop织入事务--&amp;gt;
&amp;lt;aop:config&amp;gt;
    &amp;lt;aop:pointcut id=&amp;quot;txPointcut&amp;quot; expression=&amp;quot;execution(* com.cy.dao.*.*(..))&amp;quot;/&amp;gt;
    &amp;lt;aop:advisor advice-ref=&amp;quot;txAdvice&amp;quot; pointcut-ref=&amp;quot;txPointcut&amp;quot;/&amp;gt;
&amp;lt;/aop:config&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;测试&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;删掉刚才插入的数据，再次测试！&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void test2(){
   ApplicationContext context = new ClassPathXmlApplicationContext(&amp;quot;beans.xml&amp;quot;);
   UserMapper mapper = (UserMapper) context.getBean(&amp;quot;userDao&amp;quot;);
   List&amp;lt;User&amp;gt; user = mapper.selectUser();
   System.out.println(user);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;结果发现：因为插入失败，所以事务进行了回滚！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参考文档：http://mybatis.org/spring/zh/transactions.html&lt;/p&gt;
">Spring</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jonchan1013.github.io/post/nginx/"" data-c="
          &lt;h2 id=&#34;1-nginx&#34;&gt;1、Nginx&lt;/h2&gt;
&lt;h3 id=&#34;11-nginx简介&#34;&gt;1.1 Nginx简介&lt;/h3&gt;
&lt;p&gt;​		Nginx (engine x) 是一个高性能的 HTTP 和反向代理服务。Nginx 是由伊戈尔·赛索耶夫&lt;br&gt;
为俄罗斯访问量第二的 Rambler.ru 站点（俄文：Рамблер）开发的，第一个公开版本 0.1.0&lt;br&gt;
发布于 2004 年 10 月 4 日。&lt;br&gt;
​		Nginx 是一个很强大的高性能 Web 和反向代理服务，它具有很多非常优越的特性：在连接高并发的情况下，Nginx 是 Apache 服务不错的替代品：Nginx 在美国是做虚拟主机生意的老板们经常选择的软件平台之一。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;12-nginx作用&#34;&gt;1.2 Nginx作用&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;http 协议代理&lt;/li&gt;
&lt;li&gt;搭建虚拟主机&lt;/li&gt;
&lt;li&gt;服务的反向代理&lt;/li&gt;
&lt;li&gt;在反向代理中配置集群的负载均衡&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-代理方式&#34;&gt;2、代理方式&lt;/h2&gt;
&lt;h3 id=&#34;21-正向代理&#34;&gt;2.1 正向代理&lt;/h3&gt;
&lt;p&gt;​		正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616173821.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;22-反向代理&#34;&gt;2.2 反向代理&lt;/h3&gt;
&lt;p&gt;​		反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616173902.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;23-二者的区别&#34;&gt;2.3 二者的区别&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;位置不同&lt;/strong&gt;&lt;br&gt;
正向代理，架设在客户机和目标主机之间；&lt;br&gt;
反向代理，架设在服务器端；&lt;br&gt;
&lt;strong&gt;代理对象不同&lt;/strong&gt;&lt;br&gt;
正向代理，代理客户端，服务端不知道实际发起请求的客户端；&lt;br&gt;
反向代理，代理服务端，客户端不知道实际提供服务的服务端；&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616173959.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;3-安装nginx&#34;&gt;3、安装Nginx&lt;/h2&gt;
&lt;h3 id=&#34;31-将nginx-安装包上传到linux-中&#34;&gt;3.1 将Nginx 安装包上传到Linux 中&lt;/h3&gt;
&lt;p&gt;​		使用的 Nginx 版本为 nginx-1.8.0.tar.gz&lt;/p&gt;
&lt;h3 id=&#34;32-nginx-安装环境&#34;&gt;3.2 nginx 安装环境&lt;/h3&gt;
&lt;p&gt;nginx 是 C 语言开发，建议在 linux 上运行&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;gcc&lt;br&gt;
安装 nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境，如果没有 gcc环境，需要安装 gcc：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;yum install gcc-c++&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616174224.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PCRE&lt;br&gt;
PCRE(Perl Compatible Regular Expressions)是一个 Perl 库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库。&lt;br&gt;
&lt;strong&gt;yum install -y pcre pcre-devel&lt;/strong&gt;&lt;br&gt;
注：pcre-devel 是使用 pcre 开发的一个二次开发库。nginx 也需要此库。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616174300.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;zlib&lt;/p&gt;
&lt;p&gt;zlib 库提供了很多种压缩和解压缩的方式，nginx 使用zlib 对http 包的内容进行gzip，所以需要在 linux 上安装 zlib 库。&lt;br&gt;
&lt;strong&gt;yum install -y zlib zlib-devel&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616174444.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;openssl&lt;br&gt;
OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。&lt;br&gt;
nginx 不仅支持 http 协议，还支持 https（即在 ssl 协议上传输 http），所以需要在linux 安装 openssl 库。&lt;br&gt;
&lt;strong&gt;yum install -y openssl openssl-devel&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616174646.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-编译安装&#34;&gt;3、编译安装&lt;/h2&gt;
&lt;p&gt;​		解压：tar -zxvf nginx-1.8.0.tar.gz&lt;/p&gt;
&lt;p&gt;​		进入到 nginx 的根目录&lt;br&gt;
​		cd nginx-1.8.0&lt;/p&gt;
&lt;h3 id=&#34;31-配置安装参数&#34;&gt;3.1 配置安装参数&lt;/h3&gt;
&lt;p&gt;./configure&lt;/p&gt;
&lt;p&gt;参数设置如下：&lt;br&gt;
./configure &lt;br&gt;
--prefix=/usr/local/nginx &lt;br&gt;
--pid-path=/var/run/nginx/nginx.pid &lt;br&gt;
--lock-path=/var/lock/nginx.lock &lt;br&gt;
--error-log-path=/var/log/nginx/error.log &lt;br&gt;
--http-log-path=/var/log/nginx/access.log &lt;br&gt;
--with-http_gzip_static_module &lt;br&gt;
--http-client-body-temp-path=/var/temp/nginx/client &lt;br&gt;
--http-proxy-temp-path=/var/temp/nginx/proxy &lt;br&gt;
--http-fastcgi-temp-path=/var/temp/nginx/fastcgi &lt;br&gt;
--http-uwsgi-temp-path=/var/temp/nginx/uwsgi &lt;br&gt;
--http-scgi-temp-path=/var/temp/nginx/scgi&lt;/p&gt;
&lt;p&gt;注意：上边将临时文件目录指定为/var/temp/nginx，需要在/var 下创建 temp 及 nginx目录&lt;/p&gt;
&lt;h3 id=&#34;32-编译安装&#34;&gt;3.2 编译安装&lt;/h3&gt;
&lt;p&gt;编译：make&lt;/p&gt;
&lt;p&gt;编译安装 make install&lt;/p&gt;
&lt;h2 id=&#34;4-操作nginx&#34;&gt;4、操作Nginx&lt;/h2&gt;
&lt;h3 id=&#34;41-启动nginx&#34;&gt;4.1 启动nginx&lt;/h3&gt;
&lt;p&gt;​		cd /usr/local/nginx/sbin/&lt;br&gt;
​		./nginx&lt;br&gt;
​		注意：执行./nginx 启动 nginx，这里可以-c 指定加载的 nginx 配置文件，如下：&lt;br&gt;
​		./nginx -c /usr/local/nginx/conf/nginx.conf&lt;br&gt;
​		如果不指定-c，nginx 在启动时默认加载 conf/nginx.conf 文件，此文件的地址也可以在编译安装 nginx 时指定./configure 的参数（--conf-path= 指向配置文件（nginx.conf））&lt;/p&gt;
&lt;h3 id=&#34;42-停止nginx&#34;&gt;4.2 停止nginx&lt;/h3&gt;
&lt;p&gt;方式 1：快速停止：&lt;br&gt;
cd /usr/local/nginx/sbin&lt;br&gt;
./nginx -s stop&lt;br&gt;
此方式相当于先查出 nginx 进程 id 再使用 kill 命令强制杀掉进程。&lt;/p&gt;
&lt;p&gt;方式 2：完整停止(建议使用)：&lt;br&gt;
cd /usr/local/nginx/sbin&lt;br&gt;
./nginx -s quit&lt;br&gt;
此方式停止步骤是待 nginx 进程处理任务完毕进行停止。&lt;/p&gt;
&lt;h3 id=&#34;43-重启nginx&#34;&gt;4.3 重启nginx&lt;/h3&gt;
&lt;p&gt;方式 1：先停止再启动（建议使用）：&lt;br&gt;
对nginx 进行重启相当于先停止nginx 再启动nginx，即先执行停止命令再执行启动命令。&lt;br&gt;
如下：&lt;br&gt;
./nginx -s quit&lt;br&gt;
./nginx&lt;/p&gt;
&lt;p&gt;方式 2：重新加载配置文件：&lt;br&gt;
当 nginx 的配置文件 nginx.conf 修改后，要想让配置生效需要重启 nginx，使用-s reload 不用先停止 nginx 再启动 nginx 即可将配置信息在 nginx 中生效，如下：&lt;br&gt;
./nginx -s reload&lt;/p&gt;
&lt;h3 id=&#34;44-测试&#34;&gt;4.4 测试&lt;/h3&gt;
&lt;p&gt;​		nginx 安装成功，启动 nginx，即可访问虚拟机上的 nginx&lt;br&gt;
​		Nginx 默认的是侦听 80 端口&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616232418.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;注：启动前记得关闭防火墙&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616232514.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;5-nginx的使用&#34;&gt;5、Nginx的使用&lt;/h2&gt;
&lt;h3 id=&#34;51-配置虚拟主机&#34;&gt;5.1 配置虚拟主机&lt;/h3&gt;
&lt;h4 id=&#34;511虚拟主机的介绍&#34;&gt;5.1.1虚拟主机的介绍&lt;/h4&gt;
&lt;p&gt;​		虚拟主机是一种特殊的软硬件技术，它可以将网络上的每一台计算机分成多个虚拟主机，每个虚拟主机可以独立对外提供 www 服务，这样就可以实现一台主机对外提供多个web 服务，每个虚拟主机之间是独立的，互不影响的。&lt;br&gt;
​		虚拟主机技术是互联网服务器采用的节省服务器硬件成本的技术，虚拟主机技术主要应用于 HTTP（Hypertext Transfer Protocol，超文本传输协议）服务，将一台服务器的某项或者全部服务内容逻辑划分为多个服务单位，对外表现为多个服务器，从而充分利用服务器硬&lt;br&gt;
件资源。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200617092815.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;512-nginx的虚拟主机配置方式&#34;&gt;5.1.2 nginx的虚拟主机配置方式&lt;/h4&gt;
&lt;p&gt;Nginx 支持三种类型的虚拟主机配置&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基于 IP 的虚拟主机&lt;/li&gt;
&lt;li&gt;基于端口的虚拟主机&lt;/li&gt;
&lt;li&gt;基于域名的虚拟主机&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;513-基于ip-的虚拟主机配置方式&#34;&gt;5.1.3 基于IP 的虚拟主机配置方式&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;需求&lt;/p&gt;
&lt;p&gt;一台 Linux 服务器绑定两个 ip:192.168.70.144、192.168.70.188&lt;br&gt;
访问不同的 ip 请求不同的 html 目录，即：&lt;br&gt;
访问 http://192.168.70.144 将访问“html144”目录下的 html 网页&lt;br&gt;
访问 http://192.168.70.188 将访问“html188”目录下的 html 网页&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建 HTML 目录&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200617093104.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Linux 绑定多 IP&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​		Linux 操作系统允许绑定多 IP。使用 IP 别名的方式，在一块物理网卡上可以绑定多个 lP地址。这样就能够在使用单一网卡的同一个服务器上运行多个基于 IP 的虚拟主机。但是在绑定多 IP 时需要将动态的 IP 分配方式修改为静态的指定 IP&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;将动态 IP 修改为静态IP&lt;/p&gt;
&lt;p&gt;cd /etc/sysconfig/network-scripts&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;IPADDR=192.168.10.144
NETMASK=255.255.255.0
GATEWAY=192.168.10.2
DNS1=114.114.114.114
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IP 绑定&lt;br&gt;
将/etc/sysconfig/network-scripts/ifcfg-eth0 文件复制一份，命名为ifcfg-eth0:1&lt;br&gt;
修改其中内容：&lt;br&gt;
DEVICE=eth0:1&lt;br&gt;
IPADDR=192.168.70.188&lt;/p&gt;
&lt;p&gt;其他项不用修改&lt;br&gt;
重启系统&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 Nginx 的配置文件完成基于 IP 的虚拟主机配置&lt;/p&gt;
&lt;p&gt;Nginx 的配置文件 nginx.conf&lt;/p&gt;
&lt;p&gt;如上述配置文件所示，主要由 6 个部分组成：&lt;br&gt;
main：用于进行 nginx 全局信息的配置&lt;br&gt;
events：用于 nginx 工作模式的配置&lt;br&gt;
http：用于进行 http 协议信息的一些配置&lt;br&gt;
server：用于进行服务器访问信息的配置&lt;br&gt;
location：用于进行访问路由的配置&lt;br&gt;
upstream：用于进行负载均衡的配置&lt;/p&gt;
&lt;p&gt;Nginx.conf:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;user root;
worker_processes 1;

#error_log logs/error.log;
#error_log logs/error.log notice;
#error_log logs/error.log info;

#pid logs/nginx.pid;

events {
worker_connections 1024;

}

http {

include mime.types;
default_type application/octet-stream;

#log_format main &#39;$remote_addr - $remote_user [$time_local] &amp;quot;$request&amp;quot; &#39;
# &#39;$status $body_bytes_sent &amp;quot;$http_referer&amp;quot; &#39;
# &#39;&amp;quot;$http_user_agent&amp;quot; &amp;quot;$http_x_forwarded_for&amp;quot;&#39;;

#access_log logs/access.log main;

sendfile on;
#tcp_nopush on;


#keepalive_timeout 0;
keepalive_timeout 65;

#gzip on;

#一个 Server 就是一个虚拟主机
server {
listen 80;
#为虚拟机指定 IP 或者是域名
server_name 192.168.70.144;

#主要配置路由访问信息
location / {
#用于指定访问根目录时，访问虚拟主机的 web 目录
root html144;
#在不指定访问具体资源时，默认的展示资源的列表
index index.html index.htm;

}

error_page 500 502 503 504 /50x.html;
location = /50x.html {
root html;

}

}

#一个 Server 就是一个虚拟主机
server {
listen 80;
#为虚拟机指定 IP 或者是域名
server_name 192.168.70.188;

#主要配置路由访问信息
location / {
#用于指定访问根目录时，访问虚拟主机的 web 目录
root html188;
#在不指定访问具体资源时，默认的展示资源的列表
index index.html index.htm;

}

error_page 500 502 503 504 /50x.html;
location = /50x.html {
root html;

}

}

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;514-基于端口的虚拟主机配置方式&#34;&gt;5.1.4 基于端口的虚拟主机配置方式&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;需求&lt;/p&gt;
&lt;p&gt;Nginx 对提供 8080 与 9090 两个端口的监听服务&lt;br&gt;
请求 8080 端口则访问 html8080 目录下的 index.html&lt;br&gt;
请求 9090 端口则访问 html9090 目录下的 index.html&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建 HTML 目录&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200617094255.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 Nginx 的配置文件完成基于端口的虚拟主机配置&lt;/p&gt;
&lt;p&gt;Nginx.conf：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;user root;
worker_processes 1;

#error_log logs/error.log;
#error_log logs/error.log notice;
#error_log logs/error.log info;

#pid logs/nginx.pid;

events {
worker_connections 1024;

}


http {

include mime.types;
default_type application/octet-stream;

#log_format main &#39;$remote_addr - $remote_user [$time_local] &amp;quot;$request&amp;quot; &#39;
# &#39;$status $body_bytes_sent &amp;quot;$http_referer&amp;quot; &#39;
# &#39;&amp;quot;$http_user_agent&amp;quot; &amp;quot;$http_x_forwarded_for&amp;quot;&#39;;

#access_log logs/access.log main;

sendfile on;
#tcp_nopush on;

#keepalive_timeout 0;
keepalive_timeout 65;

#gzip on;

#一个 Server 就是一个虚拟主机
server {
listen 80;
#为虚拟机指定 IP 或者是域名
server_name 192.168.70.144;

#主要配置路由访问信息
location / {
#用于指定访问根目录时，访问虚拟主机的 web 目录
root html144;
#在不指定访问具体资源时，默认的展示资源的列表
index index.html index.htm;

}

error_page 500 502 503 504 /50x.html;
location = /50x.html {
root html;

}

}

#一个 Server 就是一个虚拟主机
server {


listen 80;
#为虚拟机指定 IP 或者是域名
server_name 192.168.70.188;

#主要配置路由访问信息
location / {
#用于指定访问根目录时，访问虚拟主机的 web 目录
root html188;
#在不指定访问具体资源时，默认的展示资源的列表
index index.html index.htm;

}

error_page 500 502 503 504 /50x.html;
location = /50x.html {
root html;

}

}

#一个 Server 就是一个虚拟主机 基于端口
server {
listen 8080;
#为虚拟机指定 IP 或者是域名
server_name 192.168.70.188;

#主要配置路由访问信息
location / {
#用于指定访问根目录时，访问虚拟主机的 web 目录
root html8080;
#在不指定访问具体资源时，默认的展示资源的列表
index index.html index.htm;

}

error_page 500 502 503 504 /50x.html;
location = /50x.html {
root html;

}

}

#一个 Server 就是一个虚拟主机
server {


listen 9090;
#为虚拟机指定 IP 或者是域名
server_name 192.168.70.188;

#主要配置路由访问信息
location / {
#用于指定访问根目录时，访问虚拟主机的 web 目录
root html9090;
#在不指定访问具体资源时，默认的展示资源的列表
index index.html index.htm;

}

error_page 500 502 503 504 /50x.html;
location = /50x.html {
root html;

}

}

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;515-基于域名的虚拟主机配置方式&#34;&gt;5.1.5 基于域名的虚拟主机配置方式&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;两个域名指向同一个 nginx 服务器，用户访问不同的域名时显示不同的内容。&lt;br&gt;
域名规划：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;www.baidu1.com&lt;/li&gt;
&lt;li&gt;www.baidu2.com&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建 HTML 目录&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200617095000.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;修改 windows 的 hosts 文件配置域名与 ip 的映射&lt;/p&gt;
&lt;p&gt;文件路径：C:\Windows\System32\drivers\etc&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200617095443.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 Nginx 的配置文件完成基于域名的虚拟主机配置&lt;/p&gt;
&lt;p&gt;nginx.conf:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server {

listen 80;
#为虚拟机指定 IP 或者是域名
server_name www.baidu1.com;

#主要配置路由访问信息
location / {
#用于指定访问根目录时，访问虚拟主机的 web 目录
root html-baidu1;
#在不指定访问具体资源时，默认的展示资源的列表


index index.html index.htm;

}

error_page 500 502 503 504 /50x.html;
location = /50x.html {
root html;

}

}

#一个 Server 就是一个虚拟主机
server {
listen 80;
#为虚拟机指定 IP 或者是域名
server_name www.baidu2.cn;

#主要配置路由访问信息
location / {
#用于指定访问根目录时，访问虚拟主机的 web 目录
root html-baidu2;
#在不指定访问具体资源时，默认的展示资源的列表
index index.html index.htm;

}

error_page 500 502 503 504 /50x.html;
location = /50x.html {
root html;

}

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;52-nginx中配置服务的反向代理&#34;&gt;5.2 Nginx中配置服务的反向代理&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;需求&lt;/p&gt;
&lt;p&gt;安装两个 tomcat 服务，通过 nginx 反向代理。&lt;br&gt;
本案例中使用两台虚拟机演示。&lt;br&gt;
tomcat 安装到 192.168.70.143 环境中。端口为 8080 与 9090&lt;br&gt;
Nginx 安装在 192.168.70.144 环境中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装环境&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装tomcat&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200617095811.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;
&lt;p&gt;配置tomcat&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;修改端口&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200617095924.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改首页内容&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200617100050.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置Nginx 实现服务的反向代理&lt;/p&gt;
&lt;p&gt;nginx.conf&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;user root;
worker_processes 1;

#error_log logs/error.log;
#error_log logs/error.log notice;
#error_log logs/error.log info;

#pid logs/nginx.pid;

events {
worker_connections 1024;

}

http {

include mime.types;
default_type application/octet-stream;

sendfile on;
keepalive_timeout 65;

upstream tomcat_server1{
server 192.168.70.143:8080;

}

upstream tomcat_server2{
server 192.168.70.143:9090;

}

server {
listen 80;
#为虚拟机指定 IP 或者是域名
server_name www.baidu1.com;

#主要配置路由访问信息
location / {
#用于指定访问根目录时，访问虚拟主机的 web 目录
proxy_pass http://tomcat_server1;

#在不指定访问具体资源时，默认的展示资源的列表


index index.html index.htm;

}

error_page 500 502 503 504 /50x.html;
location = /50x.html {
root html;

}

}

#一个 Server 就是一个虚拟主机
server {
listen 80;
#为虚拟机指定 IP 或者是域名
server_name www.baidu2.cn;

#主要配置路由访问信息
location / {
#用于指定访问根目录时，访问虚拟主机的 web 目录
proxy_pass http://tomcat_server2;
#在不指定访问具体资源时，默认的展示资源的列表
index index.html index.htm;

}

error_page 500 502 503 504 /50x.html;
location = /50x.html {
root html;

}

}

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.3 在反向代理中配置负载均衡&lt;/p&gt;
&lt;h4 id=&#34;&#34;&gt;&lt;/h4&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;53-在反向代理中配置负载均衡&#34;&gt;5.3 在反向代理中配置负载均衡&lt;/h3&gt;
&lt;h4 id=&#34;531-什么是负载均衡&#34;&gt;5.3.1 什么是负载均衡&lt;/h4&gt;
&lt;p&gt;​		负载均衡建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。&lt;br&gt;
负载均衡，英文名称为 Load Balance，其意思就是分摊到多个操作单元上进行执行，例如 Web 服务器、FTP 服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。&lt;/p&gt;
&lt;h4 id=&#34;532-nginx-负载均衡策略&#34;&gt;5.3.2 Nginx 负载均衡策略&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;轮询（默认）&lt;br&gt;
每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down 掉，能自动剔除。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指定权重&lt;/p&gt;
&lt;p&gt;指定轮询几率，weight 和访问比率成正比，用于后端服务器性能不均的情况。&lt;br&gt;
upstream backserver {&lt;br&gt;
server 192.168.0.14 weight=10;&lt;br&gt;
server 192.168.0.15 weight=10;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IP 绑定 ip_hash&lt;br&gt;
每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器，可以解决 session 的问题。&lt;br&gt;
upstream backserver {&lt;br&gt;
ip_hash;&lt;br&gt;
server 192.168.0.14:88;&lt;br&gt;
server 192.168.0.15:80;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;h4 id=&#34;533-需求&#34;&gt;5.3.3 需求&lt;/h4&gt;
&lt;p&gt;nginx 作为负载均衡服务器，用户请求先到达 nginx，再由 nginx 根据负载配置&lt;br&gt;
将请求转发至 tomcat 服务器。&lt;br&gt;
nginx 负载均衡服务器：192.168.70.144&lt;br&gt;
tomcat1 服务器：192.168.70.143:8080&lt;br&gt;
tomcat2 服务器：192.168.70.143:9090&lt;/p&gt;
&lt;h4 id=&#34;534-nginx-的集群配置&#34;&gt;5.3.4 Nginx 的集群配置&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;节点说明：
在 http 节点里添加:

#定义负载均衡设备的Ip 及设备状态
upstream myServer {

server 127.0.0.1:9090 down;
server 127.0.0.1:8080 weight=2;
server 127.0.0.1:6060;
server 127.0.0.1:7070 backup;

}

在需要使用负载的 Server 节点下添加

proxy_pass http://myServer;

upstream 每个设备的状态:

down 表示单前的 server 暂时不参与负载
weight 默认为 1.weight 越大，负载的权重就越大
fail_timeout:次失败后，暂停的时间 默认 10s
max_fails ：允许请求失败的次数默认为 1.当超过最大次数时，返回
backup：其它所有的非 backup 机器 down 或者忙的时候，请求 backup 机器。所以这台
机器压力会最轻。

nginx.conf

user root;
worker_processes 1;

#error_log logs/error.log;
#error_log logs/error.log notice;
#error_log logs/error.log info;

#pid logs/nginx.pid;

events {
worker_connections 1024;


}

http {

include mime.types;
default_type application/octet-stream;

sendfile on;
keepalive_timeout 65;

upstream tomcat_server1{
server 192.168.70.143:8080 weight=10;
server 192.168.70.143:9090 weight=2;

}

server {
listen 80;
#为虚拟机指定 IP 或者是域名
server_name www.baidu1.com;

#主要配置路由访问信息
location / {
#用于指定访问根目录时，访问虚拟主机的 web 目录
proxy_pass http://tomcat_server1;

#在不指定访问具体资源时，默认的展示资源的列表
index index.html index.htm;

}

error_page 500 502 503 504 /50x.html;
location = /50x.html {
root html;

}

}

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;54-http-协议代理&#34;&gt;5.4 http 协议代理&lt;/h3&gt;
&lt;p&gt;​		由于 ftp服务器是基于 ftp协议处理的。那么现在我想在外部访问该图片，是没有办法访问的。他是不能处理 http协议的。所以我们需要拥有一个能够处理 http协议代理服务器。其实就是使用了 Nginx 的虚拟主机的方式。&lt;/p&gt;
">Nginx</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jonchan1013.github.io/post/git/"" data-c="
          &lt;h2 id=&#34;1-git简介&#34;&gt;1、Git简介&lt;/h2&gt;
&lt;h3 id=&#34;11-git概念&#34;&gt;1.1 Git概念&lt;/h3&gt;
&lt;p&gt;Git 是一个免费的、开源的分布式版本控制系统，可以快速高效地处理从小型到大型的项目。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;12-其他常见的版本控制工具&#34;&gt;1.2 其他常见的版本控制工具&lt;/h3&gt;
&lt;p&gt;Subversion(简称 SVN)、CVS 等&lt;/p&gt;
&lt;h3 id=&#34;13-版本控制工具的使用&#34;&gt;1.3  版本控制工具的使用&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;协同修改&lt;/p&gt;
&lt;p&gt;多人并行不悖的修改服务器端的同一个文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据备份&lt;/p&gt;
&lt;p&gt;不仅保存目录和文件的当前状态，还能够保存每一个提交过的历史状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;版本管理&lt;/p&gt;
&lt;p&gt;在保存每一个版本的文件信息的时候要做到不保存重复数据，以节约存储空间，提高运行效率。这方面 SVN 采用的是增量式管理的方式，而 Git 采取了文件系统快照的方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;权限控制&lt;/p&gt;
&lt;p&gt;对团队中参与开发的人员进行权限控制。&lt;br&gt;
对团队外开发者贡献的代码进行审核——Git 独有。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;历史记录&lt;/p&gt;
&lt;p&gt;查看修改人、修改时间、修改内容、日志信息。&lt;/p&gt;
&lt;p&gt;将本地文件恢复到某一个历史状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分支管理&lt;/p&gt;
&lt;p&gt;允许开发团队在工作过程中多条生产线同时推进任务，进一步提高效率。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;14-集中式版本控制工具及分布式版本控制工具示意图&#34;&gt;1.4 集中式版本控制工具及分布式版本控制工具示意图&lt;/h3&gt;
&lt;p&gt;集中式版本控制工具示意图：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616100540.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;分布式版本控制工具工作示意图：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616100635.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;15-git-官网&#34;&gt;1.5  Git 官网&lt;/h3&gt;
&lt;p&gt;​		https://git-scm.com/&lt;/p&gt;
&lt;h3 id=&#34;16-git的优势&#34;&gt;1.6 Git的优势&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;大部分操作在本地完成，不需要联网&lt;/li&gt;
&lt;li&gt;尽可能添加数据而不是删除或修改数据&lt;/li&gt;
&lt;li&gt;分支操作非常快捷流畅&lt;/li&gt;
&lt;li&gt;与 Linux 命令全面兼容&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;17-git-和代码托管中心&#34;&gt;1.7 Git 和代码托管中心&lt;/h3&gt;
&lt;p&gt;代码托管中心的任务：维护远程库&lt;/p&gt;
&lt;p&gt;局域网环境下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GitLab 服务器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;外网环境下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GitHub&lt;/li&gt;
&lt;li&gt;码云（gitee）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-git-的基本使用&#34;&gt;2、Git 的基本使用&lt;/h2&gt;
&lt;h3 id=&#34;21-安装及初始化本地仓库&#34;&gt;2.1 安装及初始化本地仓库&lt;/h3&gt;
&lt;p&gt;​		安装完成后打开 Git Bash 窗口&lt;br&gt;
​		输入 git --version 输出版本信息证明安装成功&lt;br&gt;
​		填写用户名和邮箱作为一个标识&lt;/p&gt;
&lt;p&gt;​		git config --global user.name &amp;quot;用户名&amp;quot;&lt;br&gt;
​		git config --global user.email &amp;quot;邮箱地址&amp;quot;&lt;/p&gt;
&lt;p&gt;​		在本地创建一个目录作为 git 仓库，并通过 git init 命令进行初始化，初始化成功后会在当前目录生成一个.git 目录文件，不要删除及修改。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616100959.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;21-git存储流程&#34;&gt;2.1 Git存储流程&lt;/h3&gt;
&lt;p&gt;​		代码工作区---&amp;gt;执行 git add ---&amp;gt;暂存区（临时存储）---&amp;gt;执行 git commit---&amp;gt;本地库(历史版本)&lt;/p&gt;
&lt;p&gt;工作区、暂存区和本地仓库，逻辑上是本地计算机。当我们新建一个文件时，文件位于工作区，处于已修改（modified）状态，表明文件已进行了修改，但还没有提交保存；通过命令 git add 将其添加到暂存区，文件是已暂存（staged）状态，表示把已修改的文件放到&lt;br&gt;
下次提交时要保存的清单中；通过命令 git commit 将文件放入本地仓库，文件为已提交（commited）状态，表示该文件已经被安全地保存在本地数据库中，到这一步可以说是成功生成了一个新的版本。&lt;/p&gt;
&lt;p&gt;远程仓库用来将本地仓库上传到网络，实现备份、共享和合作。&lt;/p&gt;
&lt;h2 id=&#34;3-git常用命令&#34;&gt;3、Git常用命令&lt;/h2&gt;
&lt;h3 id=&#34;31-添加文件&#34;&gt;3.1 添加文件&lt;/h3&gt;
&lt;p&gt;​		git add 文件名&lt;/p&gt;
&lt;p&gt;​		将文件添加到&lt;strong&gt;暂存区&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616110447.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;32-提交文件&#34;&gt;3.2 提交文件&lt;/h3&gt;
&lt;p&gt;​		git commit -m &amp;quot;提交注释&amp;quot;&lt;/p&gt;
&lt;p&gt;​		将文件提交到&lt;strong&gt;本地仓库&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616110701.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;33-查看状态&#34;&gt;3.3 查看状态&lt;/h3&gt;
&lt;p&gt;​		git status&lt;br&gt;
​		查看目录中是否还有文件未提交&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616110903.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;34-查看文件修改对比差异&#34;&gt;3.4 查看文件修改对比差异&lt;/h3&gt;
&lt;p&gt;​		git diff&lt;br&gt;
​		比较文件差异&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616111012.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;		git diff  文件名&lt;br&gt;
将工作区中的文件和暂存区进行比较&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616111046.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;35-查看日志&#34;&gt;3.5 查看日志&lt;/h3&gt;
&lt;p&gt;​		git log&lt;br&gt;
​		查看历史记录，显示从最近到最远的日志&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616111129.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;36-简化显示&#34;&gt;3.6 简化显示&lt;/h3&gt;
&lt;p&gt;​		git log --pretty=oneline&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616111446.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;37-查看简短日志&#34;&gt;3.7 查看简短日志&lt;/h3&gt;
&lt;p&gt;​		git reflog&lt;br&gt;
​		查看历史记录，并以简短信息显示&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616111542.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​		HEAD@{移动到当前版本需要多少步}&lt;/p&gt;
&lt;h3 id=&#34;38-前进回退&#34;&gt;3.8 前进回退&lt;/h3&gt;
&lt;p&gt;​		git reset --hard 局部版本号&lt;br&gt;
​		前进后退版本&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616112006.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;39-删除文件&#34;&gt;3.9 删除文件&lt;/h3&gt;
&lt;p&gt;​		rm 文件名&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616112239.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;391-彻底删除&#34;&gt;3.9.1 彻底删除&lt;/h3&gt;
&lt;p&gt;​		将文件添加到缓存区中，然后提交。&lt;/p&gt;
&lt;h3 id=&#34;310-恢复文件&#34;&gt;3.10 恢复文件&lt;/h3&gt;
&lt;p&gt;​		对于删除文件也可使用 reset 命令恢复&lt;br&gt;
​		如果删除文件后未提交可以使用 git checkout -- [文件名]恢复&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616113301.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;311-分支操作&#34;&gt;3.11 分支操作&lt;/h3&gt;
&lt;p&gt;​		在版本回退那里，已经知道每次提交，git 都会把他们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在 git 里，这个分支叫主分支，即 master。切换分支即可以理解为切换时间线。&lt;/p&gt;
&lt;p&gt;​		在版本控制过程中，使用多条线同时推进多个任务。每条线成为一个分支。&lt;/p&gt;
&lt;p&gt;例如：&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616113945.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;3111-创建分支&#34;&gt;3.11.1 创建分支&lt;/h4&gt;
&lt;p&gt;​		git branch 分支名&lt;/p&gt;
&lt;h4 id=&#34;3112-查看分支&#34;&gt;3.11.2 查看分支&lt;/h4&gt;
&lt;p&gt;​		git branch –v&lt;/p&gt;
&lt;h4 id=&#34;3113-切换分支&#34;&gt;3.11.3 切换分支&lt;/h4&gt;
&lt;p&gt;​		git checkout 分支名&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616123009.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;3114-合并分支mergerebase&#34;&gt;3.11.4 合并分支（merge/rebase）&lt;/h4&gt;
&lt;p&gt;​		第一步：切换到接受合并的分支&lt;br&gt;
​						git checkout 接受合并的分支名&lt;br&gt;
​		第二步：执行 merge 命令&lt;br&gt;
​						git merge 待合并的分支名&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616123204.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;3115-删除分支命令&#34;&gt;3.11.5 删除分支命令&lt;/h4&gt;
&lt;p&gt;​			git branch –d 分支名&lt;/p&gt;
&lt;h2 id=&#34;4-远程仓库操作以码云为例&#34;&gt;4、远程仓库操作（以码云为例）&lt;/h2&gt;
&lt;h3 id=&#34;41-在码云注册账号&#34;&gt;4.1 在码云注册账号&lt;/h3&gt;
&lt;p&gt;​		地址： https://gitee.com/&lt;/p&gt;
&lt;h3 id=&#34;42-创建-ssh-key&#34;&gt;4.2 创建 SSH key&lt;/h3&gt;
&lt;p&gt;​		因为数据保存在远程服务器，服务器需要对你的身份进行识别，SSH key 可以让你的电脑和码云之间建立安全的加密连接。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;运行命令 ssh-keygen -t rsa -C &amp;quot;你的邮箱&amp;quot;,会有三次提示输入，直接回车即可。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616141511.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;在用户目录下生成 .ssh 目录，里面有一个 id_rsa.pub 文件，保存的就是公钥。&lt;/p&gt;
&lt;p&gt;​		登录码云，在 SSH 公钥文本框里粘贴 id_rsa.pub 文件的内容&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616141941.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;18&#34;&gt;&lt;img src=&#34;C:%5CUsers%5CCY%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200616142238298.png&#34; alt=&#34;image-20200616142238298&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;19&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616142257.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;43-验证秘钥是否添加成功&#34;&gt;4.3 验证秘钥是否添加成功&lt;/h3&gt;
&lt;p&gt;​		执行命令 ssh -T git@git.oschina.net&lt;/p&gt;
&lt;p&gt;​		Git 使用 SSH 连接第一次验证服务器的 key 时，需要你进行确认，此时输入 yes 回车即可。&lt;/p&gt;
&lt;p&gt;​		再次执行 ssh -T git@git.oschina.net&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;20&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616142426.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;44-创建远程仓库&#34;&gt;4.4 创建远程仓库&lt;/h3&gt;
&lt;p&gt;​		在码云中新建仓库&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;21&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616142510.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;45-克隆远程仓库到本地&#34;&gt;4.5 克隆远程仓库到本地&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;22&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616142647.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;复制远程仓库地址&lt;/li&gt;
&lt;li&gt;在 bash 窗口中执行    git clone  复制的地址   ，回车&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;23&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616142937.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;进入克隆目录，添加新文件&lt;/li&gt;
&lt;li&gt;执行 git add . 将工作区所有内容上传到暂存区&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;24&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616143243.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;执行 git commit -m ‘本次提交的注释’ 提交到本地仓库&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;25&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616143411.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;执行     git push 别名  分支名   其中别名和分支名可省略。将本地仓库所有内容上传到远程仓库码云 ，码云刷新可看到最新内容&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;26&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616143523.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;27&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616143935.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;git pull 拉取远程库内容&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;28&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616144150.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;5-远程库扩展操作&#34;&gt;5、远程库扩展操作&lt;/h2&gt;
&lt;h3 id=&#34;51-创建远程库地址别名&#34;&gt;5.1 创建远程库地址别名&lt;/h3&gt;
&lt;p&gt;​		git remote -v 查看当前所有远程地址别名&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;29&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616144307.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​		git remote add  别名  远程地址         增加远程地址&lt;br&gt;
​		git remote remove 别名              删除远程地址&lt;/p&gt;
&lt;h3 id=&#34;52-解决冲突&#34;&gt;5.2 解决冲突&lt;/h3&gt;
&lt;p&gt;要点：&lt;br&gt;
如果不是基于 GitHub 远程库的最新版所做的修改，不能推送，必须先拉取。&lt;br&gt;
拉取下来后如果进入冲突状态，则修改-&amp;gt;add-&amp;gt;commit 即可。&lt;/p&gt;
&lt;h3 id=&#34;53-远程仓库邀请成员&#34;&gt;5.3 远程仓库邀请成员&lt;/h3&gt;
&lt;p&gt;​		设置-&amp;gt;数据管理-&amp;gt;私有仓库成员-&amp;gt;选中仓库-&amp;gt;邀请成员&lt;/p&gt;
&lt;h2 id=&#34;6-git常用命令集&#34;&gt;6、Git常用命令集&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;mkdir： XX（创建一个空目录 XX 指目录名）
pwd： 显示当前目录的路径
git init 把当前的目录变成可以管理的 git 仓库，生成隐藏的.git 文件。
git add XX 把 XX 文件添加到暂存区。
git commit -m “XX” 提交文件 -m 后面的是注释
git status 查看仓库状态
git diff XX 查看 XX 文件修改了哪些内容
git log 查看历史记录
git reset -hard HEAD^ 或者 git reset -hard HEAD~ 回退到上一个版本（如果想回退到 100个版本，使用 git reset -hard HEAD~100）
cat XX 查看 XX 文件内容
git reflog 查看历史记录的版本号 id
git checkout --XX 把 XX 文件在工作区的修改全部撤销
git rm XX 删除 XX 文件
git remote add origin https://gitee.com/oldlu_wk/gittest.git 关联一个远程库
git push -u （第一次提交要用-u 以后不需要）origin master 把当前 master 分支推送到远
程库
git clone https://gitee.com/oldlu_wk/gittest.git 从远程库中克隆
git checkout -b dev 创建 dev 分支 并切换到 dev 分支上
git branch 查看当前所有分支
git checkout master 切换回 master 分支
git merge dev 在当前分支上合并 dev 分支
git branch -d dev 删除 dev 分支
git branch name 创建分支
git stash 把当前的工作隐藏起来等以后恢复现场后继续工作
git stash list 查看所有被隐藏的文件列表
git stash apply 恢复被隐藏的文件，但是内容不删除
git stash drop 删除文件
git stash pop 恢复文件的同时也删除文件
git remote 查看远程库的信息
git remote -v 查看远程库的详细信息
git push origin master Git 会把 master 分支推送到远程库对应的远程分支上
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;7-idea-中操作-git&#34;&gt;7、IDEA 中操作 Git&lt;/h2&gt;
&lt;h3 id=&#34;71-使用-idea-提交代码&#34;&gt;7.1 使用 IDEA 提交代码&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在 idea 中配置 git 路径&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;30&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616154539.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在远程仓库上创建仓库&lt;/p&gt;
&lt;p&gt;​	创建本地仓库&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;31&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616154734.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;32&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616154930.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​		红色表示未管理&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;将项目添加到缓存&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;33&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616155102.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;34&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616155150.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​		这时会变成绿色，表示已加入到缓存&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;
&lt;p&gt;提交项目&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;35&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616155509.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提交并上传&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;36&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616155548.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;37&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616155656.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​		此时为正常颜色意思是已提交到本地仓库&lt;/p&gt;
&lt;p&gt;​		注：蓝色意思为本地仓库有这文件，但add后未提交（只要在idea中任意一文件做出add，后续修改了改文件，idea会自动帮我们add）&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;添加远程仓库地址&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;38&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616160611.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;39&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616160650.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;
&lt;p&gt;查看上传状态&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;40&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616161330.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​	如果上传时出现 Push rejected: Push to origin/master was rejected，是因为本地和远程版本冲突&lt;/p&gt;
&lt;p&gt;解决办法：&lt;br&gt;
1.选择你要上传代码的文件夹，鼠标右键 git Bash Here&lt;br&gt;
2.输入下面两行命令&lt;br&gt;
git pull origin master --allow-unrelated-histories    --把远程仓库中的内容 pull 到本地工作目录&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;41&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616161543.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​		git push -u origin master -f          --在 pull 下来的项目中做修改，通过以上命令 push 到远程仓库了&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;42&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616161723.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;新建文件会提示：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;43&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616162102.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​		提交文件：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;44&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616162131.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​		可以选择提交并push&lt;/p&gt;
&lt;p&gt;​		&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616162310.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;72-在-idea-中用-git-获取新项目代码&#34;&gt;7.2 在 idea 中用 git 获取新项目代码&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;45&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616164233.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;输入远程仓库地址，克隆远程仓库&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;46&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616164302.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;73-解决冲突&#34;&gt;7.3 解决冲突&lt;/h3&gt;
&lt;h4 id=&#34;731-产生冲突的原因&#34;&gt;7.3.1 产生冲突的原因&lt;/h4&gt;
&lt;p&gt;​		冲突产生的根本原因是：两个人修改了同一个文件的同一块区域，在前者已经提交代码到远程仓库的情况下，后者修改代码前没有使用 pull 命令更新代码，而是修改完代码后再使用 pull 命令，这时就会产生冲突。这也是最常见的冲突，下面介绍解决冲突的办法也主要针对这种冲突。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;47&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616164517.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;732-预防冲突&#34;&gt;7.3.2 预防冲突&lt;/h4&gt;
&lt;p&gt;​		在修改代码前，使用 pull 命令更新代码，能够保证在开始修改代码前本地的代码与远程仓库中的版本一致，这样能够大大降低冲突发生的概率。&lt;/p&gt;
&lt;h4 id=&#34;733-解决冲突&#34;&gt;7.3.3 解决冲突&lt;/h4&gt;
&lt;p&gt;​		按照图片中的步骤，顺序不能乱，先 stash，然后 pull，最后 unstash&lt;br&gt;
第一步：暂存代码，idea 会恢复到上次更新后的代码，将修改的代码隔离出去&lt;br&gt;
第二步：将远程仓库的代码拉下来&lt;/p&gt;
&lt;p&gt;第三步：将暂存的代码还原回来&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;48&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616165110.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;49&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616165209.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;50&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616165257.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;51&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616165743.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;从左至右：&lt;br&gt;
本地代码更新后的代码---&amp;gt;合并后的代码---&amp;gt;暂存文件的代码&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;52&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616165637.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">Git</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jonchan1013.github.io/post/mybatis/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616022004.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;1-简介&#34;&gt;1、简介&lt;/h2&gt;
&lt;h3 id=&#34;11-什么是mybatis&#34;&gt;1.1、什么是Mybatis&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;MyBatis 是一款优秀的&lt;strong&gt;持久层框架&lt;/strong&gt;，它支持定制化 SQL、存储过程以及高级映射。&lt;/li&gt;
&lt;li&gt;MyBatis 避免了几乎所有的&lt;strong&gt;JDBC 代码&lt;/strong&gt;和&lt;strong&gt;手动设置参数以及获取结果集&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;12-持久化&#34;&gt;1.2 持久化&lt;/h3&gt;
&lt;p&gt;持久化是将程序数据在持久状态和瞬时状态间转换的机制。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的的主要应用是将内存中的对象存储在数据库中，或者存储在磁盘文件中，xml数据文件中等等。&lt;/li&gt;
&lt;li&gt;JDBC就是一种持久化机制，文件IO也是一种持久化机制&lt;/li&gt;
&lt;li&gt;在生活中：将鲜肉冷藏，吃的时候再解冻的方法就类似与持久化&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;1-3-为什么需要持久化服务&#34;&gt;1. 3 为什么需要持久化服务？&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;是因为内存本身的缺陷引起的&lt;/li&gt;
&lt;li&gt;内存断电后数据会丢失，但有一些对象是无论如何都不能丢失的，比如银行账号等，遗憾的是，人们还无法保证内存永不掉电。&lt;/li&gt;
&lt;li&gt;内存过于昂贵，与硬盘、光盘等外存相比，内存的价格要高2~3个数量级，而且维持成本也高，至少需要一直供电吧。所以即使对象不需要永久保存，也会因为内存的容量限制不能一直呆在内存中，需要持久化来缓存到外存。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;13-持久层&#34;&gt;1.3 持久层&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;什么是持久层？&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;完成持久化工作的代码块—-&amp;gt; dao层 【DAO (Data Access Object) 数据访问对象】&lt;/li&gt;
&lt;li&gt;大多数情况下特别是企业级应用，数据持久化往往也就意味着将内存中的数据保存到磁盘上加以固化，而持久化的实现过程则大多通过各种&lt;strong&gt;关系数据库&lt;/strong&gt;来完成。&lt;/li&gt;
&lt;li&gt;不过这里有一个字需要特别强调，也就是所谓的“层”。对于应用系统而言，数据持久功能大多是必不可少的组成部分。也就是说，我们的系统中，已经天然的具备了“持久层”概念？也许是，但也许实际情况并非如此。之所以要独立出一个“持久层”的概念,而不是“持久模块”，“持久单元”，也就意味着，我们的系统架构中，应该有一个相对独立的逻辑层面，专著于数据持久化逻辑的实现.&lt;/li&gt;
&lt;li&gt;与系统其他部分相对而言，这个层面应该具有一个较为清晰和严格的逻辑边界。 【说白了就是用来操作数据库存在的！】&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;14-为什么需要mybatis&#34;&gt;1.4 为什么需要Mybatis？&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;MyBatis就是帮助程序猿将数据存入数据库中，和从数据库中取数据&lt;/li&gt;
&lt;li&gt;传统的JDBC操作，有很多重复的代码块，比如：数据取出时的封装，数据库的建立连接等等…,通过框架可以减少重复代码，提高开发的效率&lt;/li&gt;
&lt;li&gt;MyBatis 是一个半自动化的&lt;strong&gt;ORM框架 (Object Relationship Mapping) –&amp;gt;对象关系映射&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;所有的事情，不用Mybatis依旧可以做到，只是用了它，所有实现会更加简单！&lt;strong&gt;技术没有高低之分，只有使用这个技术的人有高低之别&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;15-mybatis的优点&#34;&gt;1.5 MyBatis的优点&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件就可以了，易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。&lt;/li&gt;
&lt;li&gt;灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。 sql写在xml里，便于统一管理和优化。通过sql语句可以满足操作数据库的所有需求。&lt;/li&gt;
&lt;li&gt;解除sql与程序代码的耦合：通过提供DAO层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性。&lt;/li&gt;
&lt;li&gt;提供xml标签，支持编写动态sql。&lt;/li&gt;
&lt;li&gt;………&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;最重要的一点，使用的人多！公司需要！&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-mybatis的-第一个程序&#34;&gt;2、MyBatis的 第一个程序&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;思路流程：搭建环境–&amp;gt;导入Mybatis—&amp;gt;编写代码—&amp;gt;测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码演示&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;搭建实验数据库&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;CREATE DATABASE `mybatis`;

USE `mybatis`;

DROP TABLE IF EXISTS `user`;

CREATE TABLE `user` (
  `id` int(20) NOT NULL,
  `name` varchar(30) DEFAULT NULL,
  `pwd` varchar(30) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

insert  into `user`(`id`,`name`,`pwd`) values (1,&#39;cy&#39;,&#39;123456&#39;),(2,&#39;张三&#39;,&#39;abcdef&#39;),(3,&#39;李四&#39;,&#39;987654&#39;);

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意事项：如果IDEA连接到数据库失败&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200804103844.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;解决方法:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;useJDBCCompliantTimezoneShift=true&amp;amp;useLegacyDatetimeCode=false&amp;amp;serverTimezone=UTC

&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200804103946.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;导入Mybatis相关的jar包&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.5.2&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;5.1.47&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编写MyBatis核心配置文件&lt;/p&gt;
&lt;p&gt;可以查看官方帮助文档&lt;/p&gt;
&lt;p&gt;https://mybatis.org/mybatis-3/&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE configuration
        PUBLIC &amp;quot;-//mybatis.org//DTD Config 3.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-3-config.dtd&amp;quot;&amp;gt;
&amp;lt;configuration&amp;gt;
    &amp;lt;environments default=&amp;quot;development&amp;quot;&amp;gt;
        &amp;lt;environment id=&amp;quot;development&amp;quot;&amp;gt;
            &amp;lt;transactionManager type=&amp;quot;JDBC&amp;quot;/&amp;gt;
            &amp;lt;dataSource type=&amp;quot;POOLED&amp;quot;&amp;gt;
                &amp;lt;property name=&amp;quot;driver&amp;quot; value=&amp;quot;com.mysql.jdbc.Driver&amp;quot;/&amp;gt;
                &amp;lt;property name=&amp;quot;url&amp;quot; value=&amp;quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;amp;useUnicode=true&amp;amp;amp;characterEncoding=utf8&amp;quot;/&amp;gt;
                &amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;root&amp;quot;/&amp;gt;
                &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;123456&amp;quot;/&amp;gt;
            &amp;lt;/dataSource&amp;gt;
        &amp;lt;/environment&amp;gt;
    &amp;lt;/environments&amp;gt;
    &amp;lt;mappers&amp;gt;
        &amp;lt;mapper resource=&amp;quot;com/cy/dao/userMapper.xml&amp;quot;/&amp;gt;
    &amp;lt;/mappers&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编写Mybatis工具类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import java.io.IOException;
import java.io.InputStream;

public class MybatisUtils {

    private static SqlSessionFactory sqlSessionFactory;

    static {
        try {
            String resource = &amp;quot;mybatis-config.xml&amp;quot;;
            InputStream inputStream = Resources.getResourceAsStream(resource);
            sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    //获取SqlSession连接
    public static SqlSession getSession(){
        return sqlSessionFactory.openSession();
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建实体类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class User {
    
    private int id;  //id
    private String name;   //姓名
    private String pwd;   //密码
    
    //构造,有参,无参
    //set/get
    //toString()
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编写Mapper接口类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import com.cy.pojo.User;
import java.util.List;

public interface UserMapper {
    List&amp;lt;User&amp;gt; selectUser();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编写Mapper.xml配置文件&lt;/p&gt;
&lt;p&gt;namespace 十分重要，不能写错！&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper
        PUBLIC &amp;quot;-//mybatis.org//DTD Mapper 3.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&amp;quot;&amp;gt;
&amp;lt;mapper namespace=&amp;quot;com.cy.dao.UserMapper&amp;quot;&amp;gt;
  &amp;lt;select id=&amp;quot;selectUser&amp;quot; resultType=&amp;quot;com.cy.pojo.User&amp;quot;&amp;gt;
    select * from user
  &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编写测试类&lt;/p&gt;
&lt;p&gt;Junit 包测试&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MyTest {
    @Test
    public void selectUser() {
        SqlSession session = MybatisUtils.getSession();
        //方法一:
        //List&amp;lt;User&amp;gt; users = session.selectList(&amp;quot;com.cy.mapper.UserMapper.selectUser&amp;quot;);
        //方法二:
        UserMapper mapper = session.getMapper(UserMapper.class);
        List&amp;lt;User&amp;gt; users = mapper.selectUser();

        for (User user: users){
            System.out.println(user);
        }
        session.close();
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行测试&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;问题说明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可能出现问题说明：Maven静态资源过滤问题&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;build&amp;gt;
    &amp;lt;resources&amp;gt;
        &amp;lt;resource&amp;gt;
            &amp;lt;directory&amp;gt;src/main/java&amp;lt;/directory&amp;gt;
            &amp;lt;includes&amp;gt;
                &amp;lt;include&amp;gt;**/*.properties&amp;lt;/include&amp;gt;
                &amp;lt;include&amp;gt;**/*.xml&amp;lt;/include&amp;gt;
            &amp;lt;/includes&amp;gt;
            &amp;lt;filtering&amp;gt;false&amp;lt;/filtering&amp;gt;
        &amp;lt;/resource&amp;gt;
        &amp;lt;resource&amp;gt;
            &amp;lt;directory&amp;gt;src/main/resources&amp;lt;/directory&amp;gt;
            &amp;lt;includes&amp;gt;
                &amp;lt;include&amp;gt;**/*.properties&amp;lt;/include&amp;gt;
                &amp;lt;include&amp;gt;**/*.xml&amp;lt;/include&amp;gt;
            &amp;lt;/includes&amp;gt;
            &amp;lt;filtering&amp;gt;false&amp;lt;/filtering&amp;gt;
        &amp;lt;/resource&amp;gt;
    &amp;lt;/resources&amp;gt;
&amp;lt;/build&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-mybatis-crud操作&#34;&gt;3、MyBatis CRUD操作&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;关于namespace&lt;/strong&gt;&lt;br&gt;
配置文件中namespace中的名称为对应Mapper接口或者Dao接口的完整包名,必须一致&lt;/p&gt;
&lt;h3 id=&#34;31-查询-select&#34;&gt;3.1 查询 select&lt;/h3&gt;
&lt;p&gt;id&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;命名空间中唯一的标识符&lt;/li&gt;
&lt;li&gt;接口中的&lt;strong&gt;方法名&lt;/strong&gt;与映射文件中的SQL语句ID 一一对应&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;resultType&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SQL语句返回值类型。【完整的类名或者别名】&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;parameterType&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;传入SQL语句的参数类型 。【Map】&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;需求：根据id查询用户&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在UserMapper中添加对应方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface UserMapper {
    //查询全部用户
    List&amp;lt;User&amp;gt; selectUser();
    //根据id查询用户
    User selectUserById(int id);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在UserMapper.xml中添加Select语句&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;select id=&amp;quot;selectUserById&amp;quot; resultType=&amp;quot;com.cy.pojo.User&amp;quot;&amp;gt;
  select * from user where id = #{id}
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;测试类中测试&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void tsetSelectUserById() {
    SqlSession session = MybatisUtils.getSession();  //获取SqlSession连接
    UserMapper mapper = session.getMapper(UserMapper.class);
    User user = mapper.selectUserById(1);
    System.out.println(user);
    session.close();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;思路二：根据 密码 和 名字 查询用户&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用map来查询或者插入&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在接口方法中，参数直接传递Map；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;User selectUserByNP2(Map&amp;lt;String,Object&amp;gt; map);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编写sql语句的时候，需要传递参数类型，参数类型为map&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;select id=&amp;quot;selectUserByNP2&amp;quot; parameterType=&amp;quot;map&amp;quot; resultType=&amp;quot;com.cy.pojo.User&amp;quot;&amp;gt;
select * from user where name = #{username} and pwd = #{pwd}
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在使用方法的时候，Map的 key 为 sql中取的值即可，没有顺序要求！&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Map&amp;lt;String, Object&amp;gt; map = new HashMap&amp;lt;String, Object&amp;gt;();
map.put(&amp;quot;username&amp;quot;,&amp;quot;小明&amp;quot;);
map.put(&amp;quot;pwd&amp;quot;,&amp;quot;123456&amp;quot;);
User user = mapper.selectUserByNP2(map);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;如果参数过多，我们可以考虑直接使用Map实现，如果参数比较少，直接传递参数即可&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;32-插入-insert&#34;&gt;3.2 插入 insert&lt;/h3&gt;
&lt;p&gt;一般使用insert标签进行插入操作，它的配置和select标签差不多！&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在UserMapper接口中添加对应的方法&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//添加一个用户
int addUser(User user);
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;在UserMapper.xml中添加insert语句&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;insert id=&amp;quot;addUser&amp;quot; parameterType=&amp;quot;com.cy.pojo.User&amp;quot;&amp;gt;
     insert into user (id,name,pwd) values (#{id},#{name},#{pwd})
&amp;lt;/insert&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;测试&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void testAddUser() {
    SqlSession session = MybatisUtils.getSession();
    UserMapper mapper = session.getMapper(UserMapper.class);
    User user = new User(5,&amp;quot;王五&amp;quot;,&amp;quot;zxcvbn&amp;quot;);
    int i = mapper.addUser(user);
    System.out.println(i);
    session.commit(); //提交事务,重点!不写的话不会提交到数据库
    session.close();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意点：增、删、改操作需要提交事务！&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;33-改-update&#34;&gt;3.3 改 update&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;需求：修改用户的信息&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;同理，编写接口方法&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//修改一个用户
int updateUser(User user);
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;编写对应的配置文件SQL&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;update id=&amp;quot;updateUser&amp;quot; parameterType=&amp;quot;com.cy.pojo.User&amp;quot;&amp;gt;
    update user set name=#{name},pwd=#{pwd} where id = #{id}
&amp;lt;/update&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;测试&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void testUpdateUser() {
    SqlSession session = MybatisUtils.getSession();
    UserMapper mapper = session.getMapper(UserMapper.class);
    User user = mapper.selectUserById(1);
    user.setPwd(&amp;quot;asdfgh&amp;quot;);
    int i = mapper.updateUser(user);
    System.out.println(i);
    session.commit(); //提交事务,重点!不写的话不会提交到数据库
    session.close();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;34-删除-delete&#34;&gt;3.4 删除 delete&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;需求：根据id删除一个用户&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;同理，编写接口方法&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//根据id删除用户
int deleteUser(int id);
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;编写对应的配置文件SQL&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;delete id=&amp;quot;deleteUser&amp;quot; parameterType=&amp;quot;int&amp;quot;&amp;gt;
    delete from user where id = #{id}
&amp;lt;/delete&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;测试&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void testDeleteUser() {
    SqlSession session = MybatisUtils.getSession();
    UserMapper mapper = session.getMapper(UserMapper.class);
    int i = mapper.deleteUser(5);
    System.out.println(i);
    session.commit(); //提交事务,重点!不写的话不会提交到数据库
    session.close();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;小结：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有的增删改操作都需要提交事务！&lt;/li&gt;
&lt;li&gt;接口所有的普通参数，尽量都写上@Param参数，尤其是多个参数时，必须写上！&lt;/li&gt;
&lt;li&gt;有时候根据业务的需求，可以考虑使用map传递参数！&lt;/li&gt;
&lt;li&gt;为了规范操作，在SQL的配置文件中，我们尽量将Parameter参数和resultType都写上！&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;35-补充模糊查询&#34;&gt;3.5 补充：模糊查询&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;模糊查询like语句该怎么写?&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;添加java代码&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 模糊查询
List&amp;lt;User&amp;gt; getLikeUser(String value);
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;在xml中添加查询&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;select id=&amp;quot;getLikeUser&amp;quot; resultType=&amp;quot;com.cy.pojo.User&amp;quot;&amp;gt;
    select * from mybatis.user where name like #{value}
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;测试&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void getLikeUser(){
    SqlSession session = MybatisUtils.getSession();
    Mapper mapper = session.getMapper(Mapper.class);
    System.out.println(mapper.getLikeUser(&amp;quot;%李%&amp;quot;));
    session.close();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：在sql语句中拼接通配符，会引起sql注入&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;4-mybatis-resultmap&#34;&gt;4、MyBatis ResultMap&lt;/h2&gt;
&lt;h3 id=&#34;41-resultmap&#34;&gt;4.1 ResultMap&lt;/h3&gt;
&lt;p&gt;实际：&lt;strong&gt;要解决的问题：属性名和字段名不一致&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;环境：新建一个项目，将之前的项目拷贝过来&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;查询为null问题&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;查看之前数据库的字段名&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200804111303.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;java实体类的设计&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class User {

    private int id;  //id
    private String name;   //姓名
    private String password;   //密码和数据库不一样！
    
    //构造
    //set/get
    //toString()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接口&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//根据id查询用户
User selectUserById(int id);
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;mapper映射文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;select id=&amp;quot;selectUserById&amp;quot; resultType=&amp;quot;user&amp;quot;&amp;gt;
    select * from user where id = #{id}
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;测试&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void testSelectUserById() {
    SqlSession session = MybatisUtils.getSession();  //获取SqlSession连接
    UserMapper mapper = session.getMapper(UserMapper.class);
    User user = mapper.selectUserById(1);
    System.out.println(user);
    session.close();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;结果:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;User{id=1, name=&#39;cy&#39;, password=&#39;null&#39;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查询出来的&lt;strong&gt;password&lt;/strong&gt;为空，说明出现了问题&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分析：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select * from user where id = ${id}   
可以看作
select id,name,pwd from user where id = ${id}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;根本原因&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mybatis会根据这些查询的列名(会将列名转化为小写,数据库不区分大小写) , 去对应的实体类中查找相应列名的set方法设值 , 由于找不到setPwd() , 所以password返回null ; 【自动映射】&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;解决方案：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;#方案一:从数据库层面解决  为列名设置别名，别名和java实体类的属性名一致
&amp;lt;select id=&amp;quot;selectUserById&amp;quot; resultType=&amp;quot;User&amp;quot;&amp;gt;
    select id,name,pwd as password from user where id = ${}
&amp;lt;/select&amp;gt;
# 方案二：使用结果集映射-&amp;gt;ResultMap 【推荐】
&amp;lt;resultMap id=&amp;quot;UserMap&amp;quot; type=&amp;quot;User&amp;quot;&amp;gt;
    &amp;lt;!-- id为主键 --&amp;gt;
    &amp;lt;id column=&amp;quot;id&amp;quot; property=&amp;quot;id&amp;quot;/&amp;gt;
    &amp;lt;!-- column是数据库表的列名 , property是对应实体类的属性名 --&amp;gt;
    &amp;lt;result column=&amp;quot;name&amp;quot; property=&amp;quot;name&amp;quot;/&amp;gt;
    &amp;lt;result column=&amp;quot;pwd&amp;quot; property=&amp;quot;password&amp;quot;/&amp;gt;
&amp;lt;/resultMap&amp;gt;

&amp;lt;select id=&amp;quot;selectUserById&amp;quot; resultMap=&amp;quot;UserMap&amp;quot;&amp;gt;
    select id , name , pwd from user where id = #{id}
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;42-resultmap性质&#34;&gt;4.2 ResultMap性质&lt;/h3&gt;
&lt;h4 id=&#34;421-自动映射&#34;&gt;4.2.1 自动映射&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;resultMap&lt;/code&gt; 元素是 MyBatis 中最重要最强大的元素。它可以让你从 90% 的 JDBC &lt;code&gt;ResultSets&lt;/code&gt;数据提取代码中解放出来。&lt;/li&gt;
&lt;li&gt;实际上，在为一些比如连接的复杂语句编写映射代码的时候，一份 &lt;code&gt;resultMap&lt;/code&gt; 能够代替实现同等功能的长达数千行的代码。&lt;/li&gt;
&lt;li&gt;ResultMap 的设计思想是，对于简单的语句根本不需要配置显式的结果映射，而对于复杂一点的语句只需要描述它们的关系就行了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你已经见过简单映射语句的示例了，但并没有显式指定 &lt;code&gt;resultMap&lt;/code&gt;。比如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;select id=&amp;quot;selectUserById&amp;quot; resultType=&amp;quot;map&amp;quot;&amp;gt;
    select id , name , pwd 
    from user 
    where id = #{id}
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;上述语句只是简单地将所有的列映射到 &lt;code&gt;HashMap&lt;/code&gt; 的键上，这由 &lt;code&gt;resultType&lt;/code&gt; 属性指定。虽然在大部分情况下都够用，但是 HashMap 不是一个很好的模型。你的程序更可能会使用 JavaBean 或 POJO（Plain Old Java Objects，普通老式 Java 对象）作为模型。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ResultMap&lt;/code&gt; 最优秀的地方在于，虽然你已经对它相当了解了，但是根本就不需要显式地用到他们。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;422-手动映射&#34;&gt;4.2.2 手动映射&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;返回值类型为resultMap&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;select id=&amp;quot;selectUserById&amp;quot; resultMap=&amp;quot;UserMap&amp;quot;&amp;gt;
select id , name , pwd from user where id = #{id}
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;编写resultMap，实现手动映射！&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;resultMap id=&amp;quot;UserMap&amp;quot; type=&amp;quot;User&amp;quot;&amp;gt;
&amp;lt;!-- id为主键 --&amp;gt;
&amp;lt;id column=&amp;quot;id&amp;quot; property=&amp;quot;id&amp;quot;/&amp;gt;
&amp;lt;!-- column是数据库表的列名 , property是对应实体类的属性名 --&amp;gt;
&amp;lt;result column=&amp;quot;name&amp;quot; property=&amp;quot;name&amp;quot;/&amp;gt;
&amp;lt;result column=&amp;quot;pwd&amp;quot; property=&amp;quot;password&amp;quot;/&amp;gt;
&amp;lt;/resultMap&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;如果世界总是这么简单就好了。但是肯定不是的，数据库中，存在一对多，多对一的情况，我们之后会使用到一些高级的结果集映射，association，collection这些&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;5-mybatis-配置解析&#34;&gt;5、MyBatis 配置解析&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;核心配置文件&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mybatis-config.xml 系统核心配置文件&lt;/li&gt;
&lt;li&gt;MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息&lt;/li&gt;
&lt;li&gt;能配置的内容如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;configuration（配置）
    properties（属性）
    settings（设置）
    typeAliases（类型别名）
    typeHandlers（类型处理器）
    objectFactory（对象工厂）
    plugins（插件）
    environments（环境配置）
        environment（环境变量）
            transactionManager（事务管理器）
            dataSource（数据源）
    databaseIdProvider（数据库厂商标识）
    mappers（映射器）
&amp;lt;!-- 注意元素节点的顺序！顺序不对会报错 --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以阅读 mybatis-config.xml 上面的dtd的头文件！&lt;/p&gt;
&lt;h3 id=&#34;51-environments元素&#34;&gt;5.1 environments元素&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;MyBatis 可以配置成适应多种环境，这种机制有助于将 SQL 映射应用于多种数据库之中&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;配置MyBatis的多套运行环境，将SQL映射到多个不同的数据库上，必须指定其中一个为默认运行环境（通过default指定）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;标准定义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;environments default=&amp;quot;development&amp;quot;&amp;gt;
  &amp;lt;environment id=&amp;quot;development&amp;quot;&amp;gt;
    &amp;lt;transactionManager type=&amp;quot;JDBC&amp;quot;&amp;gt;
      &amp;lt;property name=&amp;quot;...&amp;quot; value=&amp;quot;...&amp;quot;/&amp;gt;
    &amp;lt;/transactionManager&amp;gt;
    &amp;lt;dataSource type=&amp;quot;POOLED&amp;quot;&amp;gt;
      &amp;lt;property name=&amp;quot;driver&amp;quot; value=&amp;quot;${driver}&amp;quot;/&amp;gt;
      &amp;lt;property name=&amp;quot;url&amp;quot; value=&amp;quot;${url}&amp;quot;/&amp;gt;
      &amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;${username}&amp;quot;/&amp;gt;
      &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;${password}&amp;quot;/&amp;gt;
    &amp;lt;/dataSource&amp;gt;
  &amp;lt;/environment&amp;gt;
&amp;lt;/environments&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;511-子元素节点-事物管理器transactionmanager&#34;&gt;5.1.1 子元素节点 事物管理器（transactionManager）&lt;/h4&gt;
&lt;p&gt;在 MyBatis 中有两种类型的事务管理器（也就是 type=”[JDBC|MANAGED]”）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JDBC – 这个配置就是直接使用了 JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。&lt;/li&gt;
&lt;li&gt;MANAGED – 这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将 closeConnection 属性设置为 false 来阻止它默认的关闭行为。例如:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;transactionManager type=&amp;quot;MANAGED&amp;quot;&amp;gt;
  &amp;lt;property name=&amp;quot;closeConnection&amp;quot; value=&amp;quot;false&amp;quot;/&amp;gt;
&amp;lt;/transactionManager&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;提示&lt;/strong&gt;: 如果你正在使用 Spring + MyBatis，则没有必要配置事务管理器， 因为 Spring 模块会使用自带的管理器来覆盖前面的配置。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;详情：&lt;a href=&#34;http://www.mybatis.org/mybatis-3/zh/configuration.html#environments&#34;&gt;点击查看官方文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;512-子元素节点-数据源datasource&#34;&gt;5.1.2 子元素节点 &lt;strong&gt;数据源（dataSource）&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;作用：连接数据库 –&amp;gt;dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。&lt;/li&gt;
&lt;li&gt;有三种内建的数据源类型 &lt;strong&gt;type=”[UNPOOLED|POOLED|JNDI]”）&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;UNPOOLED&lt;/strong&gt;– 这个数据源的实现只是每次被请求时打开和关闭连接。虽然有点慢，但对于在数据库连接可用性方面没有太高要求的简单应用程序来说，是一个很好的选择。 不同的数据库在性能方面的表现也是不一样的，对于某些数据库来说，使用连接池并不重要，这个配置就很适合这种情形。UNPOOLED 类型的数据源具有以下属性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;POOLED&lt;/strong&gt;– 这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。 这是一种使得并发 Web 应用快速响应请求的流行处理方式。&lt;strong&gt;(默认的)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;JNDI&lt;/strong&gt; – 这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。这种数据源配置只需要两个属性：&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;数据源也有很多第三方的实现，比如dbcp，c3p0，druid等等….&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;52properties优化&#34;&gt;5.2.Properties优化&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://www.mybatis.org/mybatis-3/zh/configuration.html#properties&#34;&gt;官方文档链接&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;properties resource=&amp;quot;org/mybatis/example/config.properties&amp;quot;&amp;gt;
  &amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;dev_user&amp;quot;/&amp;gt;
  &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;F2Fa3!33TYyg&amp;quot;/&amp;gt;
&amp;lt;/properties&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如何优化：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一步 ; 在资源目录下新建一个db.properties&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;driver=com.mysql.jdbc.Driver
url=jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8
username=root
password=123456
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;第二步 : 将文件properties导入到mybatisconfig.xml 配置文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;configuration&amp;gt;
    &amp;lt;!--导入properties文件--&amp;gt;
    &amp;lt;properties resource=&amp;quot;db.properties&amp;quot;/&amp;gt;

    &amp;lt;environments default=&amp;quot;development&amp;quot;&amp;gt;
        &amp;lt;environment id=&amp;quot;development&amp;quot;&amp;gt;
            &amp;lt;transactionManager type=&amp;quot;JDBC&amp;quot;/&amp;gt;
            &amp;lt;dataSource type=&amp;quot;POOLED&amp;quot;&amp;gt;
                &amp;lt;property name=&amp;quot;driver&amp;quot; value=&amp;quot;${driver}&amp;quot;/&amp;gt;
                &amp;lt;property name=&amp;quot;url&amp;quot; value=&amp;quot;${url}&amp;quot;/&amp;gt;
                &amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;${username}&amp;quot;/&amp;gt;
                &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;${password}&amp;quot;/&amp;gt;
            &amp;lt;/dataSource&amp;gt;
        &amp;lt;/environment&amp;gt;
    &amp;lt;/environments&amp;gt;
    &amp;lt;mappers&amp;gt;
        &amp;lt;mapper resource=&amp;quot;mapper/UserMapper.xml&amp;quot;/&amp;gt;
    &amp;lt;/mappers&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;配置文件优先级问题 【properties优先级高】&lt;/li&gt;
&lt;li&gt;新特性：使用占位符&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;53-typealiases优化&#34;&gt;5.3 typeAliases优化&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;作用：类型别名是为 Java 类型设置一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--方式一：--&amp;gt;
&amp;lt;!--配置别名,注意顺序--&amp;gt;
&amp;lt;typeAliases&amp;gt;
  &amp;lt;typeAlias alias=&amp;quot;Author&amp;quot; type=&amp;quot;domain.blog.Author&amp;quot;/&amp;gt;
  &amp;lt;typeAlias alias=&amp;quot;Blog&amp;quot; type=&amp;quot;domain.blog.Blog&amp;quot;/&amp;gt;
  &amp;lt;typeAlias alias=&amp;quot;Comment&amp;quot; type=&amp;quot;domain.blog.Comment&amp;quot;/&amp;gt;
  &amp;lt;typeAlias alias=&amp;quot;Post&amp;quot; type=&amp;quot;domain.blog.Post&amp;quot;/&amp;gt;
  &amp;lt;typeAlias alias=&amp;quot;Section&amp;quot; type=&amp;quot;domain.blog.Section&amp;quot;/&amp;gt;
  &amp;lt;typeAlias alias=&amp;quot;Tag&amp;quot; type=&amp;quot;domain.blog.Tag&amp;quot;/&amp;gt;
&amp;lt;/typeAliases&amp;gt;
&amp;lt;!--方式二：--&amp;gt;
&amp;lt;!--配置别名,注意顺序--&amp;gt;
&amp;lt;typeAliases&amp;gt;
  &amp;lt;package name=&amp;quot;domain.blog&amp;quot;/&amp;gt;
&amp;lt;/typeAliases&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;每一个在包 &lt;code&gt;domain.blog&lt;/code&gt; 中的 Java Bean&lt;/li&gt;
&lt;li&gt;在没有注解的情况下，会使用 Bean 的&lt;strong&gt;首字母小写&lt;/strong&gt;的非限定类名来作为它的别名。&lt;/li&gt;
&lt;li&gt;比如 &lt;code&gt;domain.blog.Author&lt;/code&gt; 的别名为&lt;code&gt;author&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;若有注解，则别名为其注解值。见下面的例子：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//注解指定别名
@Alias(&amp;quot;author&amp;quot;)
public class Author {
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;54-设置settings&#34;&gt;5.4 设置（settings）&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://www.mybatis.org/mybatis-3/zh/configuration.html#settings&#34;&gt;设置（settings）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;懒加载 （lazyLoadingEnabled）&lt;/li&gt;
&lt;li&gt;日志实现 （logImpl）&lt;/li&gt;
&lt;li&gt;缓存开启关闭 （cacheEnabled）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;一个配置完整的 settings 元素的示例如下：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;settings&amp;gt;
  &amp;lt;setting name=&amp;quot;cacheEnabled&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
  &amp;lt;setting name=&amp;quot;lazyLoadingEnabled&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
  &amp;lt;setting name=&amp;quot;multipleResultSetsEnabled&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
  &amp;lt;setting name=&amp;quot;useColumnLabel&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
  &amp;lt;setting name=&amp;quot;useGeneratedKeys&amp;quot; value=&amp;quot;false&amp;quot;/&amp;gt;
  &amp;lt;setting name=&amp;quot;autoMappingBehavior&amp;quot; value=&amp;quot;PARTIAL&amp;quot;/&amp;gt;
  &amp;lt;setting name=&amp;quot;autoMappingUnknownColumnBehavior&amp;quot; value=&amp;quot;WARNING&amp;quot;/&amp;gt;
  &amp;lt;setting name=&amp;quot;defaultExecutorType&amp;quot; value=&amp;quot;SIMPLE&amp;quot;/&amp;gt;
  &amp;lt;setting name=&amp;quot;defaultStatementTimeout&amp;quot; value=&amp;quot;25&amp;quot;/&amp;gt;
  &amp;lt;setting name=&amp;quot;defaultFetchSize&amp;quot; value=&amp;quot;100&amp;quot;/&amp;gt;
  &amp;lt;setting name=&amp;quot;safeRowBoundsEnabled&amp;quot; value=&amp;quot;false&amp;quot;/&amp;gt;
  &amp;lt;setting name=&amp;quot;mapUnderscoreToCamelCase&amp;quot; value=&amp;quot;false&amp;quot;/&amp;gt;
  &amp;lt;setting name=&amp;quot;localCacheScope&amp;quot; value=&amp;quot;SESSION&amp;quot;/&amp;gt;
  &amp;lt;setting name=&amp;quot;jdbcTypeForNull&amp;quot; value=&amp;quot;OTHER&amp;quot;/&amp;gt;
  &amp;lt;setting name=&amp;quot;lazyLoadTriggerMethods&amp;quot; value=&amp;quot;equals,clone,hashCode,toString&amp;quot;/&amp;gt;
&amp;lt;/settings&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;55-映射器mappers&#34;&gt;5.5 映射器（mappers）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;映射器 : 定义映射SQL语句文件&lt;/li&gt;
&lt;li&gt;首先我们需要告诉 MyBatis 到哪里去找到这些语句。 Java 在自动查找这方面没有提供一个很好的方法，所以最佳的方式是告诉 MyBatis 到哪里去找映射文件。&lt;/li&gt;
&lt;li&gt;完全限定资源定位符&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- 方式一 --&amp;gt;
&amp;lt;!-- 使用相对于类路径的资源引用 --&amp;gt;
&amp;lt;mappers&amp;gt;
  &amp;lt;mapper resource=&amp;quot;org/mybatis/builder/AuthorMapper.xml&amp;quot;/&amp;gt;
  &amp;lt;mapper resource=&amp;quot;org/mybatis/builder/BlogMapper.xml&amp;quot;/&amp;gt;
  &amp;lt;mapper resource=&amp;quot;org/mybatis/builder/PostMapper.xml&amp;quot;/&amp;gt;
&amp;lt;/mappers&amp;gt;

&amp;lt;!-- 方式二 --&amp;gt;
&amp;lt;!-- 使用映射器接口实现类的完全限定类名
	需要配置文件名称和接口名称一致，并且位于同一目录下 --&amp;gt;
&amp;lt;mappers&amp;gt;
  &amp;lt;mapper class=&amp;quot;org.mybatis.builder.AuthorMapper&amp;quot;/&amp;gt;
  &amp;lt;mapper class=&amp;quot;org.mybatis.builder.BlogMapper&amp;quot;/&amp;gt;
  &amp;lt;mapper class=&amp;quot;org.mybatis.builder.PostMapper&amp;quot;/&amp;gt;
&amp;lt;/mappers&amp;gt;

&amp;lt;!-- 方式三 --&amp;gt;
&amp;lt;!-- 将包内的映射器接口实现全部注册为映射器
但是需要配置文件名称和接口名称一致，并且位于同一目录下 --&amp;gt;
&amp;lt;mappers&amp;gt;
  &amp;lt;package name=&amp;quot;org.mybatis.builder&amp;quot;/&amp;gt;
&amp;lt;/mappers&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;6-mybatis-生命周期和作用域&#34;&gt;6、MyBatis 生命周期和作用域&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;理解我们目前已经讨论过的不同作用域和生命周期类是至关重要的，因为错误的使用会导致非常严重的并发问题。&lt;/li&gt;
&lt;li&gt;画一个流程图，分析一下Mybatis的执行过程！&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200804114031.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;a href=&#34;https://mybatis.org/mybatis-3/zh/getting-started.html&#34;&gt;官方说明&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;61-sqlsessionfactorybuilder&#34;&gt;6.1 SqlSessionFactoryBuilder&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。&lt;/li&gt;
&lt;li&gt;局部方法变量&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;62-sqlsessionfactory&#34;&gt;6.2 SqlSessionFactory&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;SqlSessionFactory 可以被认为是一个数据库连接池，它的作用是创建 SqlSession 接口对象。&lt;/li&gt;
&lt;li&gt;因为 MyBatis 的本质就是 Java 对数据库的操作，所以 SqlSessionFactory 的生命周期存在于整个 MyBatis 的应用之中，所以一旦创建了 SqlSessionFactory，就要长期保存它，直至不再使用 MyBatis 应用&lt;/li&gt;
&lt;li&gt;因此 SqlSessionFactory 的最佳作用域是应用作用域&lt;/li&gt;
&lt;li&gt;最简单的就是使用单例模式或者静态单例模式。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;63-sqlsession&#34;&gt;6.3 SqlSession&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;连接到连接池的一个请求！&lt;/li&gt;
&lt;li&gt;它的最佳的作用域是请求或方法作用域。&lt;/li&gt;
&lt;li&gt;如果你现在正在使用一种 Web 框架，要考虑 SqlSession 放在一个和 HTTP 请求对象相似的作用域中。 换句话说，每次收到的 HTTP 请求，就可以打开一个 SqlSession，返回一个响应，就关闭它。 这个关闭操作是很重要的。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200804114047.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;7-mybatis-使用注解开发&#34;&gt;7、MyBatis 使用注解开发&lt;/h2&gt;
&lt;h3 id=&#34;71-面向接口编程&#34;&gt;7.1 面向接口编程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;真正的开发中，很多时候我们会选择面向接口编程&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;根本原因 : 解耦 , 可拓展 , 提高复用 , 分层开发中 , 上层不用管具体的实现 , 大家都遵守共同的标准 , 使得开发变得容易 , 规范性更好&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在一个面向对象的系统中，系统的各种功能是由许许多多的不同对象协作完成的。在这种情况下，各个对象内部是如何实现自己的,对系统设计人员来讲就不那么重要了&lt;/li&gt;
&lt;li&gt;而各个对象之间的协作关系则成为系统设计的关键。小到不同类之间的通信，大到各模块之间的交互，在系统设计之初都是要着重考虑的，这也是系统设计的主要工作内容。面向接口编程就是指按照这种思想来编程。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;711-关于接口的理解&#34;&gt;7.1.1 关于接口的理解&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;接口从更深层次的理解，应该是定义（规范，约束）与实现（名实分离的原则）的分离&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接口的本身反映了系统设计人员对系统的抽象理解&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接口应该有两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一类是对一个个体的抽象，它可对应为一个抽象体（abstract class）;&lt;/li&gt;
&lt;li&gt;第二类是对一个个体某一方面的抽象，即形成一个抽象面（interface）;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;一个个体有可能有多个抽象面，抽象体和抽象面是有区别的&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;712-三个面向的区别&#34;&gt;7.1.2 三个面向的区别&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;面向对象：考虑问题时，以对象为单位，考虑它的属性及方法&lt;/li&gt;
&lt;li&gt;面向过程：考虑问题时，以一个具体的流程（事务过程）为单位，考虑它的实现&lt;/li&gt;
&lt;li&gt;接口设计与非接口设计是针对复用技术而言的，与面向对象（过程）不是一个问题.更多的体现就是对系统整体的架构&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;72-利用注解开发&#34;&gt;7.2 利用注解开发&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;mybatis最初配置信息是基于 XML ,映射语句(SQL)也是定义在 XML 中的。而到MyBatis 3提供了新的基于注解的配置。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不幸的是，Java 注解的的表达力和灵活性十分有限。最强大的 MyBatis 映射并不能用注解来构建&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;sql类型主要分成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;@select()&lt;/li&gt;
&lt;li&gt;@update()&lt;/li&gt;
&lt;li&gt;@Insert()&lt;/li&gt;
&lt;li&gt;@delete()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;【注意】利用注解开发就不需要mapper.xml映射文件了 .&lt;/p&gt;
&lt;p&gt;步骤1：在我们的接口中添加注解&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface Mapper {

    @Select(&amp;quot;select id,name,pwd as password from user&amp;quot;)
    List&amp;lt;User&amp;gt; getUserList();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;步骤2：在mybatis的核心配置文件中注入&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--    每一个Mapper,XML都需要在mybatis核心配置文件中注册--&amp;gt;
    &amp;lt;mappers&amp;gt;
        &amp;lt;mapper class=&amp;quot;com.cy.dao.Mapper&amp;quot;/&amp;gt;
    &amp;lt;/mappers&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;步骤3：去进行测试&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void testGetAllUser() {
    SqlSession session = MybatisUtils.getSession();
    //本质上利用了jvm的动态代理机制
    UserMapper mapper = session.getMapper(UserMapper.class);

   List&amp;lt;User&amp;gt; users = mapper.getAllUser();
    for (User user : users){
        System.out.println(user);
    }

    session.close();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Debug查看本质&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200804114721.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;本质上利用了jvm动态代理机制&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200804114731.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;MyBatis详细的执行流程&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200804114738.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;73-注解实现增删改&#34;&gt;7.3 注解实现增删改&lt;/h3&gt;
&lt;h4 id=&#34;731-自动实现提交事务&#34;&gt;7.3.1 自动实现提交事务&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//改造MybatisUtils工具类的getSession( ) 方法，重载实现。

//获取SqlSession连接
public static SqlSession getSession(){
    return getSession(true); //事务自动提交
}

public static SqlSession getSession(boolean flag){
    return sqlSessionFactory.openSession(flag);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【注意】确保实体类和数据库字段对应&lt;/p&gt;
&lt;h4 id=&#34;732-查询&#34;&gt;7.3.2 查询&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;编写接口方法注解&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//根据id查询用户
@Select(&amp;quot;select * from user where id = #{id}&amp;quot;)
User selectUserById(@Param(&amp;quot;id&amp;quot;) int id);
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;测试&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void testSelectUserById() {
    SqlSession session = MybatisUtils.getSession();
    UserMapper mapper = session.getMapper(UserMapper.class);

    User user = mapper.selectUserById(1);
    System.out.println(user);

    session.close();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;733-新增&#34;&gt;7.3.3 新增&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;编写接口方法注解&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//添加一个用户
@Insert(&amp;quot;insert into user (id,name,pwd) values (#{id},#{name},#{pwd})&amp;quot;)
int addUser(User user);
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;测试&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void testAddUser() {
    SqlSession session = MybatisUtils.getSession();
    UserMapper mapper = session.getMapper(UserMapper.class);

    User user = new User(6, &amp;quot;朱酱酱&amp;quot;, &amp;quot;123456&amp;quot;);
    mapper.addUser(user);

    session.close();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;734-修改&#34;&gt;7.3.4 修改&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;编写接口方法注解：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//修改一个用户
@Update(&amp;quot;update user set name=#{name},pwd=#{pwd} where id = #{id}&amp;quot;)
int updateUser(User user);
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;测试&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void testUpdateUser() {
    SqlSession session = MybatisUtils.getSession();
    UserMapper mapper = session.getMapper(UserMapper.class);

    User user = new User(6, &amp;quot;朱酱酱帅&amp;quot;, &amp;quot;zxcvbn&amp;quot;);
    mapper.updateUser(user);

    session.close();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;735-删除&#34;&gt;7.3.5 删除&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;编写接口方法注解&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//根据id删除用
@Delete(&amp;quot;delete from user where id = #{id}&amp;quot;)
int deleteUser(@Param(&amp;quot;id&amp;quot;)int id);
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;测试&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void testDeleteUser() {
    SqlSession session = MybatisUtils.getSession();
    UserMapper mapper = session.getMapper(UserMapper.class);

    mapper.deleteUser(6);
    
    session.close();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【注意点：增删改一定记得对事务的处理】&lt;/p&gt;
&lt;h3 id=&#34;74-关于param&#34;&gt;7.4 关于@Param&lt;/h3&gt;
&lt;p&gt;采用#{}的方式把@Param注解括号内的参数进行引用&lt;/p&gt;
&lt;p&gt;当以下面的方式进行写SQL语句时：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  @Select(&amp;quot;select column from table where userid = #{userid} &amp;quot;)
   public int selectColumn(int userid);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当你使用了使用@Param注解来声明参数时，如果使用 #{} 或 ${} 的方式都可以。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  @Select(&amp;quot;select column from table where userid = ${userid} &amp;quot;)
   public int selectColumn(@Param(&amp;quot;userid&amp;quot;) int userid);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当你不使用@Param注解来声明参数时，必须使用使用 #{}方式。如果使用 ${} 的方式，会报错。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  @Select(&amp;quot;select column from table where userid = ${userid} &amp;quot;)
   public int selectColumn(@Param(&amp;quot;userid&amp;quot;) int userid);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;@Param注解用于给方法参数起一个名字。以下是总结的使用原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在方法只接受一个参数的情况下，可以不使用@Param&lt;/li&gt;
&lt;li&gt;在方法接受多个参数的情况下，建议一定要使用@Param注解给参数命名&lt;/li&gt;
&lt;li&gt;如果参数是JavaBean，则不能使用@Param&lt;/li&gt;
&lt;li&gt;不使用@Param注解时，参数只能有一个，并且是Javabean&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;75-关于和的区别&#34;&gt;7.5 关于#和$的区别&lt;/h3&gt;
&lt;p&gt;1）#{}是预编译处理(推荐使用)，${}是字符串替换。&lt;/p&gt;
&lt;p&gt;2）MyBatis在处理#{}时，会将SQL中的#{}替换为?号，使用PreparedStatement的set方法来赋值；MyBatis在处理 $ { } 时，就是把 ${ } 替换成变量的值。&lt;/p&gt;
&lt;p&gt;3）使用 #{} 可以有效的防止SQL注入，提高系统安全性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;select id=&amp;quot;selectPerson&amp;quot; parameterType=&amp;quot;int&amp;quot; resultType=&amp;quot;hashmap&amp;quot;&amp;gt;
  SELECT * FROM PERSON WHERE ID = #{id}
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个语句名为 selectPerson，接受一个 int（或 Integer）类型的参数，并返回一个 HashMap 类型的对象，其中的键是列名，值便是结果行中的对应值。&lt;/p&gt;
&lt;p&gt;注意参数符号：#{id}&lt;/p&gt;
&lt;p&gt;这就告诉 MyBatis 创建一个预处理语句（PreparedStatement）参数，在 JDBC 中，这样的一个参数在 SQL 中会由一个“?”来标识，并被传递到一个新的预处理语句中，就像这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 近似的 JDBC 代码，非 MyBatis 代码...
String selectPerson = &amp;quot;SELECT * FROM PERSON WHERE ID = ?&amp;quot;;
PreparedStatement ps = conn.prepareStatement(selectPerson);
ps.setInt(1,id);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;8-mybatis-日志和分页的实现&#34;&gt;8、MyBatis 日志和分页的实现&lt;/h2&gt;
&lt;h3 id=&#34;81日志的实现&#34;&gt;8.1日志的实现&lt;/h3&gt;
&lt;h4 id=&#34;811为什么需要日志&#34;&gt;8.1.1为什么需要日志？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;以往的开发过程，我们会经常使用到debug模式来调节，跟踪我们的代码执行过程。&lt;/li&gt;
&lt;li&gt;但是现在使用Mybatis是基于接口，配置文件的源代码执行过程。因此，我们必须选择日志工具来作为我们开发，调节程序的工具。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Mybatis内置的日志工厂提供日志功能，具体的日志实现有以下几种工具：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SLF4J&lt;/li&gt;
&lt;li&gt;Apache Commons Logging&lt;/li&gt;
&lt;li&gt;Log4j 2&lt;/li&gt;
&lt;li&gt;Log4j&lt;/li&gt;
&lt;li&gt;JDK logging&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;812-标准日志的实现&#34;&gt;8.1.2 标准日志的实现&lt;/h4&gt;
&lt;p&gt;指定MyBatis应该是用那个日志记录实现。如果此设置不存在，则会自动发现日志记录实现。&lt;/p&gt;
&lt;p&gt;实现方式：在resource文件夹下的mybatisconfig.xml添加&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;settings&amp;gt;
        &amp;lt;setting name=&amp;quot;logImpl&amp;quot; value=&amp;quot;STDOUT_LOGGING&amp;quot;/&amp;gt;
&amp;lt;/settings&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;日志输出结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;E:\jdk1.8\bin\java.exe -ea -Didea.test.cyclic.buffer.size=1048576 &amp;quot;-javaagent:E:\IntelliJ IDEA 2019.1\lib\idea_rt.jar=54966:E:\IntelliJ IDEA 2019.1\bin&amp;quot; -Dfile.encoding=UTF-8 -classpath &amp;quot;E:\IntelliJ IDEA 2019.1\lib\idea_rt.jar;E:\IntelliJ IDEA 2019.1\plugins\junit\lib\junit-rt.jar;E:\IntelliJ IDEA 2019.1\plugins\junit\lib\junit5-rt.jar;E:\jdk1.8\jre\lib\charsets.jar;E:\jdk1.8\jre\lib\deploy.jar;E:\jdk1.8\jre\lib\ext\access-bridge-64.jar;E:\jdk1.8\jre\lib\ext\cldrdata.jar;E:\jdk1.8\jre\lib\ext\dnsns.jar;E:\jdk1.8\jre\lib\ext\jaccess.jar;E:\jdk1.8\jre\lib\ext\jfxrt.jar;E:\jdk1.8\jre\lib\ext\localedata.jar;E:\jdk1.8\jre\lib\ext\nashorn.jar;E:\jdk1.8\jre\lib\ext\sunec.jar;E:\jdk1.8\jre\lib\ext\sunjce_provider.jar;E:\jdk1.8\jre\lib\ext\sunmscapi.jar;E:\jdk1.8\jre\lib\ext\sunpkcs11.jar;E:\jdk1.8\jre\lib\ext\zipfs.jar;E:\jdk1.8\jre\lib\javaws.jar;E:\jdk1.8\jre\lib\jce.jar;E:\jdk1.8\jre\lib\jfr.jar;E:\jdk1.8\jre\lib\jfxswt.jar;E:\jdk1.8\jre\lib\jsse.jar;E:\jdk1.8\jre\lib\management-agent.jar;E:\jdk1.8\jre\lib\plugin.jar;E:\jdk1.8\jre\lib\resources.jar;E:\jdk1.8\jre\lib\rt.jar;E:\MyBatis-study\MyBatis-04\target\test-classes;E:\MyBatis-study\MyBatis-04\target\classes;E:\maven_local_repo\mysql\mysql-connector-java\5.1.46\mysql-connector-java-5.1.46.jar;E:\maven_local_repo\org\mybatis\mybatis\3.5.2\mybatis-3.5.2.jar;E:\maven_local_repo\junit\junit\4.13\junit-4.13.jar;E:\maven_local_repo\org\hamcrest\hamcrest-core\1.3\hamcrest-core-1.3.jar&amp;quot; com.intellij.rt.execution.junit.JUnitStarter -ideVersion5 -junit4 daoTest,getUserByID
Logging initialized using &#39;class org.apache.ibatis.logging.stdout.StdOutImpl&#39; adapter.
PooledDataSource forcefully closed/removed all connections.
PooledDataSource forcefully closed/removed all connections.
PooledDataSource forcefully closed/removed all connections.
PooledDataSource forcefully closed/removed all connections.
Opening JDBC Connection
Created connection 1375995437.
Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@5204062d]
==&amp;gt;  Preparing: select * from mybatis.user where id = ? 
==&amp;gt; Parameters: 1(Integer)
&amp;lt;==    Columns: id, name, pwd
&amp;lt;==        Row: 1, cy, 123456
&amp;lt;==      Total: 1
User{id=1, name=&#39;cy&#39;, password=&#39;null&#39;}
Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@5204062d]
Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@5204062d]
Returned connection 1375995437 to pool.

Process finished with exit code 0
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;813-log4j的实现&#34;&gt;8.1.3 Log4j的实现&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;简介：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Log4j是Apache的一个开源项目&lt;/li&gt;
&lt;li&gt;通过使用Log4j，我们可以控制日志信息输送的目的地：控制台，文本，GUI组件….&lt;/li&gt;
&lt;li&gt;我们也可以控制每一条日志的输出格式；&lt;/li&gt;
&lt;li&gt;这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;使用步骤&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;导入log4j的包(pom.xml中)&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;log4j&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;log4j&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.2.17&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;编写配置文件（在resource文件夹下新建log4j.properties）&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码
log4j.rootLogger=DEBUG,console,file

#控制台输出的相关设置
log4j.appender.console = org.apache.log4j.ConsoleAppender
log4j.appender.console.Target = System.out
log4j.appender.console.Threshold=DEBUG
log4j.appender.console.layout = org.apache.log4j.PatternLayout
log4j.appender.console.layout.ConversionPattern=[%c]-%m%n

#文件输出的相关设置
log4j.appender.file = org.apache.log4j.RollingFileAppender
log4j.appender.file.File=./log/cy.log
log4j.appender.file.MaxFileSize=10mb
log4j.appender.file.Threshold=DEBUG
log4j.appender.file.layout=org.apache.log4j.PatternLayout
log4j.appender.file.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n

#日志输出级别
log4j.logger.org.mybatis=DEBUG
log4j.logger.java.sql=DEBUG
log4j.logger.java.sql.Statement=DEBUG
log4j.logger.java.sql.ResultSet=DEBUG
log4j.logger.java.sql.PreparedStatement=DEBUG
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Setting设置日志实现&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;settings&amp;gt;
    &amp;lt;setting name=&amp;quot;logImpl&amp;quot; value=&amp;quot;LOG4J&amp;quot;/&amp;gt;
&amp;lt;/settings&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;在程序中实现Log4j进行输出&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//注意导包：org.apache.log4j.Logger
static Logger logger = Logger.getLogger(MyTest.class);

@Test
public void selectUser() {
    logger.info(&amp;quot;info：进入selectUser方法&amp;quot;);
    logger.debug(&amp;quot;debug：进入selectUser方法&amp;quot;);
    logger.error(&amp;quot;error: 进入selectUser方法&amp;quot;);
    SqlSession session = MybatisUtils.getSession();
    UserMapper mapper = session.getMapper(UserMapper.class);
    List&amp;lt;User&amp;gt; users = mapper.selectUser();
    for (User user: users){
        System.out.println(user);
    }
    session.close();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;E:\jdk1.8\bin\java.exe -ea -Didea.test.cyclic.buffer.size=1048576 &amp;quot;-javaagent:E:\IntelliJ IDEA 2019.1\lib\idea_rt.jar=55311:E:\IntelliJ IDEA 2019.1\bin&amp;quot; -Dfile.encoding=UTF-8 -classpath &amp;quot;E:\IntelliJ IDEA 2019.1\lib\idea_rt.jar;E:\IntelliJ IDEA 2019.1\plugins\junit\lib\junit-rt.jar;E:\IntelliJ IDEA 2019.1\plugins\junit\lib\junit5-rt.jar;E:\jdk1.8\jre\lib\charsets.jar;E:\jdk1.8\jre\lib\deploy.jar;E:\jdk1.8\jre\lib\ext\access-bridge-64.jar;E:\jdk1.8\jre\lib\ext\cldrdata.jar;E:\jdk1.8\jre\lib\ext\dnsns.jar;E:\jdk1.8\jre\lib\ext\jaccess.jar;E:\jdk1.8\jre\lib\ext\jfxrt.jar;E:\jdk1.8\jre\lib\ext\localedata.jar;E:\jdk1.8\jre\lib\ext\nashorn.jar;E:\jdk1.8\jre\lib\ext\sunec.jar;E:\jdk1.8\jre\lib\ext\sunjce_provider.jar;E:\jdk1.8\jre\lib\ext\sunmscapi.jar;E:\jdk1.8\jre\lib\ext\sunpkcs11.jar;E:\jdk1.8\jre\lib\ext\zipfs.jar;E:\jdk1.8\jre\lib\javaws.jar;E:\jdk1.8\jre\lib\jce.jar;E:\jdk1.8\jre\lib\jfr.jar;E:\jdk1.8\jre\lib\jfxswt.jar;E:\jdk1.8\jre\lib\jsse.jar;E:\jdk1.8\jre\lib\management-agent.jar;E:\jdk1.8\jre\lib\plugin.jar;E:\jdk1.8\jre\lib\resources.jar;E:\jdk1.8\jre\lib\rt.jar;E:\MyBatis-study\MyBatis-04\target\test-classes;E:\MyBatis-study\MyBatis-04\target\classes;E:\maven_local_repo\log4j\log4j\1.2.17\log4j-1.2.17.jar;E:\maven_local_repo\mysql\mysql-connector-java\5.1.46\mysql-connector-java-5.1.46.jar;E:\maven_local_repo\org\mybatis\mybatis\3.5.2\mybatis-3.5.2.jar;E:\maven_local_repo\junit\junit\4.13\junit-4.13.jar;E:\maven_local_repo\org\hamcrest\hamcrest-core\1.3\hamcrest-core-1.3.jar&amp;quot; com.intellij.rt.execution.junit.JUnitStarter -ideVersion5 -junit4 daoTest,getUserByID
[daoTest]-info:进入了selectUser方法
[daoTest]-debug:进入了selectUser方法
[daoTest]-error:进入了selectUser方法
[org.apache.ibatis.logging.LogFactory]-Logging initialized using &#39;class org.apache.ibatis.logging.log4j.Log4jImpl&#39; adapter.
[org.apache.ibatis.logging.LogFactory]-Logging initialized using &#39;class org.apache.ibatis.logging.log4j.Log4jImpl&#39; adapter.
[org.apache.ibatis.datasource.pooled.PooledDataSource]-PooledDataSource forcefully closed/removed all connections.
[org.apache.ibatis.datasource.pooled.PooledDataSource]-PooledDataSource forcefully closed/removed all connections.
[org.apache.ibatis.datasource.pooled.PooledDataSource]-PooledDataSource forcefully closed/removed all connections.
[org.apache.ibatis.datasource.pooled.PooledDataSource]-PooledDataSource forcefully closed/removed all connections.
[org.apache.ibatis.transaction.jdbc.JdbcTransaction]-Opening JDBC Connection
[org.apache.ibatis.datasource.pooled.PooledDataSource]-Created connection 673186785.
[org.apache.ibatis.transaction.jdbc.JdbcTransaction]-Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@282003e1]
[com.cy.dao.Mapper.getUserbyID]-==&amp;gt;  Preparing: select * from mybatis.user where id = ? 
[com.cy.dao.Mapper.getUserbyID]-==&amp;gt; Parameters: 1(Integer)
[com.cy.dao.Mapper.getUserbyID]-&amp;lt;==      Total: 1
User{id=1, name=&#39;cy&#39;, password=&#39;null&#39;}
[org.apache.ibatis.transaction.jdbc.JdbcTransaction]-Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@282003e1]
[org.apache.ibatis.transaction.jdbc.JdbcTransaction]-Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@282003e1]
[org.apache.ibatis.datasource.pooled.PooledDataSource]-Returned connection 673186785 to pool.

Process finished with exit code 0
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;82-分页的实现&#34;&gt;8.2 分页的实现&lt;/h3&gt;
&lt;h4 id=&#34;821-为什么需要分页&#34;&gt;8.2.1 为什么需要分页？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;在学习mybatis等持久层框架的时候，会经常对数据进行增删改查操作，使用最多的是对数据库进行查询操作&lt;/li&gt;
&lt;li&gt;如果查询大量数据的时候，我们往往使用分页进行查询，也就是每次处理小部分数据，这样对数据库压力就在可控范围内。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;822-limit实现分页&#34;&gt;8.2.2 limit实现分页&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;#语法
select * from table Limit startIndex,pageSize

#如:
SELECT * FROM table LIMIT 5,10; // 检索记录行 6-15 

#如果只给定一个参数，它表示返回最大的记录行数目：    
SELECT * FROM table LIMIT 5; //检索前 5 个记录行 

#换句话说，LIMIT n 等价于 LIMIT 0,n。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;修改Mapper文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;select id=&amp;quot;selectUser&amp;quot; parameterType=&amp;quot;map&amp;quot; resultType=&amp;quot;user&amp;quot;&amp;gt;
    select * from user limit #{startIndex},#{pageSize}
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Mapper接口修改入参为map&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//选择全部用户实现分页
List&amp;lt;User&amp;gt; selectUser(Map&amp;lt;String,Integer&amp;gt; map);
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;在测试类中传入参数&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;推断：起始位置 = （当前页面 - 1 ） * 页面大小&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import com.cy.dao.Mapper;
import com.cy.pojo.User;
import com.cy.utils.MybatisUtils;
import org.apache.ibatis.session.SqlSession;
import org.junit.Test;

import java.util.HashMap;
import java.util.List;

public class daoTest {
    @Test
    public void test(){
        SqlSession session = MybatisUtils.getSession();
        Mapper mapper = session.getMapper(Mapper.class);

        int curentPage = 1;//第几页
        int pageSize = 2;//每页显示几个

        HashMap&amp;lt;String, Integer&amp;gt; map = new HashMap&amp;lt;String, Integer&amp;gt;();
        map.put(&amp;quot;startIndex&amp;quot;,(curentPage-1)*pageSize);
        map.put(&amp;quot;pageSize&amp;quot;,pageSize);

        List&amp;lt;User&amp;gt; userList = mapper.getUserList(map);
        for (User user : userList) {
            System.out.println(user);
        }
        session.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;823-rowbounds分页&#34;&gt;8.2.3 RowBounds分页&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;除了使用Limit在SQL层面实现分页，也可以使用RowBounds在Java代码层面实现分页，&lt;/li&gt;
&lt;li&gt;当然此种方式作为了解即可。我们来看下如何实现的！&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;mapper接口&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//选择全部用户RowBounds实现分页
List&amp;lt;User&amp;gt; getUserByRowBounds();
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;mapper.xml文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;select id=&amp;quot;getUserByRowBounds&amp;quot; resultType=&amp;quot;user&amp;quot;&amp;gt;
  select * from user
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;测试类&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在这里使用RowBounds类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void testUserByRowBounds() {
    SqlSession session = MybatisUtils.getSession();

    int currentPage = 2;  //第几页
    int pageSize = 2;  //每页显示几个
    RowBounds rowBounds = new RowBounds((currentPage-1)*pageSize,pageSize);

    //通过session.**方法进行传递rowBounds，[此种方式现在已经不推荐使用了]
    List&amp;lt;User&amp;gt; users = session.selectList(&amp;quot;com.cy.mapper.UserMapper.getUserByRowBounds&amp;quot;, null, rowBounds);

    for (User user: users){
        System.out.println(user);
    }
    session.close();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;83-分页插件&#34;&gt;8.3 分页插件：&lt;/h3&gt;
&lt;p&gt;官方文档：https://pagehelper.github.io/&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200804134229.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;9-mybatis-多对一一对多处理&#34;&gt;9、MyBatis 多对一,一对多处理&lt;/h2&gt;
&lt;h3 id=&#34;91-多对一的处理&#34;&gt;9.1 多对一的处理&lt;/h3&gt;
&lt;p&gt;多对一的理解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多个学生对应一个老师&lt;/li&gt;
&lt;li&gt;如果对于学生这边，就是一个多对一的理解&lt;/li&gt;
&lt;li&gt;也就是从学生这边关联了一个老师&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;911-搭建测试环境&#34;&gt;9.1.1 搭建测试环境&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;数据库设计（环境搭建）&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;USE mybatis;
CREATE TABLE `teacher` (
  `id` INT(10) NOT NULL,
  `name` VARCHAR(30) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=INNODB DEFAULT CHARSET=utf8

INSERT INTO teacher(`id`, `name`) VALUES (1, &#39;朱老师&#39;); 

CREATE TABLE `student` (
  `id` INT(10) NOT NULL,
  `name` VARCHAR(30) DEFAULT NULL,
  `tid` INT(10) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `fktid` (`tid`),
  CONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`)
) ENGINE=INNODB DEFAULT CHARSET=utf8


INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#39;1&#39;, &#39;小明&#39;, &#39;1&#39;); 
INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#39;2&#39;, &#39;小红&#39;, &#39;1&#39;); 
INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#39;3&#39;, &#39;小张&#39;, &#39;1&#39;); 
INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#39;4&#39;, &#39;小李&#39;, &#39;1&#39;); 
INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#39;5&#39;, &#39;小王&#39;, &#39;1&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200804134450.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;912-lombok的使用&#34;&gt;9.1.2 Lombok的使用&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;IDEA安装Lombok插件【在Plugins中安装】&lt;/li&gt;
&lt;li&gt;引入maven依赖&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;1.16.10&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;在代码中增加注解(@Data)&lt;/p&gt;
&lt;p&gt;使用@Data前后对比&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200804134618.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200804134624.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Data //GET,SET,ToString，有参，无参构造
public class Teacher {
    private int id;
    private String name;
}



@Data
public class Student {
    private int id;
    private String name;
    //多个学生可以是同一个老师，即多对一
    private Teacher teacher;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;编写实体类对应的Mapper接口【两个】&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface StudentMapper {
}



public interface TeacherMapper {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;编写Mapper接口对应的mapper.xml配置文件【两个】&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper
        PUBLIC &amp;quot;-//mybatis.org//DTD Mapper 3.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&amp;quot;&amp;gt;
&amp;lt;mapper namespace=&amp;quot;com.cy.dao.TeacherMapper&amp;quot;&amp;gt;


&amp;lt;/mapper&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper
        PUBLIC &amp;quot;-//mybatis.org//DTD Mapper 3.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&amp;quot;&amp;gt;
&amp;lt;mapper namespace=&amp;quot;com.cy.dao.StudentMapper&amp;quot;&amp;gt;


&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;9121-按照查询嵌套处理&#34;&gt;9.1.2.1 按照查询嵌套处理&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;给StudentMapper接口增加方法&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//获取所有学生及对应老师的信息
public List&amp;lt;Student&amp;gt; getStudents();
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;编写对应的Mapper文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper
        PUBLIC &amp;quot;-//mybatis.org//DTD Mapper 3.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&amp;quot;&amp;gt;
&amp;lt;mapper namespace=&amp;quot;com.cy.mapper.StudentMapper&amp;quot;&amp;gt;

    &amp;lt;!--
    需求：获取所有学生及对应老师的信息
    思路：
        1. 获取所有学生的信息
        2. 根据获取的学生信息的老师ID-&amp;gt;获取该老师的信息
        3. 思考问题，这样学生的结果集中应该包含老师，该如何处理呢，数据库中我们一般使用关联查询？
            1. 做一个结果集映射：StudentTeacher
            2. StudentTeacher结果集的类型为 Student
            3. 学生中老师的属性为teacher，对应数据库中为tid。
               多个 [1,...）学生关联一个老师=&amp;gt; 一对一，一对多
            4. 查看官网找到：association – 一个复杂类型的关联；使用它来处理关联查询
    --&amp;gt;
    &amp;lt;select id=&amp;quot;getStudents&amp;quot; resultMap=&amp;quot;StudentTeacher&amp;quot;&amp;gt;
      select * from student
    &amp;lt;/select&amp;gt;
    &amp;lt;resultMap id=&amp;quot;StudentTeacher&amp;quot; type=&amp;quot;Student&amp;quot;&amp;gt;
        &amp;lt;!--association关联属性  property属性名 javaType属性类型 column在多的一方的表中的列名--&amp;gt;
        &amp;lt;association property=&amp;quot;teacher&amp;quot;  column=&amp;quot;tid&amp;quot; javaType=&amp;quot;Teacher&amp;quot; select=&amp;quot;getTeacher&amp;quot;/&amp;gt;
    &amp;lt;/resultMap&amp;gt;
    &amp;lt;!--
    这里传递过来的id，只有一个属性的时候，下面可以写任何值
    association中column多参数配置：
        column=&amp;quot;{key=value,key=value}&amp;quot;
        其实就是键值对的形式，key是传给下个sql的取值名称，value是片段一中sql查询的字段名。
    --&amp;gt;
    &amp;lt;select id=&amp;quot;getTeacher&amp;quot; resultType=&amp;quot;teacher&amp;quot;&amp;gt;
        select * from teacher where id = #{id}
    &amp;lt;/select&amp;gt;

&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;在配置文件中 ，注册Mapper&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注意点说明&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;resultMap id=&amp;quot;StudentTeacher&amp;quot; type=&amp;quot;Student&amp;quot;&amp;gt;
    &amp;lt;!--association关联属性  property属性名 javaType属性类型 column在多的一方的表中的列名--&amp;gt;
    &amp;lt;association property=&amp;quot;teacher&amp;quot;  column=&amp;quot;{id=tid,name=tid}&amp;quot; javaType=&amp;quot;Teacher&amp;quot; select=&amp;quot;getTeacher&amp;quot;/&amp;gt;
&amp;lt;/resultMap&amp;gt;
&amp;lt;!--
这里传递过来的id，只有一个属性的时候，下面可以写任何值
association中column多参数配置：
    column=&amp;quot;{key=value,key=value}&amp;quot;
    其实就是键值对的形式，key是传给下个sql的取值名称，value是片段一中sql查询的字段名。
--&amp;gt;
&amp;lt;select id=&amp;quot;getTeacher&amp;quot; resultType=&amp;quot;teacher&amp;quot;&amp;gt;
    select * from teacher where id = #{id} and name = #{name}
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;测试&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void testGetStudents(){
    SqlSession session = MybatisUtils.getSession();
    StudentMapper mapper = session.getMapper(StudentMapper.class);

    List&amp;lt;Student&amp;gt; students = mapper.getStudents();

    for (Student student : students){
        System.out.println(
                &amp;quot;学生名:&amp;quot;+ student.getName()
                        +&amp;quot;\t老师:&amp;quot;+student.getTeacher().getName());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;9122-按照结果嵌套处理&#34;&gt;9.1.2.2 按照结果嵌套处理&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;编写接口方法&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public List&amp;lt;Student&amp;gt; getStudents2();
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;编写对应的Mapper文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--
按查询结果嵌套处理
思路：
    1. 直接查询出结果，进行结果集的映射
--&amp;gt;
&amp;lt;select id=&amp;quot;getStudents2&amp;quot; resultMap=&amp;quot;StudentTeacher2&amp;quot; &amp;gt;
    select s.id sid, s.name sname , t.name tname
    from student s,teacher t
    where s.tid = t.id
&amp;lt;/select&amp;gt;

&amp;lt;resultMap id=&amp;quot;StudentTeacher2&amp;quot; type=&amp;quot;Student&amp;quot;&amp;gt;
    &amp;lt;id property=&amp;quot;id&amp;quot; column=&amp;quot;sid&amp;quot;/&amp;gt;
    &amp;lt;result property=&amp;quot;name&amp;quot; column=&amp;quot;sname&amp;quot;/&amp;gt;
    &amp;lt;!--关联对象property 关联对象在Student实体类中的属性--&amp;gt;
    &amp;lt;association property=&amp;quot;teacher&amp;quot; javaType=&amp;quot;Teacher&amp;quot;&amp;gt;
        &amp;lt;result property=&amp;quot;name&amp;quot; column=&amp;quot;tname&amp;quot;/&amp;gt;
    &amp;lt;/association&amp;gt;
&amp;lt;/resultMap&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;去mybatis-config文件中注入&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void testGetStudents2(){
    SqlSession session = MybatisUtils.getSession();
    StudentMapper mapper = session.getMapper(StudentMapper.class);

    List&amp;lt;Student&amp;gt; students = mapper.getStudents2();

    for (Student student : students){
        System.out.println(
                &amp;quot;学生名:&amp;quot;+ student.getName()
                        +&amp;quot;\t老师:&amp;quot;+student.getTeacher().getName());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;小结:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按照查询进行嵌套就像SQL中的子查询&lt;/li&gt;
&lt;li&gt;按照结果进行嵌套就想SQL中的联表查询&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;92-一对多处理&#34;&gt;9.2 一对多处理&lt;/h3&gt;
&lt;p&gt;一对多的理解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个老师拥有多个学生&lt;/li&gt;
&lt;li&gt;对于老师这边，就是一个一个一对多的现象，即从一个老师下面拥有一群学生（集合）&lt;/li&gt;
&lt;li&gt;collection集合&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;921-搭建测试环境&#34;&gt;9.2.1 搭建测试环境&lt;/h4&gt;
&lt;p&gt;实体类的编写：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Data
public class Student {
    private int id;
    private String name;
    private int tid;
}
@Data 
public class Teacher {
    private int id;
    private String name;
    //一个老师多个学生
    private List&amp;lt;Student&amp;gt; students;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;9211-按照结果嵌套处理&#34;&gt;9.2.1.1 按照结果嵌套处理&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;TeacherMapper接口编写方法&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//获取指定老师，及老师下的所有学生
public Teacher getTeacher(int id);
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;编写Mapper配置文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper
        PUBLIC &amp;quot;-//mybatis.org//DTD Mapper 3.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&amp;quot;&amp;gt;
&amp;lt;mapper namespace=&amp;quot;com.cy.dao.TeacherMapper&amp;quot;&amp;gt;

&amp;lt;!--思路：
    1.从学生表和老师表中查出学生id,学生姓名，老师姓名
    2.从查询出来的结果上做结果集映射
      1.集合的话，使用collection
      2.javaType和ofType都是用来指定对象类型的
      3.JavaType是用来指定pojo中属性的类型
      4.oftype是用来以后能干涉到list集合属性中pojo的类型--&amp;gt;

    &amp;lt;select id=&amp;quot;getTeacher&amp;quot; resultMap=&amp;quot;TeacherStudent&amp;quot;&amp;gt;
        select s.id sid, s.name sname,t.name tname,t.id tid
        from student s,teacher t
        where s.tid = t.id and t.id=#{id}
    &amp;lt;/select&amp;gt;


    &amp;lt;resultMap id=&amp;quot;TeacherStudent&amp;quot; type=&amp;quot;Teacher&amp;quot;&amp;gt;
        &amp;lt;result property=&amp;quot;name&amp;quot; column=&amp;quot;tname&amp;quot;/&amp;gt;
        &amp;lt;collection property=&amp;quot;students&amp;quot; ofType=&amp;quot;Student&amp;quot;&amp;gt;
            &amp;lt;result property=&amp;quot;id&amp;quot; column=&amp;quot;sid&amp;quot;/&amp;gt;
            &amp;lt;result property=&amp;quot;name&amp;quot; column=&amp;quot;sname&amp;quot;/&amp;gt;
            &amp;lt;result property=&amp;quot;tid&amp;quot; column=&amp;quot;tid&amp;quot;/&amp;gt;
        &amp;lt;/collection&amp;gt;
    &amp;lt;/resultMap&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;将Mapper文件注册到MyBatis-config文件中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void testGetTeacher(){
    SqlSession session = MybatisUtils.getSession();
    TeacherMapper mapper = session.getMapper(TeacherMapper.class);
    Teacher teacher = mapper.getTeacher(1);
    System.out.println(teacher.getName());
    System.out.println(teacher.getStudents());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;9212-按照嵌套处理&#34;&gt;9.2.1.2 按照嵌套处理&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;TeacherMapper接口编写方法&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Teacher getTeacher2(int id);
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;编写接口对应的Mapper配置文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;select id=&amp;quot;getTeacher2&amp;quot; resultMap=&amp;quot;TeacherStudent2&amp;quot;&amp;gt;
  select * from teacher where id = #{id}
&amp;lt;/select&amp;gt;
&amp;lt;resultMap id=&amp;quot;TeacherStudent2&amp;quot; type=&amp;quot;Teacher&amp;quot;&amp;gt;
    &amp;lt;!--column是一对多的外键 , 写的是一的主键的列名--&amp;gt;
    &amp;lt;collection property=&amp;quot;students&amp;quot; javaType=&amp;quot;ArrayList&amp;quot; ofType=&amp;quot;Student&amp;quot; column=&amp;quot;id&amp;quot; select=&amp;quot;getStudentByTeacherId&amp;quot;/&amp;gt;
&amp;lt;/resultMap&amp;gt;
&amp;lt;select id=&amp;quot;getStudentByTeacherId&amp;quot; resultType=&amp;quot;Student&amp;quot;&amp;gt;
    select * from student where tid = #{id}
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;将Mapper文件注册到MyBatis-config文件中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void testGetTeacher2(){
    SqlSession session = MybatisUtils.getSession();
    TeacherMapper mapper = session.getMapper(TeacherMapper.class);
    Teacher teacher = mapper.getTeacher2(1);
    System.out.println(teacher.getName());
    System.out.println(teacher.getStudents());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;93-小结&#34;&gt;9.3 小结&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;关联-associtaion&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;集合-collection&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;association是用于一对一和多对一&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;collection是用于一对多的关系&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JavaType和ofType都是用来指定对象类型的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JavaType是用来指定pojo中的类型 （说白了就是返回的类名）&lt;/li&gt;
&lt;li&gt;ofType到指定的是映射到list集合属性中pojo的类型 （说白了就是泛型）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;10-mybatis-动态sql&#34;&gt;10、MyBatis 动态SQL&lt;/h2&gt;
&lt;p&gt;动态SQL 官方文档：&lt;a href=&#34;https://mybatis.org/mybatis-3/zh/dynamic-sql.html&#34;&gt;文档链接&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;101-介绍&#34;&gt;10.1 介绍&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;什么是动态SQL:就是根据不同的查询条件，自动生成不同的Sql语句&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;官网描述：
    MyBatis 的强大特性之一便是它的动态 SQL。如果你有使用 JDBC 或其它类似框架的经验，你就能体会到根据不同条件拼接 SQL 语句的痛苦。例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL 这一特性可以彻底摆脱这种痛苦。
    虽然在以前使用动态 SQL 并非一件易事，但正是 MyBatis 提供了可以被用在任意 SQL 映射语句中的强大的动态 SQL 语言得以改进这种情形。
    动态 SQL 元素和 JSTL 或基于类似 XML 的文本处理器相似。在 MyBatis 之前的版本中，有很多元素需要花时间了解。MyBatis 3 大大精简了元素种类，现在只需学习原来一半的元素便可。MyBatis 采用功能强大的基于 OGNL 的表达式来淘汰其它大部分元素。
    
    -------------------------------
    - if
    - choose (when, otherwise)
    - trim (where, set)
    - foreach
    -------------------------------
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;之前写的 SQL 语句都比较简单，如果有比较复杂的业务，我们需要写复杂的 SQL 语句，往往需要拼接，而拼接 SQL ，稍微不注意，由于引号，空格等缺失可能都会导致错误。&lt;/li&gt;
&lt;li&gt;那么怎么去解决这个问题呢？这就要使用 mybatis 动态SQL，通过 if, choose, when, otherwise, trim, where, set, foreach等标签，可组合成非常灵活的SQL语句，从而在提高 SQL 语句的准确性的同时，也大大提高了开发人员的效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;102-搭建环境&#34;&gt;10.2 搭建环境&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;新建一个数据库表&lt;/p&gt;
&lt;p&gt;字段：id，title，author，create_time，views&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;CREATE TABLE `blog` (
  `id` varchar(50) NOT NULL COMMENT &#39;博客id&#39;,
  `title` varchar(100) NOT NULL COMMENT &#39;博客标题&#39;,
  `author` varchar(30) NOT NULL COMMENT &#39;博客作者&#39;,
  `create_time` datetime NOT NULL COMMENT &#39;创建时间&#39;,
  `views` int(30) NOT NULL COMMENT &#39;浏览量&#39;
) ENGINE=InnoDB DEFAULT CHARSET=utf8
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;创建MyBatis工程&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://cy-bucket.oss-cn-beijing.aliyuncs.com/img/20200217175227.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;编写IDutil工具类&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class IDUtil {

    public static String genId(){
        return UUID.randomUUID().toString().replaceAll(&amp;quot;-&amp;quot;,&amp;quot;&amp;quot;);
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;实体类编写&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.Date;

public class Blog {

    private String id;
    private String title;
    private String author;
    private Date createTime;
    private int views;
    //set，get....
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;编写Mapper和Mapper.xml&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;public interface BlogMapper {
}
&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper
        PUBLIC &amp;quot;-//mybatis.org//DTD Mapper 3.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&amp;quot;&amp;gt;
&amp;lt;mapper namespace=&amp;quot;com.cy.dao.BlogMapper&amp;quot;&amp;gt;

&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;在MyBatis核心配置文件中，下划线驼峰自动转换&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE configuration
        PUBLIC &amp;quot;-//mybatis.org//DTD Config 3.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-3-config.dtd&amp;quot;&amp;gt;
&amp;lt;configuration&amp;gt;

    &amp;lt;properties resource=&amp;quot;db.properties&amp;quot;/&amp;gt;

    &amp;lt;settings&amp;gt;
        &amp;lt;setting name=&amp;quot;mapUnderscoreToCamelCase&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
        &amp;lt;setting name=&amp;quot;logImpl&amp;quot; value=&amp;quot;STDOUT_LOGGING&amp;quot;/&amp;gt;
    &amp;lt;/settings&amp;gt;

    &amp;lt;typeAliases&amp;gt;
        &amp;lt;package name=&amp;quot;com.cy.pojo&amp;quot;/&amp;gt;
    &amp;lt;/typeAliases&amp;gt;

    &amp;lt;environments default=&amp;quot;development&amp;quot;&amp;gt;
        &amp;lt;environment id=&amp;quot;development&amp;quot;&amp;gt;
            &amp;lt;transactionManager type=&amp;quot;JDBC&amp;quot;/&amp;gt;
            &amp;lt;dataSource type=&amp;quot;POOLED&amp;quot;&amp;gt;
                &amp;lt;property name=&amp;quot;driver&amp;quot; value=&amp;quot;${driver}&amp;quot;/&amp;gt;
                &amp;lt;property name=&amp;quot;url&amp;quot; value=&amp;quot;${url}&amp;quot;/&amp;gt;
                &amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;${username}&amp;quot;/&amp;gt;
                &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;${password}&amp;quot;/&amp;gt;
            &amp;lt;/dataSource&amp;gt;
        &amp;lt;/environment&amp;gt;
    &amp;lt;/environments&amp;gt;

&amp;lt;!--    每一个Mapper,XML都需要在mybatis核心配置文件中注册--&amp;gt;
    &amp;lt;mappers&amp;gt;
        &amp;lt;package name=&amp;quot;com.cy.dao&amp;quot;/&amp;gt;
    &amp;lt;/mappers&amp;gt;

&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;
&lt;p&gt;插入初始的数据&lt;/p&gt;
&lt;p&gt;编写一个接口&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//新增一个博客
int addBlog(Blog blog);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Mapper配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;insert id=&amp;quot;addBlog&amp;quot; parameterType=&amp;quot;blog&amp;quot;&amp;gt;
    insert into blog (id, title, author, create_time, views)
    values (#{id},#{title},#{author},#{createTime},#{views});
&amp;lt;/insert&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;初始化博客方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void addInitBlog(){
    SqlSession session = MybatisUtils.getSession();
    BlogMapper mapper = session.getMapper(BlogMapper.class);

    Blog blog = new Blog();
    blog.setId(IDUtil.genId());
    blog.setTitle(&amp;quot;Mybatis如此简单&amp;quot;);
    blog.setAuthor(&amp;quot;cy&amp;quot;);
    blog.setCreateTime(new Date());
    blog.setViews(9999);

    mapper.addBlog(blog);

    blog.setId(IDUtil.genId());
    blog.setTitle(&amp;quot;Java如此简单&amp;quot;);
    mapper.addBlog(blog);

    blog.setId(IDUtil.genId());
    blog.setTitle(&amp;quot;Spring如此简单&amp;quot;);
    mapper.addBlog(blog);

    blog.setId(IDUtil.genId());
    blog.setTitle(&amp;quot;微服务如此简单&amp;quot;);
    mapper.addBlog(blog);

    session.close();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;103-动态-if语句&#34;&gt;10.3 动态-if语句&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;需求：根据作者名字和博客名字来查询博客！如果作者名字为空，那么只根据博客名字查询，反之，则根据作者名来查询&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;编写接口类&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//需求1
List&amp;lt;Blog&amp;gt; queryBlogIf(Map map);
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;编写sql语句&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--需求1：
根据作者名字和博客名字来查询博客！
如果作者名字为空，那么只根据博客名字查询，反之，则根据作者名来查询

select * from blog where title = #{title} and author = #{author}
--&amp;gt;
&amp;lt;select id=&amp;quot;queryBlogIf&amp;quot; parameterType=&amp;quot;map&amp;quot; resultType=&amp;quot;blog&amp;quot;&amp;gt;
    select * from blog where
    &amp;lt;if test=&amp;quot;title != null&amp;quot;&amp;gt;
        title = #{title}
    &amp;lt;/if&amp;gt;
    &amp;lt;if test=&amp;quot;author != null&amp;quot;&amp;gt;
        and author = #{author}
    &amp;lt;/if&amp;gt;
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;测试&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void testQueryBlogIf(){
    SqlSession session = MybatisUtils.getSession();
    BlogMapper mapper = session.getMapper(BlogMapper.class);

    HashMap&amp;lt;String, String&amp;gt; map = new HashMap&amp;lt;String, String&amp;gt;();
    map.put(&amp;quot;title&amp;quot;,&amp;quot;Mybatis如此简单&amp;quot;);
    map.put(&amp;quot;author&amp;quot;,&amp;quot;狂神说&amp;quot;);
    List&amp;lt;Blog&amp;gt; blogs = mapper.queryBlogIf(map);

    System.out.println(blogs);

    session.close();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;会遇到以下几种情况：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 1.author 为 null的情况  正常查出
Checking to see if class com.cy.dao.BlogMapper matches criteria [is assignable to Object]
Opening JDBC Connection
Created connection 376416077.
==&amp;gt;  Preparing: select * from blog where title = ? 
==&amp;gt; Parameters: Mybatis如此简单(String)
&amp;lt;==    Columns: id, title, author, create_time, views
&amp;lt;==        Row: 62d300fbe0174864af4ebb089ff6952f, Mybatis如此简单, cy, 2020-02-17 17:51:03.0, 9999
&amp;lt;==      Total: 1
[Blog(id=62d300fbe0174864af4ebb089ff6952f, title=Mybatis如此简单, author=cy, createTime=Mon Feb 17 17:51:03 CST 2020, views=9999)]
Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@166fa74d]
Returned connection 376416077 to pool.

Process finished with exit code 0


// 2.title 为 null的情况  and导致报错
Opening JDBC Connection
Created connection 376416077.
==&amp;gt;  Preparing: select * from blog where and author = ? 
==&amp;gt; Parameters: cy(String)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;104-动态-where语句&#34;&gt;10.4 动态-where语句&lt;/h3&gt;
&lt;p&gt;修改上面的情况2：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;select id=&amp;quot;queryBlogIf&amp;quot; parameterType=&amp;quot;map&amp;quot; resultType=&amp;quot;blog&amp;quot;&amp;gt;
    select * from blog 
    &amp;lt;where&amp;gt;
        &amp;lt;if test=&amp;quot;title != null&amp;quot;&amp;gt;
            title = #{title}
        &amp;lt;/if&amp;gt;
        &amp;lt;if test=&amp;quot;author != null&amp;quot;&amp;gt;
            and author = #{author}
        &amp;lt;/if&amp;gt;
    &amp;lt;/where&amp;gt;
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个”where”标签会知道如果它包含标签中返回值的话，它就会插入一个“where”。此外，如果标签返回的内容是AND或OR开头的，则它会剔除掉。&lt;/p&gt;
&lt;h3 id=&#34;105-动态-set&#34;&gt;10.5 动态-Set&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;编写接口方法&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;int updateBlog(Map map);
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;sql配置文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--注意set是用的逗号隔开--&amp;gt;
&amp;lt;update id=&amp;quot;updateBlog&amp;quot; parameterType=&amp;quot;map&amp;quot;&amp;gt;
    update blog
      &amp;lt;set&amp;gt;
          &amp;lt;if test=&amp;quot;title != null&amp;quot;&amp;gt;
              title = #{title},
          &amp;lt;/if&amp;gt;
          &amp;lt;if test=&amp;quot;author != null&amp;quot;&amp;gt;
              author = #{author}
          &amp;lt;/if&amp;gt;
      &amp;lt;/set&amp;gt;
    where id = #{id};
&amp;lt;/update&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;测试&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//动态set测试
@Test
public void setTest(){
    SqlSession session = MybatisUtils.getSession();
    BlogMapper mapper = session.getMapper(BlogMapper.class);

    HashMap&amp;lt;String, String&amp;gt; map = new HashMap&amp;lt;String, String&amp;gt;();
    map.put(&amp;quot;title&amp;quot;,&amp;quot;动态SQL&amp;quot;);
    map.put(&amp;quot;author&amp;quot;,&amp;quot;cy&amp;quot;);
    map.put(&amp;quot;id&amp;quot;,&amp;quot;f279c70cf48d4b55a62d663610d9d541&amp;quot;);//这里的uuid要根据自己的数据库id来取

    mapper.updateBlog(map);


    session.close();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;106-动态-choose&#34;&gt;10.6 动态-choose&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;有时候，我们不想用到所有的查询条件，只想选择其中的一个，查询条件有一个满足即可，使用 choose 标签可以解决此类问题，类似于 Java 的 switch 语句&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;编写接口方法&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List&amp;lt;Blog&amp;gt; queryBlogChoose(Map map);
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;sql配置文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;select id=&amp;quot;queryBlogChoose&amp;quot; parameterType=&amp;quot;map&amp;quot; resultType=&amp;quot;blog&amp;quot;&amp;gt;
    select * from blog
    &amp;lt;where&amp;gt;
        &amp;lt;choose&amp;gt;
            &amp;lt;when test=&amp;quot;title != null&amp;quot;&amp;gt;
                 title = #{title}
            &amp;lt;/when&amp;gt;
            &amp;lt;when test=&amp;quot;author != null&amp;quot;&amp;gt;
                and author = #{author}
            &amp;lt;/when&amp;gt;
            &amp;lt;otherwise&amp;gt;
                and views = #{views}
            &amp;lt;/otherwise&amp;gt;
        &amp;lt;/choose&amp;gt;
    &amp;lt;/where&amp;gt;
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;测试类&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void testQueryBlogChoose(){
    SqlSession session = MybatisUtils.getSession();
    BlogMapper mapper = session.getMapper(BlogMapper.class);

    HashMap&amp;lt;String, Object&amp;gt; map = new HashMap&amp;lt;String, Object&amp;gt;();
    map.put(&amp;quot;title&amp;quot;,&amp;quot;Java如此简单&amp;quot;);
    map.put(&amp;quot;author&amp;quot;,&amp;quot;cy&amp;quot;);
    map.put(&amp;quot;views&amp;quot;,9999);
    List&amp;lt;Blog&amp;gt; blogs = mapper.queryBlogChoose(map);

    System.out.println(blogs);

    session.close();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;//返回的结果:只要满足第一个，后面的就不会在查了
Opening JDBC Connection
Created connection 843467284.
==&amp;gt;  Preparing: select * from blog WHERE title = ? 
==&amp;gt; Parameters: Java如此简单(String)
&amp;lt;==    Columns: id, title, author, create_time, views
&amp;lt;==        Row: 78739c74d1c04075b898648e8dba74e7, Java如此简单, cy, 2020-02-17 17:51:03.0, 1000
&amp;lt;==      Total: 1
[Blog(id=78739c74d1c04075b898648e8dba74e7, title=Java如此简单, author=cy, createTime=Mon Feb 17 17:51:03 CST 2020, views=1000)]
Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@32464a14]
Returned connection 843467284 to pool.

Process finished with exit code 0
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;107-提取sql片段&#34;&gt;10.7 提取sql片段&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;有时候可能某个 sql 语句我们用的特别多，为了增加代码的重用性，简化代码，我们需要将这些代码抽取出来，然后使用时直接调用。&lt;/li&gt;
&lt;li&gt;说白了就是代码的复用&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;提取sql片段&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;sql id=&amp;quot;if-title-author&amp;quot;&amp;gt;
    &amp;lt;if test=&amp;quot;title != null&amp;quot;&amp;gt;
        title = #{title}
    &amp;lt;/if&amp;gt;
    &amp;lt;if test=&amp;quot;author != null&amp;quot;&amp;gt;
        and author = #{author}
    &amp;lt;/if&amp;gt;
&amp;lt;/sql&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;引用sql片段&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;select id=&amp;quot;queryBlogIf&amp;quot; parameterType=&amp;quot;map&amp;quot; resultType=&amp;quot;blog&amp;quot;&amp;gt;
    select * from blog
    &amp;lt;where&amp;gt;
        &amp;lt;!-- 引用 sql 片段，如果refid 指定的不在本文件中，那么需要在前面加上 namespace --&amp;gt;
        &amp;lt;include refid=&amp;quot;if-title-author&amp;quot;&amp;gt;&amp;lt;/include&amp;gt;
        &amp;lt;!-- 在这里还可以引用其他的 sql 片段 --&amp;gt;
    &amp;lt;/where&amp;gt;
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;①、最好基于 单表来定义 sql 片段，提高片段的可重用性&lt;br&gt;
②、在 sql 片段中不要包括 where&lt;/p&gt;
&lt;h3 id=&#34;108-动态-foreach&#34;&gt;10.8 动态-foreach&lt;/h3&gt;
&lt;p&gt;将数据库中前三个数据的id修改为1,2,3；&lt;/p&gt;
&lt;p&gt;需求：我们需要查询 blog 表中 id 分别为1,2,3的博客信息&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;编写结口&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List&amp;lt;Blog&amp;gt; queryBlogForeach(Map map);
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;编写sql语句&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;select id=&amp;quot;queryBlogForeach&amp;quot; parameterType=&amp;quot;map&amp;quot; resultType=&amp;quot;blog&amp;quot;&amp;gt;
    select * from blog
    &amp;lt;where&amp;gt;
        &amp;lt;!--
        collection:指定输入对象中的集合属性
        item:每次遍历生成的对象
        open:开始遍历时的拼接字符串
        close:结束时拼接的字符串
        separator:遍历对象之间需要拼接的字符串
        select * from blog where 1=1 and (id=1 or id=2 or id=3)
      --&amp;gt;
        &amp;lt;foreach collection=&amp;quot;ids&amp;quot;  item=&amp;quot;id&amp;quot; open=&amp;quot;and (&amp;quot; close=&amp;quot;)&amp;quot; separator=&amp;quot;or&amp;quot;&amp;gt;
            id=#{id}
        &amp;lt;/foreach&amp;gt;
    &amp;lt;/where&amp;gt;
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;测试&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void testQueryBlogForeach(){
    SqlSession session = MybatisUtils.getSession();
    BlogMapper mapper = session.getMapper(BlogMapper.class);

    HashMap map = new HashMap();
    List&amp;lt;Integer&amp;gt; ids = new ArrayList&amp;lt;Integer&amp;gt;();
    ids.add(1);
    ids.add(2);
    ids.add(3);
    map.put(&amp;quot;ids&amp;quot;,ids);

    List&amp;lt;Blog&amp;gt; blogs = mapper.queryBlogForeach(map);

    System.out.println(blogs);

    session.close();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果如下：(查出前三条记录)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Opening JDBC Connection
Created connection 1904324159.
==&amp;gt;  Preparing: select * from blog WHERE ( id = ? or id = ? or id = ? ) 
==&amp;gt; Parameters: 1(Integer), 2(Integer), 3(Integer)
&amp;lt;==    Columns: id, title, author, create_time, views
&amp;lt;==        Row: 1, Mybatis如此简单, cy, 2020-02-17 17:51:03.0, 9999
&amp;lt;==        Row: 2, Java如此简单, cy, 2020-02-17 17:51:03.0, 1000
&amp;lt;==        Row: 3, Spring如此简单, cy, 2020-02-17 17:51:03.0, 9999
&amp;lt;==      Total: 3
[Blog(id=1, title=Mybatis如此简单, author=cy, createTime=Mon Feb 17 17:51:03 CST 2020, views=9999), Blog(id=2, title=Java如此简单, author=cy, createTime=Mon Feb 17 17:51:03 CST 2020, views=1000), Blog(id=3, title=Spring如此简单, author=cy, createTime=Mon Feb 17 17:51:03 CST 2020, views=9999)]
Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@7181ae3f]
Returned connection 1904324159 to pool.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;109-小结&#34;&gt;10.9 小结&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;动态sql语句的编写往往就是一个拼接的问题&lt;/li&gt;
&lt;li&gt;为了保证拼接准确，首先我们需要把原生的sql语句写出来，然后再通过mybatis动态sql对照着改&lt;/li&gt;
&lt;li&gt;要多实践才能掌握技巧&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;11-mybatis-缓存机制&#34;&gt;11、MyBatis 缓存机制&lt;/h2&gt;
&lt;h3 id=&#34;111-缓存简介&#34;&gt;11.1 缓存简介&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;什么是缓存？&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;存在内存中的临时数据。&lt;/li&gt;
&lt;li&gt;将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;为什么使用缓存？&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;减少和数据库的交互次数，减少系统开销，提高系统效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;什么样的数据能使用缓存？&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;经常查询并且不经常改变的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;112-mybatis缓存&#34;&gt;11.2 Mybatis缓存&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。&lt;/li&gt;
&lt;li&gt;MyBatis系统中默认定义了两级缓存：&lt;strong&gt;一级缓存和二级缓存&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;默认情况下，只有一级缓存开启（Sqlsession级别的缓存，也称为本地缓存）&lt;/li&gt;
&lt;li&gt;二级缓存需要手动开启和配置，他是基于namespace级别的缓存&lt;/li&gt;
&lt;li&gt;为了提高扩展性，MyBatis定义了缓存接口Cache，我们可以通过实现Cache借口来自定义二级缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;1121-一级缓存&#34;&gt;11.2.1 一级缓存&lt;/h4&gt;
&lt;p&gt;一级缓存也叫本地缓存：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;与数据库同一次会话期间查询到的数据会放在本地缓存中。&lt;/li&gt;
&lt;li&gt;以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库；&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;在mybatis中加入日志，方便测试结果&lt;/li&gt;
&lt;li&gt;编写接口方法&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//根据id查询用户
User queryUserById(@Param(&amp;quot;id&amp;quot;) int id);
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;接口对应的Mapper文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;select id=&amp;quot;queryUserById&amp;quot; resultType=&amp;quot;user&amp;quot;&amp;gt;
    select * from user where id = #{id}
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;测试&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void testQueryUserById(){
    SqlSession session = MybatisUtils.getSession();
    UserMapper mapper = session.getMapper(UserMapper.class);

    User user = mapper.queryUserById(1);
    System.out.println(user);
    User user2 = mapper.queryUserById(1);
    System.out.println(user2);
    System.out.println(user==user2);

    session.close();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;1122-二级缓存&#34;&gt;11.2.2 二级缓存&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基于namespace级别的缓存，一个命名空间，对应一个二级缓存&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;工作机制&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个会话查询一个数据，这个数据就会被放在当前会话的一级缓存中&lt;/li&gt;
&lt;li&gt;如果当前会话关闭了，这个会话对应的一级缓存就没了；但我们想要的使，会话关闭了，一级缓存中的数据被保存到二级缓存中。&lt;/li&gt;
&lt;li&gt;新的会话查询信息，就可以从二级缓存中获取内容&lt;/li&gt;
&lt;li&gt;不同的mapper查出的数据会放在自己对应的缓存（本质是一个k-v的map）中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;使用步骤&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;【官方文档:】&lt;a href=&#34;http://www.mybatis.org/mybatis-3/zh/sqlmap-xml.html#cache&#34;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;开启全局缓存【mybatis-config.xml】&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;setting name=&amp;quot;cacheEnabled&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;去每个mapper.xml中配置二级缓存【xxxMapper.xml】&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;cache/&amp;gt;

官方示例=====&amp;gt;查看官方文档
&amp;lt;cache
  eviction=&amp;quot;FIFO&amp;quot;
  flushInterval=&amp;quot;60000&amp;quot;
  size=&amp;quot;512&amp;quot;
  readOnly=&amp;quot;true&amp;quot;/&amp;gt;
这个更高级的配置创建了一个 FIFO 缓存，每隔 60 秒刷新，最多可以存储结果对象或列表的 512 个引用，而且返回的对象被认为是只读的，因此对它们进行修改可能会在不同线程中的调用者产生冲突。
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;代码测试&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;所有的实体类首先需要实现序列化接口&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void testQueryUserById(){
    SqlSession session = MybatisUtils.getSession();
    SqlSession session2 = MybatisUtils.getSession();

    UserMapper mapper = session.getMapper(UserMapper.class);
    UserMapper mapper2 = session2.getMapper(UserMapper.class);

    User user = mapper.queryUserById(1);
    System.out.println(user);
    session.close();

    User user2 = mapper2.queryUserById(1);
    System.out.println(user2);
    System.out.println(user==user2);

    session2.close();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;1123-结论&#34;&gt;11.2.3 结论&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;只要开启了二级缓存，在同一个mapper下查询，可以在二级缓存中拿到数据&lt;/li&gt;
&lt;li&gt;查出的数据都被先被默认保存在一级缓存中&lt;/li&gt;
&lt;li&gt;只有会话提交或者关闭后，一级缓存的数据才会转到二级缓存中&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;113-缓存的原理&#34;&gt;11.3 缓存的原理&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200804140908.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;缓存的顺序： 二级缓存-&amp;gt;一级缓存-&amp;gt;查询数据库&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;114-自定义缓存&#34;&gt;11.4 自定义缓存&lt;/h3&gt;
&lt;p&gt;第三方缓存实现–EhCache: 查看百度百科&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ehcache是一种广泛使用的java分布式缓存，用于通用缓存；&lt;/li&gt;
&lt;li&gt;要在应用程序中使用Ehcache，需要引入依赖的jar包&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-ehcache --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.mybatis.caches&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mybatis-ehcache&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.1.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;在mapper.xml中使用对应的缓存即可&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;mapper namespace = “org.acme.FooMapper” &amp;gt; 
    &amp;lt;cache type = “org.mybatis.caches.ehcache.EhcacheCache” /&amp;gt; 
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;编写ehcache.xml文件，如果在&lt;code&gt;加载时&lt;/code&gt;未找到&lt;code&gt;/ehcache.xml&lt;/code&gt;资源或出现问题，则将使用默认配置。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;ehcache xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
         xsi:noNamespaceSchemaLocation=&amp;quot;http://ehcache.org/ehcache.xsd&amp;quot;
         updateCheck=&amp;quot;false&amp;quot;&amp;gt;
    &amp;lt;!--
       diskStore：为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下：
       user.home – 用户主目录
       user.dir  – 用户当前工作目录
       java.io.tmpdir – 默认临时文件路径
     --&amp;gt;
    &amp;lt;diskStore path=&amp;quot;./tmpdir/Tmp_EhCache&amp;quot;/&amp;gt;
    
    &amp;lt;defaultCache
            eternal=&amp;quot;false&amp;quot;
            maxElementsInMemory=&amp;quot;10000&amp;quot;
            overflowToDisk=&amp;quot;false&amp;quot;
            diskPersistent=&amp;quot;false&amp;quot;
            timeToIdleSeconds=&amp;quot;1800&amp;quot;
            timeToLiveSeconds=&amp;quot;259200&amp;quot;
            memoryStoreEvictionPolicy=&amp;quot;LRU&amp;quot;/&amp;gt;
 
    &amp;lt;cache
            name=&amp;quot;cloud_user&amp;quot;
            eternal=&amp;quot;false&amp;quot;
            maxElementsInMemory=&amp;quot;5000&amp;quot;
            overflowToDisk=&amp;quot;false&amp;quot;
            diskPersistent=&amp;quot;false&amp;quot;
            timeToIdleSeconds=&amp;quot;1800&amp;quot;
            timeToLiveSeconds=&amp;quot;1800&amp;quot;
            memoryStoreEvictionPolicy=&amp;quot;LRU&amp;quot;/&amp;gt;
    &amp;lt;!--
       defaultCache：默认缓存策略，当ehcache找不到定义的缓存时，则使用这个缓存策略。只能定义一个。
     --&amp;gt;
    &amp;lt;!--
      name:缓存名称。
      maxElementsInMemory:缓存最大数目
      maxElementsOnDisk：硬盘最大缓存个数。
      eternal:对象是否永久有效，一但设置了，timeout将不起作用。
      overflowToDisk:是否保存到磁盘，当系统当机时
      timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。
      timeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。
      diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false.
      diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。
      diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。
      memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。
      clearOnFlush：内存数量最大时是否清除。
      memoryStoreEvictionPolicy:可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。
      FIFO，first in first out，这个是大家最熟的，先进先出。
      LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。
      LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。
   --&amp;gt;

&amp;lt;/ehcache&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;12-springboot整合mybatis&#34;&gt;12、SpringBoot整合MyBatis&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;导入 MyBatis 所需要的依赖&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.1.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;配置数据库连接信息（不变）&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;spring:
  datasource:
    username: root
    password: 123456
    #?serverTimezone=UTC解决时区的报错
    url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf-8
    driver-class-name: com.mysql.cj.jdbc.Driver
    type: com.alibaba.druid.pool.DruidDataSource

    #Spring Boot 默认是不注入这些属性值的，需要自己绑定
    #druid 数据源专有配置
    initialSize: 5
    minIdle: 5
    maxActive: 20
    maxWait: 60000
    timeBetweenEvictionRunsMillis: 60000
    minEvictableIdleTimeMillis: 300000
    validationQuery: SELECT 1 FROM DUAL
    testWhileIdle: true
    testOnBorrow: false
    testOnReturn: false
    poolPreparedStatements: true

    #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入
    #如果允许时报错  java.lang.ClassNotFoundException: org.apache.log4j.Priority
    #则导入 log4j 依赖即可，Maven 地址：https://mvnrepository.com/artifact/log4j/log4j
    filters: stat,wall,log4j
    maxPoolPreparedStatementPerConnectionSize: 20
    useGlobalDataSourceStat: true
    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;测试数据库是否连接成功！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建实体类并导入lombook!&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class User {

    private int id;
    private String pwd;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;创建Mapper目录以及对应的Mapper接口&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import com.cy.pojo.User;
import org.apache.ibatis.annotations.Mapper;
import org.springframework.stereotype.Repository;

import java.util.List;

//这个注解表示了这是一个mybatis的mapper类:Dao
@Mapper
@Repository
public interface UserMapper {
//    public static final int age = 18;

    List&amp;lt;User&amp;gt; queryUserlist();

    User queryUserById(int id);

    int addUser(User user);

    int updateUser(User user);

    int deleteUser(int id);

}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;对应的Mapper映射文件（放在resources/mapper/UserMapper.xml）&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper
        PUBLIC &amp;quot;-//mybatis.org//DTD Mapper 3.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&amp;quot;&amp;gt;
&amp;lt;mapper namespace=&amp;quot;com.cy.mapper.UserMapper&amp;quot;&amp;gt;

    &amp;lt;select id=&amp;quot;queryUserlist&amp;quot; resultType=&amp;quot;User&amp;quot;&amp;gt;
        select * from user
    &amp;lt;/select&amp;gt;

    &amp;lt;select id=&amp;quot;queryUserById&amp;quot; resultType=&amp;quot;User&amp;quot;&amp;gt;
        select * from user where id = #{id}
    &amp;lt;/select&amp;gt;

    &amp;lt;insert id=&amp;quot;addUser&amp;quot; parameterType=&amp;quot;User&amp;quot;&amp;gt;
        insert into user(id, name, pwd) values (#{id},#{name},#{pwd})
    &amp;lt;/insert&amp;gt;

    &amp;lt;update id=&amp;quot;updateUser&amp;quot; parameterType=&amp;quot;User&amp;quot;&amp;gt;
        update user set name=#{name},pwd=#{pwd} where id = #{id}
    &amp;lt;/update&amp;gt;

    &amp;lt;delete id=&amp;quot;deleteUser&amp;quot; parameterType=&amp;quot;int&amp;quot;&amp;gt;
        delete from user where id=#{id}
    &amp;lt;/delete&amp;gt;

&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;Maven配置资源过滤问题&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;resources&amp;gt;
    &amp;lt;resource&amp;gt;
        &amp;lt;directory&amp;gt;src/main/java&amp;lt;/directory&amp;gt;
        &amp;lt;includes&amp;gt;
            &amp;lt;include&amp;gt;**/*.xml&amp;lt;/include&amp;gt;
        &amp;lt;/includes&amp;gt;
        &amp;lt;filtering&amp;gt;true&amp;lt;/filtering&amp;gt;
    &amp;lt;/resource&amp;gt;
&amp;lt;/resources&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;8&#34;&gt;
&lt;li&gt;编写UserController进行测试&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
public class UserController {

    @Autowired
    private UserMapper userMapper;

    @GetMapping(&amp;quot;/queryUserList&amp;quot;)
    public List&amp;lt;User&amp;gt; queryUserList(){
        List&amp;lt;User&amp;gt; userList = userMapper.queryUserlist();
        for (User user : userList) {
            System.out.println(user);
        }
        return userList;
    }
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;启动项目访问进行测试！&lt;/strong&gt;&lt;/p&gt;
">Mybatis</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jonchan1013.github.io/post/linux/"" data-c="
          &lt;p&gt;👩‍💻目前在中大型互联网项目中，Linux操作系统已成为不可或缺的技术，是程序员必备技能。同时也为其他高级技术的使用提供了有效的保障。&lt;/p&gt;
&lt;h2 id=&#34;1-linux的简介&#34;&gt;1、Linux的简介&lt;/h2&gt;
&lt;h3 id=&#34;11-定位&#34;&gt;1.1 定位&lt;/h3&gt;
&lt;p&gt;服务器操作系统&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;12-历史&#34;&gt;1.2 历史&lt;/h3&gt;
&lt;p&gt;肯·汤姆森（Ken Thompson）在 MULTICS 操作系统上研发游戏“Space Travel”，发现运行速度慢且成本比较高（每次 75 美元），找到丹尼斯·里奇（Dennis Ritchie）我们能不能研发一个操作系统让这个游戏运行效率更高，成本更低。使用一台被人遗弃的计算机上（连操作系统都没有）使用汇编语言仅仅一个月就开发了一个系统。发现使用汇编开发操作系统满足不了要求。肯·汤姆森就和丹尼斯·里奇商量我们能不能研究一个语言来写系统内核，后来就研究出了 B 语言。使用 B 语言写发现还是不行，最后就研发出了大名鼎鼎的 C语言。使用 C 语言研发出了 Unix 操作系统。很多开始仿照 Unix，市场上出现了很多类似操作系统，相互告侵权。Liuns 带领了 Unix 原班人马开发出了 Liuns，后更名为 Liunx。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Linux 内核发明人&lt;/th&gt;
&lt;th&gt;林纳斯·本纳第克特·托瓦兹（Linus Benedict Torvalds）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;内核特点&lt;/td&gt;
&lt;td&gt;基于 Unix 实现。支持多用户、多进程、多线程和多 CPU&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;应用领域&lt;/td&gt;
&lt;td&gt;智能设备、后台服务器、云计算、大数据等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Linux 家族&lt;/td&gt;
&lt;td&gt;Ubuntu、Fedora、CentOS、RedHat、Android 等&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615174439.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;发展到目前，Liunx 不是一个具体的操作系统，而是一类操作系统的统称。具体版本称为发行版。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Red Hat：目前被 IBM 收购了。收费版。目前全球最大的 Linux 供应商。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cent OS&lt;/strong&gt;：Red Hat 推出的&lt;strong&gt;免费&lt;/strong&gt;版。&lt;/li&gt;
&lt;li&gt;Ubuntu：界面比较友好。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-vmware-安装及使用&#34;&gt;2、VMWare 安装及使用&lt;/h2&gt;
&lt;h3 id=&#34;21-vmware-简介&#34;&gt;2.1  VMWare 简介&lt;/h3&gt;
&lt;p&gt;​		VMWare 就是虚拟机软件。目前最新版本是 VMware Workstation Pro15。使用VMWare 就是使用软件来模拟一台真实的计算机。由于虚拟机安装在当前计算机中，所以虚拟机硬件配置上限就是当前计算机硬件配置。&lt;/p&gt;
&lt;h3 id=&#34;22-硬件要求&#34;&gt;2.2 硬件要求&lt;/h3&gt;
&lt;p&gt;​		虚拟机运行过程中比较耗费内存，为了应对后面的课程，建议同学们电脑内存至少 8G以上。如果可以最好是 16GB。当然了，即使 4G 内存也可以运行，只是那时电脑会非常非常的卡。&lt;/p&gt;
&lt;h3 id=&#34;23-安装步骤&#34;&gt;2.3 安装步骤&lt;/h3&gt;
&lt;p&gt;运行安装程序&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615174703.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;按照提示进行安装，点击“下一步”&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615174914.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;勾选“我接受许可协议中的条款”&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616021318.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;路径可以修改也可以不修改。但是路径尽量不要包含中文。示例中把路径修改了。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615174849.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;取消勾选后点击下一步&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615181534.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;点击“下一步”。桌面和开始菜单是否创建快捷方式可以根据自己的习惯进行操作。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615181655.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;点击完成进行安装&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615181728.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;点击许可证输入许可信息&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615181802.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;点击“完成”完成安装&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615181853.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;24-安装结果&#34;&gt;2.4 安装结果&lt;/h3&gt;
&lt;p&gt;VMWare 每次新建虚拟机就相当于产生一台电脑。&lt;/p&gt;
&lt;p&gt;安装完成之后产生两个虚拟网卡。这是保证 Windows 是虚拟机中系统互通的。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615181941.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;25-卸载&#34;&gt;2.5 卸载&lt;/h3&gt;
&lt;p&gt;VMWare 使用 windows 的程序卸载可能无法卸载干净。要使用安装包的卸载功能进行卸载。&lt;/p&gt;
&lt;p&gt;双击安装包&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615182110.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;后点击下一步，会出现下面的界面，点击“删除按钮进行删除”&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615182139.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;3-安装linux&#34;&gt;3、安装Linux&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;新建虚拟机&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615182223.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;选择安装模式&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615182303.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;选择 Linux 镜像文件&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615182554.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;输入用户名以及密码&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615182621.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;
&lt;p&gt;指定虚拟系统安装位置&lt;/p&gt;
&lt;p&gt;建立放到空间大的磁盘中，目录名称尽量不要含有中文。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615182717.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;
&lt;p&gt;指定磁盘容量&lt;/p&gt;
&lt;p&gt;默认就可以&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;18&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615182801.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置信息提示&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;19&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615182835.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;8&#34;&gt;
&lt;li&gt;开始安装&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;20&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615182901.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;9&#34;&gt;
&lt;li&gt;注意事项&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​		在安装时，VMWare 默认会去指定的虚拟机目录查找 Linux 的镜像文件，此时我们需要&lt;br&gt;
停止安装重新指定镜像文件位置。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;21&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615183355.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;22&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615183417.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;23&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615183608.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;10&#34;&gt;
&lt;li&gt;选择安装界面的语言&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;24&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615183637.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;11&#34;&gt;
&lt;li&gt;配置安装位置&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;25&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615183702.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;26&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615183721.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;27&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615183740.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;12&#34;&gt;
&lt;li&gt;设置 root 用户密码&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;28&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615183809.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;29&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615183826.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;13&#34;&gt;
&lt;li&gt;安装完毕后重启 Linux&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;30&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615183849.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;14&#34;&gt;
&lt;li&gt;配置 Linux&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;31&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615183910.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;32&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615183924.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;33&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615183942.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;34&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615183956.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;35&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615184010.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;36&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615184022.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;37&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615184142.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;38&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615184159.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;39&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615184213.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;40&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615184343.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;4-目录结构及路径&#34;&gt;4、目录结构及路径&lt;/h2&gt;
&lt;h3 id=&#34;41-linux-系统目录结构&#34;&gt;4.1  Linux 系统目录结构&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;/&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​		根目录.Unix 和 Linux 中,没有盘符. 一个硬盘,一个根.&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;/bin&lt;/p&gt;
&lt;p&gt;系统的常用命令目录. 包括控制台命令, 系统可执行文件, 系统的核心二进制文件等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/etc&lt;/p&gt;
&lt;p&gt;发布目录, 相当于 windows 系统中的 windows 目录, 保存系统中的所有核心内容.&lt;/p&gt;
&lt;p&gt;要求控制权限高, 建议不要随便读写&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/usr&lt;/p&gt;
&lt;p&gt;用户目录, 相当于 windows 系统中的 program files 目录. 常用于安装系统所有用户共&lt;/p&gt;
&lt;p&gt;用的软件,资源的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/root&lt;/p&gt;
&lt;p&gt;root 根用户的用户目录. 相当于 windows 系统中的 C:/users/administrator 目录&lt;/p&gt;
&lt;p&gt;称为用户主目录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/home&lt;/p&gt;
&lt;p&gt;保存其他用户主目录的目录&lt;/p&gt;
&lt;p&gt;如: Linux 系统中有 oldlu 用户. 那么一定有/home/oldlu 目录存在. 代表用户的主目录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/var&lt;/p&gt;
&lt;p&gt;系统运行过程的数据目录&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;42-路径&#34;&gt;4.2 路径&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;全路径&lt;/p&gt;
&lt;p&gt;从 filesystem 根目录开始寻找文件。&lt;/p&gt;
&lt;p&gt;写法： 以 / 开头。例如找 usr 下 local 中内容，路径： /usr/local&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;相对路径&lt;/p&gt;
&lt;p&gt;从当前资源路径开始寻找，找到其他资源路径过程。&lt;/p&gt;
&lt;p&gt;写法：一定不是以/开头。找当前资源的子目录直接写子目录名称，如果向上跳一级文&lt;/p&gt;
&lt;p&gt;件夹写法 ： ../&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;特殊路径写法&lt;/p&gt;
&lt;p&gt;/ 表示磁盘根&lt;/p&gt;
&lt;p&gt;~ 表示/root ，root 文件夹的根目录&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;5-linux常用命令&#34;&gt;5、Linux常用命令&lt;/h2&gt;
&lt;p&gt;Linux 系统中的命令是严格区分大小写的。&lt;/p&gt;
&lt;h3 id=&#34;51-pwd&#34;&gt;5.1 pwd&lt;/h3&gt;
&lt;p&gt;​		print working directory - 输出当前工作目录, 光标所在位置的目录&lt;/p&gt;
&lt;h3 id=&#34;52-cd&#34;&gt;5.2 cd&lt;/h3&gt;
&lt;p&gt;​		change directory - 切换目录&lt;/p&gt;
&lt;p&gt;​		特殊目录符号 : 当前目录 - ‘.’ , 父目录 - ‘..’&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用方式:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;切换固定位置&lt;/p&gt;
&lt;p&gt;使用根目录作为定位标准, 绝对寻址&lt;/p&gt;
&lt;p&gt;cd /xxx/yyy/zzz&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;切换相对位置&lt;/p&gt;
&lt;p&gt;在当前目录位置开始相对寻址&lt;/p&gt;
&lt;p&gt;cd xxx/yyy/zzz&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进入主目录&lt;/p&gt;
&lt;p&gt;直接进入用户主目录&lt;/p&gt;
&lt;p&gt;cd&lt;/p&gt;
&lt;p&gt;cd ~&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;53-ls&#34;&gt;5.3 ls&lt;/h3&gt;
&lt;p&gt;list - 列表目录中的内容.默认显示当前目录下的文件列表&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用方式:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;列表当前目录&lt;/p&gt;
&lt;p&gt;ls&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;列表指定目录&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ls 目录位置(绝对路径|相对路径)&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;看全部内容&lt;/p&gt;
&lt;p&gt;ls -a [目录]&lt;/p&gt;
&lt;p&gt;list all - 查看所有, 包括隐藏文件. Linux 中隐藏文件都是以’. ’开头的文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;列表查看目录内容&lt;/p&gt;
&lt;p&gt;ls -l [目录]&lt;/p&gt;
&lt;p&gt;显示当前目录下的文件属性：大小、权限、日期、符号链接。&lt;/p&gt;
&lt;p&gt;ll - 简化命令不代表全部 Linux 系统可用.&lt;/p&gt;
&lt;p&gt;list list - 以列表的信息,显示指定目录中的内容. 列表代表的是文件的详情.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;41&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616011631.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;拥有者权限&lt;/th&gt;
&lt;th&gt;同组权限&lt;/th&gt;
&lt;th&gt;其他权限&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;拥有者&lt;/th&gt;
&lt;th&gt;所在组&lt;/th&gt;
&lt;th&gt;容量&lt;/th&gt;
&lt;th&gt;时间&lt;/th&gt;
&lt;th&gt;文件名&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;rw-&lt;/td&gt;
&lt;td&gt;---&lt;/td&gt;
&lt;td&gt;---&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;root&lt;/td&gt;
&lt;td&gt;root&lt;/td&gt;
&lt;td&gt;3326&lt;/td&gt;
&lt;td&gt;Nov 8 01:23&lt;/td&gt;
&lt;td&gt;anaconda-ks.cfg&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;d&lt;/td&gt;
&lt;td&gt;rwx&lt;/td&gt;
&lt;td&gt;r-x&lt;/td&gt;
&lt;td&gt;r-x&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;rooy&lt;/td&gt;
&lt;td&gt;root&lt;/td&gt;
&lt;td&gt;4096&lt;/td&gt;
&lt;td&gt;Nov 8 01:36&lt;/td&gt;
&lt;td&gt;Desktop&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;4.1 类型&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;- | 1 代表文件
d | 2 代表目录
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.2 权限&lt;/p&gt;
&lt;p&gt;​		分为不同的角色: 文件的所有者, 就是创建文件的用户. 所在组, 和所有者同一个组的&lt;/p&gt;
&lt;p&gt;其他用户. 其他用户, 和所有者不在一个组的用户&lt;/p&gt;
&lt;p&gt;​		rwx: read write execut&lt;/p&gt;
&lt;p&gt;​		‘-’ 代表没有对应权限.&lt;/p&gt;
&lt;p&gt;4.3 容量&lt;/p&gt;
&lt;p&gt;​		单位是字节. 所有的目录固定容量为 4096.&lt;/p&gt;
&lt;p&gt;4.4 命令参数&lt;/p&gt;
&lt;p&gt;所有以 - 开头的命令后缀信息, 都是命令参数. 多参数可以并行使用. 如: ls -al&lt;/p&gt;
&lt;h3 id=&#34;54-clear&#34;&gt;5.4 clear&lt;/h3&gt;
&lt;p&gt;​		clear - 清空屏幕&lt;/p&gt;
&lt;h3 id=&#34;55-touch&#34;&gt;5.5 touch&lt;/h3&gt;
&lt;p&gt;​		创建空白文件&lt;/p&gt;
&lt;p&gt;​		在 Linux 系统中,文件不需要强制后缀名&lt;/p&gt;
&lt;p&gt;​		如: 文本文件可以定义为, a | a.txt | a.text&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用方式&lt;/p&gt;
&lt;p&gt;touch 文件名&lt;/p&gt;
&lt;p&gt;touch 目录/文件名&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;56-cat&#34;&gt;5.6 cat&lt;/h3&gt;
&lt;p&gt;​		查看文件的全部内容.&lt;/p&gt;
&lt;p&gt;​		一次性显示文件中所有内容.&lt;/p&gt;
&lt;h3 id=&#34;57-more&#34;&gt;5.7 more&lt;/h3&gt;
&lt;p&gt;​		分屏显示文件内容, 显示后,使用空格显示下一屏, 回车显示下一行,q 退出分屏显示&lt;/p&gt;
&lt;p&gt;ctrl+c,退出命令.&lt;/p&gt;
&lt;h3 id=&#34;58-head&#34;&gt;5.8 head&lt;/h3&gt;
&lt;p&gt;​		显示文件的前多少行, 默认显示前 10 行&lt;/p&gt;
&lt;p&gt;​		head -number filename&lt;/p&gt;
&lt;p&gt;​		查看文件中的前多少行&lt;/p&gt;
&lt;h3 id=&#34;59-tail&#34;&gt;5.9 tail&lt;/h3&gt;
&lt;p&gt;​		显示文件末尾多少行.默认显示末尾 10 行&lt;/p&gt;
&lt;p&gt;​		tail -number filename&lt;/p&gt;
&lt;h3 id=&#34;510-mkdir&#34;&gt;5.10 mkdir&lt;/h3&gt;
&lt;p&gt;​		make directory - 创建目录&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用方式：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;相对创建一个子目录&lt;/p&gt;
&lt;p&gt;mkdir directoryName&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;绝对创建一个目录&lt;/p&gt;
&lt;p&gt;mkdir /directoryName&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一次性创建多级目录&lt;/p&gt;
&lt;p&gt;mkdir -p parentDirectoryName/childDirectoryName&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;511-cp&#34;&gt;5.11 cp&lt;/h3&gt;
&lt;p&gt;​		copy - 复制命令&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用方式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​		cp source target&lt;/p&gt;
&lt;p&gt;​		cp 源信息 目录信息&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;复制文件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​	cp fileName newFileName&lt;/p&gt;
&lt;p&gt;​	cp directoryName/fileName directoryName/[newFileName]&lt;/p&gt;
&lt;p&gt;​	cp /directoryName/fileName /directoryName/[newFileName]&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;复制目录&lt;/p&gt;
&lt;p&gt;cp -r directoryName newDirectoryName&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;512-rm&#34;&gt;5.12 rm&lt;/h3&gt;
&lt;p&gt;​		remove - 删除&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用方式:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	rm source&lt;/p&gt;
&lt;p&gt;​	rm 要删除的资源&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;删除文件需提示&lt;/p&gt;
&lt;p&gt;​	rm fileName&lt;/p&gt;
&lt;p&gt;​	rm directoryName/fileName&lt;/p&gt;
&lt;p&gt;​	rm / directoryName/fileName&lt;/p&gt;
&lt;p&gt;​	-f force 忽略不存在的文件，从不给出提示&lt;/p&gt;
&lt;p&gt;​	-r recursive 指示 rm 将参数中列出的全部目录和子目录均递归地删除&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除文件不需提示&lt;/p&gt;
&lt;p&gt;​	rm -f fileName&lt;/p&gt;
&lt;p&gt;​	rm -f directoryName/fileName&lt;/p&gt;
&lt;p&gt;​	rm -f /directoryName/fileName&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除目录需提示&lt;/p&gt;
&lt;p&gt;​	rm -r directoryName&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除目录不需提示&lt;/p&gt;
&lt;p&gt;​	rm -rf directoryName&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;513-mv&#34;&gt;5.13 mv&lt;/h3&gt;
&lt;p&gt;​		move - 移动或重命名. 相当于剪切和重命名&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用方式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​		mv source target 移动&lt;/p&gt;
&lt;p&gt;​		mv source newName 重命名&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;移动文件到指定位置&lt;/p&gt;
&lt;p&gt;​	mv fileName directoryName&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为文件重命名&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​	mv fileName newFileName&lt;/p&gt;
&lt;h3 id=&#34;514-vi-vim&#34;&gt;5.14 vi | vim&lt;/h3&gt;
&lt;p&gt;​		编辑文件, vim 是增强命令. 不代表所有的 Linux 都支持&lt;/p&gt;
&lt;p&gt;​		vim 增强在有高亮显示&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用方式:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​		vi fileName&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;命令模式:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​		是控制编辑的文件的状态的,如:保存,退出编辑等&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;进入编辑模式:&lt;/p&gt;
&lt;p&gt;​	a - append, 追加的方式进入编辑模式&lt;/p&gt;
&lt;p&gt;​	i - insert, 插入的方式进入编辑模式&lt;/p&gt;
&lt;p&gt;​	o - under line , 在光标所在位置之下,新增一行,进入编辑模式&lt;/p&gt;
&lt;p&gt;​	O - pre line, 在光标所在位置之上,新增一行, 进入编辑模式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;dd&lt;/p&gt;
&lt;p&gt;​	dd - delete line 删除指定行, 默认 1 行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;:w&lt;/p&gt;
&lt;p&gt;​	write - 保存&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;:q&lt;/p&gt;
&lt;p&gt;​	quit - 退出 vi 编辑器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;:wq&lt;/p&gt;
&lt;p&gt;​	保存并退出&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;:q!&lt;/p&gt;
&lt;p&gt;​	强制退出不保存&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;:set nu&lt;/p&gt;
&lt;p&gt;​	显示行号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/keywords&lt;/p&gt;
&lt;p&gt;​	搜索关键字, keywords 是关键字的命名&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;G&lt;/p&gt;
&lt;p&gt;​	光标跳转到文件尾&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;gg&lt;/p&gt;
&lt;p&gt;​	光标跳转到文件头&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;编辑模式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​		是编辑文件内容的&lt;/p&gt;
&lt;p&gt;​		进入命令模式 - esc&lt;/p&gt;
&lt;h3 id=&#34;515-reboot&#34;&gt;5.15 reboot&lt;/h3&gt;
&lt;p&gt;​		reboot 用来重启 Linux 系统和 Windows 系统中的 restart 一样。但是机器重启必须&lt;/p&gt;
&lt;p&gt;要 root 用户才有权限。&lt;/p&gt;
&lt;h3 id=&#34;516-halt&#34;&gt;5.16 halt&lt;/h3&gt;
&lt;p&gt;​		halt 命令用来关闭正在运行的 Linux 操作系统。&lt;/p&gt;
&lt;h2 id=&#34;6-linux常用配置&#34;&gt;6、Linux常用配置&lt;/h2&gt;
&lt;h3 id=&#34;61-设置系统时区&#34;&gt;6.1 设置系统时区&lt;/h3&gt;
&lt;h4 id=&#34;611-安装系统时可设置时区&#34;&gt;6.1.1 安装系统时可设置时区&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;42&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616014040.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;43&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616014053.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;62-通过-linux-命令设置时区&#34;&gt;6.2 通过 Linux 命令设置时区&lt;/h3&gt;
&lt;h4 id=&#34;621-查看系统当前时间&#34;&gt;6.2.1 查看系统当前时间&lt;/h4&gt;
&lt;p&gt;date 命令&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;44&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616014153.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;622-修改时区&#34;&gt;6.2.2 修改时区&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;获取当前时区配置&lt;/p&gt;
&lt;p&gt;tzselect 命令&lt;br&gt;
选择 Asia 亚洲&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;45&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616014241.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​	选择中国&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;46&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616014303.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​	选择北京时间&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;47&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616014323.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;得到时区配置信息&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;48&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616014342.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;修改 .bash_profile 文件设置时区&lt;/p&gt;
&lt;p&gt;.bash_profile 文件在当前用户的目录下，时区一旦修改仅对当前用户生效。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;49&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616014420.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​		使用 vim 编辑 .bash_profile 文件&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;50&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616014439.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​		将获取到的时区配置信息添加到该文件中&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;51&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616014507.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​		注销当前登录用户，重新登录&lt;/p&gt;
&lt;h3 id=&#34;63-通过-linux-的操作界面设置时区&#34;&gt;6.3 通过 Linux 的操作界面设置时区&lt;/h3&gt;
&lt;p&gt;​		如果安装 Linux 时选择带有 GUI 的，那么可以通过 GUI 设置时区，该设置方式对所有用户生效。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;52&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616014607.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;53&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616015218.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;63-网络配置&#34;&gt;6.3 网络配置&lt;/h3&gt;
&lt;h4 id=&#34;631-开启网络&#34;&gt;6.3.1 开启网络&lt;/h4&gt;
&lt;p&gt;​		CentOS8 中默认没有开始网络配置。需要手动开启。&lt;/p&gt;
&lt;p&gt;​		启用 ens33 网络配置。默认只有 ens33&lt;/p&gt;
&lt;p&gt;​		nmcli c up ens33&lt;/p&gt;
&lt;p&gt;​		vim /etc/sysconfig/network-scripts/ifcfg-ens33&lt;/p&gt;
&lt;p&gt;​		先点击键盘的 i 键，左下角出现--insert-- 才能开始进行编辑。&lt;/p&gt;
&lt;p&gt;​		修改最后一行 ONBOOT=yes，表示开启此网卡设置启动。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;54&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616015446.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​		点击键盘”ESC”退出编辑状态后，不考虑光标位置，直接输入:wq，然后回车。&lt;/p&gt;
&lt;p&gt;通过下面命令查看 ip 地址&lt;/p&gt;
&lt;p&gt;ifconfig 命令&lt;/p&gt;
&lt;h4 id=&#34;632-修改网段&#34;&gt;6.3.2 修改网段&lt;/h4&gt;
&lt;p&gt;​		VMware 菜单编辑 --&amp;gt; 虚拟网络编辑器 --&amp;gt; 右下角 “更改设置” --&amp;gt; 选择“VMNet 8” -- &amp;gt; 修改子网 IP 为自己希望的网段 --&amp;gt; DHCP 设置中修改两处网段&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;55&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616015555.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;56&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616015607.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;57&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616015621.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;632-设置网络类型&#34;&gt;6.3.2 设置网络类型&lt;/h4&gt;
&lt;p&gt;​		在 VMWare 中默认使用 NAT 模式&lt;/p&gt;
&lt;p&gt;​		NAT 模式：“Network Address Translation，网络地址转换”，允许一个整体机构以一个公用 IP 地址出现在 Internet 上。顾名思义，它是一种把内部私有网络地址（IP 地址）通过 NAT 转发成合法公有网络 IP 地址的技术。&lt;/p&gt;
&lt;p&gt;​		优点：可以节省 IP 资源&lt;/p&gt;
&lt;p&gt;​		缺点：由于网段不同，局域网内其他设备无法访问虚拟机中的操作系统&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;58&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616015726.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;59&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616015753.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;64-快照与克隆&#34;&gt;6.4 快照与克隆&lt;/h3&gt;
&lt;h4 id=&#34;641快照&#34;&gt;6.4.1快照&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建快照&lt;/p&gt;
&lt;p&gt;​	快照功能是在关机状态使用的。&lt;br&gt;
​	快照就是类似 windows 的还原点。还原系统。使用快照可以还原系统也可以克隆系统。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;60&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616015902.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;删除快照&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;61&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616015925.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;62&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616015944.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;642-克隆功能&#34;&gt;6.4.2 克隆功能&lt;/h4&gt;
&lt;p&gt;​		要求：关闭状态&lt;/p&gt;
&lt;p&gt;​		可以帮助快速生成一台虚拟机&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;63&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616020018.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;64&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616020032.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;65&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616020045.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;66&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616020055.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;67&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616020107.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;7-xshell-安装及使用&#34;&gt;7、XShell 安装及使用&lt;/h2&gt;
&lt;p&gt;​		一款 Windows 中使用的 Linux 客户端命令工具。&lt;/p&gt;
&lt;p&gt;​		常见的 Linux 客户端工具：&lt;/p&gt;
&lt;p&gt;​		XShell、FinallShell、SecureCRT 等&lt;/p&gt;
&lt;h3 id=&#34;71-安装-xshell&#34;&gt;7.1 安装 Xshell&lt;/h3&gt;
&lt;p&gt;​		Xshell 版本：6&lt;/p&gt;
&lt;h3 id=&#34;72-xshell-的使用&#34;&gt;7.2 Xshell 的使用&lt;/h3&gt;
&lt;h4 id=&#34;721-创建连接&#34;&gt;7.2.1 创建连接&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;68&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616020310.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;69&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616020350.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;722-使用-xsehll-连接-linux-系统&#34;&gt;7.2.2  使用 Xsehll 连接 Linux 系统&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;70&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616020512.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;71&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616020551.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;8-linux-的文件上传与下载&#34;&gt;8、Linux 的文件上传与下载&lt;/h2&gt;
&lt;h3 id=&#34;81-xftp-安装及使用&#34;&gt;8.1 Xftp 安装及使用&lt;/h3&gt;
&lt;p&gt;​		Xftp 和 Xshell 是同一个公司的产品。Xftp 是基于 FTP 协议的工具。可以方便的实现互联网中主机和主机之间的文件传输。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;72&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200616020701.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;82-使用-lrzsz-工具完成文件的上传与下载&#34;&gt;8.2 使用 lrzsz 工具完成文件的上传与下载&lt;/h3&gt;
&lt;p&gt;lrzsz 是一款在 linux 里可代替 Xftp 上传和下载的程序&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安装 lrzsz&lt;/p&gt;
&lt;p&gt;yum install lrzsz -y&lt;/p&gt;
&lt;p&gt;yum 是一个在 Fedora 和 RedHat 以及 SUSE 中的 Shell 前端软件包管理器。&lt;/p&gt;
&lt;p&gt;yum 命令是基于 RPM 包管理的工具，能够从指定的服务器自动下载 RPM 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;lrzsz 的使用&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;sz：将选定的文件发送到本地机器&lt;/p&gt;
&lt;p&gt;rz：弹出一个文件选择窗口，从本地选择文件上传到 Linux&lt;/p&gt;
&lt;h2 id=&#34;9-linux-中文件的压缩与解压缩&#34;&gt;9、Linux 中文件的压缩与解压缩&lt;/h2&gt;
&lt;h3 id=&#34;91-targz-格式&#34;&gt;9.1 *.tar.gz 格式&lt;/h3&gt;
&lt;p&gt;​		tar.gz 是 Linux 中的一种文件压缩格式，可是使用 tar 命令实现对文件的压缩与解压处理。&lt;/p&gt;
&lt;h4 id=&#34;911-tar-命令参数介绍&#34;&gt;9.1.1  tar 命令参数介绍&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;	-c: 创建压缩文件
	-C: 指定解压文件存放的位置
	-x：解压-t：查看内容
	-z：有 gzip 属性的
	-v：显示所有过程
	-f: 使用文件名字，切记，这个参数是最后一个参数，后面只能接文件名
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;912-创建-targz-压缩文件&#34;&gt;9.1.2 创建 tar.gz 压缩文件&lt;/h4&gt;
&lt;p&gt;​		tar -czvf 压缩文件的名称.tar.gz 源文件或者目录名称&lt;/p&gt;
&lt;h4 id=&#34;913-解压-targz-文件&#34;&gt;9.1.3 解压 tar.gz 文件&lt;/h4&gt;
&lt;p&gt;​		tar -zxvf 解压文件名称&lt;/p&gt;
&lt;h3 id=&#34;92-zip-格式&#34;&gt;9.2 *.zip 格式&lt;/h3&gt;
&lt;p&gt;​		如果压缩文件格式为.zip 那么需要使用 unzip 命令解压.zip 压缩包。&lt;/p&gt;
&lt;h4 id=&#34;921-unzip-参数介绍&#34;&gt;9.2.1 unzip 参数介绍&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;-n：解压缩时不要覆盖原有的文件
-d&amp;lt;目录&amp;gt;：指定文件解压缩后所要存储的目录
-v：执行时显示详细的信息；
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;922-解压-zip-文件&#34;&gt;9.2.2 解压 zip 文件&lt;/h4&gt;
&lt;p&gt;unzip 压缩文件.zip&lt;/p&gt;
&lt;p&gt;unzip 压缩文件.zip -d 解压到指定目录&lt;/p&gt;
&lt;h2 id=&#34;10-安装jdk&#34;&gt;10、安装JDK&lt;/h2&gt;
&lt;h3 id=&#34;101-上传文件&#34;&gt;10.1 上传文件&lt;/h3&gt;
&lt;p&gt;在/root 目录下新建一个 temp 目录用于存放临时文件&lt;/p&gt;
&lt;p&gt;将 JDK 压缩文件上传到/root/temp 目录&lt;/p&gt;
&lt;h3 id=&#34;102-解压文件&#34;&gt;10.2 解压文件&lt;/h3&gt;
&lt;p&gt;使用 tar 命令解压文件&lt;/p&gt;
&lt;h3 id=&#34;103-配置环境变量&#34;&gt;10.3 配置环境变量&lt;/h3&gt;
&lt;p&gt;在 linux 中/etc/profile 此文件为环境变量配置文件。&lt;/p&gt;
&lt;p&gt;export JAVA_HOME=/usr/local/jdk&lt;/p&gt;
&lt;p&gt;export CLASSPATH=.:&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;J&lt;/mi&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mi&gt;V&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mi&gt;H&lt;/mi&gt;&lt;/msub&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mi&gt;E&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;/&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;/&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;JAVA_HOME/lib/dt.jar:&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.09618em;&#34;&gt;J&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.22222em;&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.32833099999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.08125em;&#34;&gt;H&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;M&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;JAVA_HOME/lib/tools.jar&lt;/p&gt;
&lt;p&gt;export PATH=&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;J&lt;/mi&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mi&gt;V&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mi&gt;H&lt;/mi&gt;&lt;/msub&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mi&gt;E&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;/&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;JAVA_HOME/bin:&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.09618em;&#34;&gt;J&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.22222em;&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.32833099999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.08125em;&#34;&gt;H&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;M&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;PATH&lt;/p&gt;
&lt;h3 id=&#34;104-让环境变量生效&#34;&gt;10.4 让环境变量生效&lt;/h3&gt;
&lt;p&gt;永久生效：重启 Linux&lt;/p&gt;
&lt;p&gt;临时生效：. /etc/profile 或者 source /etc/profile 有效范围是当前会话[终端]&lt;/p&gt;
&lt;h3 id=&#34;105-查看配置是否成功&#34;&gt;10.5 查看配置是否成功&lt;/h3&gt;
&lt;p&gt;java -version&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;73&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200623095105.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;11-tomcat-配置步骤&#34;&gt;11、Tomcat 配置步骤&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;上传&lt;/p&gt;
&lt;p&gt;上传 tomcat 压缩包/root/temp&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解压&lt;/p&gt;
&lt;p&gt;tar zxf apache-tomcat-7.0.68.tar.gz&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;复制&lt;/p&gt;
&lt;p&gt;cp -r apache-tomcat-7.0.68 /usr/local/tomcat&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动&lt;/p&gt;
&lt;p&gt;进入 tomcat 的 bin 文件夹&lt;/p&gt;
&lt;p&gt;cd /usr/local/tomcat/bin&lt;/p&gt;
&lt;p&gt;执行的命令为/启动文件&lt;/p&gt;
&lt;p&gt;./startup.sh&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;74&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200623095955.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看日志&lt;/p&gt;
&lt;p&gt;tomcat/logs/catalina.out 文件是日志文件. 就是控制台输出的文件&lt;/p&gt;
&lt;p&gt;tail -f tomcat/logs/catalina.out - 追加显示的模式查看文件末尾信息&lt;/p&gt;
&lt;p&gt;tomcat/bin/startup.sh &amp;amp; tail -f tomcat/logs/catalina.out 启动同时查看日志&lt;/p&gt;
&lt;p&gt;&amp;amp; - 命令连接符, 左侧命令执行结束后,立刻执行右侧命令.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关闭防火墙&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;关闭防火墙，重启失效&lt;/p&gt;
&lt;p&gt;service firewalld stop&lt;/p&gt;
&lt;p&gt;禁用防火墙&lt;/p&gt;
&lt;p&gt;systemctl disable firewalld&lt;/p&gt;
&lt;p&gt;启动防火墙&lt;/p&gt;
&lt;p&gt;systemctl enable firewalld&lt;/p&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;
&lt;p&gt;测试应用&lt;/p&gt;
&lt;p&gt;http://ip:port/&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;12-centos7安装mysql-8020&#34;&gt;12 Centos7安装mysql 8.0.20&lt;/h2&gt;
&lt;h3 id=&#34;121-配置yum源&#34;&gt;12.1 配置yum源&lt;/h3&gt;
&lt;h4 id=&#34;1211-下载mysql源安装包&#34;&gt;12.1.1 下载mysql源安装包&lt;/h4&gt;
&lt;p&gt;在MySQL官网中下载YUM源rpm安装包：http://dev.mysql.com/downloads/repo/yum/&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;75&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200623100618.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;76&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200623100847.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;复制本次下载链接：https://dev.mysql.com/get/mysql80-community-release-el8-1.noarch.rpm&lt;/p&gt;
&lt;p&gt;执行下载命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;wget https://dev.mysql.com/get/mysql80-community-release-el8-1.noarch.rpm
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;1212-安装mysql源&#34;&gt;12.1.2 安装mysql源&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;yum localinstall mysql80-community-release-el8-1.noarch.rpm
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;1213-检查是否安装成功&#34;&gt;12.1.3 检查是否安装成功&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;yum repolist enabled | grep &amp;quot;mysql.*-community.*&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;77&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200623101456.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;1214-修改安装版本可选&#34;&gt;12.1.4 修改安装版本（可选）&lt;/h4&gt;
&lt;p&gt;如果需要安装指定版本的mysql，可以修改/etc/yum.repos.d/mysql-community.repo源，改变默认安装的mysql版本。&lt;/p&gt;
&lt;p&gt;例如要安装5.7版本，将5.7源的enabled=0改成enabled=1，将8.0的enabled=1改成enabled=0即可，如下（本次未做修改，直接安装最新版8.0.20）：&lt;/p&gt;
&lt;h3 id=&#34;122-安装mysql&#34;&gt;12.2 安装mysql&lt;/h3&gt;
&lt;p&gt;直接使用命令：yum install mysql-community-server即可。&lt;/p&gt;
&lt;h3 id=&#34;123-启动mysql服务&#34;&gt;12.3 启动mysql服务&lt;/h3&gt;
&lt;h4 id=&#34;1231-启动&#34;&gt;12.3.1 启动&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;service mysqld start
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;1232-查看启动状态&#34;&gt;12.3.2 查看启动状态&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;service mysqld status
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;78&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200623101751.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;1233-设置开机启动&#34;&gt;12.3.3 设置开机启动&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;systemctl enable mysqld
systemctl daemon-reload
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;124-配置及部分命令&#34;&gt;12.4 配置及部分命令&lt;/h3&gt;
&lt;h4 id=&#34;1241-修改登录密码&#34;&gt;12.4.1 修改登录密码&lt;/h4&gt;
&lt;p&gt;mysql安装完成之后，在/var/log/mysqld.log文件中给root生成了一个默认密码。通过下面的方式找到root默认密码，然后登录mysql进行修改：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;grep &#39;temporary password&#39; /var/log/mysqld.log
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;79&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200623102259.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;本地MySQL客户端登录&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;mysql -u root -p
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;密码是上一步查询出来的。输入后回车。&lt;/p&gt;
&lt;p&gt;然后修改密码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;你的密码&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注：mysql5.7及以上默认安装了密码安全检查插件（validate_password），默认密码检查策略要求密码必须包含：大小写字母、数字和特殊符号，并且长度不能少于8位。否则会提示ERROR 1819 (HY000): Your password does not satisfy the current policy requirements错误，&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;80&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200623102637.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;1242-修改密码策略可选&#34;&gt;12.4.2 修改密码策略（可选）&lt;/h4&gt;
&lt;p&gt;在/etc/my.cnf文件添加validate_password_policy配置，指定密码策略：&lt;/p&gt;
&lt;p&gt;选择0（LOW），1（MEDIUM），2（STRONG）其中一种，选择2需要提供密码字典文件。&lt;/p&gt;
&lt;p&gt;validate_password_policy=0&lt;/p&gt;
&lt;p&gt;如果不需要密码策略，添加my.cnf文件中添加如下配置禁用即可：&lt;/p&gt;
&lt;p&gt;validate_password = off&lt;/p&gt;
&lt;p&gt;重新启动mysql服务使配置生效：systemctl restart mysqld&lt;/p&gt;
&lt;h4 id=&#34;1242-添加远程登录用户&#34;&gt;12.4.2 添加远程登录用户&lt;/h4&gt;
&lt;p&gt;默认只允许root帐户在本地登录，如果要在其它机器上连接mysql，必须修改root允许远程连接，或者添加一个允许远程连接的帐户。&lt;/p&gt;
&lt;p&gt;修改root用户远程访问权限：&lt;/p&gt;
&lt;p&gt;选择 mysql 数据库：use mysql;&lt;/p&gt;
&lt;p&gt;在 mysql 数据库的 user 表中查看当前 root 用户的相关信息：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select host, user from user;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;81&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200623102949.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;查看表格中 root 用户的 host，默认应该显示的 localhost，只支持本地访问，不允许远程访问。&lt;/p&gt;
&lt;p&gt;授权 root 用户的所有权限并设置远程访问&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;GRANT ALL ON *.* TO &#39;root&#39;@&#39;%&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可能会出现以下报错信息：&lt;/p&gt;
&lt;p&gt;ERROR 1410 (42000): You are not allowed to create a user with GRANT&lt;/p&gt;
&lt;p&gt;则可以使用下面命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;update user set host=&#39;%&#39; where user =&#39;root&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后使用下面命令使修改生效：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;flush privileges;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;1243-修改默认编码格式&#34;&gt;12.4.3 修改默认编码格式&lt;/h4&gt;
&lt;p&gt;mysql8.0默认编码方式为utf8mb4，因此使用时不需要修改，可使用如下命令查看：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;SHOW VARIABLES WHERE Variable_name LIKE &#39;character_set_%&#39; OR Variable_name LIKE &#39;collation%&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;82&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200623103509.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;修改mysql配置文件my.cnf（windows为my.ini）&lt;/p&gt;
&lt;p&gt;my.cnf一般在etc/mysql/my.cnf位置。找到后请在以下三部分里后面添加如下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;[client]

default-character-set = utf8mb4

[mysql]

default-character-set = utf8mb4

[mysqld]

character-set-client-handshake = FALSE

character-set-server = utf8mb4

collation-server = utf8mb4_unicode_ci

init_connect=&#39;SET NAMES utf8mb4&#39;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重启mysql即可。&lt;/p&gt;
&lt;p&gt;collation_connection 、collation_database 、collation_server是什么没关系。但必须保证以下这几个变量必须是utf8mb4。：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;character_set_client  (客户端来源数据使用的字符集)
character_set_connection     (连接层字符集)
character_set_database   (当前选中数据库的默认字符集)
character_set_results (查询结果字符集)
character_set_server (默认的内部操作字符集)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数据库连接参数中,characterEncoding=utf8会被自动识别为utf8mb4，也可以不加这个参数，会自动检测。&lt;/p&gt;
&lt;p&gt;而autoReconnect=true是必须加上的。&lt;/p&gt;
&lt;h4 id=&#34;1244-部分参数配置查询命令&#34;&gt;12.4.4 部分参数配置查询命令&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;#查询mysql最大连接数设置
show global variables like &#39;max_conn%&#39;;
SELECT @@MAX_CONNECTIONS AS &#39;Max Connections&#39;;

# 查看最大链接数
show global status like &#39;Max_used_connections&#39;;


# 查看慢查询日志是否开启以及日志位置
show variables like &#39;slow_query%&#39;;
 

# 查看慢查询日志超时记录时间
show variables like &#39;long_query_time&#39;;


# 查看链接创建以及现在正在链接数
show status like &#39;Threads%&#39;;
 

# 查看数据库当前链接
show processlist;


# 查看数据库配置
show variables like &#39;%quer%&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;125连接navicat&#34;&gt;12.5连接Navicat&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;83&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200623103953.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;84&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200623104159.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;85&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200623104313.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">Linux</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jonchan1013.github.io/post/leetcode-shua-ti/"" data-c="
          &lt;h2 id=&#34;70-爬楼梯&#34;&gt;70、爬楼梯&lt;/h2&gt;
&lt;p&gt;题目描述：假设你正在爬楼梯。需要 &lt;em&gt;n&lt;/em&gt; 阶你才能到达楼顶。&lt;/p&gt;
&lt;p&gt;每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;**注意：**给定 &lt;em&gt;n&lt;/em&gt; 是一个正整数。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613121348.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;方法1：记忆化递归：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int climbStairs(int n) {
        int memo[] = new int[n + 1]; //存储中间结果，避免重复计算
        return climbStairsMemo(n, memo);

    }

    public int climbStairsMemo(int n, int memo[]) {
        if (memo[n] &amp;gt; 0) {
            return memo[n];
        }
        if (n == 1) {
            return memo[n] = 1;
        } else if (n == 2) {
            return memo[n] = 2;
        } else {
            return memo[n] = climbStairs(n - 1) + climbStairs(n - 2);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;时间复杂度：O(n)&lt;/p&gt;
&lt;p&gt;空间复杂度：O(n)&lt;/p&gt;
&lt;p&gt;方法2：斐波那契数列&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int climbStairs(int n) {
        if (n == 1) {
            return 1;
        }
        int first = 1;
        int second = 2;
        for (int i = 3; i &amp;lt;= n; i++) {
            //滚动数组，优化空间复杂度,只记录两个状态
            int third = first + second;
            first = second;
            second = third;
        }
        return second;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;时间复杂度：O(n)&lt;/p&gt;
&lt;p&gt;空间复杂度：O(1)&lt;/p&gt;
">LeetCode刷题</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jonchan1013.github.io/post/ajax/"" data-c="
          &lt;p&gt;✍️Ajax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式、快速动态应用的网页开发技术，无需重新加载整个网页的情况下，能够更新页面局部数据的技术。&lt;br&gt;
通过在后台与服务器进行少量数据交换，Ajax 可以使页面实现异步更新。这意味着可以在不重新加载整个页面的情况下，对页面的某部分进行更新。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;1-ajax简介&#34;&gt;1、Ajax简介&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200612214538.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​		Ajax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式、快速动态应用的网页开发技术，无需重新加载整个网页的情况下，能够更新页面局部数据的技术。&lt;/p&gt;
&lt;p&gt;​		通过在后台与服务器进行少量数据交换，Ajax 可以使页面实现异步更新。这意味着可以在不重新加载整个页面的情况下，对页面的某部分进行更新。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200612214639.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200612214744.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;2-ajax的使用&#34;&gt;2、Ajax的使用&lt;/h2&gt;
&lt;h3 id=&#34;21-xmlhttprequest-对象&#34;&gt;2.1 XMLHttpRequest 对象&lt;/h3&gt;
&lt;p&gt;​		XMLHttpRequest 是浏览器接口对象，该对象的 API 可被 JavaScript、VBScript 以及其它&lt;br&gt;
web 浏览器内嵌的脚本语言调用，通过 HTTP 协议在浏览器和 web 服务器之间收发 XML 或&lt;br&gt;
其它数据。XMLHttpRequest 可以与服务器实现异步交互，而无需让整个页面刷新，因此成&lt;br&gt;
为 Ajax 编程的核心对象。&lt;/p&gt;
&lt;h3 id=&#34;22-ajax-的使用步骤&#34;&gt;2.2 Ajax 的使用步骤&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建 XMLHttpRequest 对象&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var xhr = new XMLHttpRequest();
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;给定请求方式以及请求地址&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;xhr.open(&amp;quot;get&amp;quot;,&amp;quot;http://www.example.com&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;发送请求&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;xhr.send();
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;获取服务器端给客户端的响应数据&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;xhr.onreadystatechange = function(){
//0:open()没有被调用
//1:open()正在被调用
//2:send()正在被调用
//3:服务端正在返回结果
//4:请求结束，并且服务端已经结束发送数据到客户端
if(xhr.readyState == 4 &amp;amp;&amp;amp; xhr.status == 200){
document.getElementById(&amp;quot;span&amp;quot;).innerHTML=xhr.responseText;
alert(xhr.responseText);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;23-ajax的运行原理&#34;&gt;2.3 Ajax的运行原理&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200612215857.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;24-示例代码&#34;&gt;2.4 示例代码&lt;/h3&gt;
&lt;p&gt;index.jsp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;%@ page contentType=&amp;quot;text/html; charset=UTF-8&amp;quot; language=&amp;quot;java&amp;quot;%&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
    &amp;lt;script&amp;gt;
        function but() {
            var xhr = new XMLHttpRequest();
            xhr.open(&amp;quot;get&amp;quot;, &amp;quot;ajax.do&amp;quot;);
            xhr.send();
            xhr.onreadystatechange = function () {
                if (xhr.readyState == 4 &amp;amp;&amp;amp; xhr.status == 200) {
                    alert(xhr.responseText);
                    //将数据插入到span标签中
                    document.getElementById(&amp;quot;span&amp;quot;).innerHTML=xhr.responseText;
                }
            }
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h2&amp;gt;你好&amp;lt;/h2&amp;gt;
&amp;lt;hr/&amp;gt;
&amp;lt;span id=&amp;quot;span&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;
&amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;ok&amp;quot; onclick=&amp;quot;but()&amp;quot;/&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;AjaxServlet:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@WebServlet(&amp;quot;/ajax.do&amp;quot;)
public class AjaxServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        PrintWriter pw=resp.getWriter();
        pw.println(&amp;quot;hello,ajax!&amp;quot;);
        pw.flush();
        pw.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200612234214.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200612234238.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;3-json详解&#34;&gt;3、JSON详解&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613002650.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;31-json简介&#34;&gt;3.1 JSON简介&lt;/h3&gt;
&lt;p&gt;​		JSON(JavaScript Object Notation) 是一种基于字符串的轻量级的数据交换格式。易于人阅读和编写，同时也易于机器解析和生成。JSON 是 JavaScript 数据类型的子集。&lt;/p&gt;
&lt;h3 id=&#34;32-为什么要使用-json&#34;&gt;3.2 为什么要使用 JSON&lt;/h3&gt;
&lt;p&gt;​		在 JSON 未出现之前在 Ajax 中对于数据传递方式，会使用 XML 作为主要数据格式来传输数据。直到 JSON 出现后逐渐放弃使用 XML 作为数据传输格式。JSON 比 XML 更小、更快，更易解析。&lt;/p&gt;
&lt;h3 id=&#34;33-json-格式的特征&#34;&gt;3.3 JSON 格式的特征&lt;/h3&gt;
&lt;h4 id=&#34;331json-的语法规则&#34;&gt;3.3.1JSON 的语法规则&lt;/h4&gt;
&lt;p&gt;JSON 是按照特定的语法规则所生成的字符串结构。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大括号表示 JSON 的字符串对象。{ }&lt;/li&gt;
&lt;li&gt;属性和值用冒号分割。{&amp;quot;属性&amp;quot;:&amp;quot;value&amp;quot;}&lt;/li&gt;
&lt;li&gt;属性和属性之间用逗号分割。{&amp;quot;属性&amp;quot;:&amp;quot;value&amp;quot;,&amp;quot;属性&amp;quot;:&amp;quot;value&amp;quot;,...}&lt;/li&gt;
&lt;li&gt;中括号表示数组。[{&amp;quot;属性&amp;quot;:&amp;quot;value&amp;quot;...},{&amp;quot;属性&amp;quot;:&amp;quot;value&amp;quot;...}]&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;JSON 字符串对象：&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613002918.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;{&amp;quot;userid&amp;quot;:1,&amp;quot;username&amp;quot;:&amp;quot;admin&amp;quot;,&amp;quot;sex&amp;quot;:&amp;quot;male&amp;quot;}&lt;/p&gt;
&lt;p&gt;数组：&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613002948.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;[{&amp;quot;userid&amp;quot;:1,&amp;quot;username&amp;quot;:&amp;quot;admin&amp;quot;},{&amp;quot;userid&amp;quot;:2,&amp;quot;username&amp;quot;:&amp;quot;oldlu&amp;quot;}]&lt;/p&gt;
&lt;h4 id=&#34;332-josn-的-6-种数据类型&#34;&gt;3.3.2 JOSN 的 6 种数据类型&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613003047.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;string：字符串，必须要用双引号引起来。&lt;/li&gt;
&lt;li&gt;number：数值，与 JavaScript 的 number 一致，&lt;/li&gt;
&lt;li&gt;object：JavaScript 的对象形式，{ key:value }表示方式，可嵌套。&lt;/li&gt;
&lt;li&gt;array：数组，JavaScript 的 Array 表示方式[ value ]，可嵌套。&lt;/li&gt;
&lt;li&gt;true/false：布尔类型，JavaScript 的 boolean 类型。&lt;/li&gt;
&lt;li&gt;null：空值，JavaScript 的 null。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;34-jackson的使用&#34;&gt;3.4 Jackson的使用&lt;/h3&gt;
&lt;p&gt;​		在 JDK 中并没有内置操作 JSON 格式数据的 API，因此使用处理 JSON 格式的数据需要借助第三方类库。&lt;br&gt;
几个常用的 JSON 解析类库：&lt;br&gt;
Gson: 谷歌开发的 JSON 库，功能十分全面。&lt;br&gt;
FastJson: 阿里巴巴开发的 JSON 库，性能十分优秀。&lt;br&gt;
Jackson: 社区十分活跃且更新速度很快。被称为“最好的 Json 解析器”&lt;/p&gt;
&lt;h4 id=&#34;341-jackson简介&#34;&gt;3.4.1 Jackson简介&lt;/h4&gt;
&lt;p&gt;Jackson 是一种解析 JSON 格式数据的 API，也是最流行，速度最快的 JSON API。在SpringMVC 中默认使用 Jackson API 处理 JSON 格式的数据。&lt;br&gt;
Jackson 下载地址：&lt;br&gt;
https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-annotations&lt;br&gt;
https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core&lt;br&gt;
https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind&lt;/p&gt;
&lt;h4 id=&#34;342-在响应中通过-json-格式传递数据&#34;&gt;3.4.2 在响应中通过 JSON 格式传递数据&lt;/h4&gt;
&lt;p&gt;在响应中使用 Jackson 处理 JSON 格式数据的步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;添加 jackson-annotations.jar、jackson-core.jar、jackson-databind.jar&lt;/li&gt;
&lt;li&gt;通过 jackson API 将 Java 对象转换 JSON 格式&lt;/li&gt;
&lt;li&gt;修改响应头，响应类型为 application/json&lt;/li&gt;
&lt;li&gt;将结果基于字符输出流推回客户端浏览器&lt;/li&gt;
&lt;li&gt;在页面的中通过 JavaScript 的 JSON.parse()函数将 JSON 格式的数据转换为 JavaScript对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;3421-通过-json-格式在响应中传递单个对象&#34;&gt;3.4.2.1 通过 JSON 格式在响应中传递单个对象&lt;/h5&gt;
&lt;p&gt;需求：&lt;br&gt;
定义一个 User 类，包含 userid、username 属性。&lt;br&gt;
实例化一个 User 对象，通过 JSON 格式将 User 对象响应到客户端浏览器。&lt;br&gt;
将 User 对象中的数据插入到页面中。&lt;/p&gt;
&lt;p&gt;User类:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class User {
    private int userid;
    private String username;

    public int getUserid() {
        return userid;
    }

    public void setUserid(int userid) {
        this.userid = userid;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    @Override
    public String toString() {
        return &amp;quot;User{&amp;quot; +
                &amp;quot;userid=&amp;quot; + userid +
                &amp;quot;, username=&#39;&amp;quot; + username + &#39;\&#39;&#39; +
                &#39;}&#39;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;SingleObjectServlet类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@WebServlet(&amp;quot;/single.do&amp;quot;)
public class SingleObjectServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //创建User对象
        User user = new User();
        user.setUserid(10);
        user.setUsername(&amp;quot;张三&amp;quot;);


        //使用jackson的api将User对象转换成JSON格式的字符串对象
        ObjectMapper objectMapper = new ObjectMapper();
        //将USer对象转换为JSON格式的字符串对象
        String s = objectMapper.writeValueAsString(user);
        System.out.println(s);
        //设置响应类型为application/json
        resp.setContentType(&amp;quot;application/json&amp;quot;);

        PrintWriter pw = resp.getWriter();
        //将数据输出到前端
        pw.print(s);
        pw.flush();
        pw.close();

    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;singleDemo.jsp&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;%@ page contentType=&amp;quot;text/html; charset=UTF-8&amp;quot; language=&amp;quot;java&amp;quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;script&amp;gt;
        function but(){
            var xhr = new XMLHttpRequest();
            xhr.open(&amp;quot;get&amp;quot;,&amp;quot;single.do&amp;quot;);
            xhr.send();
            xhr.onreadystatechange = function(){

                if(xhr.readyState == 4 &amp;amp;&amp;amp; xhr.status == 200){
                    alert(xhr.responseText);
                    //通过javaScript的内置对象JSON中的parse函数将JSON格式的字符串对转换成javascript对象
                    var obj = JSON.parse(xhr.responseText);
                    alert(obj.userid+&amp;quot; &amp;quot;+obj.username);
                    document.getElementById(&amp;quot;span&amp;quot;).innerHTML=obj.userid+&amp;quot;&amp;lt;br/&amp;gt;&amp;quot;+obj.username;
                }
            }
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h3&amp;gt;JSON格式的单个对象响应&amp;lt;/h3&amp;gt;
&amp;lt;hr/&amp;gt;
&amp;lt;span id=&amp;quot;span&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;
&amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;OK&amp;quot; onclick=&amp;quot;but()&amp;quot;/&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;3422-通过-json-格式在响应中传递多个对象&#34;&gt;3.4.2.2 通过 JSON 格式在响应中传递多个对象&lt;/h5&gt;
&lt;p&gt;需求：&lt;br&gt;
定义一个 User 类，包含 userid、username 属性。&lt;br&gt;
实例化多个 User 对象，通过 JSON 格式将 User对象响应到客户端浏览器。&lt;br&gt;
将 User 对象中的数据插入到页面中。&lt;/p&gt;
&lt;p&gt;MultipleObjectServlet类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@WebServlet(&amp;quot;/multiple.do&amp;quot;)
public class MultipleObjectServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        User user1 = new User();
        user1.setUserid(1);
        user1.setUsername(&amp;quot;张三&amp;quot;);
        User user2 = new User();
        user2.setUserid(2);
        user2.setUsername(&amp;quot;李四&amp;quot;);

        //将多个对象放入list中
        List&amp;lt;User&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        list.add(user1);
        list.add(user2);

        //通过jackson将List转换成JSON格式的字符串对象
        ObjectMapper objectMapper = new ObjectMapper();
        String s = objectMapper.writeValueAsString(list);
        System.out.println(s);
        resp.setContentType(&amp;quot;application/json&amp;quot;);

        PrintWriter pw = resp.getWriter();
        pw.print(s);
        pw.flush();
        pw.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;multipleDemo.jsp&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;%@ page contentType=&amp;quot;text/html;charset=UTF-8&amp;quot; language=&amp;quot;java&amp;quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;script&amp;gt;
        function but() {
            var xhr = new XMLHttpRequest();
            xhr.open(&amp;quot;get&amp;quot;, &amp;quot;multiple.do&amp;quot;);
            xhr.send();
            xhr.onreadystatechange = function () {

                if (xhr.readyState == 4 &amp;amp;&amp;amp; xhr.status == 200) {
                    alert(xhr.responseText);
                    //通过javaScript的内置对象JSON中的parse函数将JSON格式的字符串对转换成javascript对象
                    //此时obj是数组，里面存放的是JavaScript对象
                    var obj = JSON.parse(xhr.responseText);
                    var temp = &amp;quot;&amp;quot;;
                    for (var i = 0; i &amp;lt; obj.length; i++) {
                        alert(obj[i].userid + &amp;quot; &amp;quot; + obj[i].username);
                        temp +=obj[i].userid + &amp;quot;&amp;lt;br/&amp;gt;&amp;quot; + obj[i].username
                    }

                    document.getElementById(&amp;quot;span&amp;quot;).innerHTML = temp;
                }
            }
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h3&amp;gt;JSON格式的多个对象响应&amp;lt;/h3&amp;gt;
&amp;lt;hr/&amp;gt;
&amp;lt;span id=&amp;quot;span&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;
&amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;OK&amp;quot; onclick=&amp;quot;but()&amp;quot;/&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;3423-在-json-中通过-map-传递数据&#34;&gt;3.4.2.3 在 JSON 中通过 Map 传递数据&lt;/h5&gt;
&lt;p&gt;​		在 JSON 格式中可以直接使用 Map 作为传递数据的模型。因为 Map 结构本身就是 key与 value 的结构与 JSON 格式对象模型完全匹配，所以我们可以直接将一个 Map 对象转换为JSON 格式的字符串对象。这对于我们来说是一件非常方便的事情，如果我们返回的数据并没有对应的模型来存放数据，那么我们可以通过 Map 来解决。&lt;/p&gt;
&lt;p&gt;MapModelServlet类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@WebServlet(&amp;quot;/map.do&amp;quot;)
public class MapModelServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //一个map对象对应一个json
        Map&amp;lt;String, Object&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        map.put(&amp;quot;userid&amp;quot;,11);
        map.put(&amp;quot;url&amp;quot;,&amp;quot;map.do&amp;quot;);
        ObjectMapper objectMapper = new ObjectMapper();
        String s = objectMapper.writeValueAsString(map);
        resp.setContentType(&amp;quot;application/json&amp;quot;);

        PrintWriter pw = resp.getWriter();
        pw.print(s);
        pw.flush();
        pw.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;mapDemo.jsp&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;%@ page contentType=&amp;quot;text/html;charset=UTF-8&amp;quot; language=&amp;quot;java&amp;quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;script&amp;gt;
        function but(){
            var xhr = new XMLHttpRequest();
            xhr.open(&amp;quot;get&amp;quot;,&amp;quot;map.do&amp;quot;);
            xhr.send();
            xhr.onreadystatechange = function(){

                if(xhr.readyState == 4 &amp;amp;&amp;amp; xhr.status == 200){
                    alert(xhr.responseText);
                    //通过javaScript的内置对象JSON中的parse函数将JSON格式的字符串对转换成javascript对象
                    var obj = JSON.parse(xhr.responseText);
                    alert(obj.userid+&amp;quot; &amp;quot;+obj.url);
                    document.getElementById(&amp;quot;span&amp;quot;).innerHTML=obj.userid+&amp;quot;&amp;lt;br/&amp;gt;&amp;quot;+obj.url;
                }
            }
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h3&amp;gt;Map模型的使用&amp;lt;/h3&amp;gt;
&amp;lt;hr/&amp;gt;
&amp;lt;span id=&amp;quot;span&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;
&amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;OK&amp;quot; onclick=&amp;quot;but()&amp;quot;/&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;343-在请求中通过-json-格式传递数据&#34;&gt;3.4.3 在请求中通过 JSON 格式传递数据&lt;/h4&gt;
&lt;p&gt;我们除了可以在响应中通过 JSON 格式来传递数据以外，在请求中也可以使用 JSON 格式传递数据。如果在请求中使用 JSON 格式传递数据，那么提交方式需要使用 POST 方式，通过 JavaScript 中的 JSON.stringify()函数将 JavaScript 对象转换为 JSON 格式数据。通过 send方法将参数传递到 Servlet 中，在 Servlet 中通过字符输入流获取 JSON 格式数据。&lt;/p&gt;
&lt;p&gt;在请求中使用 Jackson 处理 JSON 格式数据的步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;添加 jackson-annotations.jar、jackson-core.jar、jackson-databind.jar&lt;/li&gt;
&lt;li&gt;在页面的 JavaScript 中通过 JSON.stringify()函数将 JavaScript 对象转换为 JSON 格式的数据&lt;/li&gt;
&lt;li&gt;将请求方式修改为 POST 方式&lt;/li&gt;
&lt;li&gt;通过 send()函数将 JSON 格式的数据提交到服务端。&lt;/li&gt;
&lt;li&gt;在 Servlet 中通过字符输入流读取请求体中 JSON 格式的数据&lt;/li&gt;
&lt;li&gt;通过 jackson API 将获取到的 JSON 格式的数据转换为 Java 对象&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;requestDemo.jsp&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;%@ page contentType=&amp;quot;text/html; charset=UTF-8&amp;quot; language=&amp;quot;java&amp;quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;script&amp;gt;
        function but() {
            var id = document.getElementById(&amp;quot;userid&amp;quot;).value;
            var name = document.getElementById(&amp;quot;username&amp;quot;).value;
            var obj = {
                userid: id,
                username: name
            }
            var content = json.stringify(obj);
            alert(content);
            var xhr = new XMLHttpRequest();
            xhr.open(&amp;quot;post&amp;quot;, &amp;quot;json.do&amp;quot;);
            //这样在/json.do请求的时候会将我们转换完的json串传递到servlet
            xhr.send(content);
            xhr.onreadystatechange = function () {

                if (xhr.readyState == 4 &amp;amp;&amp;amp; xhr.status == 200) {
                    alert(xhr.responseText);
                    //通过javaScript的内置对象JSON中的parse函数将JSON格式的字符串对转换成javascript对象
                    var obj = JSON.parse(xhr.responseText);
                    alert(obj.userid + &amp;quot; &amp;quot; + obj.username);
                    document.getElementById(&amp;quot;span&amp;quot;).innerHTML = obj.userid + &amp;quot;&amp;lt;br/&amp;gt;&amp;quot; + obj.username;
                }
            }
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h3&amp;gt;在请求中通过json格式传递数据&amp;lt;/h3&amp;gt;
&amp;lt;hr/&amp;gt;
用户ID：&amp;lt;input name=&amp;quot;userid&amp;quot; id=&amp;quot;userid&amp;quot;/&amp;gt;&amp;lt;br/&amp;gt;
用户姓名：&amp;lt;input name=&amp;quot;username&amp;quot; id=&amp;quot;username&amp;quot;/&amp;gt;&amp;lt;br/&amp;gt;
&amp;lt;span id=&amp;quot;span&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;
&amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;OK&amp;quot; onclick=&amp;quot;but()&amp;quot;/&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;RequestJsonServlet类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@WebServlet(&amp;quot;/json.do&amp;quot;)
public class RequestJsonServlet extends HttpServlet {
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //通过字符输入流从请求体中获取提交的json格式的数据
        req.setCharacterEncoding(&amp;quot;utf-8&amp;quot;);
        String s = req.getReader().readLine();

        //使用jackson将json格式数据转换成java对象
        ObjectMapper objectMapper = new ObjectMapper();
        User user = objectMapper.readValue(s, User.class);
        System.out.println(user.getUserid()+&amp;quot;&amp;quot;+user.getUsername());

        PrintWriter pw = resp.getWriter();
        pw.print(&amp;quot;OK&amp;quot;);
        pw.flush();
        pw.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;344-jackson-的常用注解&#34;&gt;3.4.4 Jackson 的常用注解&lt;/h3&gt;
&lt;h5 id=&#34;3441jsonproperty&#34;&gt;3.4.4.1@JsonProperty&lt;/h5&gt;
&lt;p&gt;​		此注解用于属性上，作用是把该属性的名称序列化为另外一个名称，如把 username 属性序列化为 name，@JsonProperty(&amp;quot;name&amp;quot;)。&lt;/p&gt;
&lt;h5 id=&#34;3442-jsonignore&#34;&gt;3.4.4.2 @JsonIgnore&lt;/h5&gt;
&lt;p&gt;​		此注解用于属性或者方法上（一般都是定义在属性上），用来完全忽略被注解的字段和方法对应的属性，返回的 json 数据即不包含该属性。&lt;/p&gt;
&lt;h5 id=&#34;3443-jsonformat&#34;&gt;3.4.4.3  @JsonFormat&lt;/h5&gt;
&lt;p&gt;​		此注解用于属性或者方法上（一般都是定义在属性上），可以方便的把 Date 类型属性的值直接转化为我们想要的样式。如：@JsonFormat(pattern=&amp;quot;yyyy-MM-dd hh:mm:ss&amp;quot;)&lt;/p&gt;
&lt;h4 id=&#34;345-jackson-工具类的使用&#34;&gt;3.4.5 Jackson 工具类的使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* JSON 转换工具类
*/
public class JsonUtils {

// 定义 jackson 对象
private static final ObjectMapper MAPPER = new ObjectMapper();
/**
* 将对象转换成 json 字符串。
* &amp;lt;p&amp;gt;Title: pojoToJson&amp;lt;/p&amp;gt;
* &amp;lt;p&amp;gt;Description: &amp;lt;/p&amp;gt;
* @param data
* @return
*/
public static String objectToJson(Object data) {
try {
	String string = MAPPER.writeValueAsString(data);
	return string;
} catch (JsonProcessingException e) {
	e.printStackTrace();
}
	return null;
}

/**
* 将 json 结果集转化为对象
* @param jsonData json 数据
* @param beanType 对象中的 object 类型
* @return
*/
public static &amp;lt;T&amp;gt; T jsonToPojo(String jsonData, Class&amp;lt;T&amp;gt; beanType)
{
	try {
		T t = MAPPER.readValue(jsonData, beanType);
		return t;
		} catch (Exception e) {
		e.printStackTrace();
		}
		return null;
}
/**
* 将 json 数据转换成 pojo 对象 list
* &amp;lt;p&amp;gt;Title: jsonToList&amp;lt;/p&amp;gt;
* &amp;lt;p&amp;gt;Description: &amp;lt;/p&amp;gt;
* @param jsonData
* @param beanType
* @return
*/
public static &amp;lt;T&amp;gt;List&amp;lt;T&amp;gt; jsonToList(String jsonData, Class&amp;lt;T&amp;gt;
beanType) {
	JavaType javaType =MAPPER.getTypeFactory().constructParametricType(List.class,
beanType);
try {
	List&amp;lt;T&amp;gt; list = MAPPER.readValue(jsonData, javaType);
	return list;
	} catch (Exception e) {
	e.printStackTrace();
}
	return null;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-jquery-的-ajax-使用&#34;&gt;4、Jquery 的 Ajax 使用&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615094159.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​		在 JQuery 中提供了对 Ajax 的封装，让我们在使用 Ajax 技术时变得更加容易。在 JQuery中提供了很多的基于 Ajax 发送异步请求的方法，如：&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;、&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;.ajax()、&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;.get()、&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;、&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;.post()、&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;.getJSON()。&lt;/p&gt;
&lt;h3 id=&#34;41-ajax的使用&#34;&gt;4.1  $.ajax()的使用&lt;/h3&gt;
&lt;h4 id=&#34;411-语法结构&#34;&gt;4.1.1 语法结构&lt;/h4&gt;
&lt;p&gt;$.ajax({name:value,name:value......})&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615094350.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;jqueryAjaxDemo.jsp&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;%@ page contentType=&amp;quot;text/html;charset=UTF-8&amp;quot; language=&amp;quot;java&amp;quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
    &amp;lt;script src=&amp;quot;js/jquery.js&amp;quot;/&amp;gt;
    &amp;lt;script&amp;gt;
        function but() {
            $.ajax({
                type:&amp;quot;get&amp;quot;,
                url:&amp;quot;jqueryAjax.do&amp;quot;,
                success:function (result) {
                    $(&amp;quot;#span&amp;quot;).html(result)
                }
            })
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;span id=&amp;quot;span&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;
&amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;ok&amp;quot; onclick=&amp;quot;but()&amp;quot;/&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;jqueryAjaxServlet类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@WebServlet(&amp;quot;/jqueryAjax.do&amp;quot;)
public class jqueryAjaxServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        PrintWriter pw = resp.getWriter();
        //将数据输出到前端
        pw.print(&amp;quot;hello,jqueryAjax&amp;quot;);
        pw.flush();
        pw.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;412-ajax在异步请求中提交数据&#34;&gt;4.1.2 $.ajax()在异步请求中提交数据&lt;/h4&gt;
&lt;p&gt;​		在$.ajax()方法中通过 data 属性来存放提交的数据，支持 JSON 格式的数据。&lt;/p&gt;
&lt;h5 id=&#34;4121-提交普通格式数据&#34;&gt;4.1.2.1 提交普通格式数据&lt;/h5&gt;
&lt;p&gt;​		在 data 属 性 中 我 们 可 以 通 过 两 种 方 式 来 指 定 需 要 提 交 的 数 据 。 一 种 是 通 过&lt;br&gt;
name=value&amp;amp;name=value 的结构。另一种是通过 JavaScript 对象来指定提交数据。无论使用哪种方式在 Servlet 中都是通过 request.getParameter 方法根据 name 获取 value 的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;通过标准格式指定提交数据&lt;/p&gt;
&lt;p&gt;data:”name=value&amp;amp;name=value.....”&lt;br&gt;
在 Servlet 中通过 request.getParameter 来获取提交的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过 JavaScript 对象指定提交数据&lt;/p&gt;
&lt;p&gt;data:{&lt;br&gt;
userid:100,&lt;br&gt;
username:”oldlu”&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 Servlet 中通过 request.getParameter 来获取提交的数据。&lt;/p&gt;
&lt;p&gt;dataDemo.jsp&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;%@ page contentType=&amp;quot;text/html;charset=UTF-8&amp;quot; language=&amp;quot;java&amp;quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
    &amp;lt;script src=&amp;quot;js/jquery.js&amp;quot;/&amp;gt;
    &amp;lt;script&amp;gt;
        function but() {
            var id = $(&amp;quot;#userid&amp;quot;).val;
            var name = $(&amp;quot;#username&amp;quot;).val;
            $.ajax({
                type:&amp;quot;get&amp;quot;,
                url:&amp;quot;data.do&amp;quot;,
                //通过标准格式
               /* data:&amp;quot;id=&amp;quot;+id+&amp;quot;&amp;amp;name=&amp;quot;+name,*/
                //通过JavaScript对象
                data:{
                    id:id,
                    name:name
                },
                success:function (result) {
                    $(&amp;quot;#span&amp;quot;).html(result)
                }
            })
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
用户ID：&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;userid&amp;quot;&amp;gt;
用户名：&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;username&amp;quot;&amp;gt;
&amp;lt;span id=&amp;quot;span&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;
&amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;ok&amp;quot; onclick=&amp;quot;but()&amp;quot;/&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;DataServlet类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@WebServlet(&amp;quot;/data.do&amp;quot;)
public class DataServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        String id = req.getParameter(&amp;quot;id&amp;quot;);
        String name = req.getParameter(&amp;quot;name&amp;quot;);

        PrintWriter pw = resp.getWriter();
        pw.print(id+&amp;quot; &amp;quot;+name);
        pw.flush();
        pw.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;4122-提交-json-格式数据&#34;&gt;4.1.2.2 提交 JSON 格式数据&lt;/h5&gt;
&lt;p&gt;在$.ajax()中提交 JSON 格式的数据需要使用 post 方式提交，通过 JSON.stringify()函数将JavaScript 对象转换成 JSON 格式的字符串。在 Servlet 中通过字符输入获取提交的 JSON 格式的数据。&lt;/p&gt;
&lt;p&gt;​		data:JSON.stringify({name:value,name:value......})&lt;br&gt;
在 Servlet 中通过 req.getReader().readLine()来获取提交的数据。&lt;/p&gt;
&lt;p&gt;jsonDataDemo.jsp&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;%@ page contentType=&amp;quot;text/html;charset=UTF-8&amp;quot; language=&amp;quot;java&amp;quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
    &amp;lt;script src=&amp;quot;js/jquery.js&amp;quot;/&amp;gt;
    &amp;lt;script&amp;gt;
        function but() {
            var id = $(&amp;quot;#userid&amp;quot;).val;
            var name = $(&amp;quot;#username&amp;quot;).val;
            $.ajax({
                type:&amp;quot;post&amp;quot;,
                url:&amp;quot;jsonData.do&amp;quot;,
                //将JavaScript 对象转换成 JSON 格式的字符串
                data:JSON.stringify({
                    id:id,
                    name:name
                }),
                success:function (result) {
                    $(&amp;quot;#span&amp;quot;).html(result)
                }
            })
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
用户ID：&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;userid&amp;quot;&amp;gt;
用户名：&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;username&amp;quot;&amp;gt;
&amp;lt;span id=&amp;quot;span&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;
&amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;ok&amp;quot; onclick=&amp;quot;but()&amp;quot;/&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JsonDataServlet类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@WebServlet(&amp;quot;/jsonData.do&amp;quot;)
public class JsonDataServlet extends HttpServlet {
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        String s= req.getReader().readLine();
        PrintWriter pw = resp.getWriter();
        pw.print(s);
        pw.flush();
        pw.close();
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;4123-ajax处理响应中的-json-格式数据&#34;&gt;4.1.2.3 $.ajax()处理响应中的 JSON 格式数据&lt;/h5&gt;
&lt;p&gt;$.ajax()方法会根据 dataType 属性中的值自动对响应的数据做类型处理。如果响应的是一个 JSON 格式的数据，那么 dataType 的值为“JSON”,在回调函数中我们得到的直接就是JSON 字符串转换完的 JavaScript 对象。不需要在使用 JSON.parse()做格式的转换处理。&lt;/p&gt;
&lt;p&gt;jsonConvertDemo.jsp&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;%@ page contentType=&amp;quot;text/html;charset=UTF-8&amp;quot; language=&amp;quot;java&amp;quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
    &amp;lt;script src=&amp;quot;js/jquery.js&amp;quot;/&amp;gt;
    &amp;lt;script&amp;gt;
        function but() {
            var id = $(&amp;quot;#userid&amp;quot;).val;
            var name = $(&amp;quot;#username&amp;quot;).val;
            $.ajax({
                type:&amp;quot;post&amp;quot;,
                url:&amp;quot;jsonConvert.do&amp;quot;,
                //将json格式的字符串转换为JavaScript对象
                datatype:&amp;quot;json&amp;quot;,
                //将JavaScript 对象转换成 JSON 格式的字符串
                data:JSON.stringify({
                    id:id,
                    name:name
                }),
                success:function (result) {
                    alert(result.id+&amp;quot; &amp;quot;+result.name);
                    $(&amp;quot;#span&amp;quot;).html(result.id+&amp;quot; &amp;quot;+result.name);
                }
            })
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
用户ID：&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;userid&amp;quot;&amp;gt;
用户名：&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;username&amp;quot;&amp;gt;
&amp;lt;span id=&amp;quot;span&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;
&amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;ok&amp;quot; onclick=&amp;quot;but()&amp;quot;/&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JsonConvertServletl类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@WebServlet(&amp;quot;/jsonConvert.do&amp;quot;)
public class JsonConvertServlet extends HttpServlet {
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        resp.setContentType(&amp;quot;application/json&amp;quot;);
        String s = req.getReader().readLine();
        PrintWriter pw = resp.getWriter();
        pw.print(s);
        pw.flush();
        pw.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;42-get的使用&#34;&gt;4.2 $.get()的使用&lt;/h3&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;方&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;法&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;是&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;.get()方法是&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;方&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;法&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;是&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;.ajax()方法基于 get 方式发送异步请求的简化版。&lt;/p&gt;
&lt;h4 id=&#34;421-语法结构&#34;&gt;4.2.1 语法结构&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;$.get(url,function(result)) //function相当于回调函数
$.get(url,data,function(result))
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;422-通过标准格式指定提交数据&#34;&gt;4.2.2 通过标准格式指定提交数据&lt;/h4&gt;
&lt;p&gt;$.get(url,”name=value&amp;amp;name=value”,function(result))&lt;/p&gt;
&lt;h4 id=&#34;423-通过-javascript-对象指定提交数据&#34;&gt;4.2.3 通过 JavaScript 对象指定提交数据&lt;/h4&gt;
&lt;p&gt;$.get(url,{userid:1,username:”oldlu”,......},function(result))&lt;/p&gt;
&lt;p&gt;getDemo.jsp&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;%@ page contentType=&amp;quot;text/html;charset=UTF-8&amp;quot; language=&amp;quot;java&amp;quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
    &amp;lt;script src=&amp;quot;js/jquery.js&amp;quot;/&amp;gt;
    &amp;lt;script&amp;gt;
        function but() {
            var id = $(&amp;quot;#userid&amp;quot;).val;
            var name = $(&amp;quot;#username&amp;quot;).val;
            /*$.get(&amp;quot;data.do&amp;quot;,&amp;quot;id=&amp;quot;+id+&amp;quot;&amp;amp;name=&amp;quot;+name,function (result) {
                $(&amp;quot;#span&amp;quot;).html(result)
            })*/
            $.get(&amp;quot;data.do&amp;quot;,{id:id,name:name},function (result) {
                $(&amp;quot;#span&amp;quot;).html(result);
            })
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
用户ID：&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;userid&amp;quot;&amp;gt;
用户名：&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;username&amp;quot;&amp;gt;
&amp;lt;span id=&amp;quot;span&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;
&amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;ok&amp;quot; onclick=&amp;quot;but()&amp;quot;/&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;DataServletle类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@WebServlet(&amp;quot;/data.do&amp;quot;)
public class DataServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        String id = req.getParameter(&amp;quot;id&amp;quot;);
        String name = req.getParameter(&amp;quot;name&amp;quot;);

        PrintWriter pw = resp.getWriter();
        pw.print(id+&amp;quot; &amp;quot;+name);
        pw.flush();
        pw.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;43-post的使用&#34;&gt;4.3 $.post()的使用&lt;/h3&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;方&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;法&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;是&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;.post()方法是&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;方&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;法&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;是&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;.ajax()方法基于 post 方式发送异步请求的简化版。&lt;/p&gt;
&lt;h4 id=&#34;431-语法结构&#34;&gt;4.3.1 语法结构&lt;/h4&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;.post(url,function(result))
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;.post(url,data,function(result))&lt;/p&gt;
&lt;h4 id=&#34;432-通过标准格式指定提交数据&#34;&gt;4.3.2 通过标准格式指定提交数据&lt;/h4&gt;
&lt;p&gt;$.post(url,”name=value&amp;amp;name=value”,function(result))&lt;/p&gt;
&lt;h4 id=&#34;433-通过-javascript-对象指定提交数据&#34;&gt;4.3.3 通过 JavaScript 对象指定提交数据&lt;/h4&gt;
&lt;p&gt;$.post(url,userid:1,username:”oldlu”,......},function(result))&lt;/p&gt;
&lt;h3 id=&#34;44-getjson的使用&#34;&gt;4.4 $.getJSON()的使用&lt;/h3&gt;
&lt;p&gt;​		&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;J&lt;/mi&gt;&lt;mi&gt;S&lt;/mi&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;方&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;法&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;是&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;.getJSON()方法是&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.09618em;&#34;&gt;J&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;方&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;法&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;是&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;.ajax()方法基于 get 方式发送异步请求，并将响应结果中 JSON 格式的字符串对象自动转换为 JavaScript 对象。在使用该方法时要求返回的数据必须是 JSON 格式类型。$.getJSON()方法和 resp.setContentType(“application/json”)是一起使用的。&lt;/p&gt;
&lt;h4 id=&#34;441-语法结构&#34;&gt;4.4.1 语法结构&lt;/h4&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;J&lt;/mi&gt;&lt;mi&gt;S&lt;/mi&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;.getJSON(url,function(result))
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.09618em;&#34;&gt;J&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;.getJSON(url,data,function(result))&lt;/p&gt;
&lt;h4 id=&#34;442-通过标准格式指定提交数据&#34;&gt;4.4.2 通过标准格式指定提交数据&lt;/h4&gt;
&lt;p&gt;$.getJSON(url,”name=value&amp;amp;name=value”,function(result))&lt;br&gt;
要求返回的数据格式必须是 JSON 格式。&lt;/p&gt;
&lt;h4 id=&#34;443-通过-javascript-对象指定提交数据&#34;&gt;4.4.3 通过 JavaScript 对象指定提交数据&lt;/h4&gt;
&lt;p&gt;$.getJSON(url{userid:1,username:”oldlu”,......},function(result))&lt;br&gt;
要求返回的数据格式必须是 JSON 格式。&lt;/p&gt;
&lt;p&gt;getJsonDemo.jsp&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;%@ page contentType=&amp;quot;text/html;charset=UTF-8&amp;quot; language=&amp;quot;java&amp;quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
    &amp;lt;script src=&amp;quot;js/jquery.js&amp;quot;/&amp;gt;
    &amp;lt;script&amp;gt;
        function but() {
            var id = $(&amp;quot;#userid&amp;quot;).val;
            var name = $(&amp;quot;#username&amp;quot;).val;
            $.getJSON(&amp;quot;getJson.do&amp;quot;,{id:id,name:name},function (result) {
                $(&amp;quot;#span&amp;quot;).html(result.userid+&amp;quot; &amp;quot;+result.username);
            })
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
用户ID：&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;userid&amp;quot;&amp;gt;
用户名：&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;username&amp;quot;&amp;gt;
&amp;lt;span id=&amp;quot;span&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;
&amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;ok&amp;quot; onclick=&amp;quot;but()&amp;quot;/&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;GetJsonServlet类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@WebServlet(&amp;quot;/getJson.do&amp;quot;)
public class GetJsonServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        String id = req.getParameter(&amp;quot;id&amp;quot;);
        String name = req.getParameter(&amp;quot;name&amp;quot;);

        HashMap&amp;lt;String, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        map.put(&amp;quot;userid&amp;quot;,id);
        map.put(&amp;quot;username&amp;quot;,name);
        String s= JsonUtils.objectToJson(map);
        resp.setContentType(&amp;quot;application/json&amp;quot;);

        PrintWriter pw = resp.getWriter();
        pw.print(s);
        pw.flush();
        pw.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;45-serialize方法的使用&#34;&gt;4.5 serialize()方法的使用&lt;/h3&gt;
&lt;p&gt;将 form 表单中的数据自动拼接成 name=value&amp;amp;name=value 结构。&lt;/p&gt;
&lt;h4 id=&#34;451-语法结构&#34;&gt;4.5.1 语法结构&lt;/h4&gt;
&lt;p&gt;var param = $(“form”).serialize();&lt;br&gt;
param 的值为：name=value&amp;amp;name=value&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;%@ page contentType=&amp;quot;text/html;charset=UTF-8&amp;quot; language=&amp;quot;java&amp;quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
    &amp;lt;script src=&amp;quot;js/jquery.js&amp;quot;/&amp;gt;
    &amp;lt;script&amp;gt;
        function but() {
            var param = $(&amp;quot;form&amp;quot;).serialize();
            alert(param);
            $.ajax({
                type: &amp;quot;get&amp;quot;,
                url: &amp;quot;data.do&amp;quot;,
                //通过标准格式
                data:param,
                success: function (result) {
                    $(&amp;quot;#span&amp;quot;).html(result)
                }
            })
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;form&amp;gt;
    用户ID：&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;userid&amp;quot;&amp;gt;
    用户名：&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;username&amp;quot;&amp;gt;
&amp;lt;/form&amp;gt;

&amp;lt;span id=&amp;quot;span&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;
&amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;ok&amp;quot; onclick=&amp;quot;but()&amp;quot;/&amp;gt;
&amp;lt;/body&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5-ajax实战案例&#34;&gt;5、Ajax实战案例&lt;/h2&gt;
&lt;p&gt;需求:&lt;br&gt;
创建 User 类，包含 uesrid、username、usersex、userbirth 属性。&lt;/p&gt;
&lt;p&gt;​		在用户管理页面中通过 Ajax 技术完成对用户数据载入、添加用户、更新用户、删除用户操作。&lt;/p&gt;
&lt;h3 id=&#34;51-搭建环境&#34;&gt;5.1 搭建环境&lt;/h3&gt;
&lt;h4 id=&#34;511-创建user类&#34;&gt;5.1.1 创建User类&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class User {
    private int userid;
    private String username;
    private String usersex;
    @JsonFormat(pattern = &amp;quot;yyyy-MM-dd&amp;quot;)
    private Date userbirth;

    public int getUserid() {
        return userid;
    }

    public void setUserid(int userid) {
        this.userid = userid;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getUsersex() {
        return usersex;
    }

    public void setUsersex(String usersex) {
        this.usersex = usersex;
    }

    public Date getUserbirth() {
        return userbirth;
    }

    public void setUserbirth(Date userbirth) {
        this.userbirth = userbirth;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;512-在页面中创建表格&#34;&gt;5.1.2 在页面中创建表格&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;%@ page contentType=&amp;quot;text/html;charset=UTF-8&amp;quot; language=&amp;quot;java&amp;quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;用户管理&amp;lt;/title&amp;gt;
    &amp;lt;script src=&amp;quot;js/jquery.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script&amp;gt;
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;table align=&amp;quot;center&amp;quot; width=&amp;quot;60%&amp;quot; border=&amp;quot;1&amp;quot;&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;td&amp;gt;ID：&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;userid&amp;quot; id=&amp;quot;userid&amp;quot;/&amp;gt;&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;姓名：&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;username&amp;quot; id=&amp;quot;username&amp;quot;/&amp;gt;&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;td&amp;gt;性别：&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;usersex&amp;quot; id=&amp;quot;usersex&amp;quot;/&amp;gt;&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;生日：&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;userbirth&amp;quot;
                   id=&amp;quot;userbirth&amp;quot;/&amp;gt;&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
    &amp;lt;tr align=&amp;quot;center&amp;quot;&amp;gt;
        &amp;lt;td colspan=&amp;quot;4&amp;quot;&amp;gt;
            &amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;添加用户&amp;quot; id=&amp;quot;add&amp;quot; /&amp;gt;
            &amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;更新用户&amp;quot; id=&amp;quot;update&amp;quot;/&amp;gt;
        &amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;
&amp;lt;hr/&amp;gt;
&amp;lt;table align=&amp;quot;center&amp;quot; width=&amp;quot;60%&amp;quot; bgcolor=&amp;quot;&amp;quot; border=&amp;quot;1&amp;quot;
       id=&amp;quot;myTable&amp;quot;&amp;gt;
    &amp;lt;thead&amp;gt;
    &amp;lt;tr align=&amp;quot;center&amp;quot;&amp;gt;
        &amp;lt;td&amp;gt;ID&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;姓名&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;性别&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;生日&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;操作&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
    &amp;lt;/thead&amp;gt;
    &amp;lt;tbody id=&amp;quot;tBody&amp;quot;&amp;gt;&amp;lt;/tbody&amp;gt;
&amp;lt;/table&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615120307.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;52-加载用户数据&#34;&gt;5.2 加载用户数据&lt;/h3&gt;
&lt;h4 id=&#34;521-通过ajax完成页面数据初始化&#34;&gt;5.2.1 通过Ajax完成页面数据初始化&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;script&amp;gt;
        $(function () {
            //获取页面初始化数据
            getData();
        });

        //获取页面初始化数据
        function getData() {
            $.getJSON(&amp;quot;user.do&amp;quot;, {flag: &amp;quot;getData&amp;quot;}, function (result) {
                init(result);
            });
        }

        //遍历数据生成数据
        function init(obj) {
            var str = &amp;quot;&amp;quot;;
            $.each(obj, function () {
                str += &amp;quot;&amp;lt;tr align=&#39;center&#39;&amp;gt;&amp;lt;td id = &#39;&amp;quot; + this.userid + &amp;quot;&#39; &amp;gt; &amp;quot; + this.userid + &amp;quot;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&amp;quot; + this.username + &amp;quot;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&amp;quot; + this.usersex + &amp;quot;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&amp;quot; + this.userbirth + &amp;quot;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&amp;lt;a href=&#39;#&#39; onclick=&#39;preUpdateUser()&#39;&amp;gt;选择更新&amp;amp;nbsp;&amp;amp;nbsp;&amp;lt;/a&amp;gt;&amp;lt;a href=&#39;#&#39; onclick=&#39;deleteUser(&amp;quot; + this.userid + &amp;quot;)&#39;&amp;gt;删除&amp;lt;/a&amp;gt;&amp;lt;/td &amp;gt; &amp;lt; /tr&amp;gt;&amp;quot;
            });
            $(&amp;quot;#tBody&amp;quot;).prepend(str);
        }
    &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;522-创建-servlet-处理页面数据初始化请求&#34;&gt;5.2.2 创建 Servlet 处理页面数据初始化请求&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@WebServlet(&amp;quot;/user.do&amp;quot;)
public class UserServlet extends HttpServlet {
    //生成模拟数据初始化
    @Override
    public void init() throws ServletException {
        User user = new User();
        user.setUserid(1);
        user.setUsername(&amp;quot;Oldlu&amp;quot;);
        user.setUsersex(&amp;quot;male&amp;quot;);
        user.setUserbirth(new Date());
        User user2 = new User();
        user2.setUserid(2);
        user2.setUsername(&amp;quot;Kevin&amp;quot;);
        user2.setUsersex(&amp;quot;male&amp;quot;);
        user2.setUserbirth(new Date());
        List&amp;lt;User&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        list.add(user);
        list.add(user2);
        ServletContext servletContext = this.getServletContext();
        servletContext.setAttribute(&amp;quot;list&amp;quot;, list);

    }

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        this.doPost(req, resp);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        String flag = req.getParameter(&amp;quot;flag&amp;quot;);
        if (&amp;quot;getData&amp;quot;.equals(flag)) {
            this.getData(req, resp);
        }
    }

    //获取页面初始化数据
    private void getData(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        List&amp;lt;User&amp;gt; list = (List&amp;lt;User&amp;gt;) this.getServletContext().getAttribute(&amp;quot;list&amp;quot;);
        String s = JsonUtils.objectToJson(list);
        resp.setContentType(&amp;quot;application/json&amp;quot;);
        PrintWriter pw = resp.getWriter();
        pw.print(s);
        pw.flush();
        pw.close();
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615144207.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;53-添加用户操作&#34;&gt;5.3 添加用户操作&lt;/h3&gt;
&lt;h4 id=&#34;531-通过-ajax-完成添加用户&#34;&gt;5.3.1 通过 Ajax 完成添加用户&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;script&amp;gt;
        $(function () {
            //获取页面初始化数据
            getData();
            //添加按钮绑定点击事件
            $(&amp;quot;#add&amp;quot;).click(function () {
                addorupdateUser(&amp;quot;addUser&amp;quot;);
            });
        });

        //获取页面初始化数据
        function getData() {
            $.getJSON(&amp;quot;user.do&amp;quot;, {flag: &amp;quot;getData&amp;quot;}, function (result) {
                init(result);
            });
        }

        //遍历数据生成数据
        function init(obj) {
            var str = &amp;quot;&amp;quot;;
            $.each(obj, function () {
                str += &amp;quot;&amp;lt;tr align=&#39;center&#39;&amp;gt;&amp;lt;td id = &#39;&amp;quot; + this.userid + &amp;quot;&#39; &amp;gt; &amp;quot; + this.userid + &amp;quot;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&amp;quot; + this.username + &amp;quot;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&amp;quot; + this.usersex + &amp;quot;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&amp;quot; + this.userbirth + &amp;quot;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&amp;lt;a href=&#39;#&#39; onclick=&#39;preUpdateUser()&#39;&amp;gt;选择更新&amp;amp;nbsp;&amp;amp;nbsp;&amp;lt;/a&amp;gt;&amp;lt;a href=&#39;#&#39; onclick=&#39;deleteUser(&amp;quot; + this.userid + &amp;quot;)&#39;&amp;gt;删除&amp;lt;/a&amp;gt;&amp;lt;/td &amp;gt; &amp;lt; /tr&amp;gt;&amp;quot;
            });
            $(&amp;quot;#tBody&amp;quot;).prepend(str);
        }

        //用户添加或者更新
        function addorupdateUser(flag) {
            var userid = $(&amp;quot;#userid&amp;quot;).val();
            var username = $(&amp;quot;#username&amp;quot;).val();
            var usersex = $(&amp;quot;#usersex&amp;quot;).val();
            var userbirth = $(&amp;quot;#userbirth&amp;quot;).val();
            var data = {
                userid: userid,
                username: username,
                usersex: usersex,
                userbirth: userbirth,
                flag: flag
            }
            //刷新页面
            location.reload();
            $.get(&amp;quot;user.do&amp;quot;, data, function (result) {
                alert(result);
            });
        }
    &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;532-在-servlet-中处理添加用户请求&#34;&gt;5.3.2 在 Servlet 中处理添加用户请求&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 用户管理 Servlet
 */
@WebServlet(&amp;quot;/user.do&amp;quot;)
public class UserServlet extends HttpServlet {
    //生成模拟数据初始化
    @Override
    public void init() throws ServletException {
        User user = new User();
        user.setUserid(1);
        user.setUsername(&amp;quot;Oldlu&amp;quot;);
        user.setUsersex(&amp;quot;male&amp;quot;);
        user.setUserbirth(new Date());
        User user2 = new User();
        user2.setUserid(2);
        user2.setUsername(&amp;quot;Kevin&amp;quot;);
        user2.setUsersex(&amp;quot;male&amp;quot;);
        user2.setUserbirth(new Date());
        List&amp;lt;User&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        list.add(user);
        list.add(user2);
        ServletContext servletContext = this.getServletContext();
        servletContext.setAttribute(&amp;quot;list&amp;quot;, list);

    }

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        this.doPost(req, resp);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        String flag = req.getParameter(&amp;quot;flag&amp;quot;);
        if (&amp;quot;getData&amp;quot;.equals(flag)) {
            this.getData(req, resp);
        }else if(&amp;quot;addUser&amp;quot;.equals(flag)){
            try {
                this.addUser(req, resp);
            } catch (ParseException e) {
                e.printStackTrace();
            }
        }
    }

    //获取页面初始化数据
    private void getData(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        List&amp;lt;User&amp;gt; list = (List&amp;lt;User&amp;gt;) this.getServletContext().getAttribute(&amp;quot;list&amp;quot;);
        String s = JsonUtils.objectToJson(list);
        resp.setContentType(&amp;quot;application/json&amp;quot;);
        PrintWriter pw = resp.getWriter();
        pw.print(s);
        pw.flush();
        pw.close();
    }

    //处理添加用户请求
    private void addUser(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException, ParseException {
        User user = createUser(req);
        //从ServletContext中取出list
        ServletContext servletContext = this.getServletContext();
        //getAttribute返回的是一个object对象
        List&amp;lt;User&amp;gt; list = (List&amp;lt;User&amp;gt;) servletContext.getAttribute(&amp;quot;list&amp;quot;);
        list.add(user);
        resp.setContentType(&amp;quot;text/plain;charset=utf-8&amp;quot;);
        PrintWriter pw = resp.getWriter();
        pw.print(&amp;quot;添加成功&amp;quot;);
        pw.flush();
        pw.close();
    }

    //获取请求数据
    private User createUser(HttpServletRequest req) throws ParseException {
        String userid = req.getParameter(&amp;quot;userid&amp;quot;);
        String username = req.getParameter(&amp;quot;username&amp;quot;);
        String usersex = req.getParameter(&amp;quot;usersex&amp;quot;);
        String userbirth = req.getParameter(&amp;quot;userbirth&amp;quot;);

        User user = new User();
        user.setUserid(Integer.parseInt(userid));
        user.setUsername(username);
        user.setUsersex(usersex);

        SimpleDateFormat sf = new SimpleDateFormat(&amp;quot;yyyy-MM-dd&amp;quot;);
        Date parse = sf.parse(userbirth);
        user.setUserbirth(parse);

        return user;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解决时区问题:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@JsonFormat(pattern = &amp;quot;yyyy-MM-dd&amp;quot;,timezone = &amp;quot;GMT+8&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615153808.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615153820.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;54-更新用户操作&#34;&gt;5.4 更新用户操作&lt;/h3&gt;
&lt;h4 id=&#34;541-通过-ajax-完成预更新用户选择&#34;&gt;5.4.1 通过 Ajax 完成预更新用户选择&lt;/h4&gt;
&lt;p&gt;实现选择更新数据回填文本框&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;script&amp;gt;
        $(function () {
            //获取页面初始化数据
            getData();
            //添加按钮绑定点击事件
            $(&amp;quot;#add&amp;quot;).click(function () {
                addorupdateUser(&amp;quot;addUser&amp;quot;);
            });
        });

        //获取页面初始化数据
        function getData() {
            $.getJSON(&amp;quot;user.do&amp;quot;, {flag: &amp;quot;getData&amp;quot;}, function (result) {
                init(result);
            });
        }

        //遍历数据生成数据
        function init(obj) {
            var str = &amp;quot;&amp;quot;;
            $.each(obj, function () {
                str += &amp;quot;&amp;lt;tr align=&#39;center&#39;&amp;gt;&amp;lt;td id = &#39;&amp;quot; + this.userid + &amp;quot;&#39; &amp;gt; &amp;quot; + this.userid + &amp;quot;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&amp;quot; + this.username + &amp;quot;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&amp;quot; + this.usersex + &amp;quot;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&amp;quot; + this.userbirth + &amp;quot;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&amp;lt;a href=&#39;#&#39; onclick=&#39;preUpdateUser(&amp;quot; + this.userid + &amp;quot;)&#39;&amp;gt;选择更新&amp;amp;nbsp;&amp;amp;nbsp;&amp;lt;/a&amp;gt;&amp;lt;a href=&#39;#&#39; onclick=&#39;deleteUser(&amp;quot; + this.userid + &amp;quot;)&#39;&amp;gt;删除&amp;lt;/a&amp;gt;&amp;lt;/td &amp;gt; &amp;lt; /tr&amp;gt;&amp;quot;
            });
            $(&amp;quot;#tBody&amp;quot;).prepend(str);
        }

        //用户添加或者更新
        function addorupdateUser(flag) {
            var userid = $(&amp;quot;#userid&amp;quot;).val();
            var username = $(&amp;quot;#username&amp;quot;).val();
            var usersex = $(&amp;quot;#usersex&amp;quot;).val();
            var userbirth = $(&amp;quot;#userbirth&amp;quot;).val();
            var data = {
                userid: userid,
                username: username,
                usersex: usersex,
                userbirth: userbirth,
                flag: flag
            }
            //刷新页面
            location.reload();
            $.get(&amp;quot;user.do&amp;quot;, data, function (result) {
                alert(result);
            });
        }

        //更新之前数据选择
        function preUpdateUser(userid) {
            var arr = new Array();
            //根据传进来的userid拼接
            $(&amp;quot;#&amp;quot;+userid).closest(&amp;quot;tr&amp;quot;).children().each(function (index, ele) {
                if (index &amp;lt;= 3) {
                    arr[index] = ele.innerText;
                }
            })
            $(&amp;quot;#userid&amp;quot;).val(arr[0]);
            $(&amp;quot;#username&amp;quot;).val(arr[1]);
            $(&amp;quot;#usersex&amp;quot;).val(arr[2]);
            $(&amp;quot;#userbirth&amp;quot;).val(arr[3]);

            $(&amp;quot;#userid&amp;quot;).Attr(&amp;quot;readonly&amp;quot;);
        }
    &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615160446.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;542-通过-ajax-完成更新用户&#34;&gt;5.4.2 通过 Ajax 完成更新用户&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;script&amp;gt;
        $(function () {
            //获取页面初始化数据
            getData();
            //添加按钮绑定点击事件
            $(&amp;quot;#add&amp;quot;).click(function () {
                addorupdateUser(&amp;quot;addUser&amp;quot;);
            });
            //更新按钮绑定点击事件
            $(&amp;quot;#update&amp;quot;).click(function () {
                addorupdateUser(&amp;quot;updateUser&amp;quot;);
            })
        });

        //获取页面初始化数据
        function getData() {
            $.getJSON(&amp;quot;user.do&amp;quot;, {flag: &amp;quot;getData&amp;quot;}, function (result) {
                init(result);
            });
        }

        //遍历数据生成数据
        function init(obj) {
            var str = &amp;quot;&amp;quot;;
            $.each(obj, function () {
                str += &amp;quot;&amp;lt;tr align=&#39;center&#39;&amp;gt;&amp;lt;td id = &#39;&amp;quot; + this.userid + &amp;quot;&#39; &amp;gt; &amp;quot; + this.userid + &amp;quot;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&amp;quot; + this.username + &amp;quot;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&amp;quot; + this.usersex + &amp;quot;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&amp;quot; + this.userbirth + &amp;quot;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&amp;lt;a href=&#39;#&#39; onclick=&#39;preUpdateUser(&amp;quot; + this.userid + &amp;quot;)&#39;&amp;gt;选择更新&amp;amp;nbsp;&amp;amp;nbsp;&amp;lt;/a&amp;gt;&amp;lt;a href=&#39;#&#39; onclick=&#39;deleteUser(&amp;quot; + this.userid + &amp;quot;)&#39;&amp;gt;删除&amp;lt;/a&amp;gt;&amp;lt;/td &amp;gt; &amp;lt; /tr&amp;gt;&amp;quot;
            });
            $(&amp;quot;#tBody&amp;quot;).prepend(str);
        }

        //用户添加或者更新
        function addorupdateUser(flag) {
            var userid = $(&amp;quot;#userid&amp;quot;).val();
            var username = $(&amp;quot;#username&amp;quot;).val();
            var usersex = $(&amp;quot;#usersex&amp;quot;).val();
            var userbirth = $(&amp;quot;#userbirth&amp;quot;).val();
            var data = {
                userid: userid,
                username: username,
                usersex: usersex,
                userbirth: userbirth,
                flag: flag
            }
            //刷新页面
            location.reload();
            $.get(&amp;quot;user.do&amp;quot;, data, function (result) {
                alert(result);
            });
        }

        //更新之前数据选择
        function preUpdateUser(userid) {
            var arr = new Array();
            $(&amp;quot;#&amp;quot;+userid).closest(&amp;quot;tr&amp;quot;).children().each(function (index, ele) {
                if (index &amp;lt;= 3) {
                    arr[index] = ele.innerText;
                }
            })
            $(&amp;quot;#userid&amp;quot;).val(arr[0]);
            $(&amp;quot;#username&amp;quot;).val(arr[1]);
            $(&amp;quot;#usersex&amp;quot;).val(arr[2]);
            $(&amp;quot;#userbirth&amp;quot;).val(arr[3]);

            $(&amp;quot;#userid&amp;quot;).Attr(&amp;quot;readonly&amp;quot;);
        }
    &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;543-在-servlet-中处理更新用户请求&#34;&gt;5.4.3 在 Servlet 中处理更新用户请求&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/** 用户管理 Servlet 
 *
 * */
@WebServlet(&amp;quot;/user.do&amp;quot;)
public class UserServlet extends HttpServlet {
  // 生成模拟数据初始化
  @Override
  public void init() throws ServletException {
    User user = new User();
    user.setUserid(1);
    user.setUsername(&amp;quot;Oldlu&amp;quot;);
    user.setUsersex(&amp;quot;male&amp;quot;);
    user.setUserbirth(new Date());
    User user2 = new User();
    user2.setUserid(2);
    user2.setUsername(&amp;quot;Kevin&amp;quot;);
    user2.setUsersex(&amp;quot;male&amp;quot;);
    user2.setUserbirth(new Date());
    List&amp;lt;User&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
    list.add(user);
    list.add(user2);
    ServletContext servletContext = this.getServletContext();
    servletContext.setAttribute(&amp;quot;list&amp;quot;, list);
  }

  @Override
  protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    this.doPost(req, resp);
  }

  @Override
  protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    String flag = req.getParameter(&amp;quot;flag&amp;quot;);
    if (&amp;quot;getData&amp;quot;.equals(flag)) {
      this.getData(req, resp);
    } else if (&amp;quot;addUser&amp;quot;.equals(flag)) {
      try {
        this.addUser(req, resp);
      } catch (ParseException e) {
        e.printStackTrace();
      }
    } else if (&amp;quot;updateUser&amp;quot;.equals(flag)) {
      try {
        this.updateUser(req, resp);
      } catch (ParseException e) {
        e.printStackTrace();
      }
    }
  }

  // 获取页面初始化数据
  private void getData(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    List&amp;lt;User&amp;gt; list = (List&amp;lt;User&amp;gt;) this.getServletContext().getAttribute(&amp;quot;list&amp;quot;);
    String s = JsonUtils.objectToJson(list);
    resp.setContentType(&amp;quot;application/json&amp;quot;);
    PrintWriter pw = resp.getWriter();
    pw.print(s);
    pw.flush();
    pw.close();
  }

  // 处理添加用户请求
  private void addUser(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException, ParseException {
    User user = createUser(req);
    // 从ServletContext中取出list
    ServletContext servletContext = this.getServletContext();
    // getAttribute返回的是一个object对象
    List&amp;lt;User&amp;gt; list = (List&amp;lt;User&amp;gt;) servletContext.getAttribute(&amp;quot;list&amp;quot;);
    list.add(user);
    resp.setContentType(&amp;quot;text/plain;charset=utf-8&amp;quot;);
    PrintWriter pw = resp.getWriter();
    pw.print(&amp;quot;添加成功&amp;quot;);
    pw.flush();
    pw.close();
  }

  // 处理更新用户请求
  private void updateUser(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException, ParseException {
    User user = this.createUser(req);
    ServletContext servletContext = this.getServletContext();
    List&amp;lt;User&amp;gt; list = (List&amp;lt;User&amp;gt;) servletContext.getAttribute(&amp;quot;list&amp;quot;);

    //避免在迭代中更改集合的长度
      User u=null;
      for (User temp :list ) {
          if(temp.getUserid() == user.getUserid()){
              u = temp;
              break;
          }
      }
      if(u != null){
          list.remove(u);
      }
      list.add(user);
      resp.setContentType(&amp;quot;text/plain;charset=utf-8&amp;quot;);
      PrintWriter pw = resp.getWriter();
      pw.print(&amp;quot;更新成功&amp;quot;);
      pw.flush();
      pw.close();
  }

  // 获取请求数据
  private User createUser(HttpServletRequest req) throws ParseException {
    String userid = req.getParameter(&amp;quot;userid&amp;quot;);
    String username = req.getParameter(&amp;quot;username&amp;quot;);
    String usersex = req.getParameter(&amp;quot;usersex&amp;quot;);
    String userbirth = req.getParameter(&amp;quot;userbirth&amp;quot;);

    User user = new User();
    user.setUserid(Integer.parseInt(userid));
    user.setUsername(username);
    user.setUsersex(usersex);

    SimpleDateFormat sf = new SimpleDateFormat(&amp;quot;yyyy-MM-dd&amp;quot;);
    Date parse = sf.parse(userbirth);
    user.setUserbirth(parse);

    return user;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615163605.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615163622.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;18&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615163635.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;55删除用户操作&#34;&gt;5.5删除用户操作&lt;/h3&gt;
&lt;h4 id=&#34;551-通过-ajax-完成删除用户&#34;&gt;5.5.1 通过 Ajax 完成删除用户&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;script&amp;gt;
        $(function () {
            //获取页面初始化数据
            getData();
            //添加按钮绑定点击事件
            $(&amp;quot;#add&amp;quot;).click(function () {
                addorupdateUser(&amp;quot;addUser&amp;quot;);
            });
            //更新按钮绑定点击事件
            $(&amp;quot;#update&amp;quot;).click(function () {
                addorupdateUser(&amp;quot;updateUser&amp;quot;);
            })
        });

        //获取页面初始化数据
        function getData() {
            $.getJSON(&amp;quot;user.do&amp;quot;, {flag: &amp;quot;getData&amp;quot;}, function (result) {
                init(result);
            });
        }

        //遍历数据生成数据
        function init(obj) {
            var str = &amp;quot;&amp;quot;;
            $.each(obj, function () {
                str += &amp;quot;&amp;lt;tr align=&#39;center&#39;&amp;gt;&amp;lt;td id = &#39;&amp;quot; + this.userid + &amp;quot;&#39; &amp;gt; &amp;quot; + this.userid + &amp;quot;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&amp;quot; + this.username + &amp;quot;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&amp;quot; + this.usersex + &amp;quot;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&amp;quot; + this.userbirth + &amp;quot;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&amp;lt;a href=&#39;#&#39; onclick=&#39;preUpdateUser(&amp;quot; + this.userid + &amp;quot;)&#39;&amp;gt;选择更新&amp;amp;nbsp;&amp;amp;nbsp;&amp;lt;/a&amp;gt;&amp;lt;a href=&#39;#&#39; onclick=&#39;deleteUser(&amp;quot; + this.userid + &amp;quot;)&#39;&amp;gt;删除&amp;lt;/a&amp;gt;&amp;lt;/td &amp;gt; &amp;lt; /tr&amp;gt;&amp;quot;
            });
            $(&amp;quot;#tBody&amp;quot;).prepend(str);
        }

        //用户添加或者更新
        function addorupdateUser(flag) {
            var userid = $(&amp;quot;#userid&amp;quot;).val();
            var username = $(&amp;quot;#username&amp;quot;).val();
            var usersex = $(&amp;quot;#usersex&amp;quot;).val();
            var userbirth = $(&amp;quot;#userbirth&amp;quot;).val();
            var data = {
                userid: userid,
                username: username,
                usersex: usersex,
                userbirth: userbirth,
                flag: flag
            }
            //刷新页面
            location.reload();
            $.get(&amp;quot;user.do&amp;quot;, data, function (result) {
                alert(result);
            });
        }

        //更新之前数据选择
        function preUpdateUser(userid) {
            var arr = new Array();
            $(&amp;quot;#&amp;quot; + userid).closest(&amp;quot;tr&amp;quot;).children().each(function (index, ele) {
                if (index &amp;lt;= 3) {
                    arr[index] = ele.innerText;
                }
            })
            $(&amp;quot;#userid&amp;quot;).val(arr[0]);
            $(&amp;quot;#username&amp;quot;).val(arr[1]);
            $(&amp;quot;#usersex&amp;quot;).val(arr[2]);
            $(&amp;quot;#userbirth&amp;quot;).val(arr[3]);

            $(&amp;quot;#userid&amp;quot;).Attr(&amp;quot;readonly&amp;quot;);
        }

        //删除用户
        function deleteUser(userid) {
            $(&amp;quot;#&amp;quot; + userid).closest(&amp;quot;tr&amp;quot;).remove();
            $.get(&amp;quot;user.do&amp;quot;, {userid: userid}, function (result) {
                alert(result);
            })
        }
    &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;552-在-servlet-处理删除用户请求&#34;&gt;5.5.2 在 Servlet 处理删除用户请求&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/** 用户管理 Servlet
 *
 * */
@WebServlet(&amp;quot;/user.do&amp;quot;)
public class UserServlet extends HttpServlet {
  // 生成模拟数据初始化
  @Override
  public void init() throws ServletException {
    User user = new User();
    user.setUserid(1);
    user.setUsername(&amp;quot;Oldlu&amp;quot;);
    user.setUsersex(&amp;quot;male&amp;quot;);
    user.setUserbirth(new Date());
    User user2 = new User();
    user2.setUserid(2);
    user2.setUsername(&amp;quot;Kevin&amp;quot;);
    user2.setUsersex(&amp;quot;male&amp;quot;);
    user2.setUserbirth(new Date());
    List&amp;lt;User&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
    list.add(user);
    list.add(user2);
    ServletContext servletContext = this.getServletContext();
    servletContext.setAttribute(&amp;quot;list&amp;quot;, list);
  }

  @Override
  protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    this.doPost(req, resp);
  }

  @Override
  protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    String flag = req.getParameter(&amp;quot;flag&amp;quot;);
    if (&amp;quot;getData&amp;quot;.equals(flag)) {
      this.getData(req, resp);
    } else if (&amp;quot;addUser&amp;quot;.equals(flag)) {
      try {
        this.addUser(req, resp);
      } catch (ParseException e) {
         e.printStackTrace();
      }
    } else if (&amp;quot;updateUser&amp;quot;.equals(flag)) {
      try {
        this.updateUser(req, resp);
      } catch (ParseException e) {
        e.printStackTrace();
      }
    }else{
        try {
            this.deleteUser(req,resp);
        } catch (ParseException e) {
            e.printStackTrace();
        }
    }
  }

  // 获取页面初始化数据
  private void getData(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    List&amp;lt;User&amp;gt; list = (List&amp;lt;User&amp;gt;) this.getServletContext().getAttribute(&amp;quot;list&amp;quot;);
    String s = JsonUtils.objectToJson(list);
    resp.setContentType(&amp;quot;application/json&amp;quot;);
    PrintWriter pw = resp.getWriter();
    pw.print(s);
    pw.flush();
    pw.close();
  }

  // 处理添加用户请求
  private void addUser(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException, ParseException {
    User user = createUser(req);
    // 从ServletContext中取出list
    ServletContext servletContext = this.getServletContext();
    // getAttribute返回的是一个object对象
    List&amp;lt;User&amp;gt; list = (List&amp;lt;User&amp;gt;) servletContext.getAttribute(&amp;quot;list&amp;quot;);
    list.add(user);
    resp.setContentType(&amp;quot;text/plain;charset=utf-8&amp;quot;);
    PrintWriter pw = resp.getWriter();
    pw.print(&amp;quot;添加成功&amp;quot;);
    pw.flush();
    pw.close();
  }

  // 处理更新用户请求
  private void updateUser(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException, ParseException {
    User user = this.createUser(req);
    ServletContext servletContext = this.getServletContext();
    List&amp;lt;User&amp;gt; list = (List&amp;lt;User&amp;gt;) servletContext.getAttribute(&amp;quot;list&amp;quot;);

    //避免在迭代中更改集合的长度
      User u = null;
      for (User temp :list ) {
          if(temp.getUserid() == user.getUserid()){
              u = temp;
              break;
          }
      }
      if(u != null){
          list.remove(u);
      }
      list.add(user);
      resp.setContentType(&amp;quot;text/plain;charset=utf-8&amp;quot;);
      PrintWriter pw = resp.getWriter();
      pw.print(&amp;quot;更新成功&amp;quot;);
      pw.flush();
      pw.close();
  }

  //处理删除用户数据
    private void deleteUser(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException, ParseException {
        String userid = req.getParameter(&amp;quot;userid&amp;quot;);
        ServletContext servletContext = this.getServletContext();
        List&amp;lt;User&amp;gt; list = (List&amp;lt;User&amp;gt;) servletContext.getAttribute(&amp;quot;list&amp;quot;);
        User user = null;
        for (User temp : list) {
            if((temp.getUserid()+&amp;quot;&amp;quot;).equals(userid)){
                user = temp;
                break;
            }
        }
        if(user != null){
            list.remove(user);
        }
        resp.setContentType(&amp;quot;text/plain;charset=utf-8&amp;quot;);
        PrintWriter pw = resp.getWriter();
        pw.print(&amp;quot;删除成功&amp;quot;);
        pw.flush();
        pw.close();
    }

  // 获取请求数据
  private User createUser(HttpServletRequest req) throws ParseException {
    String userid = req.getParameter(&amp;quot;userid&amp;quot;);
    String username = req.getParameter(&amp;quot;username&amp;quot;);
    String usersex = req.getParameter(&amp;quot;usersex&amp;quot;);
    String userbirth = req.getParameter(&amp;quot;userbirth&amp;quot;);

    User user = new User();
    user.setUserid(Integer.parseInt(userid));
    user.setUsername(username);
    user.setUsersex(usersex);

    SimpleDateFormat sf = new SimpleDateFormat(&amp;quot;yyyy-MM-dd&amp;quot;);
    Date parse = sf.parse(userbirth);
    user.setUserbirth(parse);

    return user;
  }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;19&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615170710.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;20&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615170722.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">Ajax</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jonchan1013.github.io/post/jquery/"" data-c="
          &lt;p&gt;✍️ jQuery 是一个 JavaScript 库。 jQuery 极大地简化了 JavaScript 编程......&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;1-jquery的概述&#34;&gt;1、jQuery的概述&lt;/h2&gt;
&lt;h3 id=&#34;11-为什么要用jquery&#34;&gt;1.1 为什么要用jquery&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;选择器功能弱&lt;/li&gt;
&lt;li&gt;DOM操作繁琐之极&lt;/li&gt;
&lt;li&gt;浏览器兼容性不好&lt;/li&gt;
&lt;li&gt;动画效果弱&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;12-什么是-jquery概念&#34;&gt;1.2 什么是 jQuery(概念)&lt;/h3&gt;
&lt;p&gt;​	jQuery （javaScriptQuery）JavaScript 代码库&lt;/p&gt;
&lt;p&gt;js.js:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function $(id){
    var dom = document.getElementById(id);
    return dom;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;jq的含义.html:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
	&amp;lt;head&amp;gt;
		&amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
		&amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
		
		&amp;lt;!--[1]引入js文件--&amp;gt;
		
		&amp;lt;script src=&amp;quot;js/js.js&amp;quot; type=&amp;quot;text/javascript&amp;quot; charset=&amp;quot;utf-8&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
		
		&amp;lt;script&amp;gt;
			
			//js获得元素对象的方式
			var  div =document.getElementById(&amp;quot;div1&amp;quot;);
			
			//JQ获得元素的方式
			var  div2=$(&amp;quot;div1&amp;quot;);
			
		&amp;lt;/script&amp;gt;	
		
	&amp;lt;/head&amp;gt;
	&amp;lt;body&amp;gt;
		
		&amp;lt;div id=&amp;quot;div1&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
		
	&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;13-目前-jquery-有三个大版本&#34;&gt;1.3 目前 jQuery 有三个大版本：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1.x：兼容ie678,使用最为广泛的，官方只做BUG维护，功能不再新增。因此一般项目来说，使用1.x版本就可以了，最终版本：1.12.4 (2016年5月20日)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2.x：不兼容ie678，很少有人使用，官方只做BUG维护，功&lt;br&gt;
能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x，最终版本：2.2.4 (2016年5月20日)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3.x：不兼容 ie678，只支持最新的浏览器。除非特殊要求一般不会使用 3.x 版本的，很多老的 jQuery 插件不支持这个版本。目前该版本是官方主要更新维护的版本。最新版本：3.4.1&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-jquery-中的含义&#34;&gt;2、jQuery 中$的含义&lt;/h2&gt;
&lt;p&gt;引入jQuery：&lt;/p&gt;
&lt;script src=&#34;js/jquery-1.9.1.js&#34; type=&#34;text/javascript&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
&lt;p&gt;js的方式实现隔行变色的效果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;window.onload=function(){	  	 	
		  	 	//获得所有的tr对象  	 	
  	 	var  tr =document.getElementsByTagName(&amp;quot;tr&amp;quot;);
		  	 	
	 	 	for(var i =0;i&amp;lt;tr.length;i++){ 		
  	 		 if(i%2==0){
  	 		 	tr[i].style.backgroundColor=&amp;quot;red&amp;quot;;	  	 		 	
		  		 }else { 	 		 	
		  		 	tr[i].style.backgroundColor=&amp;quot;green&amp;quot;;
	 	 		 }		  	 				  	 		
  	 	} 	 	
  	 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;jQuery实现隔行变色的效果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$(function(){	
	 	  $(&amp;quot;tr:odd&amp;quot;).css(&amp;quot;background-color&amp;quot;,&amp;quot;red&amp;quot;);
 })
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;21-作用-1function&#34;&gt;2.1 作用 1：$(function)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;相当于 window.onload=function(){}&lt;/li&gt;
&lt;li&gt;功能比window.onload更强大
&lt;ol&gt;
&lt;li&gt;window onload一个页面只能写一个,但是可以写多个$() 而不冲突&lt;/li&gt;
&lt;li&gt;window onload要等整个页面加载完后再执行（包括图片、超链接、音视频等），但是$的执行时间要早&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;3.完整形式是$(document).ready(…….);&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;22-作用-2selector&#34;&gt;2.2. 作用 2：$(selector)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;选择器&lt;br&gt;
jQuery具有强大的选择器功能&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-基本选择器一&#34;&gt;3、基本选择器（一）&lt;/h2&gt;
&lt;h3 id=&#34;31-对象之间的转换&#34;&gt;3.1 对象之间的转换&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;DOM对象：直接使用JavaScript获取的节点对象
&lt;ul&gt;
&lt;li&gt;className  innerHTML  value&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;jQuery对象：使用jQuery选择器获取的节点对象，它能够使用jQuery中的方法
&lt;ul&gt;
&lt;li&gt;addClass()  html()  val()&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DOM对象和jQuery对象分别拥有一套独立的方法，不能混用&lt;/li&gt;
&lt;li&gt;DOM对象转换成jQuery对象
&lt;ul&gt;
&lt;li&gt;$(DOM对象)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;jQuery对象转换成DOM对象
&lt;ul&gt;
&lt;li&gt;jQuery对象[index]&lt;/li&gt;
&lt;li&gt;jQuery对象.get(index)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;32-基本选择器&#34;&gt;3.2 基本选择器&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;标签选择器 $(“a”)&lt;/li&gt;
&lt;li&gt;ID选择器 $(“#id”)    $(“p#id”)&lt;/li&gt;
&lt;li&gt;类选择器 $(“.class”)    $(“h2.class”)    通配选择器 $(&amp;quot;*&amp;quot;)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;html&amp;gt;
	&amp;lt;head&amp;gt;
		&amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
		&amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
		
		&amp;lt;script src=&amp;quot;js/jquery-1.9.1.js&amp;quot; type=&amp;quot;text/javascript&amp;quot; charset=&amp;quot;utf-8&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
		
		&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
			   $(function(){		   	
			   	//js获得元素对象
			    var  zh =document.getElementById(&amp;quot;zh&amp;quot;);
			    //Element
			    // JS----JQ对象
			    var  zhh=$(zh);
			    alert(zh);
			    
			    //JQ获得元素的对象  *ID选择器
			    var  zh1=$(&amp;quot;#zh&amp;quot;);
			    //Object---[Element1,Element2,Element3]
			    //JQ----JS对象
			    alert(zh1[0]);
			    
			    //*元素选择器
			    var inp =$(&amp;quot;input&amp;quot;);
			    
			    alert(inp.length);

                //*类选择器
                
                var inp2=$(&amp;quot;.inp&amp;quot;);
                //jq先转成js再获取内容
              	alert(inp2[0].value);
                //  jq获得内容操作
			    alert(inp2.eq(0).val());

                //通用选择器
                
                $(&amp;quot;*&amp;quot;).css(&amp;quot;background-color&amp;quot;,&amp;quot;greenyellow&amp;quot;);
                
			    //分组选择器
			   })
		
		&amp;lt;/script&amp;gt;
	
	&amp;lt;/head&amp;gt;
	&amp;lt;body&amp;gt;	
		&amp;lt;p&amp;gt;		
			账号: &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;&amp;quot; id=&amp;quot;zh&amp;quot; value=&amp;quot;123&amp;quot; /&amp;gt;		
		&amp;lt;/p&amp;gt;		
		&amp;lt;p&amp;gt;
			密码: &amp;lt;input type=&amp;quot;password&amp;quot; name=&amp;quot;&amp;quot; id=&amp;quot;pwd&amp;quot; value=&amp;quot;12366&amp;quot;  class=&amp;quot;inp&amp;quot;/&amp;gt;			
		&amp;lt;/p&amp;gt;
		&amp;lt;p&amp;gt;
			 确认密码： &amp;lt;input type=&amp;quot;password&amp;quot; name=&amp;quot;&amp;quot; id=&amp;quot;pwd2&amp;quot; value=&amp;quot;123&amp;quot; class=&amp;quot;inp&amp;quot;/&amp;gt;		
		&amp;lt;/p&amp;gt;	
	&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-层级选择器&#34;&gt;4、层级选择器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;并集选择器$(&amp;quot;elem1,elem2,elem3&amp;quot;)&lt;/li&gt;
&lt;li&gt;后代选择器$(ul li)&lt;/li&gt;
&lt;li&gt;父子选择器 $(ul&amp;gt;li)&lt;/li&gt;
&lt;li&gt;后面第一个兄弟元素 prev + next
&lt;ul&gt;
&lt;li&gt;后面所有的兄弟元素 prev ~ next&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;html&amp;gt;
	&amp;lt;head&amp;gt;
		&amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
		&amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
		&amp;lt;style&amp;gt;			
			div{				
				height: 200px;				
				border:  3px solid  red;				
			}
		&amp;lt;/style&amp;gt;
		
		&amp;lt;script src=&amp;quot;js/jquery-1.9.1.js&amp;quot; type=&amp;quot;text/javascript&amp;quot; charset=&amp;quot;utf-8&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
		
		&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
			
			   $(function(){
			   	
			   	   //  div下面包含的所有span标签
			   	   $(&amp;quot;div span&amp;quot;).css(&amp;quot;background-color&amp;quot;,&amp;quot;red&amp;quot;);
			   	  // div下面的直系子元素
			   	   $(&amp;quot;div&amp;gt;span&amp;quot;).css(&amp;quot;background-color&amp;quot;,&amp;quot;green&amp;quot;);

                  //  紧接着的span标签
                 $(&amp;quot;#sp1 + span&amp;quot;).css(&amp;quot;background-color&amp;quot;,&amp;quot;red&amp;quot;);
                    
                    //获得指定元素后面同级的span标签
                   $(&amp;quot;#sp1~span&amp;quot;).css(&amp;quot;background-color&amp;quot;,&amp;quot;aqua&amp;quot;); 
			   	
			   })		
		&amp;lt;/script&amp;gt;		
	&amp;lt;/head&amp;gt;
	&amp;lt;body&amp;gt;		
	   &amp;lt;div&amp;gt;	   	 
	   	 &amp;lt;span id=&amp;quot;sp1&amp;quot;&amp;gt;你好&amp;lt;/span&amp;gt;
	   	 
	   	 &amp;lt;span&amp;gt;你好&amp;lt;/span&amp;gt;&amp;lt;br /&amp;gt;
	   	 
	   	 &amp;lt;span&amp;gt;你好&amp;lt;/span&amp;gt;&amp;lt;br /&amp;gt;
	   	 
	   	 &amp;lt;p&amp;gt;
	   	 	&amp;lt;span&amp;gt;你好&amp;lt;/span&amp;gt;&amp;lt;br /&amp;gt;
	   	 
	   	    &amp;lt;span&amp;gt;你好&amp;lt;/span&amp;gt;&amp;lt;br /&amp;gt;
	   	 
	   	    &amp;lt;span&amp;gt;你好&amp;lt;/span&amp;gt;&amp;lt;br /&amp;gt;
	   	 		   	 	
	   	 &amp;lt;/p&amp;gt;	   	
	   &amp;lt;/div&amp;gt;		
	&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5-基本选择器二&#34;&gt;5、基本选择器（二)&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;html&amp;gt;
	&amp;lt;head&amp;gt;
		&amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
		&amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
		&amp;lt;style&amp;gt;
			div{
				
				height: 200px;
				
				border:  3px solid red;
				
			}
		&amp;lt;/style&amp;gt;
		&amp;lt;script src=&amp;quot;js/jquery-1.9.1.js&amp;quot; type=&amp;quot;text/javascript&amp;quot; charset=&amp;quot;utf-8&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
		
		&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
			
			  $(function(){
			  	    //只是第一行变颜色
			  	   $(&amp;quot;ul li:first&amp;quot;).css(&amp;quot;background-color&amp;quot;,&amp;quot;red&amp;quot;);
			  	   $(&amp;quot;ul li&amp;quot;).first().css(&amp;quot;background-color&amp;quot;,&amp;quot;red&amp;quot;);
			  	   
			  	   //最后一行变颜色
			  	   $(&amp;quot;ul li:last&amp;quot;).css(&amp;quot;background-color&amp;quot;,&amp;quot;green&amp;quot;);
			  	   $(&amp;quot;ul li&amp;quot;).last().css(&amp;quot;background-color&amp;quot;,&amp;quot;green&amp;quot;);
                   //获得索引是奇数对象  索引从0开始
             	  $(&amp;quot;ul li:odd&amp;quot;).css(&amp;quot;background-color&amp;quot;,&amp;quot;green&amp;quot;);
					//获得索引是偶数对象  索引从0开始
                  $(&amp;quot;ul li:even&amp;quot;).css(&amp;quot;background-color&amp;quot;,&amp;quot;green&amp;quot;);
			  	   //获得索引下标位3的对象
			   	  $(&amp;quot;ul li:eq(3)&amp;quot;).css(&amp;quot;background-color&amp;quot;,&amp;quot;green&amp;quot;);
                    //获得大于指定索引下标的对象
                  $(&amp;quot;ul li:gt(3)&amp;quot;).css(&amp;quot;background-color&amp;quot;,&amp;quot;green&amp;quot;);
			  	    //获得小于指定索引下标的对象
			  	   $(&amp;quot;ul li:lt(3)&amp;quot;).css(&amp;quot;background-color&amp;quot;,&amp;quot;green&amp;quot;);

                   /**********子选择器*************************/
                  
                  
             	 $(&amp;quot;ul li:nth-child(1)&amp;quot;).css(&amp;quot;background-color&amp;quot;,&amp;quot;green&amp;quot;);
                    
                 $(&amp;quot;ul li:first-child&amp;quot;).css(&amp;quot;background-color&amp;quot;,&amp;quot;darkred&amp;quot;);
                    
                 $(&amp;quot;ul li:last-child&amp;quot;).css(&amp;quot;background-color&amp;quot;,&amp;quot;darkred&amp;quot;);  
                  
                 $(&amp;quot;ul li:only-child&amp;quot;).css(&amp;quot;background-color&amp;quot;,&amp;quot;#00A40C&amp;quot;);
			  })		
		&amp;lt;/script&amp;gt;
				
	&amp;lt;/head&amp;gt;
	&amp;lt;body&amp;gt;		
		&amp;lt;div&amp;gt;		
			&amp;lt;ul&amp;gt;
				&amp;lt;li&amp;gt;List  Item1&amp;lt;/li&amp;gt;
				&amp;lt;li&amp;gt;List  Item2&amp;lt;/li&amp;gt;
				&amp;lt;li&amp;gt;List  Item3&amp;lt;/li&amp;gt;
				&amp;lt;li&amp;gt;List  Item4&amp;lt;/li&amp;gt;
			&amp;lt;/ul&amp;gt;	
            
			&amp;lt;ul&amp;gt;
				&amp;lt;li&amp;gt;List  Item1&amp;lt;/li&amp;gt;
			&amp;lt;/ul&amp;gt;						
		&amp;lt;/div&amp;gt;	
	&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;6-属性选择器&#34;&gt;6、属性选择器&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
			
			$(function(){
				//type属性等于text
				$(&amp;quot;input[type=text]&amp;quot;).css(&amp;quot;background-color&amp;quot;,&amp;quot;#00A40C&amp;quot;);
				// name属性用z开头的
				$(&amp;quot;input[name^=z]&amp;quot;).css(&amp;quot;background-color&amp;quot;,&amp;quot;#FF0000&amp;quot;);
				// name属性同d结尾的
				$(&amp;quot;input[name$=d]&amp;quot;).css(&amp;quot;background-color&amp;quot;,&amp;quot;green&amp;quot;);
				//name属性中包含p 的元素
				$(&amp;quot;input[name*=p]&amp;quot;).css(&amp;quot;background-color&amp;quot;,&amp;quot;green&amp;quot;);
               
               //复合属性选择器，需要同时满足多个条件时使用
                $(&amp;quot;input[type=text][name^=z]&amp;quot;).css(&amp;quot;background-color&amp;quot;,&amp;quot;deeppink&amp;quot;); 
			})
			
			
		&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;7-表单选择器&#34;&gt;7、表单选择器&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
			
			$(function(){
				
				// √ 获得form表单中的所有的表单项
				var inp= $(&amp;quot;:input&amp;quot;) 
				//获得标签名称是input 的所有的标签对象
				var  inp2=$(&amp;quot;input&amp;quot;);
				alert(inp.length+&amp;quot;----&amp;quot;+inp2.length);
				
				$(&amp;quot;input[type=text]&amp;quot;)
				//  √ input标签 type属性等于text所对应的对象
				$(&amp;quot;:text&amp;quot;).css(&amp;quot;background-color&amp;quot;,&amp;quot;green&amp;quot;);
				
				$(&amp;quot;:password&amp;quot;).css(&amp;quot;background-color&amp;quot;,&amp;quot;red&amp;quot;);
				
				
				/********表单属性选择器*****************/
				
				//获得input标签中含有disabled属性的对象
				var but=  $(&amp;quot;input:disabled&amp;quot;);	
				
				alert(but.val());
				//√  获得含有checked属性的对象
				var  ch =$(&amp;quot;input:checked&amp;quot;);
				
			})
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;8-操作元素对象的样式&#34;&gt;8、 操作元素对象的样式&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;html&amp;gt;
	&amp;lt;head&amp;gt;
		&amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
		&amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
		
		&amp;lt;style&amp;gt;
			
			#div1{
				
				width: 200px;
				
				height: 200px;
				
				border: 2px solid  green;
				
			}			
		&amp;lt;/style&amp;gt;		
		&amp;lt;script src=&amp;quot;js/jquery-1.9.1.js&amp;quot; type=&amp;quot;text/javascript&amp;quot; charset=&amp;quot;utf-8&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
		
		&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
			
			$(function(){
				
				
				$(&amp;quot;#bu1&amp;quot;).click(function(){
					
					//获得div对象
					
					var  div =$(&amp;quot;#div1&amp;quot;);
					
					//获得css样式
					
					var wid=div.css(&amp;quot;width&amp;quot;);
					
					var hi=div.css(&amp;quot;height&amp;quot;);
					
					console.log(wid+&amp;quot;----&amp;quot;+hi);
					
					//操作元素对象的css
					
					div.css(&amp;quot;width&amp;quot;,&amp;quot;400px&amp;quot;);
					
					div.css(&amp;quot;height&amp;quot;,&amp;quot;500px&amp;quot;);
					
					div.css(&amp;quot;background-color&amp;quot;,&amp;quot;red&amp;quot;);
					
					div.css(&amp;quot;backgroundColor&amp;quot;,&amp;quot;red&amp;quot;);
					
				  //以上内容的综合---{key1:value1,key2:value2}---json数据格式
					
					div.css({&#39;width&#39;:&#39;300px&#39;,&#39;height&#39;:&#39;300px&#39;,&#39;background-color&#39;:&#39;red&#39;});
				})
				
				
			})
			
		&amp;lt;/script&amp;gt;
		
	&amp;lt;/head&amp;gt;
	&amp;lt;body&amp;gt;		
		&amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;样式的添加&amp;quot; id=&amp;quot;bu1&amp;quot;&amp;gt;		
		&amp;lt;hr /&amp;gt;	
		&amp;lt;div id=&amp;quot;div1&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;	
	&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果当页面中的css样式比较多的时候可以通过添加类的方式添加样式，方法如下：两种：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;html&amp;gt;
	&amp;lt;head&amp;gt;
		&amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
		&amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
		&amp;lt;style&amp;gt;
			#div1{
				
				width: 300px;
				
				height: 300px;
				
				border:  3px solid red;
				
			}
			
			.div{
				
				width: 500px;
				
				height: 500px;
				
				
				background-image: url(img/1.jpg);
				
				background-repeat: no-repeat;
				
				background-position: center;
				
				background-color: greenyellow;
				
			}
			
		&amp;lt;/style&amp;gt;
		
		&amp;lt;script src=&amp;quot;js/jquery-1.9.1.js&amp;quot; type=&amp;quot;text/javascript&amp;quot; charset=&amp;quot;utf-8&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
		
		&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
			
			  $(function(){
			  	 
			  	$(&amp;quot;#bu1&amp;quot;).click(function(){
			  		
			  		//获得div对象 --通过添加类的方式添加css样式
			  		$(&amp;quot;#div1&amp;quot;).attr(&amp;quot;class&amp;quot;,&amp;quot;div&amp;quot;);
			  		
			  		$(&amp;quot;#div1&amp;quot;).addClass(&amp;quot;div&amp;quot;);
			  	})			  				  	
			  })
						
		&amp;lt;/script&amp;gt;				
	&amp;lt;/head&amp;gt;
	&amp;lt;body&amp;gt;
		
		&amp;lt;input type=&amp;quot;button&amp;quot; name=&amp;quot;&amp;quot; id=&amp;quot;bu1&amp;quot; value=&amp;quot;元素样式操作&amp;quot; /&amp;gt;		
		&amp;lt;hr /&amp;gt;		
		&amp;lt;div id=&amp;quot;div1&amp;quot;&amp;gt;			
		&amp;lt;/div&amp;gt;
	&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;9-操作元素对象的属性&#34;&gt;9、操作元素对象的属性&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
	&amp;lt;head&amp;gt;
		&amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
		&amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
		&amp;lt;script src=&amp;quot;js/jquery-1.9.1.js&amp;quot; type=&amp;quot;text/javascript&amp;quot; charset=&amp;quot;utf-8&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
		
		&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
			
			 $(function(){
			 	
			 	 $(&amp;quot;#bu1&amp;quot;).click(function(){
			 	 	
			 	  //获得元素对象
			 	  var tex=$(&amp;quot;#inp1&amp;quot;);
			 	 //获得元素对象的属性	
			 	  var te=tex.attr(&amp;quot;type&amp;quot;);
			 	 	
			 	  var cl =tex.attr(&amp;quot;class&amp;quot;);
			 	 //获得元素固有的属性值
			 	 var  val =tex.attr(&amp;quot;value&amp;quot;);
			 	 
			 	 console.log(te+&amp;quot;------&amp;quot;+cl+&amp;quot;-----&amp;quot;+val);
			 	 //获得文本框实时输入的值
			 	 var  val2=tex.val();
			 	  alert(val2);
			 	 
			 	 /*********操作元素对象的属性******************/
                  
                  tex.attr(&amp;quot;type&amp;quot;,&amp;quot;button&amp;quot;);
                  
                  tex.attr(&amp;quot;value&amp;quot;,&amp;quot;测试按钮&amp;quot;);
			 	 
			 	 //支持json数据格式
			 	  tex.attr({&amp;quot;type&amp;quot;:&amp;quot;button&amp;quot;,&amp;quot;value&amp;quot;:&amp;quot;测试按钮&amp;quot;});
			 	  
			 	  var ch= $(&amp;quot;#fav&amp;quot;).attr(&amp;quot;checked&amp;quot;);//返回的是checked
                  var  flag=$(&amp;quot;#fav&amp;quot;).prop(&amp;quot;checked&amp;quot;);//返回值是true或false

                  var  flag=$(&amp;quot;#fav&amp;quot;).prop(&amp;quot;checked&amp;quot;,true);
			 	 
			 	 })			 	
			 	
			 })
		&amp;lt;/script&amp;gt;
		
	&amp;lt;/head&amp;gt;
	&amp;lt;body&amp;gt;
		
		&amp;lt;input type=&amp;quot;button&amp;quot; name=&amp;quot;&amp;quot; id=&amp;quot;bu1&amp;quot; value=&amp;quot;元素属性的获得&amp;quot; /&amp;gt;
		&amp;lt;hr /&amp;gt;
		&amp;lt;form&amp;gt;
			
			
			账号：&amp;lt;input type=&amp;quot;text&amp;quot; class=&amp;quot;inp&amp;quot; id=&amp;quot;inp1&amp;quot; value=&amp;quot;sxt&amp;quot; /&amp;gt; &amp;lt;br /&amp;gt;
			
			
			密码：&amp;lt;input type=&amp;quot;password&amp;quot; class=&amp;quot;pwd&amp;quot; id=&amp;quot;pwd1&amp;quot; value=&amp;quot;sxt&amp;quot; /&amp;gt;&amp;lt;br /&amp;gt;
			
			
			爱好： 抽烟：&amp;lt;input type=&amp;quot;checkbox&amp;quot; /&amp;gt;
			         
			       喝酒：&amp;lt;input type=&amp;quot;checkbox&amp;quot; /&amp;gt;
			
			       烫头：&amp;lt;input type=&amp;quot;checkbox&amp;quot; checked=&amp;quot;checked&amp;quot; id=&amp;quot;fav&amp;quot; /&amp;gt;
		
		&amp;lt;/form&amp;gt;
		
	&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;10-操作元素对象的内容和值&#34;&gt;10、操作元素对象的内容和值&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
	&amp;lt;head&amp;gt;
		&amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
		&amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
      &amp;lt;script src=&amp;quot;js/jquery-1.9.1.js&amp;quot; type=&amp;quot;text/javascript&amp;quot; charset=&amp;quot;utf-8&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
      
      &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
      	
      	$(function(){
      		
      		$(&amp;quot;#bu1&amp;quot;).click(function(){
      			
      			 //获得div元素对象
      			 var div =$(&amp;quot;#div1&amp;quot;);
      			 
      			 
      			 //获得元素的内容 含有HTML的标签的
      			 var  ht=div.html();
      			 
      			 console.log(ht);
      			 //只是获得文本内容， 不含有HTML标签
      			 var te =div.text();
      			 
      			 console.log(te);
      			//获得文本框的值
      			
      			var val=$(&amp;quot;#inp1&amp;quot;).val();
      			
      			console.log(val);
      			
      			
      			/********操作元素对象的内容和值****************/
      			
      			//会识别这里的b标签，覆盖之前的内容
      			div.html(&amp;quot;&amp;lt;b&amp;gt;我们都爱笑&amp;lt;/b&amp;gt;&amp;quot;);
				
				//不会识别这里的b标签，覆盖之前的内容
      			div.text(&amp;lt;b&amp;gt;我们都爱笑&amp;lt;/b&amp;gt;&amp;quot;);
      			
				//累加，不覆盖
      			div.text(div.text()+&amp;quot;&amp;lt;b&amp;gt;我们都爱笑&amp;lt;/b&amp;gt;&amp;quot;);
      			
      			
      			$(&amp;quot;#inp1&amp;quot;).val(&amp;quot;123&amp;quot;);
      			
      		})
	
      	})
      	
      	
      &amp;lt;/script&amp;gt;
	
	&amp;lt;/head&amp;gt;
	&amp;lt;body&amp;gt;
		
		&amp;lt;input type=&amp;quot;button&amp;quot; name=&amp;quot;&amp;quot; id=&amp;quot;bu1&amp;quot; value=&amp;quot;操作元素的内容&amp;quot; /&amp;gt;
		&amp;lt;hr /&amp;gt;
		
		&amp;lt;div id=&amp;quot;div1&amp;quot;&amp;gt;
			
			&amp;lt;span&amp;gt;你好&amp;lt;/span&amp;gt;
			
		&amp;lt;/div&amp;gt;
	
		&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;inp1&amp;quot;  id=&amp;quot;inp1&amp;quot; value=&amp;quot;&amp;quot; /&amp;gt;
		
	&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;11-操作元素对象的节点&#34;&gt;11、操作元素对象的节点&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;html&amp;gt;
	&amp;lt;head&amp;gt;
		&amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
		&amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
		&amp;lt;style&amp;gt;	
			#div1{
				height: 300px;
				
				border: 3px solid  red;
			}
			p{
				border: 2px solid  green;
				
			}
		&amp;lt;/style&amp;gt;
		
		&amp;lt;script src=&amp;quot;js/jquery-1.9.1.js&amp;quot; type=&amp;quot;text/javascript&amp;quot; charset=&amp;quot;utf-8&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
		
		&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
			$(function(){
				//创建了新的元素
				var  p=$(&amp;quot;&amp;lt;p&amp;gt; &amp;lt;b&amp;gt;List  Item0&amp;lt;/b&amp;gt; &amp;lt;/p&amp;gt;&amp;quot;)
				//增加子元素   ---现有元素之后
				$(&amp;quot;#div1&amp;quot;).append(p);
                 //把p元素增加到  div里面 
                p.appendTo(&amp;quot;#div1&amp;quot;);
               //添加内部的子元素  ---现有元素之前
                $(&amp;quot;#div1&amp;quot;).prepend(p);
               
                p.prependTo(&amp;quot;#div1&amp;quot;);
               //平级的添加元素---现有元素之前
                p.insertBefore(&amp;quot;#div1&amp;quot;);
               
                $(&amp;quot;#div1&amp;quot;).before(p);
                
                //平级的添加元素---现有元素之后
                p.insertAfter(&amp;quot;#div1&amp;quot;);
                
                $(&amp;quot;#div1&amp;quot;).after(p);

            /***********替换指定的节点******************/
            
            $(&amp;quot;div p:nth-child(1)&amp;quot;).replaceWith(p);
            
            p.replaceAll(&amp;quot;div p:nth-child(5)&amp;quot;);
             
             /**********删除指定的节点元素***************************/
             //删除指定的元素
            $(&amp;quot;#div1&amp;quot;).remove();
	        //删除指定下标为3的子元素
	         $(&amp;quot;div p:nth-child(3)&amp;quot;).remove();
	         
	         
	         //清空内容,div1里面的内容全清空
	         $(&amp;quot;#div1&amp;quot;).empty();
	         
	         $(&amp;quot;div p:nth-child(2)&amp;quot;).empty();
	         
			})
			
		&amp;lt;/script&amp;gt;
		
	&amp;lt;/head&amp;gt;
	&amp;lt;body&amp;gt;
		
		&amp;lt;div id=&amp;quot;div1&amp;quot;&amp;gt;
			
			&amp;lt;p&amp;gt;List Item1&amp;lt;/p&amp;gt;
			
			&amp;lt;p&amp;gt;List Item2&amp;lt;/p&amp;gt;
			
			&amp;lt;p&amp;gt;List Item3&amp;lt;/p&amp;gt;
			
			&amp;lt;p&amp;gt;List Item4&amp;lt;/p&amp;gt;
			
			&amp;lt;p&amp;gt;List Item5&amp;lt;/p&amp;gt;	
		&amp;lt;/div&amp;gt;
		
	&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;html&amp;gt;
	&amp;lt;head&amp;gt;
		&amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
		&amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
		&amp;lt;script src=&amp;quot;js/jquery-1.9.1.js&amp;quot; type=&amp;quot;text/javascript&amp;quot; charset=&amp;quot;utf-8&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
		
		&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
			
			 function insertNode(){
			 	
			 	//创建节点对象
			 	var  p =$(&#39;&amp;lt;p&amp;gt;&#39;+
				&#39;照片:&amp;lt;input type=&amp;quot;file&amp;quot; name=&amp;quot;&amp;quot; id=&amp;quot;&amp;quot; value=&amp;quot;&amp;quot; /&amp;gt;&#39;+
				&#39;&amp;lt;input type=&amp;quot;button&amp;quot; name=&amp;quot;&amp;quot; id=&amp;quot;&amp;quot; value=&amp;quot;删除&amp;quot; onclick=&amp;quot;removeNode(this)&amp;quot; /&amp;gt;&#39;+
			    &#39;&amp;lt;/p&amp;gt;&#39;);
			 	
			 	$(&amp;quot;#last&amp;quot;).before(p);
			 	
			 }
			 function removeNode(obj){
			 	
			 	$(obj).parent().remove();
			 }
						
		&amp;lt;/script&amp;gt;
				
	&amp;lt;/head&amp;gt;
	&amp;lt;body&amp;gt;
		
		&amp;lt;form&amp;gt;
			
			&amp;lt;p&amp;gt;
				
				用户名:&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;&amp;quot; id=&amp;quot;&amp;quot; value=&amp;quot;&amp;quot; /&amp;gt;
				
			&amp;lt;/p&amp;gt;
			
			&amp;lt;p&amp;gt;
				照片:&amp;lt;input type=&amp;quot;file&amp;quot; name=&amp;quot;&amp;quot; id=&amp;quot;&amp;quot; value=&amp;quot;&amp;quot; /&amp;gt;
				
				&amp;lt;input type=&amp;quot;button&amp;quot; name=&amp;quot;&amp;quot; id=&amp;quot;&amp;quot; value=&amp;quot;添加&amp;quot; onclick=&amp;quot;insertNode()&amp;quot; /&amp;gt;
			&amp;lt;/p&amp;gt;
			
			&amp;lt;p id=&amp;quot;last&amp;quot;&amp;gt;
				&amp;lt;input type=&amp;quot;button&amp;quot; name=&amp;quot;&amp;quot; id=&amp;quot;&amp;quot; value=&amp;quot;提交&amp;quot; /&amp;gt;
				
				&amp;lt;input type=&amp;quot;button&amp;quot; name=&amp;quot;&amp;quot; id=&amp;quot;&amp;quot; value=&amp;quot;清空&amp;quot; /&amp;gt;
			&amp;lt;/p&amp;gt;
			
		&amp;lt;/form&amp;gt;	
	&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;12-事件处理&#34;&gt;12、事件处理&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
	&amp;lt;head&amp;gt;
		&amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
		&amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
		&amp;lt;script src=&amp;quot;http://apps.bdimg.com/libs/jquery/1.7.0/jquery.js&amp;quot; type=&amp;quot;text/javascript&amp;quot; charset=&amp;quot;utf-8&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
		
		&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
			/*页面加载完执行的操作*/
//			$(function(){})
			
//			jQuery(function(){})
			
//			$(document).ready(function(){})
			
			$(function(){
				/*******事件的基础绑定*************/
				$(&amp;quot;#bu1&amp;quot;).click(function(){
				
				alert(&amp;quot;单击事件&amp;quot;);
				
			  })
			  
			 $(&amp;quot;#bu1&amp;quot;).dblclick(function(){
			  	
			  	alert(&amp;quot;双击事件&amp;quot;);
			  })
			 
			  /*******bind事件绑定**************/
			  $(&amp;quot;#bu2&amp;quot;).bind(&#39;click&#39;,function(){
			  	
			  	alert(&amp;quot;单击事件绑定&amp;quot;);
			  	
			  })*/
			  //内容还支持json数据格式
			  $(&amp;quot;#bu2&amp;quot;).bind({
			  	 &#39;click&#39;:function(){},
			  	 &#39;dblclick&#39;:function(){},
			  	 &#39;blur&#39;:function(){}
			  	})
			  
			  /*********one一次事件绑定*************/
			  
				$(&amp;quot;#bu3&amp;quot;).one(&#39;click&#39;,function(){
					
					alert(&amp;quot;一次事件绑定&amp;quot;);
				})			
				
				/*********trigger事件操作****************/
				
				$(&amp;quot;#bu4&amp;quot;).click(function(){
						
					$(&amp;quot;#bu1&amp;quot;).trigger(&#39;dblclick&#39;);
					
					$(&amp;quot;#bu3&amp;quot;).trigger(&#39;click&#39;);
					
				})
				
				/********事件的解绑***********/
				
				$(&amp;quot;#bu5&amp;quot;).click(function(){
					
					//事件的解绑
					//解绑指定对象上的所有事件
					$(&amp;quot;#bu1&amp;quot;).unbind();
					//解绑指定的事件
					$(&amp;quot;#bu1&amp;quot;).unbind(&amp;quot;dblclick&amp;quot;);
					
				})
				
				$(&amp;quot;.bu6&amp;quot;).click(function(){
					
					alert(&amp;quot;单击事件的绑定&amp;quot;);
					
				})
				
				$(&amp;quot;.bu6&amp;quot;).live(&#39;click&#39;,function(){
					
					alert(&amp;quot;单击事件绑定&amp;quot;);
					
				})
				
				
				$(&amp;quot;body&amp;quot;).append(&#39;&amp;lt;input type=&amp;quot;button&amp;quot; name=&amp;quot;&amp;quot; id=&amp;quot;&amp;quot; class=&amp;quot;bu6&amp;quot; value=&amp;quot;事件操作2&amp;quot; /&amp;gt;&#39;);
				
			})
		
		&amp;lt;/script&amp;gt;
	
	&amp;lt;/head&amp;gt;
	&amp;lt;body&amp;gt;
	
		&amp;lt;input type=&amp;quot;button&amp;quot; name=&amp;quot;bu1&amp;quot; id=&amp;quot;bu1&amp;quot; value=&amp;quot;事件绑定&amp;quot; /&amp;gt;
		
		&amp;lt;input type=&amp;quot;button&amp;quot; name=&amp;quot;bu2&amp;quot; id=&amp;quot;bu2&amp;quot; value=&amp;quot;bind事件绑定&amp;quot; /&amp;gt;
		
		&amp;lt;input type=&amp;quot;button&amp;quot; name=&amp;quot;bu3&amp;quot; id=&amp;quot;bu3&amp;quot; value=&amp;quot;one事件绑定&amp;quot; /&amp;gt;
		
		&amp;lt;input type=&amp;quot;button&amp;quot; name=&amp;quot;bu4&amp;quot; id=&amp;quot;bu4&amp;quot; value=&amp;quot;tigger事件学习&amp;quot; /&amp;gt;
		
		&amp;lt;input type=&amp;quot;button&amp;quot; name=&amp;quot;bu5&amp;quot; id=&amp;quot;bu5&amp;quot; value=&amp;quot;事件解绑&amp;quot; /&amp;gt;
	
		&amp;lt;input type=&amp;quot;button&amp;quot; name=&amp;quot;&amp;quot; id=&amp;quot;&amp;quot; class=&amp;quot;bu6&amp;quot; value=&amp;quot;事件操作&amp;quot; /&amp;gt;
	
	&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;13-动画功能&#34;&gt;13、动画功能&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
	&amp;lt;head&amp;gt;
		&amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
		&amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
		&amp;lt;style&amp;gt;
			#div1{		
				height: 300px;
				background-color: green;
			}
			
			#div2{
				
				height: 300px;
				
				background-color: yellow;
		}
		&amp;lt;/style&amp;gt;
		
		&amp;lt;script src=&amp;quot;js/jquery-1.9.1.js&amp;quot; type=&amp;quot;text/javascript&amp;quot; charset=&amp;quot;utf-8&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
		
		&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
			
			  $(function(){
			  	  $(&amp;quot;#bu1&amp;quot;).click(function(){
			  	  	
			  	  	  //获得div对象
			  	  	  var  div1 =$(&amp;quot;#div1&amp;quot;);
			  	  	  
			  	  	  //3s隐藏动画
			  	  	  div1.hide(3000);
			  	  	  
			  	  	  div1.show(3000);
                      //隐藏的显示 ---显示的隐藏
                      $(&amp;quot;div&amp;quot;).toggle(3000);
                     //滑动上
                   div1.slideUp(3000);
                     //滑动下
                   div1.slideDown(3000);
                     //滑动上--滑动下    滑动下---滑动上
                   $(&amp;quot;div&amp;quot;).slideToggle(3000);
                   
                     //淡出
                     div1.fadeOut(3000);
                     //淡入
                     div1.fadeIn(3000);
			  	  	
			  	  })
	  	
			  })
			
		&amp;lt;/script&amp;gt;
		
	&amp;lt;/head&amp;gt;
	&amp;lt;body&amp;gt;
		
		&amp;lt;input type=&amp;quot;button&amp;quot; id=&amp;quot;bu1&amp;quot; value=&#39;动画触发&#39;&amp;gt;
		
		&amp;lt;hr /&amp;gt;
		
		&amp;lt;div id=&amp;quot;div1&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
		
		&amp;lt;div id=&amp;quot;div2&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;	
	&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
">jQuery</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jonchan1013.github.io/post/javaweb/"" data-c="
          &lt;p&gt;✍️JAVAEE的核心内容：Servlet和JSP、Tomcat服务器等。此外Maven的配置、Servlet的原理、Cookie和Session、JSP、监听器和过滤器、JDBC......&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;1-基本概念&#34;&gt;1、基本概念&lt;/h2&gt;
&lt;h3 id=&#34;11-前言&#34;&gt;1.1、前言&lt;/h3&gt;
&lt;p&gt;web开发：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;web，网页的意思  ， www.baidu.com&lt;/li&gt;
&lt;li&gt;静态web
&lt;ul&gt;
&lt;li&gt;html，css&lt;/li&gt;
&lt;li&gt;提供给所有人看的数据始终不会发生变化！&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;动态web
&lt;ul&gt;
&lt;li&gt;淘宝，几乎是所有的网站；&lt;/li&gt;
&lt;li&gt;提供给所有人看的数据始终会发生变化，每个人在不同的时间，不同的地点看到的信息各不相同！&lt;/li&gt;
&lt;li&gt;技术栈：Servlet/JSP，ASP，PHP&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在Java中，动态web资源开发的技术统称为JavaWeb；&lt;/p&gt;
&lt;h3 id=&#34;12-web应用程序&#34;&gt;1.2、web应用程序&lt;/h3&gt;
&lt;p&gt;web应用程序：可以提供浏览器访问的程序；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a.html、b.html......多个web资源，这些web资源可以被外界访问，对外界提供服务；&lt;/li&gt;
&lt;li&gt;你们能访问到的任何一个页面或者资源，都存在于这个世界的某一个角落的计算机上。&lt;/li&gt;
&lt;li&gt;URL&lt;/li&gt;
&lt;li&gt;这个统一的web资源会被放在同一个文件夹下，web应用程序--&amp;gt;Tomcat：服务器&lt;/li&gt;
&lt;li&gt;一个web应用由多部分组成 （静态web，动态web）
&lt;ul&gt;
&lt;li&gt;html，css，js&lt;/li&gt;
&lt;li&gt;jsp，servlet&lt;/li&gt;
&lt;li&gt;Java程序&lt;/li&gt;
&lt;li&gt;jar包&lt;/li&gt;
&lt;li&gt;配置文件 （Properties）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;web应用程序编写完毕后，若想提供给外界访问：需要一个服务器来统一管理；&lt;/p&gt;
&lt;h3 id=&#34;13-静态web&#34;&gt;1.3、静态web&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;*.htm, *.html,这些都是网页的后缀，如果服务器上一直存在这些东西，我们就可以直接进行读取。通络；&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613005453.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;静态web存在的缺点
&lt;ul&gt;
&lt;li&gt;Web页面无法动态更新，所有用户看到都是同一个页面
&lt;ul&gt;
&lt;li&gt;轮播图，点击特效：伪动态&lt;/li&gt;
&lt;li&gt;JavaScript [实际开发中，它用的最多]&lt;/li&gt;
&lt;li&gt;VBScript&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;它无法和数据库交互（数据无法持久化，用户无法交互）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;14-动态web&#34;&gt;1.4、动态web&lt;/h3&gt;
&lt;p&gt;页面会动态展示： “Web的页面展示的效果因人而异”；&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613005517.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加入服务器的动态web资源出现了错误，我们需要重新编写我们的&lt;strong&gt;后台程序&lt;/strong&gt;,重新发布；
&lt;ul&gt;
&lt;li&gt;停机维护&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Web页面可以动态更新，所有用户看到都不是同一个页面&lt;/li&gt;
&lt;li&gt;它可以与数据库交互 （数据持久化：注册，商品信息，用户信息........）&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613005534.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;新手村：--魔鬼训练（分析原理，看源码）--&amp;gt; PK场&lt;/p&gt;
&lt;h2 id=&#34;2-web服务器&#34;&gt;2、web服务器&lt;/h2&gt;
&lt;h3 id=&#34;21-技术讲解&#34;&gt;2.1、技术讲解&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;ASP:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;微软：国内最早流行的就是ASP；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在HTML中嵌入了VB的脚本，  ASP + COM；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在ASP开发中，基本一个页面都有几千行的业务代码，页面极其换乱&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;维护成本高！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C#&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IIS&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;h1&amp;gt;
    &amp;lt;h1&amp;gt;&amp;lt;h1&amp;gt;
        &amp;lt;h1&amp;gt;
            &amp;lt;h1&amp;gt;
                &amp;lt;h1&amp;gt;
        &amp;lt;h1&amp;gt;
            &amp;lt;%
            System.out.println(&amp;quot;hello&amp;quot;)
            %&amp;gt;
            &amp;lt;h1&amp;gt;
                &amp;lt;h1&amp;gt;
   &amp;lt;h1&amp;gt;&amp;lt;h1&amp;gt;
&amp;lt;h1&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;php：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PHP开发速度很快，功能很强大，跨平台，代码很简单 （70% , WP）&lt;/li&gt;
&lt;li&gt;无法承载大访问量的情况（局限性）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;**JSP/Servlet : **&lt;/p&gt;
&lt;p&gt;B/S：浏览和服务器&lt;/p&gt;
&lt;p&gt;C/S:  客户端和服务器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sun公司主推的B/S架构&lt;/li&gt;
&lt;li&gt;基于Java语言的 (所有的大公司，或者一些开源的组件，都是用Java写的)&lt;/li&gt;
&lt;li&gt;可以承载三高问题带来的影响；&lt;/li&gt;
&lt;li&gt;语法像ASP ， ASP--&amp;gt;JSP , 加强市场强度；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;.....&lt;/p&gt;
&lt;h3 id=&#34;22-web服务器&#34;&gt;2.2、web服务器&lt;/h3&gt;
&lt;p&gt;服务器是一种被动的操作，用来处理用户的一些请求和给用户一些响应信息；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IIS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;微软的； ASP...,Windows中自带的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tomcat&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613005712.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;面向百度编程；&lt;/p&gt;
&lt;p&gt;Tomcat是Apache 软件基金会（Apache Software Foundation）的Jakarta 项目中的一个核心项目，最新的Servlet 和JSP 规范总是能在Tomcat 中得到体现，因为Tomcat 技术先进、性能稳定，而且&lt;strong&gt;免费&lt;/strong&gt;，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。&lt;/p&gt;
&lt;p&gt;Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用&lt;a href=&#34;https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8&#34;&gt;服务器&lt;/a&gt;，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。对于一个Java初学web的人来说，它是最佳的选择&lt;/p&gt;
&lt;p&gt;Tomcat 实际上运行JSP 页面和Servlet。Tomcat最新版本为&lt;strong&gt;9.0。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;....&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;工作3-5年之后，可以尝试手写Tomcat服务器；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下载tomcat：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装 or  解压&lt;/li&gt;
&lt;li&gt;了解配置文件及目录结构&lt;/li&gt;
&lt;li&gt;这个东西的作用&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-tomcat&#34;&gt;3、Tomcat&lt;/h2&gt;
&lt;h3 id=&#34;31-安装tomcat&#34;&gt;3.1、 安装tomcat&lt;/h3&gt;
&lt;p&gt;tomcat官网：http://tomcat.apache.org/&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613005728.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613005741.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;32-tomcat启动和配置&#34;&gt;3.2、Tomcat启动和配置&lt;/h3&gt;
&lt;p&gt;文件夹作用：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613005759.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;启动。关闭Tomcat&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613005814.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;访问测试：http://localhost:8080/&lt;/p&gt;
&lt;p&gt;可能遇到的问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Java环境变量没有配置&lt;/li&gt;
&lt;li&gt;闪退问题：需要配置兼容性&lt;/li&gt;
&lt;li&gt;乱码问题：配置文件中设置&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;33-配置&#34;&gt;3.3、配置&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613005836.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;可以配置启动的端口号&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tomcat的默认端口号为：8080&lt;/li&gt;
&lt;li&gt;mysql：3306&lt;/li&gt;
&lt;li&gt;http：80&lt;/li&gt;
&lt;li&gt;https：443&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;Connector port=&amp;quot;8081&amp;quot; protocol=&amp;quot;HTTP/1.1&amp;quot;
           connectionTimeout=&amp;quot;20000&amp;quot;
           redirectPort=&amp;quot;8443&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以配置主机的名称&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;默认的主机名为：localhost-&amp;gt;127.0.0.1&lt;/li&gt;
&lt;li&gt;默认网站应用存放的位置为：webapps&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;  &amp;lt;Host name=&amp;quot;www.cy.com&amp;quot;  appBase=&amp;quot;webapps&amp;quot;
        unpackWARs=&amp;quot;true&amp;quot; autoDeploy=&amp;quot;true&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;高难度面试题&#34;&gt;高难度面试题：&lt;/h4&gt;
&lt;p&gt;请你谈谈网站是如何进行访问的！&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;输入一个域名；回车&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;检查本机的 C:\Windows\System32\drivers\etc\hosts配置文件下有没有这个域名映射；&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;有：直接返回对应的ip地址，这个地址中，有我们需要访问的web程序，可以直接访问&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;127.0.0.1       www.qinjiang.com
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;没有：去DNS服务器找，找到的话就返回，找不到就返回找不到；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613005939.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以配置一下环境变量（可选性）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;34-发布一个web网站&#34;&gt;3.4、发布一个web网站&lt;/h3&gt;
&lt;p&gt;不会就先模仿&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将自己写的网站，放到服务器(Tomcat)中指定的web应用的文件夹（webapps）下，就可以访问了&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;网站应该有的结构&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;--webapps ：Tomcat服务器的web目录
	-ROOT
	-kuangstudy ：网站的目录名
		- WEB-INF
			-classes : java程序
			-lib：web应用所依赖的jar包
			-web.xml ：网站配置文件
		- index.html 默认的首页
		- static 
            -css
            	-style.css
            -js
            -img
         -.....
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;HTTP协议 ： 面试&lt;/p&gt;
&lt;p&gt;Maven：构建工具&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Maven安装包&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Servlet 入门&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HelloWorld！&lt;/li&gt;
&lt;li&gt;Servlet配置&lt;/li&gt;
&lt;li&gt;原理&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-http&#34;&gt;4、Http&lt;/h2&gt;
&lt;h3 id=&#34;41-什么是http&#34;&gt;4.1、什么是HTTP&lt;/h3&gt;
&lt;p&gt;HTTP（超文本传输协议）是一个简单的请求-响应协议，它通常运行在TCP之上。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文本：html，字符串，~ ….&lt;/li&gt;
&lt;li&gt;超文本：图片，音乐，视频，定位，地图…….&lt;/li&gt;
&lt;li&gt;80&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Https：安全的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;443&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;42-两个时代&#34;&gt;4.2、两个时代&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;http1.0&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP/1.0：客户端可以与web服务器连接后，只能获得一个web资源，断开连接&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;http2.0&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP/1.1：客户端可以与web服务器连接后，可以获得多个web资源。‘&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;43-http请求&#34;&gt;4.3、Http请求&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;客户端---发请求（Request）---服务器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;百度：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Request URL:https://www.baidu.com/   请求地址
Request Method:GET    get方法/post方法
Status Code:200 OK    状态码：200
Remote（远程） Address:14.215.177.39:443
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Accept:text/html  
Accept-Encoding:gzip, deflate, br
Accept-Language:zh-CN,zh;q=0.9    语言
Cache-Control:max-age=0
Connection:keep-alive
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;1-请求行&#34;&gt;1、请求行&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;请求行中的请求方式：GET&lt;/li&gt;
&lt;li&gt;请求方式：&lt;strong&gt;Get，Post&lt;/strong&gt;，HEAD,DELETE,PUT,TRACT…
&lt;ul&gt;
&lt;li&gt;get：请求能够携带的参数比较少，大小有限制，会在浏览器的URL地址栏显示数据内容，不安全，但高效&lt;/li&gt;
&lt;li&gt;post：请求能够携带的参数没有限制，大小没有限制，不会在浏览器的URL地址栏显示数据内容，安全，但不高效。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-消息头&#34;&gt;2、消息头&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Accept：告诉浏览器，它所支持的数据类型
Accept-Encoding：支持哪种编码格式  GBK   UTF-8   GB2312  ISO8859-1
Accept-Language：告诉浏览器，它的语言环境
Cache-Control：缓存控制
Connection：告诉浏览器，请求完成是断开还是保持连接
HOST：主机..../.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;44-http响应&#34;&gt;4.4、Http响应&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;服务器---响应-----客户端&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;百度：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Cache-Control:private    缓存控制
Connection:Keep-Alive    连接
Content-Encoding:gzip    编码
Content-Type:text/html   类型
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;1响应体&#34;&gt;1.响应体&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Accept：告诉浏览器，它所支持的数据类型
Accept-Encoding：支持哪种编码格式  GBK   UTF-8   GB2312  ISO8859-1
Accept-Language：告诉浏览器，它的语言环境
Cache-Control：缓存控制
Connection：告诉浏览器，请求完成是断开还是保持连接
HOST：主机..../.
Refresh：告诉客户端，多久刷新一次；
Location：让网页重新定位；
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2-响应状态码&#34;&gt;2、响应状态码&lt;/h4&gt;
&lt;p&gt;200：请求响应成功  200&lt;/p&gt;
&lt;p&gt;3xx：请求重定向&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重定向：你重新到我给你新位置去；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4xx：找不到资源   404&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;资源不存在；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;5xx：服务器代码错误   500       502:网关错误&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常见面试题：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当你的浏览器中地址栏输入地址并回车的一瞬间到页面能够展示回来，经历了什么？&lt;/p&gt;
&lt;h2 id=&#34;5-maven&#34;&gt;5、Maven&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;我为什么要学习这个技术？&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在Javaweb开发中，需要使用大量的jar包，我们手动去导入；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何能够让一个东西自动帮我导入和配置这个jar包。&lt;/p&gt;
&lt;p&gt;由此，Maven诞生了！&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;51-maven项目架构管理工具&#34;&gt;5.1 Maven项目架构管理工具&lt;/h3&gt;
&lt;p&gt;我们目前用来就是方便导入jar包的！&lt;/p&gt;
&lt;p&gt;Maven的核心思想：&lt;strong&gt;约定大于配置&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有约束，不要去违反。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Maven会规定好你该如何去编写我们的Java代码，必须要按照这个规范来；&lt;/p&gt;
&lt;h3 id=&#34;52-下载安装maven&#34;&gt;5.2 下载安装Maven&lt;/h3&gt;
&lt;p&gt;官网;https://maven.apache.org/&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613010043.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;下载完成后，解压即可；&lt;/p&gt;
&lt;h3 id=&#34;53-配置环境变量&#34;&gt;5.3 配置环境变量&lt;/h3&gt;
&lt;p&gt;在我们的系统环境变量中&lt;/p&gt;
&lt;p&gt;配置如下配置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;M2_HOME     maven目录下的bin目录&lt;/li&gt;
&lt;li&gt;MAVEN_HOME      maven的目录&lt;/li&gt;
&lt;li&gt;在系统的path中配置  %MAVEN_HOME%\bin&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613010116.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;测试Maven是否安装成功，保证必须配置完毕！&lt;/p&gt;
&lt;h3 id=&#34;54-阿里云镜像&#34;&gt;5.4 阿里云镜像&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613010134.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;镜像：mirrors
&lt;ul&gt;
&lt;li&gt;作用：加速我们的下载&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;国内建议使用阿里云的镜像&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;mirror&amp;gt;
    &amp;lt;id&amp;gt;nexus-aliyun&amp;lt;/id&amp;gt;  
    &amp;lt;mirrorOf&amp;gt;*,!jeecg,!jeecg-snapshots&amp;lt;/mirrorOf&amp;gt;  
    &amp;lt;name&amp;gt;Nexus aliyun&amp;lt;/name&amp;gt;  
    &amp;lt;url&amp;gt;http://maven.aliyun.com/nexus/content/groups/public&amp;lt;/url&amp;gt; 
&amp;lt;/mirror&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;55-本地仓库&#34;&gt;5.5 本地仓库&lt;/h3&gt;
&lt;p&gt;在本地的仓库，远程仓库；&lt;/p&gt;
&lt;p&gt;**建立一个本地仓库：**localRepository&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;localRepository&amp;gt;D:\Environment\apache-maven-3.6.2\maven-repo&amp;lt;/localRepository&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;56-在idea中使用maven&#34;&gt;5.6、在IDEA中使用Maven&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;启动IDEA&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建一个MavenWeb项目&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613010155.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613010224.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613010243.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613010308.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;18&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613010344.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;等待项目初始化完毕&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;19&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613010438.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;20&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613010525.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;观察maven仓库中多了什么东西？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IDEA中的Maven设置&lt;/p&gt;
&lt;p&gt;注意：IDEA项目创建成功后，看一眼Maven的配置&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;21&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613010556.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;22&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613010613.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;到这里，Maven在IDEA中的配置和使用就OK了!&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;57-创建一个普通的maven项目&#34;&gt;5.7、创建一个普通的Maven项目&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;23&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613010651.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;24&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613010711.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;这个只有在Web应用下才会有！&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;25&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613010738.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;58-标记文件夹功能&#34;&gt;5.8  标记文件夹功能&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;26&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613010816.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;27&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613010846.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;28&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613010926.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;29&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613010954.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;59-在-idea中配置tomcat&#34;&gt;5.9 在 IDEA中配置Tomcat&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;30&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613011016.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;31&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613011032.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;32&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613011049.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;33&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613011103.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;解决警告问题&lt;/p&gt;
&lt;p&gt;必须要的配置：&lt;strong&gt;为什么会有这个问题：我们访问一个网站，需要指定一个文件夹名字；&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;34&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613011122.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;35&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613011156.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;36&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613011214.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;37&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613011230.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;510-pom文件&#34;&gt;5.10 pom文件&lt;/h3&gt;
&lt;p&gt;pom.xml 是Maven的核心配置文件&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;38&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613011251.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;

&amp;lt;!--Maven版本和头文件--&amp;gt;
&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
  xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
  &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

  &amp;lt;!--这里就是我们刚才配置的GAV--&amp;gt;
  &amp;lt;groupId&amp;gt;com.kuang&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;javaweb-01-maven&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
  &amp;lt;!--Package：项目的打包方式
  jar：java应用
  war：JavaWeb应用
  --&amp;gt;
  &amp;lt;packaging&amp;gt;war&amp;lt;/packaging&amp;gt;


  &amp;lt;!--配置--&amp;gt;
  &amp;lt;properties&amp;gt;
    &amp;lt;!--项目的默认构建编码--&amp;gt;
    &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
    &amp;lt;!--编码版本--&amp;gt;
    &amp;lt;maven.compiler.source&amp;gt;1.8&amp;lt;/maven.compiler.source&amp;gt;
    &amp;lt;maven.compiler.target&amp;gt;1.8&amp;lt;/maven.compiler.target&amp;gt;
  &amp;lt;/properties&amp;gt;

  &amp;lt;!--项目依赖--&amp;gt;
  &amp;lt;dependencies&amp;gt;
    &amp;lt;!--具体依赖的jar包配置文件--&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;4.11&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
  &amp;lt;/dependencies&amp;gt;

  &amp;lt;!--项目构建用的东西--&amp;gt;
  &amp;lt;build&amp;gt;
    &amp;lt;finalName&amp;gt;javaweb-01-maven&amp;lt;/finalName&amp;gt;
    &amp;lt;pluginManagement&amp;gt;&amp;lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&amp;gt;
      &amp;lt;plugins&amp;gt;
        &amp;lt;plugin&amp;gt;
          &amp;lt;artifactId&amp;gt;maven-clean-plugin&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;3.1.0&amp;lt;/version&amp;gt;
        &amp;lt;/plugin&amp;gt;
        &amp;lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&amp;gt;
        &amp;lt;plugin&amp;gt;
          &amp;lt;artifactId&amp;gt;maven-resources-plugin&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;3.0.2&amp;lt;/version&amp;gt;
        &amp;lt;/plugin&amp;gt;
        &amp;lt;plugin&amp;gt;
          &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;3.8.0&amp;lt;/version&amp;gt;
        &amp;lt;/plugin&amp;gt;
        &amp;lt;plugin&amp;gt;
          &amp;lt;artifactId&amp;gt;maven-surefire-plugin&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;2.22.1&amp;lt;/version&amp;gt;
        &amp;lt;/plugin&amp;gt;
        &amp;lt;plugin&amp;gt;
          &amp;lt;artifactId&amp;gt;maven-war-plugin&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;3.2.2&amp;lt;/version&amp;gt;
        &amp;lt;/plugin&amp;gt;
        &amp;lt;plugin&amp;gt;
          &amp;lt;artifactId&amp;gt;maven-install-plugin&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;2.5.2&amp;lt;/version&amp;gt;
        &amp;lt;/plugin&amp;gt;
        &amp;lt;plugin&amp;gt;
          &amp;lt;artifactId&amp;gt;maven-deploy-plugin&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;2.8.2&amp;lt;/version&amp;gt;
        &amp;lt;/plugin&amp;gt;
      &amp;lt;/plugins&amp;gt;
    &amp;lt;/pluginManagement&amp;gt;
  &amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;39&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613011335.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;maven由于他的约定大于配置，我们之后可以能遇到我们写的配置文件，无法被导出或者生效的问题，解决方案：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--在build中配置resources，来防止我们资源导出失败的问题--&amp;gt;
&amp;lt;build&amp;gt;
    &amp;lt;resources&amp;gt;
        &amp;lt;resource&amp;gt;
            &amp;lt;directory&amp;gt;src/main/resources&amp;lt;/directory&amp;gt;
            &amp;lt;includes&amp;gt;
                &amp;lt;include&amp;gt;**/*.properties&amp;lt;/include&amp;gt;
                &amp;lt;include&amp;gt;**/*.xml&amp;lt;/include&amp;gt;
            &amp;lt;/includes&amp;gt;
            &amp;lt;filtering&amp;gt;true&amp;lt;/filtering&amp;gt;
        &amp;lt;/resource&amp;gt;
        &amp;lt;resource&amp;gt;
            &amp;lt;directory&amp;gt;src/main/java&amp;lt;/directory&amp;gt;
            &amp;lt;includes&amp;gt;
                &amp;lt;include&amp;gt;**/*.properties&amp;lt;/include&amp;gt;
                &amp;lt;include&amp;gt;**/*.xml&amp;lt;/include&amp;gt;
            &amp;lt;/includes&amp;gt;
            &amp;lt;filtering&amp;gt;true&amp;lt;/filtering&amp;gt;
        &amp;lt;/resource&amp;gt;
    &amp;lt;/resources&amp;gt;
&amp;lt;/build&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;512-idea操作&#34;&gt;5.12 IDEA操作&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;40&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613011355.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;41&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613011409.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;513-解决遇到的问题&#34;&gt;5.13 解决遇到的问题&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Maven 3.6.2&lt;/p&gt;
&lt;p&gt;解决方法：降级为3.6.1&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;42&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613011426.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Tomcat闪退&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IDEA中每次都要重复配置Maven&lt;br&gt;
在IDEA中的全局默认配置中去配置&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;43&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613011443.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;44&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613011501.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Maven项目中Tomcat无法配置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;maven默认web项目中的web.xml版本问题&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;45&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613011524.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;替换为webapp4.0版本和tomcat一致&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;web-app xmlns=&amp;quot;http://xmlns.jcp.org/xml/ns/javaee&amp;quot;
         xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
         xsi:schemaLocation=&amp;quot;http://xmlns.jcp.org/xml/ns/javaee
                      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&amp;quot;
         version=&amp;quot;4.0&amp;quot;
         metadata-complete=&amp;quot;true&amp;quot;&amp;gt;



&amp;lt;/web-app&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Maven仓库的使用&lt;/p&gt;
&lt;p&gt;地址：https://mvnrepository.com/&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;46&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613011542.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;47&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613011612.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;48&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613011624.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;49&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613011643.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;6-servlet&#34;&gt;6、Servlet&lt;/h2&gt;
&lt;h3 id=&#34;61-servlet简介&#34;&gt;6.1、Servlet简介&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Servlet就是sun公司开发动态web的一门技术&lt;/li&gt;
&lt;li&gt;Sun在这些API中提供一个接口叫做：Servlet，如果你想开发一个Servlet程序，只需要完成两个小步骤：
&lt;ul&gt;
&lt;li&gt;编写一个类，实现Servlet接口&lt;/li&gt;
&lt;li&gt;把开发好的Java类部署到web服务器中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;把实现了Servlet接口的Java程序叫做，Servlet&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;62-helloservlet&#34;&gt;6.2、HelloServlet&lt;/h3&gt;
&lt;p&gt;Serlvet接口Sun公司有两个默认的实现类：HttpServlet，GenericServlet&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;构建一个普通的Maven项目，删掉里面的src目录，以后我们的学习就在这个项目里面建立Moudel；这个空的工程就是Maven主工程；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关于Maven父子工程的理解：&lt;/p&gt;
&lt;p&gt;父项目中会有&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;    &amp;lt;modules&amp;gt;
        &amp;lt;module&amp;gt;servlet-01&amp;lt;/module&amp;gt;
    &amp;lt;/modules&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;子项目会有&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;    &amp;lt;parent&amp;gt;
        &amp;lt;artifactId&amp;gt;javaweb-02-servlet&amp;lt;/artifactId&amp;gt;
        &amp;lt;groupId&amp;gt;com.kuang&amp;lt;/groupId&amp;gt;
        &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;/parent&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;父项目中的java子项目可以直接使用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;son extends father
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Maven环境优化&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;修改web.xml为最新的&lt;/li&gt;
&lt;li&gt;将maven的结构搭建完整&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编写一个Servlet程序&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;50&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613011708.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;编写一个普通类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现Servlet接口，这里我们直接继承HttpServlet&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class HelloServlet extends HttpServlet {
    
    //由于get或者post只是请求实现的不同的方式，可以相互调用，业务逻辑都一样；
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //ServletOutputStream outputStream = resp.getOutputStream();
        PrintWriter writer = resp.getWriter(); //响应流
        writer.print(&amp;quot;Hello,Serlvet&amp;quot;);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编写Servlet的映射&lt;/p&gt;
&lt;p&gt;为什么需要映射：我们写的是JAVA程序，但是要通过浏览器访问，而浏览器需要连接web服务器，所以我们需要再web服务中注册我们写的Servlet，还需给他一个浏览器能够访问的路径；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;
    &amp;lt;!--注册Servlet--&amp;gt;
    &amp;lt;servlet&amp;gt;
        &amp;lt;servlet-name&amp;gt;hello&amp;lt;/servlet-name&amp;gt;
        &amp;lt;servlet-class&amp;gt;com.cy.servlet.HelloServlet&amp;lt;/servlet-class&amp;gt;
    &amp;lt;/servlet&amp;gt;
    &amp;lt;!--Servlet的请求路径--&amp;gt;
    &amp;lt;servlet-mapping&amp;gt;
        &amp;lt;servlet-name&amp;gt;hello&amp;lt;/servlet-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/hello&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/servlet-mapping&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置Tomcat&lt;/p&gt;
&lt;p&gt;注意：配置项目发布的路径就可以了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动测试，OK！&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;63-servlet原理&#34;&gt;6.3、Servlet原理&lt;/h3&gt;
&lt;p&gt;Servlet是由Web服务器调用，web服务器在收到浏览器请求之后，会：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;51&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613011737.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;64-mapping问题&#34;&gt;6.4、Mapping问题&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;一个Servlet可以指定一个映射路径&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;    &amp;lt;servlet-mapping&amp;gt;
        &amp;lt;servlet-name&amp;gt;hello&amp;lt;/servlet-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/hello&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/servlet-mapping&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个Servlet可以指定多个映射路径&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;    &amp;lt;servlet-mapping&amp;gt;
        &amp;lt;servlet-name&amp;gt;hello&amp;lt;/servlet-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/hello&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/servlet-mapping&amp;gt;
    &amp;lt;servlet-mapping&amp;gt;
        &amp;lt;servlet-name&amp;gt;hello&amp;lt;/servlet-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/hello2&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/servlet-mapping&amp;gt;
    &amp;lt;servlet-mapping&amp;gt;
        &amp;lt;servlet-name&amp;gt;hello&amp;lt;/servlet-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/hello3&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/servlet-mapping&amp;gt;
    &amp;lt;servlet-mapping&amp;gt;
        &amp;lt;servlet-name&amp;gt;hello&amp;lt;/servlet-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/hello4&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/servlet-mapping&amp;gt;
    &amp;lt;servlet-mapping&amp;gt;
        &amp;lt;servlet-name&amp;gt;hello&amp;lt;/servlet-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/hello5&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/servlet-mapping&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个Servlet可以指定通用映射路径&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;    &amp;lt;servlet-mapping&amp;gt;
        &amp;lt;servlet-name&amp;gt;hello&amp;lt;/servlet-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/hello/*&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/servlet-mapping&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;默认请求路径&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;    &amp;lt;!--默认请求路径--&amp;gt;
    &amp;lt;servlet-mapping&amp;gt;
        &amp;lt;servlet-name&amp;gt;hello&amp;lt;/servlet-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/servlet-mapping&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指定一些后缀或者前缀等等….&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;
&amp;lt;!--可以自定义后缀实现请求映射
    注意点，*前面不能加项目映射的路径
    hello/sajdlkajda.qinjiang
    --&amp;gt;
&amp;lt;servlet-mapping&amp;gt;
    &amp;lt;servlet-name&amp;gt;hello&amp;lt;/servlet-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;*.cy&amp;lt;/url-pattern&amp;gt;
&amp;lt;/servlet-mapping&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;优先级问题&lt;br&gt;
指定了固有的映射路径优先级最高，如果找不到就会走默认的处理请求；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--404--&amp;gt;
&amp;lt;servlet&amp;gt;
    &amp;lt;servlet-name&amp;gt;error&amp;lt;/servlet-name&amp;gt;
    &amp;lt;servlet-class&amp;gt;com.cy.servlet.ErrorServlet&amp;lt;/servlet-class&amp;gt;
&amp;lt;/servlet&amp;gt;
&amp;lt;servlet-mapping&amp;gt;
    &amp;lt;servlet-name&amp;gt;error&amp;lt;/servlet-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;
&amp;lt;/servlet-mapping&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;65-servletcontext&#34;&gt;6.5、ServletContext&lt;/h3&gt;
&lt;p&gt;web容器在启动的时候，它会为每个web程序都创建一个对应的ServletContext对象，它代表了当前的web应用；&lt;/p&gt;
&lt;h4 id=&#34;1-共享数据&#34;&gt;1、共享数据&lt;/h4&gt;
&lt;p&gt;我在这个Servlet中保存的数据，可以在另外一个servlet中拿到；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class HelloServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        
        //this.getInitParameter()   初始化参数
        //this.getServletConfig()   Servlet配置
        //this.getServletContext()  Servlet上下文
        ServletContext context = this.getServletContext();

        String username = &amp;quot;CY&amp;quot;; //数据
        context.setAttribute(&amp;quot;username&amp;quot;,username); //将一个数据保存在了ServletContext中，名字为：username 。值 username

    }

}

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class GetServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        ServletContext context = this.getServletContext();
        String username = (String) context.getAttribute(&amp;quot;username&amp;quot;);

        resp.setContentType(&amp;quot;text/html&amp;quot;);
        resp.setCharacterEncoding(&amp;quot;utf-8&amp;quot;);
        resp.getWriter().print(&amp;quot;名字&amp;quot;+username);

    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-XML&#34;&gt;    &amp;lt;servlet&amp;gt;
        &amp;lt;servlet-name&amp;gt;hello&amp;lt;/servlet-name&amp;gt;
        &amp;lt;servlet-class&amp;gt;com.cy.servlet.HelloServlet&amp;lt;/servlet-class&amp;gt;
    &amp;lt;/servlet&amp;gt;
    &amp;lt;servlet-mapping&amp;gt;
        &amp;lt;servlet-name&amp;gt;hello&amp;lt;/servlet-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/hello&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/servlet-mapping&amp;gt;


    &amp;lt;servlet&amp;gt;
        &amp;lt;servlet-name&amp;gt;getc&amp;lt;/servlet-name&amp;gt;
        &amp;lt;servlet-class&amp;gt;com.cy.servlet.GetServlet&amp;lt;/servlet-class&amp;gt;
    &amp;lt;/servlet&amp;gt;
    &amp;lt;servlet-mapping&amp;gt;
        &amp;lt;servlet-name&amp;gt;getc&amp;lt;/servlet-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/getc&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/servlet-mapping&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试访问结果；&lt;/p&gt;
&lt;h4 id=&#34;2-获取初始化参数&#34;&gt;2、获取初始化参数&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;    &amp;lt;!--配置一些web应用初始化参数--&amp;gt;
    &amp;lt;context-param&amp;gt;
        &amp;lt;param-name&amp;gt;url&amp;lt;/param-name&amp;gt;
        &amp;lt;param-value&amp;gt;jdbc:mysql://localhost:3306/mybatis&amp;lt;/param-value&amp;gt;
    &amp;lt;/context-param&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    ServletContext context = this.getServletContext();
    String url = context.getInitParameter(&amp;quot;url&amp;quot;);
    resp.getWriter().print(url);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3-请求转发&#34;&gt;3、请求转发&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    ServletContext context = this.getServletContext();
    System.out.println(&amp;quot;进入了ServletDemo04&amp;quot;);
    //RequestDispatcher requestDispatcher = context.getRequestDispatcher(&amp;quot;/gp&amp;quot;); //转发的请求路径
    //requestDispatcher.forward(req,resp); //调用forward实现请求转发；
    context.getRequestDispatcher(&amp;quot;/gp&amp;quot;).forward(req,resp);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;52&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613011803.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;4-读取资源文件&#34;&gt;4、读取资源文件&lt;/h4&gt;
&lt;p&gt;Properties&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在java目录下新建properties&lt;/li&gt;
&lt;li&gt;在resources目录下新建properties&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;发现：都被打包到了同一个路径下：classes，我们俗称这个路径为classpath:&lt;/p&gt;
&lt;p&gt;思路：需要一个文件流；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;username=root12312
password=zxczxczxc
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ServletDemo05 extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

        InputStream is = this.getServletContext().getResourceAsStream(&amp;quot;/WEB-INF/classes/com/kuang/servlet/aa.properties&amp;quot;);

        Properties prop = new Properties();
        prop.load(is);
        String user = prop.getProperty(&amp;quot;username&amp;quot;);
        String pwd = prop.getProperty(&amp;quot;password&amp;quot;);

        resp.getWriter().print(user+&amp;quot;:&amp;quot;+pwd);

    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;访问测试即可ok；&lt;/p&gt;
&lt;h3 id=&#34;66-httpservletresponse&#34;&gt;6.6、HttpServletResponse&lt;/h3&gt;
&lt;p&gt;web服务器接收到客户端的http请求，针对这个请求，分别创建一个代表请求的HttpServletRequest对象，代表响应的一个HttpServletResponse；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果要获取客户端请求过来的参数：找HttpServletRequest&lt;/li&gt;
&lt;li&gt;如果要给客户端响应一些信息：找HttpServletResponse&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;1-简单分类&#34;&gt;1、简单分类&lt;/h4&gt;
&lt;p&gt;负责向浏览器发送数据的方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ServletOutputStream getOutputStream() throws IOException;
PrintWriter getWriter() throws IOException;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;负责向浏览器发送响应头的方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    void setCharacterEncoding(String var1);

    void setContentLength(int var1);

    void setContentLengthLong(long var1);

    void setContentType(String var1);

    void setDateHeader(String var1, long var2);

    void addDateHeader(String var1, long var2);

    void setHeader(String var1, String var2);

    void addHeader(String var1, String var2);

    void setIntHeader(String var1, int var2);

    void addIntHeader(String var1, int var2);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;响应的状态码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    int SC_CONTINUE = 100;
    int SC_SWITCHING_PROTOCOLS = 101;
    int SC_OK = 200;
    int SC_CREATED = 201;
    int SC_ACCEPTED = 202;
    int SC_NON_AUTHORITATIVE_INFORMATION = 203;
    int SC_NO_CONTENT = 204;
    int SC_RESET_CONTENT = 205;
    int SC_PARTIAL_CONTENT = 206;
    int SC_MULTIPLE_CHOICES = 300;
    int SC_MOVED_PERMANENTLY = 301;
    int SC_MOVED_TEMPORARILY = 302;
    int SC_FOUND = 302;
    int SC_SEE_OTHER = 303;
    int SC_NOT_MODIFIED = 304;
    int SC_USE_PROXY = 305;
    int SC_TEMPORARY_REDIRECT = 307;
    int SC_BAD_REQUEST = 400;
    int SC_UNAUTHORIZED = 401;
    int SC_PAYMENT_REQUIRED = 402;
    int SC_FORBIDDEN = 403;
    int SC_NOT_FOUND = 404;
    int SC_METHOD_NOT_ALLOWED = 405;
    int SC_NOT_ACCEPTABLE = 406;
    int SC_PROXY_AUTHENTICATION_REQUIRED = 407;
    int SC_REQUEST_TIMEOUT = 408;
    int SC_CONFLICT = 409;
    int SC_GONE = 410;
    int SC_LENGTH_REQUIRED = 411;
    int SC_PRECONDITION_FAILED = 412;
    int SC_REQUEST_ENTITY_TOO_LARGE = 413;
    int SC_REQUEST_URI_TOO_LONG = 414;
    int SC_UNSUPPORTED_MEDIA_TYPE = 415;
    int SC_REQUESTED_RANGE_NOT_SATISFIABLE = 416;
    int SC_EXPECTATION_FAILED = 417;
    int SC_INTERNAL_SERVER_ERROR = 500;
    int SC_NOT_IMPLEMENTED = 501;
    int SC_BAD_GATEWAY = 502;
    int SC_SERVICE_UNAVAILABLE = 503;
    int SC_GATEWAY_TIMEOUT = 504;
    int SC_HTTP_VERSION_NOT_SUPPORTED = 505;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2-下载文件&#34;&gt;2、下载文件&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;向浏览器输出消息&lt;/li&gt;
&lt;li&gt;下载文件
&lt;ol&gt;
&lt;li&gt;要获取下载文件的路径&lt;/li&gt;
&lt;li&gt;下载的文件名是啥？&lt;/li&gt;
&lt;li&gt;设置想办法让浏览器能够支持下载我们需要的东西&lt;/li&gt;
&lt;li&gt;获取下载文件的输入流&lt;/li&gt;
&lt;li&gt;创建缓冲区&lt;/li&gt;
&lt;li&gt;获取OutputStream对象&lt;/li&gt;
&lt;li&gt;将FileOutputStream流写入到buffer缓冲区&lt;/li&gt;
&lt;li&gt;使用OutputStream将缓冲区中的数据输出到客户端！&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    // 1. 要获取下载文件的路径
    String realPath = &amp;quot;F:代码\\JavaWeb\\javaweb-02-servlet\\response\\target\\classes\\123.png&amp;quot;;
    System.out.println(&amp;quot;下载文件的路径：&amp;quot;+realPath);
    // 2. 下载的文件名是啥？
    String fileName = realPath.substring(realPath.lastIndexOf(&amp;quot;\\&amp;quot;) + 1);
    // 3. 设置想办法让浏览器能够支持(Content-Disposition)下载我们需要的东西,中文文件名URLEncoder.encode编码，否则有可能乱码
    resp.setHeader(&amp;quot;Content-Disposition&amp;quot;,&amp;quot;attachment;filename=&amp;quot;+URLEncoder.encode(fileName,&amp;quot;UTF-8&amp;quot;));
    // 4. 获取下载文件的输入流
    FileInputStream in = new FileInputStream(realPath);
    // 5. 创建缓冲区
    int len = 0;
    byte[] buffer = new byte[1024];
    // 6. 获取OutputStream对象
    ServletOutputStream out = resp.getOutputStream();
    // 7. 将FileOutputStream流写入到buffer缓冲区,使用OutputStream将缓冲区中的数据输出到客户端！
    while ((len=in.read(buffer))&amp;gt;0){
        out.write(buffer,0,len);
    }

    in.close();
    out.close();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3-验证码功能&#34;&gt;3、验证码功能&lt;/h4&gt;
&lt;p&gt;验证怎么来的？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前端实现&lt;/li&gt;
&lt;li&gt;后端实现，需要用到 Java 的图片类，生产一个图片&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.kuang.servlet;

import javax.imageio.ImageIO;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.Random;

public class ImageServlet extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

        //如何让浏览器3秒自动刷新一次;
        resp.setHeader(&amp;quot;refresh&amp;quot;,&amp;quot;3&amp;quot;);
        
        //在内存中创建一个图片
        BufferedImage image = new BufferedImage(80,20,BufferedImage.TYPE_INT_RGB);
        //得到图片
        Graphics2D g = (Graphics2D) image.getGraphics(); //笔
        //设置图片的背景颜色
        g.setColor(Color.white);
        g.fillRect(0,0,80,20);
        //给图片写数据
        g.setColor(Color.BLUE);
        g.setFont(new Font(null,Font.BOLD,20));
        g.drawString(makeNum(),0,20);

        //告诉浏览器，这个请求用图片的方式打开
        resp.setContentType(&amp;quot;image/jpeg&amp;quot;);
        //网站存在缓存，不让浏览器缓存
        resp.setDateHeader(&amp;quot;expires&amp;quot;,-1);
        resp.setHeader(&amp;quot;Cache-Control&amp;quot;,&amp;quot;no-cache&amp;quot;);
        resp.setHeader(&amp;quot;Pragma&amp;quot;,&amp;quot;no-cache&amp;quot;);

        //把图片写给浏览器
        ImageIO.write(image,&amp;quot;jpg&amp;quot;, resp.getOutputStream());

    }

    //生成随机数
    private String makeNum(){
        Random random = new Random();
        String num = random.nextInt(9999999) + &amp;quot;&amp;quot;;
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i &amp;lt; 7-num.length() ; i++) {
            sb.append(&amp;quot;0&amp;quot;);
        }
        num = sb.toString() + num;
        return num;
    }


    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4-实现重定向&#34;&gt;4、实现重定向&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;53&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613012114.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;B一个web资源收到客户端A请求后，B他会通知A客户端去访问另外一个web资源C，这个过程叫重定向&lt;/p&gt;
&lt;p&gt;常见场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户登录&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void sendRedirect(String var1) throws IOException;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

    /*
        resp.setHeader(&amp;quot;Location&amp;quot;,&amp;quot;/r/img&amp;quot;);
        resp.setStatus(302);
         */
    resp.sendRedirect(&amp;quot;/r/img&amp;quot;);//重定向
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;面试题：请你聊聊重定向和转发的区别？&lt;/p&gt;
&lt;p&gt;相同点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;页面都会实现跳转&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不同点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;请求转发的时候，url不会产生变化&lt;/li&gt;
&lt;li&gt;重定向时候，url地址栏会发生变化；&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;54&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613012129.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;5-简单实现登录重定向&#34;&gt;5、简单实现登录重定向&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;%--这里提交的路径，需要寻找到项目的路径--%&amp;gt;
&amp;lt;%--${pageContext.request.contextPath}代表当前的项目--%&amp;gt;

&amp;lt;form action=&amp;quot;${pageContext.request.contextPath}/login&amp;quot; method=&amp;quot;get&amp;quot;&amp;gt;
    用户名：&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;username&amp;quot;&amp;gt; &amp;lt;br&amp;gt;
    密码：&amp;lt;input type=&amp;quot;password&amp;quot; name=&amp;quot;password&amp;quot;&amp;gt; &amp;lt;br&amp;gt;
    &amp;lt;input type=&amp;quot;submit&amp;quot;&amp;gt;
&amp;lt;/form&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-JAVA&#34;&gt;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //处理请求
        String username = req.getParameter(&amp;quot;username&amp;quot;);
        String password = req.getParameter(&amp;quot;password&amp;quot;);

        System.out.println(username+&amp;quot;:&amp;quot;+password);

        //重定向时候一定要注意，路径问题，否则404；
        resp.sendRedirect(&amp;quot;/r/success.jsp&amp;quot;);
    }

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;  &amp;lt;servlet&amp;gt;
    &amp;lt;servlet-name&amp;gt;requset&amp;lt;/servlet-name&amp;gt;
    &amp;lt;servlet-class&amp;gt;com.cy.servlet.RequestTest&amp;lt;/servlet-class&amp;gt;
  &amp;lt;/servlet&amp;gt;
  &amp;lt;servlet-mapping&amp;gt;
    &amp;lt;servlet-name&amp;gt;requset&amp;lt;/servlet-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;/login&amp;lt;/url-pattern&amp;gt;
  &amp;lt;/servlet-mapping&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;%@ page contentType=&amp;quot;text/html;charset=UTF-8&amp;quot; language=&amp;quot;java&amp;quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;h1&amp;gt;Success&amp;lt;/h1&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;67-httpservletrequest&#34;&gt;6.7、HttpServletRequest&lt;/h3&gt;
&lt;p&gt;HttpServletRequest代表客户端的请求，用户通过Http协议访问服务器，HTTP请求中的所有信息会被封装到HttpServletRequest，通过这个HttpServletRequest的方法，获得客户端的所有信息；&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;55&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613012206.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;56&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613012223.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;获取参数请求转发&#34;&gt;获取参数，请求转发&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;57&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613012235.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

    req.setCharacterEncoding(&amp;quot;utf-8&amp;quot;);
    resp.setCharacterEncoding(&amp;quot;utf-8&amp;quot;);

    String username = req.getParameter(&amp;quot;username&amp;quot;);
    String password = req.getParameter(&amp;quot;password&amp;quot;);
    String[] hobbys = req.getParameterValues(&amp;quot;hobbys&amp;quot;);
    System.out.println(&amp;quot;=============================&amp;quot;);
    //后台接收中文乱码问题
    System.out.println(username);
    System.out.println(password);
    System.out.println(Arrays.toString(hobbys));
    System.out.println(&amp;quot;=============================&amp;quot;);


    System.out.println(req.getContextPath());
    //通过请求转发
    //这里的 / 代表当前的web应用
    req.getRequestDispatcher(&amp;quot;/success.jsp&amp;quot;).forward(req,resp);

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;面试题：请你聊聊重定向和转发的区别？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;相同点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;页面都会实现跳转&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不同点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;请求转发的时候，url不会产生变化   307&lt;/li&gt;
&lt;li&gt;重定向时候，url地址栏会发生变化； 302&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;7-cookie-session&#34;&gt;7、Cookie、Session&lt;/h2&gt;
&lt;h3 id=&#34;71-会话&#34;&gt;7.1、会话&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;会话&lt;/strong&gt;：用户打开一个浏览器，点击了很多超链接，访问多个web资源，关闭浏览器，这个过程可以称之为会话；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有状态会话&lt;/strong&gt;：一个同学来过教室，下次再来教室，我们会知道这个同学，曾经来过，称之为有状态会话；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你能怎么证明你是清华的学生？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你              清华&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;发票                清华给你发票&lt;/li&gt;
&lt;li&gt;学校登记        清华标记你来过了&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;一个网站，怎么证明你来过？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;客户端              服务端&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;服务端给客户端一个 信件，客户端下次访问服务端带上信件就可以了； cookie&lt;/li&gt;
&lt;li&gt;服务器登记你来过了，下次你来的时候我来匹配你； seesion&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;72-保存会话的两种技术&#34;&gt;7.2、保存会话的两种技术&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;cookie&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端技术   （响应，请求）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;session&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务器技术，利用这个技术，可以保存用户的会话信息？ 我们可以把信息或者数据放在Session中！&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;常见常见：网站登录之后，你下次不用再登录了，第二次访问直接就上去了！&lt;/p&gt;
&lt;h3 id=&#34;73-cookie&#34;&gt;7.3、Cookie&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;58&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613012332.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;从请求中拿到cookie信息&lt;/li&gt;
&lt;li&gt;服务器响应给客户端cookie&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Cookie[] cookies = req.getCookies(); //获得Cookie
cookie.getName(); //获得cookie中的key
cookie.getValue(); //获得cookie中的vlaue
new Cookie(&amp;quot;lastLoginTime&amp;quot;, System.currentTimeMillis()+&amp;quot;&amp;quot;); //新建一个cookie
cookie.setMaxAge(24*60*60); //设置cookie的有效期
resp.addCookie(cookie); //响应给客户端一个cookie
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;cookie：一般会保存在本地的 用户目录下 appdata；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个网站cookie是否存在上限！&lt;strong&gt;聊聊细节问题&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个Cookie只能保存一个信息；&lt;/li&gt;
&lt;li&gt;一个web站点可以给浏览器发送多个cookie，最多存放20个cookie；&lt;/li&gt;
&lt;li&gt;Cookie大小有限制4kb；&lt;/li&gt;
&lt;li&gt;300个cookie浏览器上限&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;删除Cookie；&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不设置有效期，关闭浏览器，自动失效；&lt;/li&gt;
&lt;li&gt;设置有效期时间为 0 ；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;编码解码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;URLEncoder.encode(&amp;quot;CY&amp;quot;,&amp;quot;utf-8&amp;quot;)
URLDecoder.decode(cookie.getValue(),&amp;quot;UTF-8&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;74-session重点&#34;&gt;7.4、Session（重点）&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;59&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613012402.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;什么是Session：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务器会给每一个用户（浏览器）创建一个Seesion对象；&lt;/li&gt;
&lt;li&gt;一个Seesion独占一个浏览器，只要浏览器没有关闭，这个Session就存在；&lt;/li&gt;
&lt;li&gt;用户登录之后，整个网站它都可以访问！--&amp;gt; 保存用户的信息；保存购物车的信息…..&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;60&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613012415.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;Session和cookie的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Cookie是把用户的数据写给用户的浏览器，浏览器保存 （可以保存多个）&lt;/li&gt;
&lt;li&gt;Session把用户的数据写到用户独占Session中，服务器端保存  （保存重要的信息，减少服务器资源的浪费）&lt;/li&gt;
&lt;li&gt;Session对象由服务创建；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保存一个登录用户的信息；&lt;/li&gt;
&lt;li&gt;购物车信息；&lt;/li&gt;
&lt;li&gt;在整个网站中经常会使用的数据，我们将它保存在Session中；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用Session：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.cy.servlet;

import com.kuang.pojo.Person;

import javax.servlet.ServletException;
import javax.servlet.http.*;
import java.io.IOException;

public class SessionDemo01 extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        
        //解决乱码问题
        req.setCharacterEncoding(&amp;quot;UTF-8&amp;quot;);
        resp.setCharacterEncoding(&amp;quot;UTF-8&amp;quot;);
        resp.setContentType(&amp;quot;text/html;charset=utf-8&amp;quot;);
        
        //得到Session
        HttpSession session = req.getSession();
        //给Session中存东西
        session.setAttribute(&amp;quot;name&amp;quot;,new Person(&amp;quot;秦疆&amp;quot;,1));
        //获取Session的ID
        String sessionId = session.getId();

        //判断Session是不是新创建
        if (session.isNew()){
            resp.getWriter().write(&amp;quot;session创建成功,ID:&amp;quot;+sessionId);
        }else {
            resp.getWriter().write(&amp;quot;session以及在服务器中存在了,ID:&amp;quot;+sessionId);
        }

        //Session创建的时候做了什么事情；
//        Cookie cookie = new Cookie(&amp;quot;JSESSIONID&amp;quot;,sessionId);
//        resp.addCookie(cookie);

    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}

//得到Session
HttpSession session = req.getSession();

Person person = (Person) session.getAttribute(&amp;quot;name&amp;quot;);

System.out.println(person.toString());

HttpSession session = req.getSession();
session.removeAttribute(&amp;quot;name&amp;quot;);
//手动注销Session
session.invalidate();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;会话自动过期：web.xml配置&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--设置Session默认的失效时间--&amp;gt;
&amp;lt;session-config&amp;gt;
    &amp;lt;!--15分钟后Session自动失效，以分钟为单位--&amp;gt;
    &amp;lt;session-timeout&amp;gt;15&amp;lt;/session-timeout&amp;gt;
&amp;lt;/session-config&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;61&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613012454.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;8-jsp&#34;&gt;8、JSP&lt;/h2&gt;
&lt;h3 id=&#34;81-什么是jsp&#34;&gt;8.1、什么是JSP&lt;/h3&gt;
&lt;p&gt;Java Server Pages ： Java服务器端页面，也和Servlet一样，用于动态Web技术！&lt;/p&gt;
&lt;p&gt;最大的特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;写JSP就像在写HTML&lt;/li&gt;
&lt;li&gt;区别：
&lt;ul&gt;
&lt;li&gt;HTML只给用户提供静态的数据&lt;/li&gt;
&lt;li&gt;JSP页面中可以嵌入JAVA代码，为用户提供动态数据；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;82-jsp原理&#34;&gt;8.2、JSP原理&lt;/h3&gt;
&lt;p&gt;思路：JSP到底怎么执行的！&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;代码层面没有任何问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务器内部工作&lt;/p&gt;
&lt;p&gt;tomcat中有一个work目录；&lt;/p&gt;
&lt;p&gt;IDEA中使用Tomcat的会在IDEA的tomcat中生产一个work目录&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;62&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613012516.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;我电脑的地址：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;C:\Users\Administrator\.IntelliJIdea2018.1\system\tomcat\Unnamed_javaweb-session-cookie\work\Catalina\localhost\ROOT\org\apache\jsp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;发现页面转变成了Java程序！&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;63&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613012553.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;浏览器向服务器发送请求，不管访问什么资源，其实都是在访问Servlet！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JSP最终也会被转换成为一个Java类！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JSP 本质上就是一个Servlet&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//初始化
  public void _jspInit() {
      
  }
//销毁
  public void _jspDestroy() {
  }
//JSPService
  public void _jspService(.HttpServletRequest request,HttpServletResponse response)
      
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;判断请求&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内置一些对象&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final javax.servlet.jsp.PageContext pageContext;  //页面上下文
javax.servlet.http.HttpSession session = null;    //session
final javax.servlet.ServletContext application;   //applicationContext
final javax.servlet.ServletConfig config;         //config
javax.servlet.jsp.JspWriter out = null;           //out
final java.lang.Object page = this;               //page：当前
HttpServletRequest request                        //请求
HttpServletResponse response                      //响应
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输出页面前增加的代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;response.setContentType(&amp;quot;text/html&amp;quot;);       //设置响应的页面类型
pageContext = _jspxFactory.getPageContext(this, request, response,
                                          null, true, 8192, true);
_jspx_page_context = pageContext;
application = pageContext.getServletContext();
config = pageContext.getServletConfig();
session = pageContext.getSession();
out = pageContext.getOut();
_jspx_out = out;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;以上的这些个对象我们可以在JSP页面中直接使用！&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;64&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613012856.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在JSP页面中；&lt;/p&gt;
&lt;p&gt;只要是 JAVA代码就会原封不动的输出；&lt;/p&gt;
&lt;p&gt;如果是HTML代码，就会被转换为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;out.write(&amp;quot;&amp;lt;html&amp;gt;\r\n&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样的格式，输出到前端！&lt;/p&gt;
&lt;h3 id=&#34;83-jsp基础语法&#34;&gt;8.3、JSP基础语法&lt;/h3&gt;
&lt;p&gt;任何语言都有自己的语法，JAVA中有,。 JSP 作为java技术的一种应用，它拥有一些自己扩充的语法（了解，知道即可！），Java所有语法都支持！&lt;/p&gt;
&lt;h4 id=&#34;jsp表达式&#34;&gt;&lt;strong&gt;JSP表达式&lt;/strong&gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;  &amp;lt;%--JSP表达式
  作用：用来将程序的输出，输出到客户端
  &amp;lt;%= 变量或者表达式%&amp;gt;
  --%&amp;gt;
  &amp;lt;%= new java.util.Date()%&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;jsp脚本片段&#34;&gt;&lt;strong&gt;jsp脚本片段&lt;/strong&gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;
  &amp;lt;%--jsp脚本片段--%&amp;gt;
  &amp;lt;%
    int sum = 0;
    for (int i = 1; i &amp;lt;=100 ; i++) {
      sum+=i;
    }
    out.println(&amp;quot;&amp;lt;h1&amp;gt;Sum=&amp;quot;+sum+&amp;quot;&amp;lt;/h1&amp;gt;&amp;quot;);
  %&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;脚本片段的再实现&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;  &amp;lt;%
    int x = 10;
    out.println(x);
  %&amp;gt;
  &amp;lt;p&amp;gt;这是一个JSP文档&amp;lt;/p&amp;gt;
  &amp;lt;%
    int y = 2;
    out.println(y);
  %&amp;gt;

  &amp;lt;hr&amp;gt;


  &amp;lt;%--在代码嵌入HTML元素--%&amp;gt;
  &amp;lt;%
    for (int i = 0; i &amp;lt; 5; i++) {
  %&amp;gt;
    &amp;lt;h1&amp;gt;Hello,World  &amp;lt;%=i%&amp;gt; &amp;lt;/h1&amp;gt;
  &amp;lt;%
    }
  %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;jsp声明&#34;&gt;JSP声明&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;  &amp;lt;%!
    static {
      System.out.println(&amp;quot;Loading Servlet!&amp;quot;);
    }

    private int globalVar = 0;

    public void kuang(){
      System.out.println(&amp;quot;进入了方法Kuang！&amp;quot;);
    }
  %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JSP声明：会被编译到JSP生成Java的类中！其他的，就会被生成到_jspService方法中！&lt;/p&gt;
&lt;p&gt;在JSP，嵌入Java代码即可！&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;%%&amp;gt;
&amp;lt;%=%&amp;gt;
&amp;lt;%!%&amp;gt;

&amp;lt;%--注释--%&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JSP的注释，不会在客户端显示，HTML就会！&lt;/p&gt;
&lt;h3 id=&#34;84-jsp指令&#34;&gt;8.4、JSP指令&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;%@page args.... %&amp;gt;
&amp;lt;%@include file=&amp;quot;&amp;quot;%&amp;gt;

&amp;lt;%--@include会将两个页面合二为一--%&amp;gt;

&amp;lt;%@include file=&amp;quot;common/header.jsp&amp;quot;%&amp;gt;
&amp;lt;h1&amp;gt;网页主体&amp;lt;/h1&amp;gt;

&amp;lt;%@include file=&amp;quot;common/footer.jsp&amp;quot;%&amp;gt;

&amp;lt;hr&amp;gt;


&amp;lt;%--jSP标签
    jsp:include：拼接页面，本质还是三个
    --%&amp;gt;
&amp;lt;jsp:include page=&amp;quot;/common/header.jsp&amp;quot;/&amp;gt;
&amp;lt;h1&amp;gt;网页主体&amp;lt;/h1&amp;gt;
&amp;lt;jsp:include page=&amp;quot;/common/footer.jsp&amp;quot;/&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;85-9大内置对象&#34;&gt;8.5、9大内置对象&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;PageContext    存东西&lt;/li&gt;
&lt;li&gt;Request     存东西&lt;/li&gt;
&lt;li&gt;Response&lt;/li&gt;
&lt;li&gt;Session      存东西&lt;/li&gt;
&lt;li&gt;Application   【SerlvetContext】   存东西&lt;/li&gt;
&lt;li&gt;config    【SerlvetConfig】&lt;/li&gt;
&lt;li&gt;out&lt;/li&gt;
&lt;li&gt;page ，不用了解&lt;/li&gt;
&lt;li&gt;exception&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;pageContext.setAttribute(&amp;quot;name1&amp;quot;,&amp;quot;1号&amp;quot;); //保存的数据只在一个页面中有效
request.setAttribute(&amp;quot;name2&amp;quot;,&amp;quot;2号&amp;quot;); //保存的数据只在一次请求中有效，请求转发会携带这个数据
session.setAttribute(&amp;quot;name3&amp;quot;,&amp;quot;3号&amp;quot;); //保存的数据只在一次会话中有效，从打开浏览器到关闭浏览器
application.setAttribute(&amp;quot;name4&amp;quot;,&amp;quot;4号&amp;quot;);  //保存的数据只在服务器中有效，从打开服务器到关闭服务器
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;request：客户端向服务器发送请求，产生的数据，用户看完就没用了，比如：新闻，用户看完没用的！&lt;/p&gt;
&lt;p&gt;session：客户端向服务器发送请求，产生的数据，用户用完一会还有用，比如：购物车；&lt;/p&gt;
&lt;p&gt;application：客户端向服务器发送请求，产生的数据，一个用户用完了，其他用户还可能使用，比如：聊天数据；&lt;/p&gt;
&lt;h3 id=&#34;86-jsp标签-jstl标签-el表达式&#34;&gt;8.6、JSP标签、JSTL标签、EL表达式&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- JSTL表达式的依赖 --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;javax.servlet.jsp.jstl&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jstl-api&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.2&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;!-- standard标签库 --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;taglibs&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;standard&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.1.2&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;EL表达式：  ${ }&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;获取数据&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;执行运算&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;获取web开发的常用对象&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;JSP标签&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;%--jsp:include--%&amp;gt;

&amp;lt;%--
http://localhost:8080/jsptag.jsp?name=kuangshen&amp;amp;age=12
--%&amp;gt;

&amp;lt;jsp:forward page=&amp;quot;/jsptag2.jsp&amp;quot;&amp;gt;
    &amp;lt;jsp:param name=&amp;quot;name&amp;quot; value=&amp;quot;kuangshen&amp;quot;&amp;gt;&amp;lt;/jsp:param&amp;gt;
    &amp;lt;jsp:param name=&amp;quot;age&amp;quot; value=&amp;quot;12&amp;quot;&amp;gt;&amp;lt;/jsp:param&amp;gt;
&amp;lt;/jsp:forward&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;JSTL表达式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JSTL标签库的使用就是为了弥补HTML标签的不足；它自定义许多标签，可以供我们使用，标签的功能和Java代码一样！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;格式化标签&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SQL标签&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;XML 标签&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;核心标签&lt;/strong&gt; （掌握部分）&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;65&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613013014.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;JSTL标签库使用步骤&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;引入对应的 taglib&lt;/li&gt;
&lt;li&gt;使用其中的方法&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在Tomcat 也需要引入 jstl的包，否则会报错：JSTL解析错误&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;c：if&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;


&amp;lt;h4&amp;gt;if测试&amp;lt;/h4&amp;gt;

&amp;lt;hr&amp;gt;

&amp;lt;form action=&amp;quot;coreif.jsp&amp;quot; method=&amp;quot;get&amp;quot;&amp;gt;
    &amp;lt;%--
    EL表达式获取表单中的数据
    ${param.参数名}
    --%&amp;gt;
    &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;username&amp;quot; value=&amp;quot;${param.username}&amp;quot;&amp;gt;
    &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;登录&amp;quot;&amp;gt;
&amp;lt;/form&amp;gt;

&amp;lt;%--判断如果提交的用户名是管理员，则登录成功--%&amp;gt;
&amp;lt;c:if test=&amp;quot;${param.username==&#39;admin&#39;}&amp;quot; var=&amp;quot;isAdmin&amp;quot;&amp;gt;
    &amp;lt;c:out value=&amp;quot;管理员欢迎您！&amp;quot;/&amp;gt;
&amp;lt;/c:if&amp;gt;

&amp;lt;%--自闭合标签--%&amp;gt;
&amp;lt;c:out value=&amp;quot;${isAdmin}&amp;quot;/&amp;gt;

&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;c:choose   c:when&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;body&amp;gt;

&amp;lt;%--定义一个变量score，值为85--%&amp;gt;
&amp;lt;c:set var=&amp;quot;score&amp;quot; value=&amp;quot;55&amp;quot;/&amp;gt;

&amp;lt;c:choose&amp;gt;
    &amp;lt;c:when test=&amp;quot;${score&amp;gt;=90}&amp;quot;&amp;gt;
        你的成绩为优秀
    &amp;lt;/c:when&amp;gt;
    &amp;lt;c:when test=&amp;quot;${score&amp;gt;=80}&amp;quot;&amp;gt;
        你的成绩为一般
    &amp;lt;/c:when&amp;gt;
    &amp;lt;c:when test=&amp;quot;${score&amp;gt;=70}&amp;quot;&amp;gt;
        你的成绩为良好
    &amp;lt;/c:when&amp;gt;
    &amp;lt;c:when test=&amp;quot;${score&amp;lt;=60}&amp;quot;&amp;gt;
        你的成绩为不及格
    &amp;lt;/c:when&amp;gt;
&amp;lt;/c:choose&amp;gt;

&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;c:forEach&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;%

    ArrayList&amp;lt;String&amp;gt; people = new ArrayList&amp;lt;&amp;gt;();
    people.add(0,&amp;quot;张三&amp;quot;);
    people.add(1,&amp;quot;李四&amp;quot;);
    people.add(2,&amp;quot;王五&amp;quot;);
    people.add(3,&amp;quot;赵六&amp;quot;);
    people.add(4,&amp;quot;田六&amp;quot;);
    request.setAttribute(&amp;quot;list&amp;quot;,people);
%&amp;gt;


&amp;lt;%--
var , 每一次遍历出来的变量
items, 要遍历的对象
begin,   哪里开始
end,     到哪里
step,   步长
--%&amp;gt;
&amp;lt;c:forEach var=&amp;quot;people&amp;quot; items=&amp;quot;${list}&amp;quot;&amp;gt;
    &amp;lt;c:out value=&amp;quot;${people}&amp;quot;/&amp;gt; &amp;lt;br&amp;gt;
&amp;lt;/c:forEach&amp;gt;

&amp;lt;hr&amp;gt;

&amp;lt;c:forEach var=&amp;quot;people&amp;quot; items=&amp;quot;${list}&amp;quot; begin=&amp;quot;1&amp;quot; end=&amp;quot;3&amp;quot; step=&amp;quot;1&amp;quot; &amp;gt;
    &amp;lt;c:out value=&amp;quot;${people}&amp;quot;/&amp;gt; &amp;lt;br&amp;gt;
&amp;lt;/c:forEach&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;9-javabean&#34;&gt;9、JavaBean&lt;/h2&gt;
&lt;p&gt;实体类&lt;/p&gt;
&lt;p&gt;JavaBean有特定的写法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;必须要有一个无参构造&lt;/li&gt;
&lt;li&gt;属性必须私有化&lt;/li&gt;
&lt;li&gt;必须有对应的get/set方法；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般用来和数据库的字段做映射  ORM；&lt;/p&gt;
&lt;p&gt;ORM ：对象关系映射&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表---&amp;gt;类&lt;/li&gt;
&lt;li&gt;字段--&amp;gt;属性&lt;/li&gt;
&lt;li&gt;行记录----&amp;gt;对象&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;people表&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;id&lt;/th&gt;
&lt;th&gt;name&lt;/th&gt;
&lt;th&gt;age&lt;/th&gt;
&lt;th&gt;address&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1号&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;西安&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2号&lt;/td&gt;
&lt;td&gt;18&lt;/td&gt;
&lt;td&gt;西安&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;3号&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;西安&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class People{
    private int id;
    private String name;
    private int id;
    private String address;
}

class A{
    new People(1,&amp;quot;1号&amp;quot;,3，&amp;quot;西安&amp;quot;);
    new People(2,&amp;quot;2号&amp;quot;,3，&amp;quot;西安&amp;quot;);
    new People(3,&amp;quot;3号&amp;quot;,3，&amp;quot;西安&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;过滤器&lt;/li&gt;
&lt;li&gt;文件上传&lt;/li&gt;
&lt;li&gt;邮件发送&lt;/li&gt;
&lt;li&gt;JDBC 复习 ： 如何使用JDBC ,  JDBC crud， jdbc 事务&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;10-mvc三层架构&#34;&gt;10、MVC三层架构&lt;/h2&gt;
&lt;p&gt;什么是MVC：  Model     view     Controller  模型、视图、控制器&lt;/p&gt;
&lt;h3 id=&#34;101-早些年&#34;&gt;10.1、早些年&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;66&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613013052.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;用户直接访问控制层，控制层就可以直接操作数据库；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;servlet--CRUD--&amp;gt;数据库
弊端：程序十分臃肿，不利于维护  
servlet的代码中：处理请求、响应、视图跳转、处理JDBC、处理业务代码、处理逻辑代码

架构：没有什么是加一层解决不了的！
程序猿调用
|
JDBC
|
Mysql Oracle SqlServer ....
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;102-mvc三层架构&#34;&gt;10.2、MVC三层架构&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;67&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613013122.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;Model&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;业务处理 ：业务逻辑（Service）&lt;/li&gt;
&lt;li&gt;数据持久层：CRUD   （Dao）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;View&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;展示数据&lt;/li&gt;
&lt;li&gt;提供链接发起Servlet请求 （a，form，img…）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Controller  （Servlet）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;接收用户的请求 ：（req：请求参数、Session信息….）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;交给业务层处理对应的代码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;控制视图的跳转&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;登录---&amp;gt;接收用户的登录请求---&amp;gt;处理用户的请求（获取用户登录的参数，username，password）----&amp;gt;交给业务层处理登录业务（判断用户名密码是否正确：事务）---&amp;gt;Dao层查询用户名和密码是否正确--&amp;gt;数据库
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;11-filter-重点&#34;&gt;11、Filter （重点）&lt;/h2&gt;
&lt;p&gt;Filter：过滤器 ，用来过滤网站的数据；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;处理中文乱码&lt;/li&gt;
&lt;li&gt;登录验证….&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;68&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613013144.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;Filter开发步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;导包&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编写过滤器&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;导包不要错&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;69&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613013158.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;实现Filter接口，重写对应的方法即可&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class CharacterEncodingFilter implements Filter {

    //初始化：web服务器启动，就以及初始化了，随时等待过滤对象出现！
    public void init(FilterConfig filterConfig) throws ServletException {
        System.out.println(&amp;quot;CharacterEncodingFilter初始化&amp;quot;);
    }

    //Chain : 链
    /*
    1. 过滤中的所有代码，在过滤特定请求的时候都会执行
    2. 必须要让过滤器继续同行
        chain.doFilter(request,response);
     */
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        request.setCharacterEncoding(&amp;quot;utf-8&amp;quot;);
        response.setCharacterEncoding(&amp;quot;utf-8&amp;quot;);
        response.setContentType(&amp;quot;text/html;charset=UTF-8&amp;quot;);

        System.out.println(&amp;quot;CharacterEncodingFilter执行前....&amp;quot;);
        chain.doFilter(request,response); //让我们的请求继续走，如果不写，程序到这里就被拦截停止！
        System.out.println(&amp;quot;CharacterEncodingFilter执行后....&amp;quot;);
    }

    //销毁：web服务器关闭的时候，过滤会销毁
    public void destroy() {
        System.out.println(&amp;quot;CharacterEncodingFilter销毁&amp;quot;);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在web.xml中配置 Filter&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;filter&amp;gt;
    &amp;lt;filter-name&amp;gt;CharacterEncodingFilter&amp;lt;/filter-name&amp;gt;
    &amp;lt;filter-class&amp;gt;com.cy.filter.CharacterEncodingFilter&amp;lt;/filter-class&amp;gt;
&amp;lt;/filter&amp;gt;
&amp;lt;filter-mapping&amp;gt;
    &amp;lt;filter-name&amp;gt;CharacterEncodingFilter&amp;lt;/filter-name&amp;gt;
    &amp;lt;!--只要是 /servlet的任何请求，会经过这个过滤器--&amp;gt;
    &amp;lt;url-pattern&amp;gt;/servlet/*&amp;lt;/url-pattern&amp;gt;
    &amp;lt;!--&amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;--&amp;gt;
&amp;lt;/filter-mapping&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;12-监听器&#34;&gt;12、监听器&lt;/h2&gt;
&lt;p&gt;实现一个监听器的接口；（有N种）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;编写一个监听器&lt;/p&gt;
&lt;p&gt;实现监听器的接口…&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//统计网站在线人数 ： 统计session
public class OnlineCountListener implements HttpSessionListener {

    //创建session监听： 看你的一举一动
    //一旦创建Session就会触发一次这个事件！
    public void sessionCreated(HttpSessionEvent se) {
        ServletContext ctx = se.getSession().getServletContext();

        System.out.println(se.getSession().getId());

        Integer onlineCount = (Integer) ctx.getAttribute(&amp;quot;OnlineCount&amp;quot;);

        if (onlineCount==null){
            onlineCount = new Integer(1);
        }else {
            int count = onlineCount.intValue();
            onlineCount = new Integer(count+1);
        }

        ctx.setAttribute(&amp;quot;OnlineCount&amp;quot;,onlineCount);

    }

    //销毁session监听
    //一旦销毁Session就会触发一次这个事件！
    public void sessionDestroyed(HttpSessionEvent se) {
        ServletContext ctx = se.getSession().getServletContext();

        Integer onlineCount = (Integer) ctx.getAttribute(&amp;quot;OnlineCount&amp;quot;);

        if (onlineCount==null){
            onlineCount = new Integer(0);
        }else {
            int count = onlineCount.intValue();
            onlineCount = new Integer(count-1);
        }

        ctx.setAttribute(&amp;quot;OnlineCount&amp;quot;,onlineCount);

    }


    /*
    Session销毁：
    1. 手动销毁  getSession().invalidate();
    2. 自动销毁
     */
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;web.xml中注册监听器&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--注册监听器--&amp;gt;
&amp;lt;listener&amp;gt;
    &amp;lt;listener-class&amp;gt;com.kuang.listener.OnlineCountListener&amp;lt;/listener-class&amp;gt;
&amp;lt;/listener&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;看情况是否使用！&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;13-过滤器-监听器常见应用&#34;&gt;13、过滤器、监听器常见应用&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;监听器：GUI编程中经常使用；&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TestPanel {
    public static void main(String[] args) {
        Frame frame = new Frame(&amp;quot;中秋节快乐&amp;quot;);  //新建一个窗体
        Panel panel = new Panel(null); //面板
        frame.setLayout(null); //设置窗体的布局

        frame.setBounds(300,300,500,500);
        frame.setBackground(new Color(0,0,255)); //设置背景颜色

        panel.setBounds(50,50,300,300);
        panel.setBackground(new Color(0,255,0)); //设置背景颜色

        frame.add(panel);

        frame.setVisible(true);

        //监听事件，监听关闭事件
        frame.addWindowListener(new WindowAdapter() {
            @Override
            public void windowClosing(WindowEvent e) {
                super.windowClosing(e);
            }
        });


    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用户登录之后才能进入主页！用户注销后就不能进入主页了！&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;用户登录之后，向Sesison中放入用户的数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进入主页的时候要判断用户是否已经登录；要求：在过滤器中实现！&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;HttpServletRequest request = (HttpServletRequest) req;
HttpServletResponse response = (HttpServletResponse) resp;

if (request.getSession().getAttribute(Constant.USER_SESSION)==null){
    response.sendRedirect(&amp;quot;/error.jsp&amp;quot;);
}

chain.doFilter(request,response);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;14-jdbc&#34;&gt;14、JDBC&lt;/h2&gt;
&lt;p&gt;什么是JDBC ： Java连接数据库！&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;70&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613013240.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;需要jar包的支持：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;java.sql&lt;/li&gt;
&lt;li&gt;javax.sql&lt;/li&gt;
&lt;li&gt;mysql-conneter-java…  连接驱动（必须要导入）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;实验环境搭建&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;
CREATE TABLE users(
    id INT PRIMARY KEY,
    `name` VARCHAR(40),
    `password` VARCHAR(40),
    email VARCHAR(60),
    birthday DATE
);

INSERT INTO users(id,`name`,`password`,email,birthday)
VALUES(1,&#39;张三&#39;,&#39;123456&#39;,&#39;zs@qq.com&#39;,&#39;2000-01-01&#39;);
INSERT INTO users(id,`name`,`password`,email,birthday)
VALUES(2,&#39;李四&#39;,&#39;123456&#39;,&#39;ls@qq.com&#39;,&#39;2000-01-01&#39;);
INSERT INTO users(id,`name`,`password`,email,birthday)
VALUES(3,&#39;王五&#39;,&#39;123456&#39;,&#39;ww@qq.com&#39;,&#39;2000-01-01&#39;);


SELECT	* FROM users;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;导入数据库依赖&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--mysql的驱动--&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;5.1.47&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;IDEA中连接数据库：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;71&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613013255.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;JDBC 固定步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;加载驱动&lt;/li&gt;
&lt;li&gt;连接数据库,代表数据库&lt;/li&gt;
&lt;li&gt;向数据库发送SQL的对象Statement : CRUD&lt;/li&gt;
&lt;li&gt;编写SQL （根据业务，不同的SQL）&lt;/li&gt;
&lt;li&gt;执行SQL&lt;/li&gt;
&lt;li&gt;关闭连接&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TestJdbc {
    public static void main(String[] args) throws ClassNotFoundException, SQLException {
        //配置信息
        //useUnicode=true&amp;amp;characterEncoding=utf-8 解决中文乱码
        String url=&amp;quot;jdbc:mysql://localhost:3306/jdbc?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;quot;;
        String username = &amp;quot;root&amp;quot;;
        String password = &amp;quot;123456&amp;quot;;

        //1.加载驱动
        Class.forName(&amp;quot;com.mysql.jdbc.Driver&amp;quot;);
        //2.连接数据库,代表数据库
        Connection connection = DriverManager.getConnection(url, username, password);

        //3.向数据库发送SQL的对象Statement,PreparedStatement : CRUD
        Statement statement = connection.createStatement();

        //4.编写SQL
        String sql = &amp;quot;select * from users&amp;quot;;

        //5.执行查询SQL，返回一个 ResultSet  ： 结果集
        ResultSet rs = statement.executeQuery(sql);

        while (rs.next()){
            System.out.println(&amp;quot;id=&amp;quot;+rs.getObject(&amp;quot;id&amp;quot;));
            System.out.println(&amp;quot;name=&amp;quot;+rs.getObject(&amp;quot;name&amp;quot;));
            System.out.println(&amp;quot;password=&amp;quot;+rs.getObject(&amp;quot;password&amp;quot;));
            System.out.println(&amp;quot;email=&amp;quot;+rs.getObject(&amp;quot;email&amp;quot;));
            System.out.println(&amp;quot;birthday=&amp;quot;+rs.getObject(&amp;quot;birthday&amp;quot;));
        }

        //6.关闭连接，释放资源（一定要做） 先开后关
        rs.close();
        statement.close();
        connection.close();
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;预编译SQL&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TestJDBC2 {
    public static void main(String[] args) throws Exception {
        //配置信息
        //useUnicode=true&amp;amp;characterEncoding=utf-8 解决中文乱码
        String url=&amp;quot;jdbc:mysql://localhost:3306/jdbc?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;quot;;
        String username = &amp;quot;root&amp;quot;;
        String password = &amp;quot;123456&amp;quot;;

        //1.加载驱动
        Class.forName(&amp;quot;com.mysql.jdbc.Driver&amp;quot;);
        //2.连接数据库,代表数据库
        Connection connection = DriverManager.getConnection(url, username, password);

        //3.编写SQL
        String sql = &amp;quot;insert into  users(id, name, password, email, birthday) values (?,?,?,?,?);&amp;quot;;

        //4.预编译
        PreparedStatement preparedStatement = connection.prepareStatement(sql);

        preparedStatement.setInt(1,2);//给第一个占位符？ 的值赋值为1；
        preparedStatement.setString(2,&amp;quot;Java&amp;quot;);//给第二个占位符？ 的值赋值为狂神说Java；
        preparedStatement.setString(3,&amp;quot;123456&amp;quot;);//给第三个占位符？ 的值赋值为123456；
        preparedStatement.setString(4,&amp;quot;24736743@qq.com&amp;quot;);//给第四个占位符？ 的值赋值为1；
        preparedStatement.setDate(5,new Date(new java.util.Date().getTime()));//给第五个占位符？ 的值赋值为new Date(new java.util.Date().getTime())；

        //5.执行SQL
        int i = preparedStatement.executeUpdate();

        if (i&amp;gt;0){
            System.out.println(&amp;quot;插入成功@&amp;quot;);
        }

        //6.关闭连接，释放资源（一定要做） 先开后关
        preparedStatement.close();
        connection.close();
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;事务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要么都成功，要么都失败！&lt;/p&gt;
&lt;p&gt;ACID原则：保证数据的安全。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;开启事务
事务提交  commit()
事务回滚  rollback()
关闭事务

转账：
A:1000
B:1000
    
A(900)   --100--&amp;gt;   B(1100) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Junit单元测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;依赖&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--单元测试--&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;4.12&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;简单使用&lt;/p&gt;
&lt;p&gt;@Test注解只有在方法上有效，只要加了这个注解的方法，就可以直接运行！&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void test(){
    System.out.println(&amp;quot;Hello&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;72&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613013348.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;失败的时候是红色：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;73&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200613013404.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;搭建一个环境&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE TABLE account(
   id INT PRIMARY KEY AUTO_INCREMENT,
   `name` VARCHAR(40),
   money FLOAT
);

INSERT INTO account(`name`,money) VALUES(&#39;A&#39;,1000);
INSERT INTO account(`name`,money) VALUES(&#39;B&#39;,1000);
INSERT INTO account(`name`,money) VALUES(&#39;C&#39;,1000);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    @Test
    public void test() {
        //配置信息
        //useUnicode=true&amp;amp;characterEncoding=utf-8 解决中文乱码
        String url=&amp;quot;jdbc:mysql://localhost:3306/jdbc?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;quot;;
        String username = &amp;quot;root&amp;quot;;
        String password = &amp;quot;123456&amp;quot;;

        Connection connection = null;

        //1.加载驱动
        try {
            Class.forName(&amp;quot;com.mysql.jdbc.Driver&amp;quot;);
            //2.连接数据库,代表数据库
             connection = DriverManager.getConnection(url, username, password);

            //3.通知数据库开启事务,false 开启
            connection.setAutoCommit(false);

            String sql = &amp;quot;update account set money = money-100 where name = &#39;A&#39;&amp;quot;;
            connection.prepareStatement(sql).executeUpdate();

            //制造错误
            //int i = 1/0;

            String sql2 = &amp;quot;update account set money = money+100 where name = &#39;B&#39;&amp;quot;;
            connection.prepareStatement(sql2).executeUpdate();

            connection.commit();//以上两条SQL都执行成功了，就提交事务！
            System.out.println(&amp;quot;success&amp;quot;);
        } catch (Exception e) {
            try {
                //如果出现异常，就通知数据库回滚事务
                connection.rollback();
            } catch (SQLException e1) {
                e1.printStackTrace();
            }
            e.printStackTrace();
        }finally {
            try {
                connection.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;
">JavaWeb</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jonchan1013.github.io/post/about/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;欢迎来到我的小站呀，很高兴遇见你！🤝&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;关于本站&#34;&gt;🏠 关于本站&lt;/h2&gt;
&lt;h2 id=&#34;博主是谁&#34;&gt;👨‍💻 博主是谁&lt;/h2&gt;
&lt;h2 id=&#34;兴趣爱好&#34;&gt;⛹ 兴趣爱好&lt;/h2&gt;
&lt;h2 id=&#34;联系我呀&#34;&gt;📬 联系我呀&lt;/h2&gt;
">关于</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jonchan1013.github.io/post/intellij-idea-chang-yong-kuai-jie-jian/"" data-c="
          &lt;h3 id=&#34;️最常用快捷键&#34;&gt;✍️最常用快捷键&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Alt+回车 导入包,自动修正&lt;/li&gt;
&lt;li&gt;Ctrl+N  查找类&lt;!-- more --&gt;
&lt;/li&gt;
&lt;li&gt;Ctrl+Shift+N 查找文件&lt;/li&gt;
&lt;li&gt;Ctrl+Alt+L  格式化代码&lt;/li&gt;
&lt;li&gt;Ctrl+Alt+O 优化导入的类和包&lt;/li&gt;
&lt;li&gt;Alt+Insert 生成代码(如get,set方法,构造函数等)&lt;/li&gt;
&lt;li&gt;Ctrl+E或者Alt+Shift+C  最近更改的代码&lt;/li&gt;
&lt;li&gt;Ctrl+R 替换文本&lt;/li&gt;
&lt;li&gt;Ctrl+F 查找文本&lt;/li&gt;
&lt;li&gt;Ctrl+Shift+Space 自动补全代码&lt;/li&gt;
&lt;li&gt;Ctrl+空格 代码提示&lt;/li&gt;
&lt;li&gt;Ctrl+Alt+Space 类名或接口名提示&lt;/li&gt;
&lt;li&gt;Ctrl+P 方法参数提示&lt;/li&gt;
&lt;li&gt;Ctrl+Shift+Alt+N 查找类中的方法或变量&lt;/li&gt;
&lt;li&gt;Alt+Shift+C 对比最近修改的代码&lt;/li&gt;
&lt;li&gt;Shift+F6  重构-重命名&lt;/li&gt;
&lt;li&gt;Ctrl+Shift+先上键&lt;/li&gt;
&lt;li&gt;Ctrl+X 删除行&lt;/li&gt;
&lt;li&gt;Ctrl+D 复制行&lt;/li&gt;
&lt;li&gt;Ctrl+/ 或 Ctrl+Shift+/  注释（// 或者/&lt;em&gt;...&lt;/em&gt;/ ）&lt;/li&gt;
&lt;li&gt;Ctrl+J  自动代码&lt;/li&gt;
&lt;li&gt;Ctrl+E 最近打开的文件&lt;/li&gt;
&lt;li&gt;Ctrl+H 显示类结构图&lt;/li&gt;
&lt;li&gt;Ctrl+Q 显示注释文档&lt;/li&gt;
&lt;li&gt;Alt+F1 查找代码所在位置&lt;/li&gt;
&lt;li&gt;Alt+1 快速打开或隐藏工程面板&lt;/li&gt;
&lt;li&gt;Ctrl+Alt+ left/right 返回至上次浏览的位置&lt;/li&gt;
&lt;li&gt;Alt+ left/right 切换代码视图&lt;/li&gt;
&lt;li&gt;Alt+ Up/Down 在方法间快速移动定位&lt;/li&gt;
&lt;li&gt;Ctrl+Shift+Up/Down 代码向上/下移动。&lt;/li&gt;
&lt;li&gt;F2 或Shift+F2 高亮错误或警告快速定位&lt;/li&gt;
&lt;li&gt;代码标签输入完成后，按Tab，生成代码。&lt;/li&gt;
&lt;li&gt;选中文本，按Ctrl+Shift+F7 ，高亮显示所有该文本，按Esc高亮消失。&lt;/li&gt;
&lt;li&gt;Ctrl+W 选中代码，连续按会有其他效果&lt;/li&gt;
&lt;li&gt;选中文本，按Alt+F3 ，逐个往下查找相同文本，并高亮显示。&lt;/li&gt;
&lt;li&gt;Ctrl+Up/Down 光标跳转到第一行或最后一行下&lt;/li&gt;
&lt;li&gt;Ctrl+B 快速打开光标处的类或方法&lt;/li&gt;
&lt;li&gt;Ctrl＋E，可以显示最近编辑的文件列表&lt;/li&gt;
&lt;li&gt;Shift＋Click可以关闭文件&lt;/li&gt;
&lt;li&gt;Ctrl＋[或]可以跳到大括号的开头结尾&lt;/li&gt;
&lt;li&gt;Ctrl＋Shift＋Backspace可以跳转到上次编辑的地方&lt;/li&gt;
&lt;li&gt;Ctrl＋F12，可以显示当前文件的结构&lt;/li&gt;
&lt;li&gt;Ctrl＋F7可以查询当前元素在当前文件中的引用，然后按F3可以选择&lt;/li&gt;
&lt;li&gt;Ctrl＋Shift＋N，可以快速打开文件&lt;/li&gt;
&lt;li&gt;Alt＋Q可以看到当前方法的声明&lt;/li&gt;
&lt;li&gt;Ctrl＋W可以选择单词继而语句继而行继而函数&lt;/li&gt;
&lt;li&gt;Alt＋F1可以将正在编辑的元素在各个面板中定位&lt;/li&gt;
&lt;li&gt;Ctrl＋Shift＋Insert可以选择剪贴板内容并插入&lt;/li&gt;
&lt;li&gt;Alt＋Insert可以生成构造器/Getter/Setter等&lt;/li&gt;
&lt;li&gt;Ctrl＋Alt＋V 可以引入变量。例如把括号内的SQL赋成一个变量&lt;/li&gt;
&lt;li&gt;Ctrl＋Alt＋T可以把代码包在一块内，例如try/catch&lt;/li&gt;
&lt;li&gt;Alt＋Up and Alt＋Down可在方法间快速移动&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;👨‍💻👨‍💻👨‍💻👨‍💻👨‍💻&lt;/p&gt;
">Intellij IDEA常用快捷键</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jonchan1013.github.io/post/hello-gridea/"" data-c="
          &lt;p&gt;👏  欢迎使用 &lt;strong&gt;Gridea&lt;/strong&gt; ！&lt;br&gt;
✍️  &lt;strong&gt;Gridea&lt;/strong&gt; 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/getgridea/gridea&#34;&gt;Github&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://gridea.dev/&#34;&gt;Gridea 主页&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;http://fehey.com/&#34;&gt;示例网站&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;特性&#34;&gt;特性👇&lt;/h2&gt;
&lt;p&gt;📝  你可以使用最酷的 &lt;strong&gt;Markdown&lt;/strong&gt; 语法，进行快速创作&lt;/p&gt;
&lt;p&gt;🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片&lt;/p&gt;
&lt;p&gt;🏷️  你可以对文章进行标签分组&lt;/p&gt;
&lt;p&gt;📋  你可以自定义菜单，甚至可以创建外部链接菜单&lt;/p&gt;
&lt;p&gt;💻  你可以在 &lt;strong&gt;Windows&lt;/strong&gt;，&lt;strong&gt;MacOS&lt;/strong&gt; 或 &lt;strong&gt;Linux&lt;/strong&gt; 设备上使用此客户端&lt;/p&gt;
&lt;p&gt;🌎  你可以使用 &lt;strong&gt;𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌&lt;/strong&gt; 或 &lt;strong&gt;Coding Pages&lt;/strong&gt; 向世界展示，未来将支持更多平台&lt;/p&gt;
&lt;p&gt;💬  你可以进行简单的配置，接入 &lt;a href=&#34;https://github.com/gitalk/gitalk&#34;&gt;Gitalk&lt;/a&gt; 或 &lt;a href=&#34;https://github.com/SukkaW/DisqusJS&#34;&gt;DisqusJS&lt;/a&gt; 评论系统&lt;/p&gt;
&lt;p&gt;🇬🇧  你可以使用&lt;strong&gt;中文简体&lt;/strong&gt;或&lt;strong&gt;英语&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力&lt;/p&gt;
&lt;p&gt;🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步&lt;/p&gt;
&lt;p&gt;🌱 当然 &lt;strong&gt;Gridea&lt;/strong&gt; 还很年轻，有很多不足，但请相信，它会不停向前 🏃&lt;/p&gt;
&lt;p&gt;未来，它一定会成为你离不开的伙伴&lt;/p&gt;
&lt;p&gt;尽情发挥你的才华吧！&lt;/p&gt;
&lt;p&gt;😘 Enjoy~&lt;/p&gt;
">Hello Gridea</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jonchan1013.github.io/post/java-ji-chu-zong-jie-shu-zu/"" data-c="
          &lt;h2 id=&#34;1-数组的基本概念&#34;&gt;1、 数组的基本概念&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;数组可以看成是多个相同类型数据组合，对这些数据的统一管理。&lt;/li&gt;
&lt;li&gt;数组变量属引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量。&lt;/li&gt;
&lt;li&gt;数组的元素可以是任何数据类型，包括基本类型和引用类型。&lt;/li&gt;
&lt;li&gt;C和C++中的数组都可以分配在栈上面，而JAVA中的数组是只能分配在堆上面的，因为JAVA中的数组是引用类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;2-一维数组&#34;&gt;2、一维数组&lt;/h2&gt;
&lt;p&gt;一维数组的声明方式有2种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;格式一：数组元素类型 数组名[ ]; 即type var[ ];&lt;/li&gt;
&lt;li&gt;格式二：数组元素类型[ ] 数组名; 即type[ ] var;&lt;/li&gt;
&lt;li&gt;格式二声明数组的方法与C#上声明一维数组的方法一样。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;int a1[ ];  
int[ ] a2;
double b[ ];
person[ ] p1;
String s1[ ];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：JAVA语言中声明数组时不能指定其长度(数组中的元素个数)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​    如：int a[5]; 这样声明一维数组是非法的。&lt;/p&gt;
&lt;h2 id=&#34;3-数组的模型&#34;&gt;3、数组的模型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;一维数组：一维数组就是一行，一行小格。&lt;/li&gt;
&lt;li&gt;二维数组：二维数组就是一行加一列组成的一个平面分成的小格，有行有列。&lt;/li&gt;
&lt;li&gt;三维数组：三维数组就是一个立方体。&lt;/li&gt;
&lt;li&gt;人类对最多认识到三维空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-数组对象的创建&#34;&gt;4、数组对象的创建&lt;/h2&gt;
&lt;p&gt;JAVA中使用关键字&lt;strong&gt;new&lt;/strong&gt;创建数组对象。&lt;/p&gt;
&lt;p&gt;格式为：数组名 = &lt;strong&gt;new&lt;/strong&gt; 数组元素的类型[数组元素的个数]&lt;/p&gt;
&lt;p&gt;例如：&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200614033838.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;5-元素为引用数据类型的数组&#34;&gt;5、元素为引用数据类型的数组&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;注意：元素为引用数据类型的数组中的每一个元素都需要实例化。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Date{
      int year; int moth; int day;
      Date(int y; int m, int d){
      　　year=y ;
　　　　  month=m ;
　　　　  day=d ;
　　}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200614034019.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;6-数组的初始化&#34;&gt;6、数组的初始化&lt;/h2&gt;
&lt;h3 id=&#34;61-动态初始化&#34;&gt;6.1 动态初始化&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;数组定义与为数组元素分配空间和赋值的操作分开进行&lt;/strong&gt;。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test{
    public static void main(String args[ ]){
    int a[ ];  //定义数组，即声明一个int类型的数组a[ ]
    a=new int[3];  //给数组元素分配内存空间。
    a[0]=3; a[1]=9; a[2]=8;  //给数组元素赋值。
    Date days[ ];
    days=new Date[3];
    days[0]=new Date(1, 4, 2004);
    days[1]=new Date(2, 4, 2004);
    days[2]=new Date(3, 4, 2004);
    }
}

class Date{
    int year, month, day;
    Date(int y, int m, int d){
        year = y ;
        month = m ;
        day = d ;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;62-静态初始化&#34;&gt;6.2 静态初始化&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;在定义数组的同时就为数组元素分配空间并赋值。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;puclic class Test{
        public static void main(String args[ ]){
            int a[ ] = { 3, 9, 8};   //在定义数组的同时给数组分配空间并赋值。
            Date days[ ] = {
                new Date(1, 4, 2004),
                new Date(2 ,4 ,2004),
                new Date(3 ,4, 2004)
        };
    }
}
class Date{
    int year, month, day;
    Date(int y, int m, int d){
        year = y ;
        month = m ;
        day = d ;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;7-数组元素的默认初始化&#34;&gt;7、数组元素的默认初始化&lt;/h2&gt;
&lt;p&gt;​		数组是引用类型，它的元素相当于类的成员变量，因此给数组分配内存空间后，每个元素也被按照成员变量的规则被隐式初始化。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test{
        public static void main(String args[ ]){
            int a[ ] = new int[5];
            Date[ ] days=new Date[3];
            System.out.println(a[3]);
            System.out.println(days[2]);
    }
}
class Date{
    int year, month, day;
    Date(int y, int m, int d){
        year = y ;
        month = m ;
        day = d ;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;p&gt;System.out.println(a[3]);  打印出来的结果是：0。&lt;/p&gt;
&lt;p&gt;System.out.println(days[2]); 打印出来的结果是：null(空)&lt;/p&gt;
&lt;h2 id=&#34;8-数组元素的引用&#34;&gt;8、数组元素的引用&lt;/h2&gt;
&lt;p&gt;​		定义并用运算符new为之分配内存空间后，才可以引用数组中的每个元素，数组元素的引用方式为：&lt;strong&gt;arrayName[index]，&lt;/strong&gt; index为数组元素下标，可以是整型常量或整型表达式。如：&lt;strong&gt;a[3], b[i], c[6*i]。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数组元素下标从0开始；长度为n的数组的合法下标取值范围为&lt;strong&gt;0～n—1。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​    	每个数组都有一个属性length指明它的长度，例如：&lt;strong&gt;a.&lt;strong&gt;&lt;strong&gt;length&lt;/strong&gt;&lt;/strong&gt;的值为数组&lt;strong&gt;&lt;strong&gt;a&lt;/strong&gt;&lt;/strong&gt;的长度&lt;/strong&gt;**(&lt;strong&gt;&lt;strong&gt;元素个数&lt;/strong&gt;&lt;/strong&gt;)****。**&lt;/p&gt;
&lt;h2 id=&#34;9-二维数组&#34;&gt;9、二维数组&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200614034607.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;二维数组初始化：&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200614034640.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;10-理解java中的各个维度的数组模型&#34;&gt;10、理解JAVA中的各个维度的数组模型&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;C:%5CUsers%5CCY%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200614034726096.png&#34; alt=&#34;image-20200614034726096&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">Java基础总结-数组</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jonchan1013.github.io/post/java-ji-chu-mian-xiang-dui-xiang/"" data-c="
          &lt;p&gt;✍️面向对象的基本思想是，从现实世界中客观存在的事物出发来构造软件系统，并在系统的构造中尽可能运用人类的自然思维方式。&lt;br&gt;
面向对象更加强调运用人类在日常生活的逻辑思维中经常采用的思想方法与原则，如抽象、分类，继承、聚合、多态等。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;1-面向对象一&#34;&gt;1、面向对象（一）&lt;/h2&gt;
&lt;h3 id=&#34;11-面向过程的思想和面向对象的思想&#34;&gt;1.1 面向过程的思想和面向对象的思想&lt;/h3&gt;
&lt;p&gt;​		面向对象和面向过程的思想有着本质上的区别, &lt;strong&gt;作为面向对象的思维来说，当你拿到一个问题时，你分析这个问题不再是第一步先做什么，第二步再做什么，这是面向过程的思维，你应该分析这个问题里面有哪些类和对象，这是第一点，然后再分析这些类和对象应该具有哪些属性和方法。这是第二点。最后分析类和类之间具体有什么关系，这是第三点。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​		&lt;strong&gt;面向对象有一个非常重要的设计思维：合适的方法应该出现在合适的类里面。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;12-简单理解面向对象&#34;&gt;1.2 简单理解面向对象&lt;/h3&gt;
&lt;p&gt;​		就是在程序里面首先分解出来的应该是注意不再是一步一步的过程了，而是首先考虑在这个问题域里面或者程序里面应该具有有哪些对象，所以从现在开始考虑任何问题脑子里不要再想着我实现这件事我第一步应该干什么，第二步应该干什么，如果这样想，那就是面向过程的思维了。面向对象的思维是，当我碰到这个问题域的时候，碰到这个程序的时候，我首先应该把这个问题里有哪些对象，对象与对象之间有什么关系抽象出来。&lt;/p&gt;
&lt;h3 id=&#34;13-面向对象的设计思想&#34;&gt;1.3 面向对象的设计思想&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;面向对象的基本思想是，从现实世界中客观存在的事物出发来构造软件系统，并在系统的构造中尽可能运用人类的自然思维方式。&lt;/li&gt;
&lt;li&gt;面向对象更加强调运用人类在日常生活的逻辑思维中经常采用的思想方法与原则，如抽象、分类，继承、聚合、多态等。&lt;/li&gt;
&lt;li&gt;人在思考的时候，首先眼睛里看到的是一个一个的对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;14-对象和类的概念&#34;&gt;1.4  对象和类的概念&lt;/h3&gt;
&lt;p&gt;​		对象是用于计算机语言对问题域中事物的描述，&lt;strong&gt;对象通过“属性（attribute）”和“方法（method）”来分别对应事物所具有的静态属性和动态属性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;​		&lt;strong&gt;类是用于描述同一类的对象的一个抽象的概念，类中定义了这一类对象所具有的静态属性和动态属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​		&lt;strong&gt;类可以看成一类对象的模板，对象可以看成该类的一个具体实例&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;​		&lt;strong&gt;eg.什么叫瓶子？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​		瓶子的定义：具有某些类特征的东西就是瓶子，比分说什么样的形状，比方说有个口，能倒水，能装水，一般有个盖等等。给瓶子下定义的过程，其实就是把瓶子里的某些东西抽象出来了，所以瓶子在这里是叫做一类事物的一个抽象，在你脑子里有瓶子的概念，可瓶子的概念在你脑子里到底是什么呢？瓶子的概念在你脑子里叫做一类事物的一个抽象。怎么抽象的呢？你往往抽象的是这两个方面：第一个方面我们叫它静态的属性，瓶子应该具有哪些特征，比分说瓶子应有个口，这是它的具有的一个静态属性，瓶子一般有一个盖，这也是它的具有一个静态属性，除此之外，你还可能给它总结动态的属性，什么动态的属性呢？比放说瓶子能倒水，这是它的动态属性。瓶子这个概念在你脑子里如果你细细的思维的话，其实你给它做了两方面的总结，一方面是静态的，一方面是动态的。反映到JAVA的类上，一个就是成员变量（静态属性），一个就是方法（动态属性）方法是可以执行的，可以动的。成员变量是某一个类的静态属性。所以你脑子里瓶子的概念实际上是一类事物的一个抽象，这种东西我们叫它类，椅子是类，桌子是类，学生是类。什么是对象呢？这一类事物的具体的某个实例就叫做对象。所以&lt;strong&gt;一类事物的具体的某一个东西，符合这类事物具体的特征的某个东西就叫做对象&lt;/strong&gt;。瓶子是一个类，某个瓶子就是瓶子这个类里面的一个对象。&lt;/p&gt;
&lt;h3 id=&#34;15-如何抽象出一个类&#34;&gt;1.5 如何抽象出一个类？&lt;/h3&gt;
&lt;p&gt;​		有两个方面，一方面是它的静态属性，另一方面是它的动态属性。反映到JAVA里面的类怎么包装它呢？一方面成员变量，另一方面是方法。&lt;/p&gt;
&lt;p&gt;​		eg.职员这个类该怎么抽象出来？也是从两个方面，一方面是它的静态属性，另一方面它的动态属性&lt;/p&gt;
&lt;p&gt;​		职员有哪些属性呢？有姓名，年龄，目前工资数额等属性，他有哪些方法呢？让这个职员来显示姓名，显示年龄，修改姓名，领取工资。当然显示姓名，显示年龄，修改姓名，领取工资这些也可以让别人来做，但&lt;strong&gt;面向对象的设计思维是最合适的方法应该出现在最合适的类里面&lt;/strong&gt;。显示姓名，显示年龄，修改姓名，领取工资由谁来做更合适呢，那就是职员自己最合适。所以这些方法应该出现在职员这个类里面。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200610155239.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​		对于类来说，它有一些属性或者称为成员变量，以后说属性或者成员变量指的是同一回事。具体的对象他有没有相关的一些属性或者叫成员变量呢？有，每一个人都有一份，只不过是取值不同而已。如从职员这个类实例化出来的两个职员：职员A和职员B，他们都有姓名，年龄，目前工资数额这些属性，但他们的名字，年龄，领取的工资数额都不一样。这样就能把职员A和职员B区分开来了，正是因为他们的属性值不一样，所以这个对象才能和另外的对象区分开来，&lt;strong&gt;所以通过属性是可以区分两个对象的&lt;/strong&gt;。猫是一个类，这只猫是一个对象，这只猫和另外一只猫该怎么区分开来呢？那就得看你的猫这个类是怎么定义的了，猫有猫毛，毛有颜色。OK，这只猫是黑猫，另一只猫是白猫，这样通过猫毛的颜色区分开来了。如果只定义一个，如捉老鼠，白猫也能捉，黑猫也能捉，这样就没办法区分出黑猫和白猫了，所以&lt;strong&gt;根据方法是没办法区分两个对象的&lt;/strong&gt;。所以&lt;strong&gt;每个对象都有自己的属性，属性值和另外一个对象一般是不一样的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;​		一定要区分类和对象，什么叫做类？什么叫做对象？类是一类事物的一个抽象，具有共同特征的一类事物的一个抽象。对象是这个类具体的某一个实例，所以以后说实例（instance）或者说对象（object）指的是同一回事。&lt;/p&gt;
&lt;h3 id=&#34;16-类对象之间的关系&#34;&gt;1.6 类（对象）之间的关系&lt;/h3&gt;
&lt;h4 id=&#34;161-关联关系最弱的一种关系&#34;&gt;1.6.1 关联关系(最弱的一种关系)&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200610155402.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​		类和类之间是有关系的，如学生和老师这两个类，老师可以教学生，学生可以向老师学习。这就是他们之间的关系。关系和关系之间是不同的，你和你老婆的关系和你和你其他女朋友的关系是不能混为一谈的。关系最弱的一种关系叫关联关系。关联关系反应到代码上往往是一个类的方法里面的参数是另一个类的具体的某一个对象，比如教授教研究生，教哪个研究生，教是教授这个类里面的一个方法，某个研究生是研究生这个类里面的一个具体的对象。&lt;strong&gt;关联关系是最弱的一种关系&lt;/strong&gt;，咱们两个类之间有关系，或者两个对象之间有关系，但关系不是很紧密。&lt;/p&gt;
&lt;h4 id=&#34;162-继承关系比较强的一种关系&#34;&gt;1.6.2 继承关系（比较强的一种关系）&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200610155535.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​		&lt;strong&gt;继承关系封装了这样一种逻辑：“XX是一种XX”，只要这东西能说通了，就可以考虑用继承关系来封装它&lt;/strong&gt;。如：游泳运动员从运动员继承，游泳运动员是一种运动员，这能说得通，所以游泳运动员就是从运动员继承过来的，游泳运动员和运动员就是一种继承关系。学生是一个人，学生从人继承，老师是一个人，老师也从人继承，学生是一种老师，这说不通，所以学生和老师就不存在继承关系。所以将来做设计的时候要分清继承关系很简单，你只要说通这么一句话：“XX是一种XX”。OK，那他们之间就是继承关系。篮球运动员是一种球类运动员，这说得通，所以篮球运动员从球类运动员继承，这样继承很有可能会产生一棵继承树，运动员派生出来，派生出来的意思是游泳运动员这个类、球类运动员这个类、射击运动员类从它继承，相当于运动员派生出来了这些个不同的运动员，包括游泳的，球类的，射击的。球类的再派生足球的，篮球的，排球的。这就是一棵继承树，不过这棵树是比较理想化的情况，只有一个根节点。但实际当中，我们真实世界当中的继承关系不一定只从一个类继承，一个类可能从多个类继承过来，比如说：金丝猴从动物这个类继承，这很正常，但我还有另外一个专门的类：“应该受到保护的东西”，这也是一个类，金丝猴应该受到保护，所以金丝猴是一种应该受到保护的东西。所以金丝猴从“应该受到保护的东西”这个类继承过来。所以在现实情况当中，一个类完完全全有可能从多个不同的类继承，C++正是因为想封装这种继承关系，所以C++存在多重继承。&lt;/p&gt;
&lt;h4 id=&#34;163-聚合关系整体和部分比较强的一种关系&#34;&gt;1.6.3 聚合关系（整体和部分）（比较强的一种关系）&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200610155626.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​		什么是聚合？&lt;strong&gt;聚合就是一个整体与部分的关系&lt;/strong&gt;。我们说**“XX是XX的一部分”，只要说得通，那么他们之间的关系就是聚合关系**，队长是球队的一部分，队员是球队的一部分。所以队长和球队是聚合关系，队员和球队也是聚合关系。脑袋是人的以部分，身体和胳膊也是人的一部分，因此脑袋，身体和胳膊与人都是聚合关系。&lt;strong&gt;聚合关系分得再细一点的话就可以分成聚集关系和组合关系&lt;/strong&gt;，比如球队、队长，队员，这三者是聚集关系，假如这个队长既是足球的队长，同时也是篮球的队长，一个人分属两个不同的球队，这是可以的，球队与队长之间没有我离不了你，你离不了我这种情况，所以如果分得更细的话，这种就叫做聚集关系。还有一种情况叫组合，组合说的是咱们俩密不可分，我是你必不可少的一部分。一个人的脑袋不可能既属于你又属于别人，身体也一样，不可能既属于你又属于别人。所以你的身体，脑袋和你是密不可分的，这是一种更加严格的聚合关系，专门给它取了个名字叫组合。&lt;/p&gt;
&lt;h4 id=&#34;164-实现关系&#34;&gt;1.6.4 实现关系&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200610155715.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​		**作为父类来说，我觉得我应该具有这样一个方法，但我不知道怎么去实现，谁去实现，我的子类去实现，这就是实现关系。**和实现关系息息相关的还有一种关系叫多态。&lt;/p&gt;
&lt;h4 id=&#34;165-多态&#34;&gt;1.6.5 多态&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200610155757.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;17-java与面向对象&#34;&gt;1.7 Java与面向对象&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;	对象和类是分不开的，必须首先定义类才能有对象。首先定义方法才能调用。对象是JAVA里面的核心，做任何东西你首先都得给我造出一个对象才能做。静态属性简称属性，也叫成员变量，以后说属性或者说成员变量它们指的都是同一回事。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;整个类可以看作是静态的属性还有方法他们之间的一个综合。怎么抽象出一个类的概念，还是那句话，你必须抽象出两个方面来，第一方面是看他们的静态属性，他们有哪些成员变量，第二方面是看他们的有哪些方法。&lt;/p&gt;
&lt;p&gt;写JAVA程序时，我们一上来写的就是public class（声明一个类），在这个class里面我们写的是成员变量和方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每一个JAVA里面的class（类）都对应了我们现实生活中某一类事物的一个抽象&lt;/strong&gt;。比如说要在JAVA里面封装一只狗，具体怎么封装，如何写代码，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 一类事物封装到JAVA里面首先得写class，定义这个类，类名是什么可以自己取。
 * 这里把类名叫做Dog
 */
public class Dog {
    /**
     * 接下来就是写这个狗这个类的属性或者叫成员变量，
     * 比如说狗这个类的毛的颜色，怎么定义这个属性呢，
     * 首先得定义毛的一个类型,如使用int来定义毛的颜色类型
     */
    int furcolor; //定义属性：毛的颜色
    float height; //定义属性：狗的高度
    float weight; //定义属性：狗的体重

    /**
     * 狗的颜色，高度，体重这些属性定义完了，接下来要定义的就是方法了。
     * 如写一个CatchMouse（）方法，捉老鼠的方法。
     * CatchMouse这个方法里面有一个对象类型的参数，捉哪一只老鼠，这个对象参数是属于Mouse这个类的
     * @param m
     */
    void CatchMouse(Mouse m){
            //在方法体内写捉老鼠这个过程，怎么捉，跑着捉，走着捉
            System.out.println(&amp;quot;我捉到老鼠了，汪汪！，老鼠要尖叫了！&amp;quot;);
            /**
             * 老鼠尖叫一声，表示被狗咬到了，咬到了能不叫吗，很自然而然地想到，
             * 尖叫（scream()）这个方法是属于Mouse这个类里面的某一个方法。
             * 老鼠自己调用它，让它自己尖叫。这就是面向对象的思维。
             */
            m.scream();
    }

    public static void main(String[] args) {
        Dog  d = new Dog();//首先用new关键字创建一只狗
        Mouse m=new Mouse();//造出一只老鼠。
        d.CatchMouse(m);//然后用这只狗去抓老鼠，让狗调用CatchMouse()方法去捉某只老鼠。
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		从这个意义上来讲，JAVA里面的每定义一个类实际上就相当于一种新的数据类型。就跟int ，float， String等一样，不过是一种新定义的类型而已。&lt;/p&gt;
&lt;h3 id=&#34;18-为什么使用面向对象编程&#34;&gt;1.8 为什么使用面向对象编程？&lt;/h3&gt;
&lt;p&gt;​		面向对象编程：一组对象互相配合通过沟通完成特定功能&lt;/p&gt;
&lt;p&gt;做软件苦苦追求的一种境界是可重用性（reusable），可扩展性。如果是面向过程，一般情况是属性和方法它们是分开的，他们不是聚合的关系，不是合在一起的，这样要复用起来比较麻烦，复用的层次只是局限于方法这个层次上，而面向对象则不同，它是把属性和方法综合在一个里面。综合在一起复用的时候是整个对象进行复用。所以面向对象和面向过程相比，前者更加容易让我们达到可重用性。&lt;/p&gt;
&lt;h2 id=&#34;2-java面向对象二&#34;&gt;2、Java面向对象（二）&lt;/h2&gt;
&lt;h3 id=&#34;21-java类的定义&#34;&gt;2.1 Java类的定义&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//用class关键字定义一个类
class Person{
    private int id;
    private int age = 20;
    //方法的定义
    public int getAge(){
        return age;
    }
    public void setAge(int i){
        age = i;
    }
    public int getId(){
        return id;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;类的定义主要有两方面组成一成员变量和方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;声明成员变量的格式为: [&amp;lt; modifiers&amp;gt;] type &amp;lt; attr_name&amp;gt;[=defaultValue] ;&lt;br&gt;
例如:  private int id;    private int age = 20;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;声明方法的格式为:&lt;br&gt;
[&amp;lt; modifiers&amp;gt;)] &amp;lt; modifiers&amp;gt; &amp;lt;return_ type&amp;gt; &lt;name&gt;([&amp;lt; argu list&amp;gt;]) {&lt;br&gt;
[&amp;lt; statements&amp;gt;]&lt;br&gt;
}    例如: public int getAge() {return age;}&lt;/p&gt;
&lt;p&gt;​		JAVA里面有&lt;strong&gt;class&lt;/strong&gt;关键字定义一个类，后面加上自定义的类名即可。如这里定义的person类，使用class person定义了一个person类，然后在person这个类的类体里面定义person这个类应该具有的成员变量（即属性）和方法，如这里定义的int id和int age这个两个成员变量，或者叫属性，这个id表示人的身份证号码，人应该具有这个属性，age表示人的年龄，这也是人应该具有的。这样就在person这个类里面定义了两个人应该有的属性，接下来就是定义方法了，这里定义了三个方法，分别是getAge()、setAge(int i)和getId()，分别用来获取人的年龄，设置人的年龄，获取人的id，getAge()方法获取了人的年龄后，将获取到的值返回，所以使用了return age语句，getId()方法也使用了return id语句用于返回获取到的id的值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;22-成员变量&#34;&gt;2.2 成员变量&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200610160936.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;**在JAVA里面的任何变量首先应该要声明，然后再赋值，然后再使用。**成员变量和局部变量有一个重要区别：&lt;strong&gt;成员变量在类里面声明时如果不进行初始化，那么JAVA会默认给它初始化，而局部变量JAVA不会默认给它初始化，所以在方法里面声明一个局部变量如果不给它初始化时就会出错&lt;/strong&gt;。默认初始化大多数都是0，boolean类型的为false，引用类型的为null，如过不记得JAVA对成员变量默认的初始化是多少的话，那就这样做，定义一个成员变量，不给它初始化，然后直接打印这个成员变量，打印出来的结果就是JAVA默认的初始化的值。&lt;/p&gt;
&lt;h3 id=&#34;23-java面向对象的基本概念引用&#34;&gt;2.3 Java面向对象的基本概念——引用&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200610161110.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​		&lt;strong&gt;引用类型和基本类型有着巨大的区别&lt;/strong&gt;，当声明一个int i=0时，系统会马上给这个i分配一个内存空间（在栈内存里面分配一小块区域用来装数字0），里面装着一个值为0，以后使用i这个名字马上就可以访问这个内存空间里面的值，这就是基本数据类型，所以&lt;strong&gt;基础类型就只占一块内存&lt;/strong&gt;。基础类型之外的类型全都叫引用类型，我们定义一个Mouse m，这个m就是一个引用类型的数据。引用类型有什么重要的特征——&lt;strong&gt;引用类型占&lt;strong&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/strong&gt;块内存&lt;/strong&gt;。我们定义好这个类之后，需要使用new关键字把这个类的对象实例化出来，也就是真真正正造出一个对象出来才能使用这个对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何在内存中区分类和对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类是静态的概念，是位于代码区里面。对象是new出来的，它是位于堆内存，为什么对象要位于堆内存？因为堆内存是用来动态分配内存的，只有在运行当中才会new一个对象放堆内存里面，那这个对象到底有多大个，这个东西你不知道，你没有办法提前知道，所以你没有办法提前分配内存给这个对象，你只有在运行期间才能去分配它。什么叫运行期间？敲JAVAC这个命令那是在编译期间，编译完成后再敲JAVA命令，那就是运行期间了。只有在运行期间，才能够明白这个对象到底要分配多大的空间给它，所以把它放在堆内存里面，堆内存比较大，动态分配内存用它。如果这个对象不用了，那它就是垃圾，那么就等着垃圾收集器把它收集回去，释放掉占用的内存。&lt;/p&gt;
&lt;p&gt;​		记住，&lt;strong&gt;以后一提到引用，脑子里马上浮现引用那就是一小块内存指向一大块内存。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;24-对象的创建和使用&#34;&gt;2.4 对象的创建和使用&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;必须使用new关键字创建对象。&lt;/li&gt;
&lt;li&gt;使用对象(引用) .成员变量或来引用对象的成员变量。&lt;/li&gt;
&lt;li&gt;使用对象(引用) .方法(参数列表)来调用对象的方法。&lt;/li&gt;
&lt;li&gt;同一类的每个对象有不同的成员变量存储空间。&lt;/li&gt;
&lt;li&gt;同一类的每个对象共享该类的方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;25-类和对象的关系&#34;&gt;2.5 类和对象的关系&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200610162714.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;在内存中分析类和对象的关系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设这里有一个类C，我们定义了一个类class C，然后在这个类里面定义了两个成员变量: int i和int j。定义好了这两个成员变量以后，我们写了一个main()方法（public static void main(Strng[] args)），程序开始执行。第一句我们写了 C c1 = new C()，这句的代码是我们相当于在堆内存里创建了一个对象，同时也创建了这个对象的一个引用对象c1，c1位于栈内存中，c1这个引用对象指向堆中一大块内存，这一大块内存里面装着new出来的那个对象。这里面我们一般来说是new出来两个对象c1和c2，当然，实际上，严格来讲，c1和c2叫做对象的引用，有时候，简称new出来了两个对象，c1和c2。你脑子里马上要浮现出两块内存，c1指向一块，c2指向一块。局部变量是分配在栈内存里面的，main方法里面的c1和c2都是局部变量，所以在栈里面分配了两小块内存出来，一块是c1的，一块是c2的，c1这块内存里面装着一个值，或者叫装着一个地址，这个地址是什么，我们不知道，我们只知道根据这个值就能找到new出来的C这个类里面的一个对象，而在这个对象里面有它自己的成员变量i和j，里面的两小块内存是分别用来装i和j的值的，因为每一个对象都有自己不同的成员变量的值，所以c1指向的那块对内存里面又分成一小块一小块内存，每一个小块的内存都装着这个对象的成员变量（或者叫属性）。如这里的第一小块装着i的值，第二小块装着j的值，所以当我们去访问第一小块里面装着的成员变量时，我们应该这样写：c1.i，这样就拿到了i的值，c1.j，这样就拿到了j的值。同理，c2这个对象也指向了一个new出来的C这个类里面的另一个对象，这个对象也有成员变量i和j，只不过和c1指向的那个对象里的i和j的值不同而已。要访问这个这个对象的成员变量时 ，也是要c2.i，c2.j这样去访问。&lt;/p&gt;
&lt;h3 id=&#34;26-构造方法&#34;&gt;2.6 构造方法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用new+构造方法创建-一个新的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;构造函数是定义在Java类中的一个用来初始化对象的函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;构造函数与类同名且没有返回值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;例如: Person 类的构造函数:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Person(){
    int id;
    int age;
    Person(int n,int i){
        id = n;
        age = i;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在面向对象里面有一个特殊的方法，叫构造方法。&lt;/p&gt;
&lt;p&gt;构造方法是用来创建一个新的对象的，与new组合在一起用，使用new+构造方法创建一个新的对象。你new一个东西的时候，实际上你调用的是一个构造方法，构造方法就是把自己构造成一个新的对象，所以叫构造方法，构造一个新对象用的方法叫构造方法。&lt;/p&gt;
&lt;p&gt;构造方法比较特殊，构造方法的名字必须和类的名字完全一模一样，包括大小写，并且没有返回值。如原来定义的一个person类，在类里面声明了两个成员变量id与age，这时候你可以再为这个person类定义一个它的构造方法person(int n，int i)，这个方法的名字和类名完全相同，并且没有返回值，也就是在这个方法前面不能写任何的方法的返回类型修饰符，连void都不可以写。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;构造方法范例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Person {
    int id;  //在person这类里面定义两个成员变量id和age,
    int age=20;  //给成员变量age赋了初值为20

    /**这里就是person这个类的一个构造方法
     * 构造方法的规则很简单，和类名要完全一样，一点都不能错，包括大小写。
     * 并且没有返回值，不能写void在它前面修饰
     * @param _id
     * @param _age
     */
    public Person(int _id,int _age ) {
        id = _id;
        age = _age;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		构造方法写好后就和new组合在一起使用，new的作用是构建一个新对象，创造一个新对象，所以new的时候实际当中调用的是构造方法。只有调用了这个构造方法才能构造出一个新的对象。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void main(String[] args) {
    Person tom = new Person(1, 25); // 调用person这个构造方法创建一个新的对象，并给这个对象的成员变量赋初始值
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200610161822.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​	&lt;strong&gt;下面是在main方法里面调用person构造方法时的内存分析情况：&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200610161855.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200610161922.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​		&lt;strong&gt;当方法调用完成之后，栈里面为它分配的空间全部都要消失，即把这个方法调用时分配给它的内存空间释放出来&lt;/strong&gt;，所以这个构造方法person调用完成之后，栈内存里面分配的两小块内存_id和_age自动消失了。这样就把它们所占的空间让了出来，让其他的方法去占用。而new出来的对象则永远留在了堆内存里面。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200610162016.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​		&lt;strong&gt;声明一个类，若没有在类中指定其构造方法（构造函数）时，编译器会为这个类自动添加形如类名( ){ }的构造函数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class  point{//这里声明一个类时并没有给它指定其构造方法。
     int  x;
     int  y;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		但在main方法里面我们却可以这样使用：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void main(String[] args){
     point  p = new  point();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		这里这样写是可以的，当没有给这个类指明构造方法时，系统会默认地给这个类加上point ( ) { }这样一个空的构造方法。所以才可以在main方法中使用point p = new point(); 实际上你调用的就是编译器默认给它加上的point ( ) { }这个构造方法，在这个构造方法当中，默认地把类里面的成员变量x和y初始值设为0。正是因为系统给它默认加上这么一个构造方法，所以才能在main方法里面调用。但&lt;strong&gt;要记住一点，一旦给这个类里面指定了构造方法，那么系统就不会再给这个类添加构造方法了&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;3-封装&#34;&gt;3、封装&lt;/h2&gt;
&lt;h3 id=&#34;31-封装概述&#34;&gt;3.1 封装概述&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;概述：&lt;/p&gt;
&lt;p&gt;​		面向对象编程语言是对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界无法直接操作和修改。&lt;br&gt;
封装可以被认为是一个保护屏障，防止该类的代码和数据被其他类随意访问。要访问该类的数据，必须通过指定的&lt;br&gt;
方式。适当的封装可以让代码更容易理解与维护，也加强了代码的安全性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;原则：&lt;/p&gt;
&lt;p&gt;​		将属性隐藏起来，若需要访问某个属性，提供公共方法对其访问。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;32-封装的步骤&#34;&gt;3.2 封装的步骤&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;使用 private 关键字来修饰成员变量。&lt;/li&gt;
&lt;li&gt;对需要访问的成员变量，提供对应的一对 getXxx 方法 、 setXxx 方法。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;33-封装的操作private关键字&#34;&gt;3.3 封装的操作——private关键字&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;private的含义&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;private是一个权限修饰符，代表最小权限。&lt;/li&gt;
&lt;li&gt;可以修饰成员变量和成员方法。&lt;/li&gt;
&lt;li&gt;被private修饰后的成员变量和成员方法，只在本类中才能访问。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;private的使用格式&lt;/strong&gt; ：&lt;/p&gt;
&lt;p&gt;​	private 数据类型 变量名 ；&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用 private 修饰成员变量，代码如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Student {
  private String name;
  private int age;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;提供 getXxx 方法 / setXxx 方法，可以访问成员变量，代码如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Student {
  private String name;
  private int age;
 
  public void setName(String n) {
    name = n;
  }
 
  public String getName() {
    return name;
  }
 
  public void setAge(int a) {
    age = a;
  }
 
  public int getAge() {
    return age;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;34-封装的优化1-this关键字&#34;&gt;3.4 封装的优化1----this关键字&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在类的方法定义中使用的this关键字代表使用该方法的对象的引用。&lt;/li&gt;
&lt;li&gt;当必须指出当前使用方法的对象是谁时要使用this.&lt;/li&gt;
&lt;li&gt;有时使用this可以处理方法中成员变量和参数重名的情况。&lt;/li&gt;
&lt;li&gt;this可以看作是一一个变量，它的值是当前对象的引用&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Student {
  private String name;
  private int age;
 
  public void setName(String name) {
    //name = name;
    this.name = name;
  }
 
  public String getName() {
    return name;
  }
 
  public void setAge(int age) {
    //age = age;
    this.age = age;
  }
 
  public int getAge() {
    return age;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;小贴士：方法中只有一个变量名时，默认也是使用 this 修饰，可以省略不写。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;this是一个引用，它指向自身的这个对象。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;看内存分析图：&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615022306.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;​		假设我们在堆内存new了一个对象，在这个对象里面你想象着他有一个引用this，this指向这个对象自己，所以这就是this，这个new出来的对象名字是什么，我们不知道，不知道也没关系，因为这并不影响这个对象在内存里面的存在，这个对象只要在内存中存在，他就一定有一个引用this。&lt;/p&gt;
&lt;p&gt;看下面的例子分析：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
public class Leaf {

    int i = 0;

    public Leaf(int i) {
        this.i = i;
    }

    Leaf increament() {
        i++;
        return this;
    }

    void print() {
        System.out.println(&amp;quot;i = &amp;quot; + i);
    }

    public static void main(String[] args) {
        Leaf leaf = new Leaf(100);
        leaf.increament().increament().print();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615022412.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;在内存中分析main方法的执行过程:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先分析第一句话：&lt;strong&gt;Leaf leaf = new Leaf(100);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;程序执行到这里的时候，栈空间里面有一个变量leaf，它指向了我们new出来的在堆空间里面的Leaf对象。new这个Leaf对象的时候，调用了构造方法Leaf(),这个构造方法里面有一个形参i，所以在栈空间里面给构造方法分配有一小块内存，名字叫i用来装传递过来的实参。这里传过来的实参是100，所以i里面装的值就是100。得到这个值之后，构造方法继续执行，执行this.i = i;这里就是把栈空间里面的i的值通过值传递给Leaf对象里面的成员变量i，所以成员变量i的值也变成了100。内存中的布局如下图所示：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615022457.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​		构造方法执行完之后，为这个构造方法分配的内存消失，所以栈里面的i所标记的那一小块内存会消失。因此第一句话执行完之后，内存中的布局如下图所示：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615022536.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;接下来分析第二句话：&lt;strong&gt;leaf.increament().increament().print();&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先逐个分析：leaf.increament()，这里是调用increament()方法，是对new出来的那个Leaf对象调用的，leaf是Leaf对象的引用对象，因此通过这个引用对象来调用increament()方法，即相当于是Leaf对象自己调用了increament()方法。increament()方法的定义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Leaf increament(){
　　i++;
　　return this;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		因此Leaf对象调用increament()方法时，首先执行方法体里面的第一句话i++;这样就把Leaf对象的成员变量i的值由原来的100变成了101。此时的内存布局如下图所示:&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615022622.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;接下来执行方法体里面的第二句话：&lt;strong&gt;return this;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里把this作为返回值，当有返回值的时候，首先会在栈里面给这个返回值分配一小块临时的存储空间。这块存储空间里面的内容是this里面的内容。this指向它自身，所以栈内存里面的那块临时存储空间里面装的this也是指向堆内存里面的Leaf对象。&lt;/p&gt;
&lt;p&gt;​		所以leaf.increament().increament().print();这句话里面left.increament()这一小句话执行完之后，内存中的布局如下图所示:&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;18&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615022741.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;leaf.increament().increament().print();这句话里面的left.increament()这一小句话执行完之后，返回一个this，此时leaf.increament().increament().print();就相当于是this.increament().print();&lt;/p&gt;
&lt;p&gt;接着栈里面的存储在临时空间里面的this调用increament()方法，而this指的就是Leaf对象，所以又是Leaf对象调用increament()方法。Leaf对象调用increament()方法时，又会执行方法体里面的i++，所以此时i又由原来的101变成了102。然后又执行return this，所以栈内存里面又多了一块临时存储空间，里面装的值也是this，这个this又是指向堆内存里面的Leaf对象。因此此时这个Leaf对象有了四个指向他自己的引用对象。&lt;/p&gt;
&lt;p&gt;leaf.increament().increament().print();这句话里面的leaf.increament().increament()这一小句话执行完之后,都返回了一个this，所以此时的leaf.increament().increament().print();就相当于是这样子的：this.this.print();&lt;/p&gt;
&lt;p&gt;接下来又是栈里面的那个新的this调用print()方法，使用this来调用，那就相当于是Leaf对象来调用，Leaf对象自己调用print()方法将自己的i属性的值打印出来，所以打印出来的结果应该是102。&lt;/p&gt;
&lt;p&gt;因此main方法里面的整个程序执行完之后，内存中的布局如下图所示：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;19&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615022842.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​		this的总结：this一般出现在方法里面，当这个方法还没有调用的时候，this指的是谁并不知道。但是实际当中，你如果new了一个对象出来，那么this指的就是当前这个对象。对哪个对象调用方法，this指的就是调用方法的这个对象（你对哪个对象调用这个方法，this指的就是谁）。如果再new一个对象，这个对象他也有自己的this，他自己的this就当然指的是他自己了。&lt;/p&gt;
&lt;h3 id=&#34;35-封装的优化2-构造方法&#34;&gt;3.5 封装的优化2----构造方法&lt;/h3&gt;
&lt;p&gt;​		当一个对象被创建时候，构造方法用来初始化该对象，给对象的成员变量赋初始值。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;小贴士：无论你与否自定义构造方法，所有的类都有构造方法，因为Java自动提供了一个无参数构造方法，一旦自己定义了构造方法，Java自动提供的默认无参数构造方法就会失效。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;构造方法的定义格式：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;修饰符 构造方法名(参数列表){
    // 方法体
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		构造方法的写法上，方法名与它所在的类名相同。它没有返回值，所以不需要返回值类型，甚至不需要void。使用&lt;br&gt;
构造方法后，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Student {
  private String name;
  private int age;
  // 无参数构造方法
  public Student() {} 
  // 有参数构造方法
  public Student(String name,int age) {
    this.name = name;
    this.age = age; 
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意事项:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果你不提供构造方法，系统会给出无参数构造方法。&lt;/li&gt;
&lt;li&gt;如果你提供了构造方法，系统将不再提供无参数构造方法。&lt;/li&gt;
&lt;li&gt;构造方法是可以重载的，既可以定义参数，也可以不定义参数。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;36-标准代码javabean&#34;&gt;3.6 标准代码——JavaBean&lt;/h3&gt;
&lt;p&gt;​		JavaBean 是 Java语言编写类的一种标准规范。符合 JavaBean 的类，要求类必须是具体的和公共的，并且具有无参数的构造方法，提供用来操作成员变量的 set 和 get 方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ClassName{
  //成员变量
  //构造方法
  //无参构造方法【必须】
  //有参构造方法【建议】
  //成员方法    
  //getXxx()
  //setXxx()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编写符合 JavaBean 规范的类，以学生类为例，标准代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Student {
  //成员变量
  private String name;
  private int age;
 
  //构造方法
  public Student() {}
 
  public Student(String name,int age) {
    this.name = name;
    this.age = age;
  }
 
  //成员方法
  publicvoid setName(String name) {
    this.name = name;
  }
 
  public String getName() {
    return name;
  }
 
  publicvoid setAge(int age) {
    this.age = age;
  }
 
  publicint getAge() {
    return age;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试类，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TestStudent {
  public static void main(String[] args) {
    //无参构造使用
    Student s= new Student();
    s.setName(&amp;quot;柳岩&amp;quot;);
    s.setAge(18);
    System.out.println(s.getName()+&amp;quot;‐‐‐&amp;quot;+s.getAge());
      //带参构造使用
    Student s2= new Student(&amp;quot;赵丽颖&amp;quot;,18);
    System.out.println(s2.getName()+&amp;quot;‐‐‐&amp;quot;+s2.getAge());
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-继承&#34;&gt;4、继承&lt;/h2&gt;
&lt;h3 id=&#34;41-继承的概述&#34;&gt;4.1 继承的概述&lt;/h3&gt;
&lt;p&gt;​		多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那一个类即可。如图所示：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;20&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615023612.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​		其中，多个类可以称为子类，单独那一个类称为父类、超类（superclass）或者基类。&lt;br&gt;
​		继承描述的是事物之间的所属关系，这种关系是： is-a 的关系。例如，图中兔子属于食草动物，食草动物属于动物。可见，父类更通用，子类更具体。我们通过继承，可以使多种事物之间形成一种关系体系。&lt;br&gt;
&lt;strong&gt;定义：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;继承：就是子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接访问父类中的非私有的属性和行为。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;好处：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;提高&lt;strong&gt;代码的复用性。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;类与类之间产生了关系，是&lt;strong&gt;多态的前提。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;42-继承的格式&#34;&gt;4.2 继承的格式&lt;/h3&gt;
&lt;p&gt;通过 extends 关键字，可以声明一个子类继承另外一个父类，定义格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class 父类 {
    ...
}
 
class 子类 extends 父类 {
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;继承演示，代码如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/*
 * 定义员工类Employee，做为父类
  */
class Employee {
    String name; // 定义name属性
    // 定义员工的工作方法
    public void work() {
        System.out.println(&amp;quot;尽心尽力地工作&amp;quot;);
    }
}
 
/*
 * 定义讲师类Teacher 继承 员工类Employee
 */
class Teacher extends Employee {
    // 定义一个打印name的方法
    public void printName() {
        System.out.println(&amp;quot;name=&amp;quot; + name);
    }
}
 
/*
 * 定义测试类
 */
public class ExtendDemo01 {
    public static void main(String[] args) {
        // 创建一个讲师类对象
        Teacher t = new Teacher();
      
        // 为该员工类的name属性进行赋值
        t.name = &amp;quot;小明&amp;quot;; 
      
        // 调用该员工的printName()方法
        t.printName(); // name = 小明
        
        // 调用Teacher类继承来的work()方法
        t.work();  // 尽心尽力地工作
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;43-继承后的特点成员变量&#34;&gt;4.3 继承后的特点——成员变量&lt;/h3&gt;
&lt;p&gt;当类之间产生了关系后，其中各类中的成员变量，又产生了哪些影响呢？&lt;/p&gt;
&lt;h4 id=&#34;成员变量不重名&#34;&gt;成员变量不重名：&lt;/h4&gt;
&lt;p&gt;如果子类父类中出现不重名的成员变量，这时的访问是没有影响的。代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Fu {
    // Fu中的成员变量。
    int num = 5;
}
class Zi extends Fu {// Zi中的成员变量
    int num2 = 6;
    // Zi中的成员方法
    public void show() {
        // 访问父类中的num，
        System.out.println(&amp;quot;Fu num=&amp;quot;+num); // 继承而来，所以直接访问。
        // 访问子类中的num2
        System.out.println(&amp;quot;Zi num2=&amp;quot;+num2);
    }
}
class ExtendDemo02 {
    public static void main(String[] args) {
        // 创建子类对象
        Zi z = new Zi(); 
        // 调用子类中的show方法
        z.show();  
    }
}
 
演示结果：
Fu num = 5
Zi num2 = 6
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;成员变量重名&#34;&gt;成员变量重名:&lt;/h4&gt;
&lt;p&gt;如果子类父类中出现重名的成员变量，这时的访问是有影响的。代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt; 

    // Zi中的成员变量
    int num2 = 6;
    // Zi中的成员方法
    public void show() {
        // 访问父类中的num，
        System.out.println(&amp;quot;Fu num=&amp;quot;+num); // 继承而来，所以直接访问。
        // 访问子类中的num2
        System.out.println(&amp;quot;Zi num2=&amp;quot;+num2);
    }
}
class ExtendDemo02 {
    public static void main(String[] args) {
        // 创建子类对象
        Zi z = new Zi(); 
        // 调用子类中的show方法
        z.show();  
    }
}
 
演示结果：
Fu num = 5
Zi num2 = 6

class Fu {
    // Fu中的成员变量。
    int num = 5;
}
class Zi extends Fu {
    // Zi中的成员变量
    int num = 6;
    public void show() {
        // 访问父类中的num
        System.out.println(&amp;quot;Fu num=&amp;quot; + num);
        // 访问子类中的num
        System.out.println(&amp;quot;Zi num=&amp;quot; + num);
    }
}
class ExtendsDemo03 {
    public static void main(String[] args) {
        // 创建子类对象
        Zi z = new Zi(); 
        // 调用子类中的show方法
        z.show(); 
    }
}
演示结果：
Fu num = 6
Zi num = 6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用 super 关键字，修饰父类成员变量，类似于之前学过的 this 。&lt;/p&gt;
&lt;p&gt;使用格式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;super.父类成员变量名
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;子类方法需要修改，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Zi extends Fu {
    // Zi中的成员变量
    int num = 6;
    public void show() {
        //访问父类中的num
        System.out.println(&amp;quot;Fu num=&amp;quot; + super.num);
        //访问子类中的num
        System.out.println(&amp;quot;Zi num=&amp;quot; + this.num);
    }
}
演示结果：
Fu num = 5
Zi num = 6
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;小贴士：Fu 类中的成员变量是非私有的，子类中可以直接访问。若Fu 类中的成员变量私有了，子类是不能直接访问的。通常编码时，我们遵循封装的原则，使用private修饰成员变量，那么如何访问父类的私有成员变量呢？对！可以在父类中提供公共的getXxx方法和setXxx方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;44-继承后的特点成员方法&#34;&gt;4.4  继承后的特点——成员方法&lt;/h3&gt;
&lt;p&gt;当类之间产生了关系，其中各类中的成员方法，又产生了哪些影响呢？&lt;/p&gt;
&lt;h4 id=&#34;成员方法不重名&#34;&gt;成员方法不重名:&lt;/h4&gt;
&lt;p&gt;如果子类父类中出现&lt;strong&gt;不重名&lt;/strong&gt;的成员方法，这时的调用是&lt;strong&gt;没有影响&lt;/strong&gt;的。对象调用方法时，会先在子类中查找有没有对应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法。代码如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Fu{
    public void show(){
        System.out.println(&amp;quot;Fu类中的show方法执行&amp;quot;);
    }
}
class Zi extends Fu{
    public void show2(){
        System.out.println(&amp;quot;Zi类中的show2方法执行&amp;quot;);
    }
}
public  class ExtendsDemo04{
    public static void main(String[] args) {
        Zi z = new Zi();
        //子类中没有show方法，但是可以找到父类方法去执行
             z.show(); 
        z.show2();
    }
}
 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;成员方法重名——重写(Override):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果子类父类中出现&lt;strong&gt;重名&lt;/strong&gt;的成员方法，这时的访问是一种特殊情况，叫做&lt;strong&gt;方法重写&lt;/strong&gt; (Override)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;方法重写&lt;/strong&gt; ：子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写。&lt;strong&gt;声明不变，重新实现。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Fu {
    public void show() {
        System.out.println(&amp;quot;Fu show&amp;quot;);
    }
}
class Zi extends Fu {
    //子类重写了父类的show方法
    public void show() {
        System.out.println(&amp;quot;Zi show&amp;quot;);
    }
}
public class ExtendsDemo05{
    public static void main(String[] args) {
        Zi z = new Zi();
        // 子类中有show方法，只执行重写后的show方法
        z.show();  // Zi show
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;重写的应用&#34;&gt;重写的应用:&lt;/h4&gt;
&lt;p&gt;​		子类可以根据需要，定义特定于自己的行为。既沿袭了父类的功能名称，又根据子类的需要重新实现父类方法，从而进行扩展增强。比如新的手机增加来电显示头像的功能，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Phone{
	public void sendMessage(){
    	System.out.println(&amp;quot;发短信&amp;quot;);
	}
	public void call(){
    	System.out.println(&amp;quot;打电话&amp;quot;);
	}
	public void showNum(){
    	System.out.println(&amp;quot;来电显示号码&amp;quot;);
	}
}

//智能手机类
class NewPhone extends Phone {
    //重写父类的来电显示号码功能，并增加自己的显示姓名和图片功能
    public void showNum(){
        //调用父类已经存在的功能使用super
        super.showNum();
        //增加自己特有显示姓名和图片功能
        System.out.println(&amp;quot;显示来电姓名&amp;quot;);
        System.out.println(&amp;quot;显示头像&amp;quot;);
    }
}
 
public class ExtendsDemo06 {
    public static void main(String[] args) {
        // 创建子类对象
        NewPhone np = new NewPhone()；
        
        // 调用父类继承而来的方法
        np.call();
      
        // 调用子类重写的方法
        np.showNum();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;小贴士：这里重写时，用到super.父类成员方法，表示调用父类的成员方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意事项:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;子类方法覆盖父类方法，必须要保证权限大于等于父类权限。&lt;/li&gt;
&lt;li&gt;子类方法覆盖父类方法，返回值类型、函数名和参数列表都要一模一样。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;45-继承后的特点构造方法&#34;&gt;4.5 继承后的特点——构造方法&lt;/h3&gt;
&lt;p&gt;当类之间产生了关系，其中各类中的构造方法，又产生了哪些影响呢？&lt;br&gt;
首先我们要回忆两个事情，构造方法的定义格式和作用。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;构造方法的名字是与类名一致的。所以子类是无法继承父类构造方法的。&lt;/li&gt;
&lt;li&gt;构造方法的作用是初始化成员变量的。所以子类的初始化过程中，必须先执行父类的初始化动作。子类的构造方法中默认有一个 super() ，表示调用父类的构造方法，父类成员变量初始化后，才可以给子类使用。代码如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Fu {
  private int n;
  Fu(){
    System.out.println(&amp;quot;Fu()&amp;quot;);
  }
}

class Zi extends Fu {
  Zi(){
    // super（），调用父类构造方法
    super();
    System.out.println(&amp;quot;Zi（）&amp;quot;);
  }  
}

public class ExtendsDemo07{
  public static void main (String args[]){
    Zi zi = new Zi();
  }
}

输出结果：
Fu（）
Zi（）
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;46-super和this&#34;&gt;4.6 super和this&lt;/h3&gt;
&lt;h4 id=&#34;父类空间优先于子类对象产生&#34;&gt;父类空间优先于子类对象产生&lt;/h4&gt;
&lt;p&gt;在每次创建子类对象时，先初始化父类空间，再创建其子类对象本身。目的在于子类对象中包含了其对应的父类空间，便可以包含其父类的成员，如果父类成员非private修饰，则子类可以随意使用父类成员。代码体现在子类的构造方法调用时，一定先调用父类的构造方法。理解图解如下：&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615025331.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;super和this的含义&#34;&gt;super和this的含义：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;super ：代表父类的存储空间标识(可以理解为父亲的引用)。&lt;/li&gt;
&lt;li&gt;this ：代表当前对象的引用(谁调用就代表谁)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;super和this的用法&#34;&gt;super和this的用法:&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;访问成员&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;this.成员变量       ‐‐    本类的
super.成员变量      ‐‐    父类的
 
this.成员方法名()    ‐‐    本类的    
super.成员方法名()   ‐‐    父类的
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用法演示，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Animal {
    public void eat() {
        System.out.println(&amp;quot;animal : eat&amp;quot;);
    }
}
 
class Cat extends Animal {
    public void eat() {
        System.out.println(&amp;quot;cat : eat&amp;quot;);
    }
    public void eatTest() {
        this.eat();   // this  调用本类的方法
        super.eat();  // super 调用父类的方法
    }
}
 
public class ExtendsDemo08 {
    public static void main(String[] args) {
        Animal a = new Animal();
        a.eat();
        Cat c = new Cat();
        c.eatTest();
    }
}
 
输出结果为：
animal : eat
cat : eat
animal : eat
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;访问构造方法&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;this(...)       ‐‐    本类的构造方法
super(...)      ‐‐    父类的构造方法
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;​		子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;47-继承的特点&#34;&gt;4.7 继承的特点&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Java只支持单继承，不支持多继承。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//一个类只能有一个父类，不可以有多个父类。
class C extends A{}     //ok
class C extends A，B...  //error
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Java支持多层继承(继承体系)。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class A{}
class B extends A{}
class C extends B{}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;顶层父类是Object类。所有的类默认继承Object，作为父类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;子类和父类是一种相对的概念。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;5-多态&#34;&gt;5、多态&lt;/h2&gt;
&lt;h3 id=&#34;51-概述&#34;&gt;5.1 概述&lt;/h3&gt;
&lt;p&gt;多态是继封装、继承之后，面向对象的第三大特性。&lt;br&gt;
生活中，比如跑的动作，小猫、小狗和大象，跑起来是不一样的。再比如飞的动作，昆虫、鸟类和飞机，飞起来也是不一样的。可见，同一行为，通过不同的事物，可以体现出来的不同的形态。多态，描述的就是这样的状态。&lt;/p&gt;
&lt;p&gt;定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多态： 是指同一行为，具有多个不同表现形式。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前提（重点）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;继承或者实现【二选一】&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;方法的重写【意义体现：不重写，无意义】&lt;/li&gt;
&lt;li&gt;父类引用指向子类对象【格式体现】&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;52-多态的体现&#34;&gt;5.2 多态的体现&lt;/h3&gt;
&lt;p&gt;多态体现的格式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;父类类型 变量名 = new 子类对象；
变量名.方法名();
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;父类类型：指子类对象继承的父类类型，或者实现的父接口类型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;代码如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Fu f = new Zi();
f.method();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，执行的是子类重写后方法。&lt;/strong&gt;&lt;br&gt;
代码如下：&lt;br&gt;
定义父类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public abstract class Animal {  
    public abstract void eat();  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定义子类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Cat extends Animal {  
    public void eat() {  
        System.out.println(&amp;quot;吃鱼&amp;quot;);  
    }  
}  
 
class Dog extends Animal {  
    public void eat() {  
        System.out.println(&amp;quot;吃骨头&amp;quot;);  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定义测试类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        // 多态形式，创建对象
        Animal a1 = new Cat();  
        // 调用的是 Cat 的 eat
        a1.eat();          
 
        // 多态形式，创建对象
        Animal a2 = new Dog(); 
        // 调用的是 Dog 的 eat
        a2.eat();               
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;53-多态的好处&#34;&gt;5.3 多态的好处&lt;/h3&gt;
&lt;p&gt;实际开发的过程中，父类类型作为方法形式参数，传递子类对象给方法，进行方法的调用，更能体现出多态的扩展性与便利。代码如下：&lt;br&gt;
定义父类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public abstract class Animal {  
    public abstract void eat();  
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定义子类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Cat extends Animal {  
    public void eat() {  
        System.out.println(&amp;quot;吃鱼&amp;quot;);  
    }  
}  
 
class Dog extends Animal {  
    public void eat() {  
        System.out.println(&amp;quot;吃骨头&amp;quot;);  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定义测试类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        // 多态形式，创建对象
        Cat c = new Cat();  
        Dog d = new Dog(); 
 
        // 调用showCatEat 
        showCatEat(c);
        // 调用showDogEat 
         showDogEat(d); 
 
        /*
        以上两个方法, 均可以被showAnimalEat(Animal a)方法所替代
        而执行效果一致
        */
        showAnimalEat(c);
        showAnimalEat(d); 
    }
 
    public static void showCatEat (Cat c){
        c.eat(); 
    }
 
    public static void showDogEat (Dog d){
        d.eat();
    }
 
    public static void showAnimalEat (Animal a){
        a.eat();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于多态特性的支持，showAnimalEat方法的Animal类型，是Cat和Dog的父类类型，父类类型接收子类对象，当然可以把Cat对象和Dog对象，传递给方法。&lt;br&gt;
当eat方法执行时，多态规定，执行的是子类重写的方法，那么效果自然与showCatEat、showDogEat方法一致，所以showAnimalEat完全可以替代以上两方法。&lt;br&gt;
不仅仅是替代，在扩展性方面，无论之后再多的子类出现，我们都不需要编写showXxxEat方法了，直接使用showAnimalEat都可以完成。&lt;br&gt;
所以，多态的好处，体现在，可以使程序编写的更简单，并有良好的扩展。&lt;/p&gt;
&lt;h3 id=&#34;54-引用类型转换&#34;&gt;5.4 引用类型转换&lt;/h3&gt;
&lt;p&gt;多态的转型分为向上转型与向下转型两种：&lt;/p&gt;
&lt;h4 id=&#34;向上转型&#34;&gt;向上转型&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;向上转型：多态本身是子类类型向父类类型向上转换的过程，这个过程是默认的。当父类引用指向一个子类对象时，便是向上转型。&lt;br&gt;
使用格式：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;父类类型  变量名 = new 子类类型();
如：Animal a = new Cat();
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;向下转型&#34;&gt;向下转型&lt;/h4&gt;
&lt;p&gt;向下转型：父类类型向子类类型向下转换的过程，这个过程是强制的。&lt;/p&gt;
&lt;p&gt;一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。&lt;br&gt;
使用格式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;子类类型 变量名 = (子类类型) 父类变量名;
如:Cat c =(Cat) a;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;为什么要转型&#34;&gt;为什么要转型&lt;/h4&gt;
&lt;p&gt;当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，不能调用子类拥有，而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点&amp;quot;小麻烦&amp;quot;。所以，想要调用子类特有的方法，必须做向下转型。&lt;br&gt;
转型演示，代码如下：&lt;br&gt;
定义类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;abstract class Animal {  
    abstract void eat();  
}  
 
class Cat extends Animal {  
    public void eat() {  
        System.out.println(&amp;quot;吃鱼&amp;quot;);  
    }  
    public void catchMouse() {  
        System.out.println(&amp;quot;抓老鼠&amp;quot;);  
    }  
}  
 
class Dog extends Animal {  
    public void eat() {  
        System.out.println(&amp;quot;吃骨头&amp;quot;);  
    }  
    public void watchHouse() {  
        System.out.println(&amp;quot;看家&amp;quot;);  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定义测试类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        // 向上转型  
        Animal a = new Cat();  
        a.eat();                // 调用的是 Cat 的 eat
 
        // 向下转型  
        Cat c = (Cat)a;       
        c.catchMouse();         // 调用的是 Cat 的 catchMouse
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;转型的异常&#34;&gt;转型的异常&lt;/h4&gt;
&lt;p&gt;转型的过程中，一不小心就会遇到这样的问题，请看如下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        // 向上转型  
        Animal a = new Cat();  
        a.eat();               // 调用的是 Cat 的 eat
 
        // 向下转型  
        Dog d = (Dog)a;       
        d.watchHouse();        // 调用的是 Dog 的 watchHouse 【运行报错】
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码可以通过编译，但是运行时，却报出了 ClassCastException ，类型转换异常！这是因为，明明创建了Cat类型对象，运行时，当然不能转换成Dog对象的。这两个类型并没有任何继承关系，不符合类型转换的定义。&lt;br&gt;
为了避免ClassCastException的发生，Java提供了 instanceof 关键字，给引用变量做类型的校验，格式如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;变量名 instanceof 数据类型&lt;/li&gt;
&lt;li&gt;如果变量属于该数据类型，返回true。&lt;/li&gt;
&lt;li&gt;如果变量不属于该数据类型，返回false。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，转换前，我们最好先做一个判断，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        // 向上转型  
        Animal a = new Cat();  
        a.eat();               // 调用的是 Cat 的 eat
 
        // 向下转型  
        if (a instanceof Cat){
            Cat c = (Cat)a;       
            c.catchMouse();        // 调用的是 Cat 的 catchMouse
        } else if (a instanceof Dog){
            Dog d = (Dog)a;       
            d.watchHouse();       // 调用的是 Dog 的 watchHouse
        }
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;55-面向对象最核心的机制动态绑定也叫多态的理解&#34;&gt;5.5 面向对象最核心的机制——动态绑定（也叫多态）的理解&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;21&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615031915.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;551-通过下面的例子理解动态绑定即多态&#34;&gt;5.5.1 通过下面的例子理解动态绑定，即多态&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Animal {
    /**
     * 声明一个私有的成员变量name。
     */
    private String name;

    /**
     * 在Animal类自定义的构造方法
     * @param name
     */
    Animal(String name) {
        this.name = name;
    }

    /**
     * 在Animal类里面自定义一个方法enjoy
     */
    public void enjoy() {
        System.out.println(&amp;quot;动物的叫声……&amp;quot;);
    }
}

/**
 * 子类Cat从父类Animal继承下来，Cat类拥有了Animal类所有的属性和方法。
 * @author gacl
 *
 */
class Cat extends Animal {
    /**
     * 在子类Cat里面定义自己的私有成员变量
     */
    private String eyesColor;

    /**
     * 在子类Cat里面定义Cat类的构造方法
     * @param n
     * @param c
     */
    Cat(String n, String c) {
        /**
         * 在构造方法的实现里面首先使用super调用父类Animal的构造方法Animal(String name)。
         * 把子类对象里面的父类对象先造出来。
         */
        super(n);
        eyesColor = c;
    }

    /**
     * 子类Cat对从父类Animal继承下来的enjoy方法不满意，在这里重写了enjoy方法。
     */
    public void enjoy() {
        System.out.println(&amp;quot;我养的猫高兴地叫了一声……&amp;quot;);
    }
}

/**
 * 子类Dog从父类Animal继承下来，Dog类拥有了Animal类所有的属性和方法。
 * @author gacl
 *
 */
class Dog extends Animal {
    /**
     * 在子类Dog里面定义自己的私有成员变量
     */
    private String furColor;

    /**
     * 在子类Dog里面定义Dog类的构造方法
     * @param n
     * @param c
     */
    Dog(String n, String c) {
        /**
         * 在构造方法的实现里面首先使用super调用父类Animal的构造方法Animal(String name)。
         * 把子类对象里面的父类对象先造出来。
         */
        super(n);
        furColor = c;
    }

    /**
     * 子类Dog对从父类Animal继承下来的enjoy方法不满意，在这里重写了enjoy方法。
     */
    public void enjoy() {
        System.out.println(&amp;quot;我养的狗高兴地叫了一声……&amp;quot;);
    }
}

/**
 * 子类Bird从父类Animal继承下来，Bird类拥有Animal类所有的属性和方法
 * @author gacl
 *
 */
class Bird extends Animal {
    /**
     * 在子类Bird里面定义Bird类的构造方法
     */
    Bird() {
        /**
         * 在构造方法的实现里面首先使用super调用父类Animal的构造方法Animal(String name)。
         * 把子类对象里面的父类对象先造出来。
         */
        super(&amp;quot;bird&amp;quot;);
    }

    /**
     * 子类Bird对从父类Animal继承下来的enjoy方法不满意，在这里重写了enjoy方法。
     */
    public void enjoy() {
        System.out.println(&amp;quot;我养的鸟高兴地叫了一声……&amp;quot;);
    }
}

/**
 * 定义一个类Lady(女士)
 * @author gacl
 *
 */
class Lady {
    /**
     * 定义Lady类的私有成员变量name和pet
     */
    private String name;
    private Animal pet;

    /**
     * 在Lady类里面定义自己的构造方法Lady()，
     * 这个构造方法有两个参数，分别为String类型的name和Animal类型的pet，
     * 这里的第二个参数设置成Animal类型可以给我们的程序带来最大的灵活性，
     * 因为作为养宠物来说，可以养猫，养狗，养鸟，只要是你喜欢的都可以养，
     * 因此把它设置为父类对象的引用最为灵活。
     * 因为这个Animal类型的参数是父类对象的引用类型，因此当我们传参数的时候，
     * 可以把这个父类的子类对象传过去，即传Dog、Cat和Bird等都可以。
     * @param name
     * @param pet
     */
    Lady(String name, Animal pet) {
        this.name = name;
        this.pet = pet;
    }

    /**
     * 在Lady类里面自定义一个方法myPetEnjoy()
     * 方法体内是让Lady对象养的宠物自己调用自己的enjoy()方法发出自己的叫声。
     */
    public void myPetEnjoy() {
        pet.enjoy();
    }
}

public class TestPolymoph {
    public static void main(String args[]) {
        /**
         * 在堆内存里面new了一只蓝猫对象出来，这个蓝猫对象里面包含有一个父类对象Animal。
         */
        Cat c = new Cat(&amp;quot;Catname&amp;quot;, &amp;quot;blue&amp;quot;);
        /**
         * 在堆内存里面new了一只黑狗对象出来，这个黑狗对象里面包含有一个父类对象Animal。
         */
        Dog d = new Dog(&amp;quot;Dogname&amp;quot;, &amp;quot;black&amp;quot;);
        /**
         * 在堆内存里面new了一只小鸟对象出来，这个小鸟对象里面包含有一个父类对象Animal。
         */
        Bird b = new Bird();

        /**
         * 在堆内存里面new出来3个小姑娘，名字分别是l1，l2，l3。
         * l1养了一只宠物是c(Cat)，l2养了一只宠物是d(Dog)，l3养了一只宠物是b(Bird)。
         * 注意：调用Lady类的构造方法时，传递过来的c，d，b是当成Animal来传递的，
         * 因此使用c，d，b这三个引用对象只能访问父类Animal里面的enjoy()方法。
         */
        Lady l1 = new Lady(&amp;quot;l1&amp;quot;, c);
        Lady l2 = new Lady(&amp;quot;l2&amp;quot;, d);
        Lady l3 = new Lady(&amp;quot;l3&amp;quot;, b);
        /**
         * 这三个小姑娘都调用myPetEnjoy()方法使自己养的宠物高兴地叫起来。
         */
        l1.myPetEnjoy();
        l2.myPetEnjoy();
        l3.myPetEnjoy();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615032029.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;552-画内存图理解动态绑定多态&#34;&gt;5.5.2 画内存图理解动态绑定（多态）&lt;/h4&gt;
&lt;p&gt;首先从main方法的第一句话开始分析：&lt;/p&gt;
&lt;p&gt;Cat c = new Cat(&amp;quot;Catname&amp;quot;,&amp;quot;blue&amp;quot;);&lt;/p&gt;
&lt;p&gt;程序执行到这里，栈空间里有一个变量c，c里面装着一系列的值，通过这些值可以找到位于堆内存里面new出来的Cat对象。因此c是Cat对象的一个引用，通过c可以看到这个Cat对象的全部。c指向new出来的Cat对象。在new这个Cat对象的时候，调用了Cat对象的构造方法Cat(String n,String c)，定义如下：&lt;/p&gt;
&lt;p&gt;Cat(String n,String c){&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;super(n);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;eyesColor=c;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;因此在构造子类对象时首先使用父类对象的引用super调用父类的构造方法Animal(String name),定义如下：&lt;/p&gt;
&lt;p&gt;Animal(String name){&lt;/p&gt;
&lt;p&gt;this.name=name;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;因此会把传过来的字符串“Catname”传递给父类对象的name属性。当Cat(String n,String c)构造方法调用结束后，真真正正在堆内存里面new出了一只Cat，这只Cat里面包含有父类对象Animal，这个Animal对象有自己的属性name，name属性的值为调用父类构造方法时传递过来的字符串Catname。除此之外，这只Cat还有自己的私有成员变量eyesColor，eyesColor属性的属性值为调用子类构造方法时传递过来的字符串blue。所以执行完这句话以后，内存中的布局是栈内存里面有一个引用c，c指向堆内存里面new出来的一只Cat，而这只Cat对象里面又包含有父类对象Animal，Animal对象有自己的属性name，属性值为Catname，Cat除了拥有从Animal类继承下来的name属性外，还拥有一个自己私有的属性eyesColor，属性值为blue。这就是执行完第一句话以后整个内存布局的情况如下图所示：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;22&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615032133.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;接着看这句话：Lady l1 = new Lady(“l1”,c);&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;23&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200615032154.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;程序执行到这里,首先在栈内存里面多了一个引用变量l1,l1里面装着一个值，通过这个值可以找到在堆内存里面new出来的Lady对象。l1就是这个Lady对象的引用，l1指向Lady对象。在创建Lady对象时，调用Lady类的构造方法：Lady(String name,Animal pet)，其定义如下：&lt;/p&gt;
&lt;p&gt;Lady(String name,Animal pet){&lt;/p&gt;
&lt;p&gt;this.name=name;&lt;/p&gt;
&lt;p&gt;this.pet=pet;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;这个构造方法有两个参数，分别是String类型的name和Animal类型的pet，pet参数是一个父类对象的引用类型，这里把l1和c作为实参传递给了构造方法，接着在构造方法里面执行this.name=name，把传递过来的l1由传给Lady对象的name属性，因此Lady对象的name属性值为l1，这里也把前面new出来的那只Cat的引用c传递给了构造方法里面的参数pet，接着在构造方法里面执行this.pet=pet，pet参数又把c传过来的内容传递给Lady对象的pet属性，因此pet属性的属性值就是可以找到Cat对象的地址，因此Lady对象的pet属性也成为了Cat对象的引用对象了，通过pet里面装着的值是可以找到Cat对象的，因此pet也指向了Cat，但并不是全部指向Cat，pet指向的只是位于Cat对象内部的Animal对象，这是因为在调用构造方法时，是把c当成一个Animal对象的引用传过来的，把c作为一个Animal对象传递给了pet，所以得到的pet也是一个Animal对象的引用，因此这个pet引用指向的只能是位于Cat对象里面的Animal对象。在我pet引用对象眼里，你Cat对象就是一只普通的Animal，访问你的时候只能访问得到你里面的name属性，而你的eyesColor属性我是访问不到的，我能访问到你的name属性，访问的是位于你内部里面的父对象的name属性，因为我pet引用本身就是一个父类对象的引用，因此我可以访问父类对象的全部属性，而你子类对象Cat自己新增加的成员我pet引用是访问不了的。不过现在我pet引用不去访问你父类对象的成员变量name了，而是去访问你的成员方法enjoy了。首先是使用Lady对象的引用l1去调用Lady对象的myPetEnjoy()方法，myPetEnjoy()方法定义如下：&lt;/p&gt;
&lt;p&gt;public void myPetEnjoy(){&lt;/p&gt;
&lt;p&gt;pet.enjoy();&lt;/p&gt;
&lt;p&gt;｝&lt;/p&gt;
&lt;p&gt;然后在myPetEnjoy()方法体里面又使用pet引用对象去调用父类对象里面的enjoy方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法是放在代码区(code seg)里面的，里面的方法就是一句句代码。&lt;strong&gt;因此当&lt;/strong&gt;使用pet引用去访问父类对象的方法时，首先是找到这个父类对象，然后看看它里面的方法到底在哪里存着，找到那个方法再去执行&lt;/strong&gt;。这里头就比较有意思了，code seg里面有很多个enjoy方法，有父类的enjoy()方法，也有子类重写了从父类继续下来的enjoy()方法，那么调用的时候到底调用的是哪一个呢？是根据谁来确定呢？注意：这是根据你实际当中的对象来确定的，你实际当中new出来的是谁，就调用谁的enjoy方法，当你找这个方法的时候，通过pet引用能找得到这个方法，但调用代码区里面的哪一个enjoy方法不是通过引用类型来确定的，如果是通过引用类型pet来确定，那么调用的肯定是Animal的enjoy()方法，可是现在是根据实际的类型来确定，我们的程序运行以后才在堆内存里面创建出一只Cat，然后根据你实际当中new出来的类型来判断我到底应该调用哪一个enjoy()方法。如果是根据实际类型，那么调用的就应该是Cat的enjoy()方法。如果是根据引用类型，那么调用的就应该是Animal的enjoy()方法。现在动态绑定这种机制指的是实际当中new的是什么类型，就调用谁的enjoy方法。所以说虽然你是根据我父类里面的enjoy方法来调用，可是实际当中却是你new的是谁调用的就是谁的enjoy()方法。即实际当中调用的却是子类里面重写后的那个enjoy方法。当然，讲一点更深的机制，你实际当中找这个enjoy方法的时候，在父类对象的内部有一个enjoy方法的指针，指针指向代码区里面父类的Animal的enjoy方法，只不过当你new这个对象的时候，这个指针随之改变，你new的是什么对象，这个指针就指向这个对象重写后的那个enjoy方法，所以这就叫做动态绑定。只有在动起来的时候，也就是在程序运行期间，new出了这个对象了以后你才能确定到底要调用哪一个方法。我实际当中的地址才会绑定到相应的方法的地址上面，所以叫动态绑定。调这个方法的时候，只要你这个方法重写了，实际当中调哪一个，要看你实际当中new的是哪个对象，这就叫多态，也叫动态绑定。&lt;strong&gt;动态绑定带来莫大的好处是使程序的可扩展性达到了最好&lt;/strong&gt;，我们原来做这个可扩展性的时候，首先都是要在方法里面判断一下这只动物是哪一类里面的动物，通过if (object instanceof class)这样的条件来判断这个new出来的对象到底是属于哪一个类里面的，如果是一只猫，就调用猫的enjoy方法，如果是一条狗，就调用狗的enjoy方法。如果我现在增加了一个Bird类，那么扩展的时候，你又得在方法里面写判断这只鸟属于哪一个类然后才能调用这只鸟的enjoy方法。每增加一个对象，你都要在方法里面增加一段判断这个对象到底属于哪个类里面的代码然后才能执行这个对象相应的方法。即每增加一个新的对象，都要改变方法里面的处理代码，而现在，你不需要再改变方法里面的处理代码了，因为有了动态绑定。你要增加哪一个对象，你实际当中把这个对象new出来就完了，不再用去修改对象的处理方法里面的代码了。也就是当你实际当中要增加别的东西的时候，很简单，你直接加上去就成了，不用去改原来的结构，你要在你们家大楼的旁边盖一个厨房，很简单，直接在旁边一盖就行了，大楼的主要支柱什么的你都不用动，这就可以让可扩展性达到了极致，这就为将来的可扩展打下了基础，&lt;strong&gt;也只有动态绑定（多态）这种机制能帮助我们做到这一点——让程序的可扩展性达到极致。因此动态绑定是面向对象的核心，如果没有动态绑定，那么面向对象绝对不可能发展得像现在这么流行，所以动态绑定是面向对象核心中的核心。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;**总结动态绑定（多态）：动态绑定是指在“执行期间”（而非编译期间）判断所引用的实际对象类型，根据其实际的类型调用其相应的方法。**所以实际当中找要调用的方法时是动态的去找的，new的是谁就找谁的方法，这就叫动态绑定。动态绑定帮助我们的程序的可扩展性达到了极致。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多态的存在有三个必要的条件：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;要有继承（两个类之间存在继承关系，子类继承父类）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;要有重写（在子类里面重写从父类继承下来的方法）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;父类引用指向子类对象&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这三个条件一旦满足，当你调用父类里面被重写的方法的时候，实际当中new的是哪个子类对象，就调用子类对象的方法（这个方法是从父类继承下来后重写后的方法）。&lt;/p&gt;
&lt;p&gt;面向对象比较强调类和类之间，对象和对象之间的一种组织关系，如果能把这种组织关系组织得比较好的话，你的程序想扩展性比较好，比较健壮，维护性比较好这些都可以达到，关键看你的设计到底好还是不好。&lt;/p&gt;
">Java基础总结-面向对象</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jonchan1013.github.io/post/java-ji-chu-ji-chu-yu-fa/"" data-c="
          &lt;p&gt;✍️JavaSE是Java Standard Edtion的缩写，译成中文就是Java标准版，也是Java的核心。无论是JavaEE(Java企业版)还是JavaME(Java微型版)都是以JavaSE为基础。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;1-标识符&#34;&gt;1、标识符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Java对各种变量、方法和类等要素命名时使用的字符序列称为标识符。
&lt;ul&gt;
&lt;li&gt;凡是自己可以起名字的地方都叫标识符，都遵守标识符的规则&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Java标识符命名规则:
&lt;ul&gt;
&lt;li&gt;标识符应以字母、下划线、美元符开头。&lt;/li&gt;
&lt;li&gt;Java 标识符大小写敏感，长度无限制。&lt;/li&gt;
&lt;li&gt;Java 标识符大小写敏感，长度无限制。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;约定俗成: Java标识符选取因注意&amp;quot;见名知意&amp;quot;且不能与Java语言的关键字重名。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-关键字&#34;&gt;2、关键字&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Java中一些赋以特定的含义，用做专门用途的字符串称为关键字( keyword)。大多数编辑器会将关键字用特殊方式标出&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有Java关键字都是小写英文。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有Java关键字都是小写英文。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200610115950.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-java基础数据类型&#34;&gt;3、Java基础数据类型&lt;/h2&gt;
&lt;h3 id=&#34;31-java常量&#34;&gt;3.1 Java常量&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Java 的常量值用字符串表示，区分为不同的数据类型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如整型常量123&lt;/li&gt;
&lt;li&gt;实型常量3.14&lt;/li&gt;
&lt;li&gt;字符常量&#39;a&#39;&lt;/li&gt;
&lt;li&gt;逻辑常量true. false&lt;/li&gt;
&lt;li&gt;字符串常量&amp;quot;helloworld&amp;quot;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注意:区分字符常量和字符串常量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注意:“常量”这个名词还会用在另外其它语境中表示值不可变的变量&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;32-java变量&#34;&gt;3.2 Java变量&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Java变量是程序中最基本的存储单元，其要素包括变量名，变量类型和作用域。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Java程序中每一个变量都属于特定的数据类型，在使用前必须对其声明，声明格式为:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;例如：int i=100;&lt;br&gt;
float f=12.3f;&lt;/p&gt;
&lt;p&gt;​			double d1, d2, d3 = 0.123;&lt;br&gt;
​			String s=&amp;quot;hello&amp;quot;;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从本质上讲，变量其实是内存中的一-小块区域，使用变量名来访问这块区域，因此，每一个变量使用前必须要先申请(声明)，然后必须进行赋值(填充内容)，才能使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个程序在运行的时候，实际上这个程序是位于内存里面，然后才开始运行。一个.exe文件存放在硬盘上是无法运行的，在硬盘上看到的.exe文件无非就是一个文件而已，当我们双击这个.exe文件时，运行起来的时候实际上是整个.exe文件被放在了在内存里面，然后操作系统找到main方法，也就是程序的入口，然后就开始执行了。执行的过程之中，会不断地在内存里面分配一些区域，变量在内存里面就是一小块区域，变量有两个概念，一个是变量的名字，另一个是变量的值，即这一小块区域是有名字的，里面装着一个值，因此以后要想访问这小块区域里面的内容就可以根据这小块区域的名字来访问了。因此，变量的本质就是一小块内存区域。就变量来说，该在内存里面分配多大的存储空间呢？不同的变量类型分配不同大小的存储空间，每一个变量都是属于特定的数据类型的，声明成不同的数据类型，它就在内存里面分配不同的存储空间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;变量作用域：变量的作用域只在“{ }”有效，出了这个“{ }”就没有作用了&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;33-java变量分类&#34;&gt;3.3 Java变量分类&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;按被声明的位置划分:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;局部变量:方法或语句块内部定义的变量&lt;/li&gt;
&lt;li&gt;成员变量:方法外部、类的内部定义的变量&lt;/li&gt;
&lt;li&gt;注意:类外面(与类对应的大括号外面)不能有变量的声明&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按所属的数据类型划分:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本数据类型变量&lt;/li&gt;
&lt;li&gt;引用数据类型变量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;34-java局部变量和成员变量&#34;&gt;3.4 Java局部变量和成员变量&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;方法体内部声明的变量(包括形参)称为局部变量:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方法体内部是指与方法对应的大括号内部&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在方法体外，类体内声明的变量成为成员变量&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void method(){
int i;
int j= i+5://编译出错，变量i还未被初始化
double d= 3.14;
Dog dog;
dog = new Dog(22,7,1964);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;35-java数据类型划分&#34;&gt;3.5 Java数据类型划分&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200610124522.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;Java中定义了4类8种基本数据类型。
&lt;ul&gt;
&lt;li&gt;逻辑型一boolean&lt;/li&gt;
&lt;li&gt;文本型一char&lt;/li&gt;
&lt;li&gt;整数型一byte, short, int, long&lt;/li&gt;
&lt;li&gt;浮点数型一float, double&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-java数据类型讲解&#34;&gt;4、Java数据类型讲解&lt;/h2&gt;
&lt;h3 id=&#34;41-boolean-布尔型&#34;&gt;4.1 boolean--布尔型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;boolean类型适于逻辑运算，一般用于程序流程控制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;boolean类型数据只允许取值true或false，不可以0或非0的整数替代true和false，这点和C语言不同。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用法举例:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;boolean flag;
flag = true;
if(f1ag) {
    //do something
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;42-char-字符型&#34;&gt;4.2 char--字符型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;char型数据用来表示通常意义上字符”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;字符常量为用单引号括起来的单个字符，例如:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;char eChar = &#39;a&#39;; char cChar =&#39;中‘；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Java字符采用Unicode编码，每个字符占两个字节，因而可用十六进制编码形式表示，例如:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;char c1 =’\u0061&#39;;&lt;/li&gt;
&lt;li&gt;注: Unicode是全球语言统一编码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Java语言中还允许使用转义字符\来将其后的字符转变为其它的含义，例如:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;@ char c2= &#39;\n&#39;;
&lt;ul&gt;
&lt;li&gt;&#39;\n&#39;代表换行符&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全球的文字放到计算机里面表示全是0和1，Unicode是统一了全世界国家文字的一种编码方式，用这样的编码可以把全世界国家的文字连接在一起。Unicode编码又分为两种，一种是Utf-8，另一种是Utf-16。JAVA所采用的是Utf-16，每一个字符占2个字节，任何国家的文字放到Unicode里面都是占2个字节。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;43-整数类型&#34;&gt;4.3 整数类型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Java各整数类型有固定的表数范围和字段长度，其不受具体操作系统的影响，以保证Java程序的可移植性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Java语言整型常量的:三种表示形式:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;十进制整数，如: 12, -314, 0。&lt;/li&gt;
&lt;li&gt;八进制整数，要求以0开头，如: 012。&lt;/li&gt;
&lt;li&gt;十六进制数，要求0x或0X开头，如: 0x12。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Java语言的整型常量默认为int型，声明long型常 量可以后加工或L’，如1:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;int i1= 600; //正确 long l1 = 888888888L; l1必须加否则会出错&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200610125719.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;C语言编译好的程序为什么不能移植，如把.exe文件放到Linux下是执行不了的，一个很大很大的原因在于C语言定义的变量在不同的操作系统上所占的大小是不一样的，声明一个int类型的变量，在Windows下面占32位，但放到Linux下面就有可能只占16位，那么这时候很可能表示的大小就不一样了，在Windows下声明一个很大的数，在Linux下面很可能就会溢出。因此这就是C语言为什么在编译完成之后不能移植的原因。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;44-浮点类型&#34;&gt;4.4 浮点类型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;与整数类型类似，Java浮 点类型有固定的表数范围和字段长度，不受平台影响。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Java浮点类型常量有两种表示形式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;十进制数形式，例如:3.14&lt;/li&gt;
&lt;li&gt;⑥科学记数法形式，如3.14e2  3.14E2  100E2&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Java浮点型常量默认为double型，如要声明一个常量为float型，则需在数字后面加f或F，如:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;double d= 12345.6; //正确 float f= 12.3f; //必须加f否则会出错&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下面列出Java的各种浮点类型&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200610130037.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;45-基本数据类型的转换&#34;&gt;4.5 基本数据类型的转换&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;boolean类型不可以转换为其他的数据类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;整型，字符型，浮点型的数据在混合运算中相互转换，转换时遵循以下原则:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容量小的类型自动转换为容量大的数据类型:数据类型按容量大小排序为:
&lt;ul&gt;
&lt;li&gt;byte,short,char-&amp;gt;int-&amp;gt;long-&amp;gt;float-&amp;gt;double&lt;/li&gt;
&lt;li&gt;byte,short,char之间不会互相转换， 他们三者在计算时首先回转换为int类型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;容量大的数据类型转换为容量小的数据类型时，要加上强制转换符，但可能造成精度降低或溢出:使用时要格外注意。&lt;/li&gt;
&lt;li&gt;有多种类型的数据混合运算时，系统首先自动的将所有数据转换成容量最大的那一:种数据类型，然后再进行计算。&lt;/li&gt;
&lt;li&gt;实数常量(如: 1.2)默认为double。&lt;/li&gt;
&lt;li&gt;整数常量(如: 123) 默认为int。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;类型转换测试&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TestConvert {
    public static void main(String arg[]) {
        int i1 = 123;
        int i2 = 456;
        double d1 = (i1+i2)*1.2;//系统将转换为double型运算
        float f1 = (float)((i1+i2)*1.2);//需要加强制转换符
        byte b1 = 67;
        byte b2 = 89;
        byte b3 = (byte)(b1+b2);//系统将转换为int型运算，需要强制转换符
        System.out.println(b3);
        double d2 = 1e200;
        float f2 = (float)d2;//会产生溢出
        System.out.println(f2);
        float f3 = 1.23f;//必须加f
        long l1 = 123;
        long l2 = 30000000000L;//必须加l
        float f = l1+l2+f3;//系统将转换为float型计算
        long l = (long)f;//强制转换会舍去小数部分（不是四舍五入）
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;5-运算符&#34;&gt;5、运算符&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200610130557.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;51-算数运算符自加和自减运算符&#34;&gt;5.1 算数运算符（自加和自减运算符)&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200610130722.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;52-逻辑运算符&#34;&gt;5.2 逻辑运算符&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200610130816.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;53-赋值运算符&#34;&gt;5.3 赋值运算符&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200610131019.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;赋值运算符，就是将符号右边的值，赋给左边的变量。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void main(String[] args){ 
    int i = 5; 
    i+=5;//计算方式 i=i+5 变量i先加5，再赋值变量i 
    System.out.println(i); //输出结果是10 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;54-比较运算符&#34;&gt;5.4 比较运算符&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200610131143.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;比较运算符，是两个数据之间进行比较的运算，运算结果都是布尔值 true 或者 false 。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void main(String[] args) { 
    System.out.println(1==1);//true 
    System.out.println(1&amp;lt;2);//true 
    System.out.println(3&amp;gt;4);//false 
    System.out.println(3&amp;lt;=4);//true 
    System.out.println(3&amp;gt;=4);//false 
    System.out.println(3!=4);//true 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;55-逻辑运算符&#34;&gt;5.5 逻辑运算符&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200610152457.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;逻辑运算符，是用来连接两个布尔类型结果的运算符，运算结果都是布尔值 true 或者 false&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void main(String[] args) { 
    System.out.println(true &amp;amp;&amp;amp; true);//true 
    System.out.println(true &amp;amp;&amp;amp; false);//false 
    System.out.println(false &amp;amp;&amp;amp; true);//false，右边不计算 
    System.out.println(false || false);//falase 
    System.out.println(false || true);//true 
    System.out.println(true || false);//true，右边不计算				
    System.out.println(!false);//true 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;56-三元运算符&#34;&gt;5.6 三元运算符&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;三元运算符格式：&lt;br&gt;
数据类型 变量名 = 布尔类型表达式？结果1：结果2&lt;/li&gt;
&lt;li&gt;三元运算符计算方式：
&lt;ul&gt;
&lt;li&gt;布尔类型表达式结果是true，三元运算符整体结果为结果1，赋值给变量。&lt;/li&gt;
&lt;li&gt;布尔类型表达式结果是false，三元运算符整体结果为结果2，赋值给变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void main(String[] args) { 
	int i = (1==2 ? 100 : 200); 
    System.out.println(i);//200 
    int j = (3&amp;lt;=4 ? 500 : 600); 
    System.out.println(j);//500 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;6-语句&#34;&gt;6、语句&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200610151654.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;61-条件语句&#34;&gt;6.1 条件语句&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;if语句&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200610151746.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分支语句(switch语句)&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200610151816.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200610151831.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200610152413.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;62-循环语句&#34;&gt;6.2 循环语句&lt;/h3&gt;
&lt;h4 id=&#34;621-for循环语句&#34;&gt;6.2.1 for循环语句&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200610151930.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/h4&gt;
&lt;p&gt;学会画内存分析图分析别人写的程序，这样就很容易分析出规律，分析出规律也就明白了别人的算法，也就很容易读懂别人的程序。&lt;/p&gt;
&lt;h4 id=&#34;622-while循环和do-while循环&#34;&gt;6.2.2 while循环和do while循环&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200610152239.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;623-break和continue语句&#34;&gt;6.2.3 break和continue语句&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200610152202.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;7-方法&#34;&gt;7、方法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Java的方法类似于其它语言的函数，是一段用来完成特定功能的代码片段&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;形式参数:在方法被调用时用 于接收外界输入的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实参:调用方法时实际传给方法的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;返回值:方法在执行完毕后返还给调用它的环境的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;返回值类型:事先约定的返回值的数据类型，如无返回值，必须给出返回值类型void.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Java语言中使用下述形式调用方法:对象名方法名(实参列表)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实参的数目、数据类型和次序必须和所调用方法声明的形参列表匹配，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;retun语句终止方法的运行并指定要返回的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Java中进行函数调用中传递参数时，遵循值传递的原则:基本类型传递的是该数据值本身。引用类型传递的是对对象的引用，而不是对象本身。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方法执行到return语句后，这个方法的执行就结束了，&lt;strong&gt;方法可以有返回值，但可以不用这个返回值&lt;/strong&gt;。方法首先要定义，然后才能调用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TestMethod{
    public static void main(String args[]){
        m();
        m1(3);
        m2(2,3);
        int i = m3(4,5);
        System.out.println(i);
    }
    //以下定义的都是静态方法，静态方法可以在main()方法里面直接调用
    public static void m(){
            System.out.println(&amp;quot;Hello!&amp;quot;);
            System.out.println(&amp;quot;World!&amp;quot;);
        }

    public static void m1(int i){
            if(i==5){
                    return;
                }
            System.out.println(i);
        }

    public static void m2(int i,int j){
            System.out.println(i+j);
        }

    public static int m3(int i,int j){
            return i+j;
        }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;8-变量的作用域&#34;&gt;8、变量的作用域&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;变量的作用域只在“{ }”有效，出了这个“{ }”就没有作用了&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;9-递归调用&#34;&gt;9、递归调用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;递归：在一个方法内部对自身的调用就称为递归&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;18&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200610153500.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;19&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200610153511.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;范例：使用递归计算第5个斐波那契数列数&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/*计算第5个斐波那契数列数*/
/*
斐波那契数列特点：f(1)=1,f(2)=1,f(3)=f(1)+f(2),f(4)=(f2)+(f3)……依次类推。
即后一个数都是等于前两个数的和，这样的数列就是斐波那契数列。
*/
/*
使用递归调用的方法计算
*/
public class Fab{
    public static void main(String args[]){
        System.out.println(f(5));
    }

    public static int f(int n){
            if(n==1||n==2){
                    return 1;
                }else{
                        return f(n-1)+f(n-2);
                    }
        }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	整个在内存中执行过程如下图所示&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;20&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200610153613.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;10-程序的执行过程&#34;&gt;10、程序的执行过程&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;21&#34;&gt;&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200610153705.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">Java基础总结-基础语法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jonchan1013.github.io/post/java-ji-chu/"" data-c="
          &lt;p&gt;✍️学习java的第一步就要搭建java的学习环境，首先是要安装JDK，JDK安装好之后，还需要在电脑上配置&amp;quot;JAVA_HOME”、&amp;quot;path”、&amp;quot;classpath&amp;quot;这三个环境变量才能够把java的开发环境搭建好。在没安装过jdk的环境下，path环境变量是系统变量，本来存在的，而JAVA_HOME和classpath是不存在的。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;配置JAVA_HOME变量&lt;br&gt;
操作步骤：计算机→右键“属性”→高级系统设置→高级→环境变量，如下图所示：&lt;br&gt;
&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200610095005.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200610095133.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200610095235.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击系统变量下面的“【新建】”，弹出一个新建系统变量对话框，首先在变量名写上JAVA_HOME，顾名思义，JAVA_HOME的含义就是JDK的安装路径，，然后在变量值写JDK的安装路径，如这里设置的变量值是&amp;quot;C:\Program Files (x86)\Java\jdk1.8.0&amp;quot;，设置好变量值之后，点击【确定】按钮，JAVA_HOME环境变量就设置完成，如下图所示：系统变量中多了一个&amp;quot;JAVA_HOME&amp;quot;变量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置path环境变量&lt;br&gt;
操作步骤：计算机→右键“属性”→高级系统设置→高级→环境变量&lt;br&gt;
找到系统变量中的Path变量，点击【编辑】按钮，弹出编辑系统变量的对话框，可以看到，Path变量中设置有很多的目录，每个目录之间使用;(分号)隔开,将%JAVA_HOME%\bin;添加到Path变量的变量值中，点击【确定】按钮，Path环境变量的就设置完成了，如下图所示：&lt;br&gt;
&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200610095552.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置ClassPath变量&lt;br&gt;
设置Classpath的目的，在于告诉Java执行环境，在哪些目录下可以找到您所要执行的Java程序(.class文件)，关于这个ClassPath变量，其实可以不用配置了&lt;br&gt;
&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200610095445.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JAVA_HOME变量、Path变量、ClassPath变量的说明&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设置JAVA_HOME变量的目的
&lt;ol&gt;
&lt;li&gt;为了方便引用，比如，JDK安装在C:\Program Files (x86)\Java\jdk1.8.0目录里，则设置JAVA_HOME为该目录路径, 那么以后要使用这个路径的时候, 只需输入%JAVA_HOME%即可, 避免每次引用都输入很长的路径串;&lt;/li&gt;
&lt;li&gt;归一原则, 当JDK路径被迫改变的时候, 仅需更改JAVA_HOME的变量值即可。&lt;/li&gt;
&lt;li&gt;第三方软件会引用约定好的JAVA_HOME变量, 典型的就是tomcat服务器，如果不配置JAVA_HOME变量，那么tomcat服务器根本运行不起来&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Path变量(重点说明)&lt;br&gt;
操作系统用path的路径来找可执行程序(.exe程序)，在windows下当我们敲任何一个命令时，实际上就是在执行一个可执行文件，如输入notepad命令就可以打开一个记事本&lt;br&gt;
&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200610100042.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
实际上是执行了c:\Windows下的notepad.exe这个可执行文件，和用鼠标双击notepad.exe后能够打开一个记事本的效果是一样的&lt;br&gt;
&lt;img src=&#34;https://gitee.com/chenyong1013/picCloud/raw/master/20200610100137.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
当在命令窗口敲一个命令时，系统就会去自动寻找这个命令对应的可执行文件(.exe)，如果这个文件不存在，就当然无法执行这个命令了。这个可执行文件的根目录必须设置在path环境变量中。&lt;/li&gt;
&lt;li&gt;在命令窗口显示path设置的环境变量&lt;br&gt;
直接输入“echo %path%”命令就可以显示设置的path环境变量的所有根目录了，只要是根目录里面存在相应的.exe文件，敲入命令时就能执行这个相应的.exe文件。因为notepad.exe所在的Windows目录已经添加到了Path环境变量中了，这就解释了为什么输入命令notepad就可以打开一个记事本，所以前面配置java开发环境时，将%JAVA_HOME%\bin添加到Path变量中的目的就是希望可以在命令行窗口下使用javac和java这两个命令来执行javac.exe和java.exe这两个可执行程序。&lt;/li&gt;
&lt;li&gt;Classpath变量说明&lt;br&gt;
使用javac命令编译.java文件时，如果需要其他的类，也是通过classpath去找的，&lt;br&gt;
　　使用java命令执行.class文件时，执行的.class文件是通过classpath去找的。&lt;br&gt;
　　classpath表示的是要查找的类所在的路径。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户变量和系统变量的区别&lt;br&gt;
用户变量，顾名思义，是针对某一个特定的用户的，只对特定的用户有效，而系统变量，则对任何用户都有效。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
">Java环境变量配置</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }
  //拿来主义(真香)^_^，Clipboard 实现摘自掘金 https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        console.log('复制操作频率过高');
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>

<script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
<script>
  var scroll = new SmoothScroll('a[href*="#"]', {
    speed: 200
  });
</script>


<script src="/media/js/mouse/love.js"></script>


<script src="/media/js/cool.js"></script>


</html>